# ğŸ§® Selection Sort in C++

---

## ğŸš© Problem Statement

**Sort an array** of `n` integers in **ascending order** using the **Selection Sort algorithm**.

---

## ğŸ’¡ What is Selection Sort?

**Selection Sort** is a simple **comparison-based sorting algorithm**. The idea is to **repeatedly find the minimum element** from the unsorted part of the array and place it at the beginning.

---

## ğŸ› ï¸ Approach & Intuition

In each iteration:

1. Find the **minimum element** in the **unsorted part** of the array.
2. Swap it with the **first element** of the unsorted part.
3. Now the sorted part increases by one, and the unsorted part shrinks.

### ğŸ” Visualization

Letâ€™s say `arr = [3, 6, 12, 9, 1]`

* **Pass 1** â†’ min = 1 â†’ swap with 3 â†’ `[1, 6, 12, 9, 3]`
* **Pass 2** â†’ min = 3 â†’ swap with 6 â†’ `[1, 3, 12, 9, 6]`
* **Pass 3** â†’ min = 6 â†’ swap with 12 â†’ `[1, 3, 6, 9, 12]`
* **Pass 4** â†’ min = 9 â†’ already in place

---

## ğŸ”¢ Code Walkthrough

```cpp
#include <bits/stdc++.h>
using namespace std;

void SelectionSort(int arr[], int n) {
    for (int i = 0; i <= n-2; i++) {
        int min = i;
        for (int j = i; j <= n-1; j++) {
            if (arr[j] < arr[min])
                min = j;
        }
        swap(arr[min], arr[i]);
    }
}

int main() {
    int arr[] = {3, 6, 12, 9, 1};
    int n = 5;

    SelectionSort(arr, n);
    for (auto i : arr)
        cout << i << " ";
    return 0;
}
```

---

## âš™ï¸ Algorithm Breakdown

### Step-by-step:

```text
for i from 0 to n-2:
    min = i
    for j from i to n-1:
        if arr[j] < arr[min]:
            min = j
    swap arr[min] and arr[i]
```

### âœ… Dry Run

Letâ€™s dry-run on `arr = [3, 6, 12, 9, 1]`:

| Iteration | `i` | `min` index | Swap      | Array State        |
| --------- | --- | ----------- | --------- | ------------------ |
| 1         | 0   | 4           | 3 â†” 1     | `[1, 6, 12, 9, 3]` |
| 2         | 1   | 4           | 6 â†” 3     | `[1, 3, 12, 9, 6]` |
| 3         | 2   | 4           | 12 â†” 6    | `[1, 3, 6, 9, 12]` |
| 4         | 3   | 3           | No change | `[1, 3, 6, 9, 12]` |

---

## ğŸ“Š Time & Space Complexity

| Complexity       | Value           |
| ---------------- | --------------- |
| **Best Case**    | O(nÂ²)           |
| **Average Case** | O(nÂ²)           |
| **Worst Case**   | O(nÂ²)           |
| **Space**        | O(1) (in-place) |
| **Stability**    | âŒ Not stable    |

---

## ğŸ“ Characteristics of Selection Sort

* **In-place**: Uses no extra space.
* **Not stable**: Relative order of equal elements may change.
* **Not adaptive**: Even if the array is sorted, time complexity remains O(nÂ²).
* **Less number of swaps** compared to Bubble Sort.

---

## â“ FAQs

#### Q1: Why does Selection Sort go till `n-2`?

Because in the last iteration, only one element is left â€” and it's already in place. So we need only `n-1` passes.

---

#### Q2: Why is it not stable?

Because it swaps elements, and might place a smaller value before an equal one â€” disturbing their original order.

---

#### Q3: Where is Selection Sort used?

While inefficient for large data sets, it's used:

* In **small embedded systems**.
* When **swap operations are costly**, but comparisons are cheap.

---

## ğŸ§ª Sample Output

```cpp
Input:  {3, 6, 12, 9, 1}
Output: 1 3 6 9 12
```

---

## ğŸš€ Bonus: Optimized Insight

Even though Selection Sort has a fixed O(nÂ²) complexity, it performs **fewer swaps** compared to Bubble Sort â€” which might make it more efficient in **situations where swaps are costly**, like writing to flash memory.

---

> âœ… **Tip**: Always prefer efficient sorting algorithms like **Merge Sort**, **Quick Sort**, or use **C++ STL's `sort()`**, unless you're explicitly required to implement simple sorting algorithms manually.

---

