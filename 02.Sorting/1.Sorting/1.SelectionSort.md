# 🧮 Selection Sort in C++

---

## 🚩 Problem Statement

**Sort an array** of `n` integers in **ascending order** using the **Selection Sort algorithm**.

---

## 💡 What is Selection Sort?

**Selection Sort** is a simple **comparison-based sorting algorithm**. The idea is to **repeatedly find the minimum element** from the unsorted part of the array and place it at the beginning.

---

## 🛠️ Approach & Intuition

In each iteration:

1. Find the **minimum element** in the **unsorted part** of the array.
2. Swap it with the **first element** of the unsorted part.
3. Now the sorted part increases by one, and the unsorted part shrinks.

### 🔁 Visualization

Let’s say `arr = [3, 6, 12, 9, 1]`

* **Pass 1** → min = 1 → swap with 3 → `[1, 6, 12, 9, 3]`
* **Pass 2** → min = 3 → swap with 6 → `[1, 3, 12, 9, 6]`
* **Pass 3** → min = 6 → swap with 12 → `[1, 3, 6, 9, 12]`
* **Pass 4** → min = 9 → already in place

---

## 🔢 Code Walkthrough

```cpp
#include <bits/stdc++.h>
using namespace std;

void SelectionSort(int arr[], int n) {
    for (int i = 0; i <= n-2; i++) {
        int min = i;
        for (int j = i; j <= n-1; j++) {
            if (arr[j] < arr[min])
                min = j;
        }
        swap(arr[min], arr[i]);
    }
}

int main() {
    int arr[] = {3, 6, 12, 9, 1};
    int n = 5;

    SelectionSort(arr, n);
    for (auto i : arr)
        cout << i << " ";
    return 0;
}
```

---

## ⚙️ Algorithm Breakdown

### Step-by-step:

```text
for i from 0 to n-2:
    min = i
    for j from i to n-1:
        if arr[j] < arr[min]:
            min = j
    swap arr[min] and arr[i]
```

### ✅ Dry Run

Let’s dry-run on `arr = [3, 6, 12, 9, 1]`:

| Iteration | `i` | `min` index | Swap      | Array State        |
| --------- | --- | ----------- | --------- | ------------------ |
| 1         | 0   | 4           | 3 ↔ 1     | `[1, 6, 12, 9, 3]` |
| 2         | 1   | 4           | 6 ↔ 3     | `[1, 3, 12, 9, 6]` |
| 3         | 2   | 4           | 12 ↔ 6    | `[1, 3, 6, 9, 12]` |
| 4         | 3   | 3           | No change | `[1, 3, 6, 9, 12]` |

---

## 📊 Time & Space Complexity

| Complexity       | Value           |
| ---------------- | --------------- |
| **Best Case**    | O(n²)           |
| **Average Case** | O(n²)           |
| **Worst Case**   | O(n²)           |
| **Space**        | O(1) (in-place) |
| **Stability**    | ❌ Not stable    |

---

## 📎 Characteristics of Selection Sort

* **In-place**: Uses no extra space.
* **Not stable**: Relative order of equal elements may change.
* **Not adaptive**: Even if the array is sorted, time complexity remains O(n²).
* **Less number of swaps** compared to Bubble Sort.

---

## ❓ FAQs

#### Q1: Why does Selection Sort go till `n-2`?

Because in the last iteration, only one element is left — and it's already in place. So we need only `n-1` passes.

---

#### Q2: Why is it not stable?

Because it swaps elements, and might place a smaller value before an equal one — disturbing their original order.

---

#### Q3: Where is Selection Sort used?

While inefficient for large data sets, it's used:

* In **small embedded systems**.
* When **swap operations are costly**, but comparisons are cheap.

---

## 🧪 Sample Output

```cpp
Input:  {3, 6, 12, 9, 1}
Output: 1 3 6 9 12
```

---

## 🚀 Bonus: Optimized Insight

Even though Selection Sort has a fixed O(n²) complexity, it performs **fewer swaps** compared to Bubble Sort — which might make it more efficient in **situations where swaps are costly**, like writing to flash memory.

---

> ✅ **Tip**: Always prefer efficient sorting algorithms like **Merge Sort**, **Quick Sort**, or use **C++ STL's `sort()`**, unless you're explicitly required to implement simple sorting algorithms manually.

---

