# 🫧 Bubble Sort in C++

---

## 🚩 Problem Statement

Sort an array of `n` integers in **ascending order** using the **Bubble Sort algorithm**.

---

## 💡 What is Bubble Sort?

**Bubble Sort** is a **simple comparison-based** sorting algorithm. It works by **repeatedly swapping adjacent elements** if they are in the wrong order — pushing the largest unsorted element to the end in each pass.

It’s like how **bubbles rise to the surface** — hence the name.

---

## 🛠️ Approach & Intuition

1. Traverse the array from index `0` to `n-1`.
2. Compare each pair of adjacent elements.
3. If the left element is **greater**, swap it with the right.
4. The **largest element gets bubbled to the rightmost end** in each pass.
5. Repeat this for the unsorted portion of the array until all elements are sorted.

---

## 🔢 Code Walkthrough

```cpp
#include <bits/stdc++.h>
using namespace std;

void BubbleSort(int arr[], int n) {
    for (int i = n - 1; i > 0; i--) {                // Outer loop: n-1 passes
        for (int j = 0; j <= i - 1; j++) {           // Inner loop: pairwise comparisons
            if (arr[j] > arr[j + 1])                 // If left is greater than right
                swap(arr[j], arr[j + 1]);            // Swap them
        }
    }
}

int main() {
    int n;
    cin >> n;
    int arr[n];

    for (int i = 0; i < n; i++)
        cin >> arr[i];

    BubbleSort(arr, n);

    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    return 0;
}
```

---

## 🧠 Dry Run Example

### Input:

```
n = 5
arr = [4, 3, 1, 5, 2]
```

### Process:

**Pass 1**:
`[4, 3, 1, 5, 2] → [3, 1, 4, 2, 5]` (5 is at correct place)

**Pass 2**:
`[3, 1, 4, 2, 5] → [1, 3, 2, 4, 5]`

**Pass 3**:
`[1, 3, 2, 4, 5] → [1, 2, 3, 4, 5]`

**Pass 4**:
Sorted already, no swaps.

---

## 🧮 Time & Space Complexity

| Case                    | Complexity                |
| ----------------------- | ------------------------- |
| **Best Case**           | O(n²) *(current version)* |
| **Optimized Best Case** | O(n) with early exit flag |
| **Average Case**        | O(n²)                     |
| **Worst Case**          | O(n²)                     |
| **Space**               | O(1) *(in-place)*         |

---

## ✅ Output

### Input:

```
5
4 3 1 5 2
```

### Output:

```
1 2 3 4 5
```

---

## 📌 Optimization Tip

You can add a **flag** to detect if any swaps were made during a pass. If no swaps are made, the array is already sorted and you can **break early**.

```cpp
void OptimizedBubbleSort(int arr[], int n) {
    for (int i = n - 1; i > 0; i--) {
        bool swapped = false;
        for (int j = 0; j <= i - 1; j++) {
            if (arr[j] > arr[j+1]) {
                swap(arr[j], arr[j+1]);
                swapped = true;
            }
        }
        if (!swapped) break;  // Optimization: stop if already sorted
    }
}
```

---

## 🧠 Bubble Sort vs Selection Sort

| Criteria  | Bubble Sort           | Selection Sort |
| --------- | --------------------- | -------------- |
| Stability | ✅ Stable              | ❌ Not stable   |
| Best Case | O(n²) *(without opt)* | O(n²)          |
| Adaptive  | ❌ No                  | ❌ No           |
| Swaps     | Many                  | Few            |
| Real Use  | Rare                  | Rare           |

---

## ❓ FAQs

### Q1: Why does it go till `n-1` passes?

Because after `n-1` passes, the array is sorted — every pass places one largest element at the end.

---

### Q2: Is Bubble Sort used in real-world?

Hardly ever. It’s mainly used for:

* Teaching purposes (intro to sorting).
* Very small arrays where simplicity is preferred over performance.

---

### Q3: Is it in-place?

✅ Yes. It modifies the original array and uses **no extra space**.

---

### Q4: Is Bubble Sort stable?

✅ Yes. It doesn’t change the relative order of equal elements.

---

## ✨ Final Thoughts

* Great for understanding **how sorting algorithms work**.
* **Inefficient** on large arrays.
* Use **C++ STL `sort()`** or advanced algorithms like **Merge Sort**, **Quick Sort** in production.

---
