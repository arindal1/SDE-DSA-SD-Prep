# ğŸ“¦ Heap Sort â€“ In-Depth Guide

---

## ğŸ“Œ Problem Statement

Given an array of integers, sort it **in-place** in ascending order using the **Heap Sort** algorithm.

---

## ğŸ’¡ What Is Heap Sort?

Heap Sort is a **comparison-based**, **in-place**, **unstable** sorting algorithm that leverages a **binary heap** data structure to achieve **O(n log n)** time in all cases.

* **Build a max-heap** from the array.
* **Repeatedly** extract the maximum element (root of the heap), swap it with the last unsorted element, shrink the heap by one, and **heapify** the root.

---

## ğŸ” High-Level Steps

1. **Build Max-Heap**

   * Treat the array as a complete binary tree.
   * For each non-leaf node from `âŒŠn/2âŒ‹âˆ’1` down to `0`, call `heapify`.

2. **Sort**

   * For `i` from `nâˆ’1` down to `1`:

     1. **Swap** `arr[0]` (max) with `arr[i]`.
     2. **Reduce** heap size by one (`heapSize = i`).
     3. **Heapify** at root (`index 0`) to restore max-heap.

---

## ğŸ“ Algorithm Pseudocode

```text
FUNCTION heapSort(arr, n):
    // 1) Build max heap
    FOR i FROM floor(n/2) - 1 DOWN TO 0:
        heapify(arr, n, i)

    // 2) One by one extract max
    FOR i FROM n - 1 DOWN TO 1:
        swap(arr[0], arr[i])       // move current max to end
        heapify(arr, i, 0)         // restore heap on arr[0..i-1]

FUNCTION heapify(arr, heapSize, root):
    largest â† root
    left    â† 2*root + 1
    right   â† 2*root + 2

    IF left < heapSize AND arr[left] > arr[largest]:
        largest â† left
    IF right < heapSize AND arr[right] > arr[largest]:
        largest â† right

    IF largest â‰  root:
        swap(arr[root], arr[largest])
        heapify(arr, heapSize, largest)
```

---

## ğŸ’¾ C++ Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

// Maintains max-heap property for subtree rooted at 'root'
void heapify(vector<int>& arr, int heapSize, int root) {
    int largest = root;
    int left    = 2*root + 1;
    int right   = 2*root + 2;

    if (left < heapSize && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < heapSize && arr[right] > arr[largest]) {
        largest = right;
    }
    if (largest != root) {
        swap(arr[root], arr[largest]);
        heapify(arr, heapSize, largest);
    }
}

// Main Heap Sort function
void heapSort(vector<int>& arr) {
    int n = arr.size();
    // 1) Build max-heap
    for (int i = n/2 - 1; i >= 0; --i) {
        heapify(arr, n, i);
    }
    // 2) Extract elements from heap one by one
    for (int i = n - 1; i > 0; --i) {
        swap(arr[0], arr[i]);       // move max to end
        heapify(arr, i, 0);         // restore heap on reduced array
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    heapSort(arr);

    for (int x : arr)
        cout << x << " ";
    cout << "\n";
    return 0;
}
```

---

## ğŸ“ˆ Complexity Analysis

| **Case**               | **Time Complexity** | **Space Complexity** |
| ---------------------- | ------------------- | -------------------- |
| Best / Average / Worst | O(n log n)          | O(1) (in-place)      |

* **Build heap:** O(n)
* **Each extraction:** O(log n), done n âˆ’ 1 times â†’ O(n log n)
* **Total:** O(n + n log n) = O(n log n)

---

## âœ¨ Characteristics

* **In-Place:** Uses the input array as the heapâ€”no auxiliary arrays.
* **Unstable:** Equal elements may change relative order.
* **Not Adaptive:** Doesnâ€™t benefit from partly-sorted data.
* **Guaranteed O(n log n):** No worst-case degradation.

---

## â“ FAQs

**Q1: Why does build-heap take O(n) time, not O(n log n)?**

> Heapify at each node costs proportional to height; summing over all nodes yields O(n).

---

**Q2: Is Heap Sort faster than Quick Sort?**

> In practice, Quick Sort is usually faster due to cache-friendliness and smaller constants, though its worst case is O(nÂ²).

---

**Q3: Can we make Heap Sort stable?**

> A **stable** variant requires extra bookkeeping (e.g., pairing each key with original index), losing the in-place advantage.

---

**Q4: When would you choose Heap Sort?**

> When you need guaranteed O(n log n) time and constant extra space, e.g., in memory-constrained environments.

---
