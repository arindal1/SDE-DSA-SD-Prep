# 🧠 Merge Sort – Explained in Depth

---

## 📌 Problem Statement

> Given an unsorted array of integers, sort it using **Merge Sort** — a classic **Divide and Conquer** algorithm.

---

## ✨ What is Merge Sort?

**Merge Sort** is a comparison-based **Divide and Conquer** algorithm. It works by:

* **Dividing** the array into two halves,
* **Sorting** each half recursively,
* And then **merging** the sorted halves.

It is **stable**, **efficient**, and suitable for large datasets.

---

## 🧩 Merge Sort Algorithm

### 🔄 High-Level Steps:

1. **Divide**: Recursively divide the array into two halves until subarrays are of size 1.
2. **Conquer**: Sort the two halves recursively.
3. **Combine**: Merge the sorted halves into a single sorted array.

---

## ✅ Code Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

// Function to merge two sorted halves
void merge(int arr[], int low, int mid, int high) {
    vector<int> temp;
    int left = low;       // starting index of left half
    int right = mid + 1;  // starting index of right half

    // Merge the two halves into temp[]
    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {
            temp.push_back(arr[left]);
            left++;
        } else {
            temp.push_back(arr[right]);
            right++;
        }
    }

    // Copy remaining elements of left half
    while (left <= mid) {
        temp.push_back(arr[left]);
        left++;
    }

    // Copy remaining elements of right half
    while (right <= high) {
        temp.push_back(arr[right]);
        right++;
    }

    // Copy sorted elements back into original array
    for (int i = low; i <= high; i++) {
        arr[i] = temp[i - low];
    }
}

// Recursive function to apply merge sort
void mergeSort(int arr[], int low, int high) {
    if (low >= high) return;

    int mid = (low + high) / 2;

    // Recursively sort first half
    mergeSort(arr, low, mid);

    // Recursively sort second half
    mergeSort(arr, mid + 1, high);

    // Merge the sorted halves
    merge(arr, low, mid, high);
}

// Driver code
int main() {
    int arr[] = {6, 3, 9, 5, 2, 8};
    int n = sizeof(arr) / sizeof(arr[0]);

    mergeSort(arr, 0, n - 1);

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;

    return 0;
}
```

---

## 🧠 Step-by-Step Dry Run

Input:

```
arr = [6, 3, 9, 5, 2, 8]
```

### Breakdown:

1. Divide into \[6, 3, 9] and \[5, 2, 8]
2. Sort \[6, 3, 9] → merge \[3, 6, 9]
3. Sort \[5, 2, 8] → merge \[2, 5, 8]
4. Merge \[3, 6, 9] and \[2, 5, 8] → \[2, 3, 5, 6, 8, 9]

---

## 📊 Time and Space Complexity

| Case         | Time Complexity | Space Complexity |
| ------------ | --------------- | ---------------- |
| Best Case    | O(n log n)      | O(n)             |
| Average Case | O(n log n)      | O(n)             |
| Worst Case   | O(n log n)      | O(n)             |

💡 Even in the worst case, **Merge Sort** maintains **O(n log n)** performance, which is better than **Bubble**, **Insertion**, and **Selection Sort** (O(n²)).

---

## 📌 Characteristics of Merge Sort

| Property                            | Value |
| ----------------------------------- | ----- |
| **Stable**                          | ✅ Yes |
| **In-place**                        | ❌ No  |
| **Recursive**                       | ✅ Yes |
| **Divide & Conquer**                | ✅ Yes |
| **Efficient on large arrays**       | ✅ Yes |
| **Used in STL (C++ `stable_sort`)** | ✅     |

---

## 🧠 Real-Life Analogy

> Think of **Merge Sort** as a tournament. Split all players (elements) into pairs, sort them, and keep merging winners (smaller numbers) until you get a fully sorted bracket.

---

## ❓ Frequently Asked Questions

### ❓ Q1: Is Merge Sort better than Quick Sort?

🔸 Merge Sort has guaranteed O(n log n) time in all cases, but Quick Sort is generally faster for in-place sorting and smaller auxiliary space.

---

### ❓ Q2: Is Merge Sort a stable sorting algorithm?

✅ Yes. Elements with equal values maintain their relative position.

---

### ❓ Q3: Can Merge Sort be done in-place?

🔸 Traditional merge sort is **not in-place** due to auxiliary space used for merging. But with advanced techniques, **in-place merge** can be attempted with trade-offs.

---

### ❓ Q4: Where is Merge Sort used in real life?

* Sorting linked lists
* External sorting (when data doesn't fit in memory)
* STL's `stable_sort()` in C++

---

## 🛠️ Tips for Implementation

* Always prefer passing indices (`low` and `high`) over slicing the array — better for performance.
* Merge sort works **best** on large datasets or when you **need stability**.
* Use `vector<int> temp` instead of raw arrays for easier memory handling.

---

## 🧪 Test Case Suggestions

| Input            | Output           |
| ---------------- | ---------------- |
| \[5, 4, 3, 2, 1] | \[1, 2, 3, 4, 5] |
| \[1, 1, 1, 1]    | \[1, 1, 1, 1]    |
| \[10]            | \[10]            |
| \[]              | \[]              |

---

## 🔚 Final Thoughts

Merge Sort is one of the **most powerful recursive sorting algorithms**, especially effective when stability and performance on large datasets is a must.

---
