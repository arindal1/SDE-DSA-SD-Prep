# âš¡ Quick Sort â€“ Complete Guide

---

## ðŸ“Œ Problem Statement

> Given an unsorted array of integers, sort it using the **Quick Sort** algorithm â€” a classic and efficient **Divide and Conquer** sorting technique.

---

## ðŸš€ What is Quick Sort?

**Quick Sort** is an in-place, divide-and-conquer sorting algorithm. It works by:

* Choosing a **pivot** element,
* **Partitioning** the array such that elements smaller than the pivot go left, and larger go right,
* Recursively sorting the left and right halves.

It's known for its **speed and low memory usage**.

---

## ðŸ§  Quick Sort Algorithm

### ðŸ”„ High-Level Steps:

1. **Choose a pivot** (typically the last or middle element).
2. **Partition** the array:

   * Elements less than pivot go to the left.
   * Elements greater go to the right.
3. **Recursively apply** the above steps to left and right subarrays.

---

## âœ… Code Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

// Function to perform partition
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // choose the last element as pivot
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }

    // Place pivot in its correct sorted position
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// Recursive function for quicksort
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high); // partition index
        quickSort(arr, low, pi - 1);        // sort left of pivot
        quickSort(arr, pi + 1, high);       // sort right of pivot
    }
}

// Driver Code
int main() {
    int arr[] = {7, 2, 1, 6, 8, 5, 3, 4};
    int n = sizeof(arr) / sizeof(arr[0]);

    quickSort(arr, 0, n - 1);

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;

    return 0;
}
```

---

## ðŸ§© Step-by-Step Example

Given:

```
arr = [7, 2, 1, 6, 8, 5, 3, 4]
```

### Step 1:

* Choose pivot = 4
* Partition around 4 â†’ `[2, 1, 3] 4 [7, 8, 5, 6]`

### Step 2:

* Recursively sort left and right subarrays:

  * Left of 4 â†’ `[2, 1, 3]` â†’ sorted to `[1, 2, 3]`
  * Right of 4 â†’ `[7, 8, 5, 6]` â†’ sorted to `[5, 6, 7, 8]`

### Result:

Final sorted array:

```
[1, 2, 3, 4, 5, 6, 7, 8]
```

---

## ðŸ“Š Time and Space Complexity

| Case         | Time Complexity            | Space Complexity |
| ------------ | -------------------------- | ---------------- |
| Best Case    | O(n log n)                 | O(log n)         |
| Average Case | O(n log n)                 | O(log n)         |
| Worst Case   | O(nÂ²) *(unbalanced pivot)* | O(log n)         |

ðŸ”” *Worst case occurs when pivot is the smallest or largest element consistently (like in already sorted arrays).*

---

## ðŸ“Œ Characteristics of Quick Sort

| Property                                 | Value   |
| ---------------------------------------- | ------- |
| **In-place**                             | âœ… Yes   |
| **Stable**                               | âŒ No    |
| **Recursive**                            | âœ… Yes   |
| **Divide & Conquer**                     | âœ… Yes   |
| **Memory Efficient**                     | âœ… Yes   |
| **Faster than Merge Sort (in practice)** | âœ… Often |

---

## ðŸ› ï¸ Tips for Better Quick Sort

* **Random Pivoting**: Choosing a random pivot avoids worst-case performance on sorted inputs.
* **Tail Recursion Optimization**: Can help reduce stack depth.
* **Hybrid with Insertion Sort**: For small arrays (n < 10), use insertion sort.

---

## â“ Frequently Asked Questions

#### â“ Q1: Is Quick Sort stable?

âŒ No. It may not preserve the original order of equal elements.

---

#### â“ Q2: Why is Quick Sort faster than Merge Sort in practice?

ðŸ”¸ It uses less memory (no auxiliary array) and exhibits better **cache locality**.

---

#### â“ Q3: Can we make Quick Sort stable?

ðŸ”¸ Not easily. It requires significant changes that often eliminate its advantages.

---

#### â“ Q4: What are the common applications of Quick Sort?

* Efficient sorting in-memory
* Database sorting
* Competitive programming

---

## ðŸ§ª Test Case Suggestions

| Input         | Output        |
| ------------- | ------------- |
| \[1, 2, 3]    | \[1, 2, 3]    |
| \[3, 2, 1]    | \[1, 2, 3]    |
| \[4, 4, 4, 4] | \[4, 4, 4, 4] |
| \[]           | \[]           |

---

# ðŸ”š Final Thoughts

**Quick Sort** is a beautiful and elegant sorting algorithm that dominates in practice for its **speed**, **in-place sorting**, and **low memory usage** â€” though it trades off stability.

---

## ðŸ“Š Comparison Table: Sorting Algorithms

| Algorithm          | Time Complexity (Best) | Time Complexity (Average) | Time Complexity (Worst) | Space Complexity | Stable | In-Place |
| ------------------ | ---------------------- | ------------------------- | ----------------------- | ---------------- | ------ | -------- |
| **Bubble Sort**    | O(n)                   | O(nÂ²)                     | O(nÂ²)                   | O(1)             | âœ… Yes  | âœ… Yes    |
| **Selection Sort** | O(nÂ²)                  | O(nÂ²)                     | O(nÂ²)                   | O(1)             | âŒ No   | âœ… Yes    |
| **Insertion Sort** | O(n)                   | O(nÂ²)                     | O(nÂ²)                   | O(1)             | âœ… Yes  | âœ… Yes    |
| **Merge Sort**     | O(n log n)             | O(n log n)                | O(n log n)              | O(n)             | âœ… Yes  | âŒ No     |
| **Quick Sort**     | O(n log n)             | O(n log n)                | O(nÂ²)                   | O(log n)         | âŒ No   | âœ… Yes    |

---

