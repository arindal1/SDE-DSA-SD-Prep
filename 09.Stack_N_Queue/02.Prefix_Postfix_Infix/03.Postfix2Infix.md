# ðŸ”„ Postfix âžœ Infix (fully parenthesized)

## ðŸ§© Problem Statement

Given a string `s` representing a **postfix** expression with binary operators (e.g., `+ - * / ^`) and alphanumeric operands, return the **infix** expression.
Weâ€™ll produce a **fully parenthesized** infix (every binary operation wrapped in parentheses) to avoid precedence ambiguity.



### ðŸ§  Intuition

Postfix means operators come **after** their operands. To rebuild infix:

* Scan left â†’ right
* If you see an **operand** â†’ push it as a string
* If you see an **operator** â†’ pop two strings `t1` (right), `t2` (left), combine as `("(" + t2 + op + t1 + ")")`, then push back
* At the end, the stack should have exactly **one** string â†’ the result

This is the classic **stack-based** reconstruction.


### âœ… Clean Code (single-char operands, spaces ignored)

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isOperand(char c) {
    return isalnum(static_cast<unsigned char>(c)); // A-Z, a-z, 0-9
}

bool isOperator(char c) {
    return c=='+' || c=='-' || c=='*' || c=='/' || c=='^';
}

// Convert postfix to fully parenthesized infix
string postfixToInfix(const string& s) {
    stack<string> st;

    for (char ch : s) {
        if (isspace(static_cast<unsigned char>(ch))) continue;

        if (isOperand(ch)) {
            st.push(string(1, ch));
        } else if (isOperator(ch)) {
            if (st.size() < 2)
                throw runtime_error("Invalid expression: insufficient operands for operator.");
            string t1 = st.top(); st.pop(); // right
            string t2 = st.top(); st.pop(); // left
            st.push("(" + t2 + ch + t1 + ")");
        } else {
            throw runtime_error(string("Invalid character in expression: '") + ch + "'");
        }
    }

    if (st.size() != 1)
        throw runtime_error("Invalid expression: leftover operands/operators.");

    return st.top();
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s);
    try {
        cout << "Infix: " << postfixToInfix(s) << "\n";
    } catch (const exception& e) {
        cout << "Error: " << e.what() << "\n";
    }
    return 0;
}
```

---

### ðŸ”¡ Token-Based Version (multi-digit numbers & identifiers)

Supports inputs like: `12 3 + x1 5 * -` â†’ `((12+3)-(x1*5))`
Rules:

* **Numbers**: consecutive digits
* **Identifiers**: letter/underscore, followed by letters/digits/underscore
* Operators: `+ - * / ^`
* Spaces separate tokens (recommended)

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isOperator(const string& tk) {
    return tk == "+" || tk == "-" || tk == "*" || tk == "/" || tk == "^";
}

vector<string> tokenize(const string& s) {
    vector<string> tokens;
    for (size_t i = 0; i < s.size();) {
        char c = s[i];
        if (isspace(static_cast<unsigned char>(c))) { ++i; continue; }

        if (isdigit(static_cast<unsigned char>(c))) {
            size_t j = i;
            while (j < s.size() && isdigit(static_cast<unsigned char>(s[j]))) ++j;
            tokens.emplace_back(s.substr(i, j - i));
            i = j;
        } else if (isalpha(static_cast<unsigned char>(c)) || c == '_') {
            size_t j = i;
            while (j < s.size() && (isalnum(static_cast<unsigned char>(s[j])) || s[j] == '_')) ++j;
            tokens.emplace_back(s.substr(i, j - i));
            i = j;
        } else if (string("+-*/^").find(c) != string::npos) {
            tokens.emplace_back(string(1, c));
            ++i;
        } else {
            throw runtime_error(string("Invalid character: ") + c);
        }
    }
    return tokens;
}

string postfixToInfixTokens(const string& s) {
    auto tokens = tokenize(s);
    stack<string> st;

    for (const string& tk : tokens) {
        if (isOperator(tk)) {
            if (st.size() < 2)
                throw runtime_error("Invalid expression: insufficient operands for operator.");
            string t1 = st.top(); st.pop();
            string t2 = st.top(); st.pop();
            st.push("(" + t2 + tk + t1 + ")");
        } else {
            st.push(tk);
        }
    }

    if (st.size() != 1)
        throw runtime_error("Invalid expression: leftover operands/operators.");
    return st.top();
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s);
    try {
        cout << "Infix: " << postfixToInfixTokens(s) << "\n";
    } catch (const exception& e) {
        cout << "Error: " << e.what() << "\n";
    }
}
```



### ðŸ§ª Examples

| Postfix                 | Infix (fully parenthesized)                          |
| ----------------------- | ---------------------------------------------------- |
| `ab+`                   | `(a+b)`                                              |
| `ab+c*`                 | `((a+b)*c)`                                          |
| `abc*+`                 | `(a+(b*c))`                                          |
| `ab^c^` *(right assoc)* | `((a^b)^c)` *(postfix fixes association inherently)* |
| `12 3 + x1 5 * -`       | `((12+3)-(x1*5))`                                    |

> Note: Postfix already encodes grouping. This reconstruction is always **unambiguous**. We output **fully parenthesized** form for clarity.


### â±ï¸ Complexity

* **Time:** `O(n)` (each token pushed/popped at most once)
* **Space:** `O(n)` (stack of strings)


### ðŸ§  Tips & Variations

* For **minimal parentheses** (pretty-print respecting precedence), youâ€™d need to build an **AST** and re-print with precedence/associativity rulesâ€”more involved than always wrapping `(...)`.
* To support **unary operators** in postfix, you must know each operatorâ€™s **arity** and pop accordingly.
* Validate aggressively: stack underflow and leftover items are the two classic failure modes.


### â“ FAQs

**Q: Why fully parenthesize instead of relying on precedence?**
>It guarantees correctness regardless of operator precedence and is simpler to implement from postfix.

**Q: Can this break on malformed input?**
>We now throw clear errors for insufficient operands, invalid characters, and leftover items.

**Q: How do I handle custom operators?**
>Add them to `isOperator`, and if arities differ, track arity and pop that many operands.

