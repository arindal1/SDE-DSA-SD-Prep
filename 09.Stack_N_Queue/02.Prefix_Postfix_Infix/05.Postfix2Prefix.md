# ðŸ”„ Postfix âžœ Prefix

## ðŸ§© Problem Statement

Given a **postfix** expression `s` consisting of operands (alphanumeric) and binary operators `+ - * / ^`, return its **prefix** form.

We assume:

* Operators are **binary**.
* Spaces may appear and should be ignored.

---

### ðŸ§  Intuition

Postfix reads **operands first, operator after**. To convert to prefix:

* Scan **left â†’ right**.
* If you see an **operand**: push it as a string.
* If you see an **operator** `op`: pop **two** items `t1` (right), `t2` (left), then push **`op t2 t1`** as a single string.
* At the end, the stack should contain exactly **one** string â€” the result.

This is the mirror of postfixâ†’infix, except the concatenation order is `op + left + right`.


### âœ… Clean Code (single-char operands)

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isOperand(char c) {
    return isalnum(static_cast<unsigned char>(c)); // A-Z, a-z, 0-9
}

bool isOperator(char c) {
    return c=='+' || c=='-' || c=='*' || c=='/' || c=='^';
}

string postfixToPrefix(const string& s) {
    stack<string> st;

    for (size_t i = 0; i < s.size(); ++i) {
        unsigned char ch = static_cast<unsigned char>(s[i]);

        if (isspace(ch)) continue;

        if (isOperand(ch)) {
            st.push(string(1, s[i]));
        } else if (isOperator(ch)) {
            if (st.size() < 2)
                throw runtime_error("Invalid expression: insufficient operands for operator.");
            string t1 = st.top(); st.pop(); // right
            string t2 = st.top(); st.pop(); // left
            st.push(string(1, s[i]) + t2 + t1); // prefix: op + left + right
        } else {
            throw runtime_error(string("Invalid character in expression: '") + s[i] + "'");
        }
    }

    if (st.size() != 1)
        throw runtime_error("Invalid expression: leftover operands/operators.");

    return st.top();
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s);
    try {
        cout << "Prefix: " << postfixToPrefix(s) << "\n";
    } catch (const exception& e) {
        cout << "Error: " << e.what() << "\n";
    }
    return 0;
}
```


### ðŸ§ª Dry Run

Postfix: `ab+c*`

* `a` â†’ push `"a"`
* `b` â†’ push `"b"`
* `+` â†’ pop `"b"`,`"a"` â†’ push `"+ab"`
* `c` â†’ push `"c"`
* `*` â†’ pop `"c"`, `"+ab"` â†’ push `"*+abc"`

Stack â†’ `*+abc` âœ…

---

### ðŸ”¡ Token-Based Version (multi-digit numbers & identifiers)

Support inputs like: `12 3 + x1 5 * -` â†’ Prefix: `-+12x1*3y`

Tokenization rules:

* **Numbers**: consecutive digits
* **Identifiers**: letter/underscore followed by letters/digits/underscore
* **Operators**: `+ - * / ^`
* **Spaces**: separators

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isOperator(const string& tk) {
    return tk=="+" || tk=="-" || tk=="*" || tk=="/" || tk=="^";
}

vector<string> tokenizePostfix(const string& s) {
    vector<string> tokens;
    for (size_t i = 0; i < s.size(); ) {
        unsigned char c = static_cast<unsigned char>(s[i]);
        if (isspace(c)) { ++i; continue; }

        if (isdigit(c)) {
            size_t j = i;
            while (j < s.size() && isdigit(static_cast<unsigned char>(s[j]))) ++j;
            tokens.emplace_back(s.substr(i, j - i));
            i = j;
        } else if (isalpha(c) || c == '_') {
            size_t j = i;
            while (j < s.size()) {
                unsigned char d = static_cast<unsigned char>(s[j]);
                if (!isalnum(d) && d != '_') break;
                ++j;
            }
            tokens.emplace_back(s.substr(i, j - i));
            i = j;
        } else if (string("+-*/^").find(c) != string::npos) {
            tokens.emplace_back(string(1, s[i]));
            ++i;
        } else {
            throw runtime_error(string("Invalid character: ") + s[i]);
        }
    }
    return tokens;
}

string postfixToPrefixTokens(const string& s) {
    vector<string> toks = tokenizePostfix(s);
    stack<string> st;

    for (const string& tk : toks) {
        if (isOperator(tk)) {
            if (st.size() < 2) throw runtime_error("Invalid expression: insufficient operands.");
            string t1 = st.top(); st.pop();
            string t2 = st.top(); st.pop();
            st.push(tk + t2 + t1);
        } else {
            st.push(tk);
        }
    }

    if (st.size() != 1) throw runtime_error("Invalid expression: leftover operands/operators.");
    return st.top();
}
```


### â±ï¸ Complexity

* **Time:** `O(n)` â€” each token/char is pushed/popped at most once.
* **Space:** `O(n)` â€” stack of partial strings.


### âš ï¸ Edge Cases & Tips

* **Insufficient operands** for an operator â†’ invalid.
* **Leftover items** at the end â†’ invalid.
* **Unary operators** are **not** handled here; if needed, track operator **arity** and pop accordingly.
* Postfix already encodes grouping; you donâ€™t need to worry about precedence/associativity here.


### â“ FAQs

**Q: Why `op + left + right`?**
> Because prefix requires the operator first, followed by the left subtree, then the right subtree.

**Q: Do I need parentheses in prefix?**
>No â€” prefix is unambiguous without them.

**Q: How do I support unary minus?**
> You must know arity per operator. For a unary `op`, pop one operand, then push `op + operand`.

