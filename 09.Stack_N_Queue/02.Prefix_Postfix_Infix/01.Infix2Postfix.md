# üßÆ Infix ‚Üí Postfix (Shunting-Yard)


## üìå Problem Statement

Given a string `s` representing an arithmetic expression in **infix** notation with operators `+ - * / ^` and parentheses `()`, return the **postfix** notation where operators follow their operands.

**Assumptions (baseline version):**

* Operands are single letters (`A‚ÄìZ`, `a‚Äìz`) or single digits (`0‚Äì9`)
* No unary operators (like unary minus)
* No spaces (or we ignore them)

---

### üß† Intuition  (Shunting-Yard by Dijkstra)

We scan the infix expression from left to right and use a **stack** for operators:

* **Operand** ‚Üí Append directly to output.
* **Left parenthesis `(`** ‚Üí Push to stack.
* **Right parenthesis `)`** ‚Üí Pop from stack to output until `(` is found. Discard both parentheses.
* **Operator `op`** ‚Üí While there is an operator `top` on the stack with **greater precedence** or **equal precedence and `op` is left-associative**, pop `top` to output. Then push `op`.

At the end, pop all remaining stack operators to the output.

### Precedence & Associativity

* Precedence: `^` > `* /` > `+ -`
* Associativity:

  * `+ - * /` are **left-associative**
  * `^` is **right-associative** (‚ö†Ô∏è easy to get wrong!)



### ‚úÖ Clean Code (single-char operands)

```cpp
#include <bits/stdc++.h>
using namespace std;

int prec(char c) {
    if (c == '^') return 3;
    if (c == '*' || c == '/') return 2;
    if (c == '+' || c == '-') return 1;
    return -1;
}

bool isLeftAssociative(char c) {
    // +, -, *, / are left-associative; ^ is right-associative
    return (c != '^');
}

bool isOperand(char c) {
    return (isalnum(static_cast<unsigned char>(c))); // A-Z, a-z, 0-9
}

string infixToPostfix(const string& s) {
    stack<char> st;
    string out;

    for (char ch : s) {
        if (isspace(static_cast<unsigned char>(ch))) continue; // ignore spaces

        if (isOperand(ch)) {
            out += ch;
        }
        else if (ch == '(') {
            st.push(ch);
        }
        else if (ch == ')') {
            // pop until '('
            while (!st.empty() && st.top() != '(') {
                out += st.top();
                st.pop();
            }
            if (st.empty()) {
                throw runtime_error("Invalid expression: mismatched parentheses");
            }
            st.pop(); // discard '('
        }
        else { // operator
            while (!st.empty() && st.top() != '(') {
                int pc = prec(ch), pt = prec(st.top());
                if (pt > pc || (pt == pc && isLeftAssociative(ch))) {
                    out += st.top();
                    st.pop();
                } else break;
            }
            st.push(ch);
        }
    }

    // pop remaining
    while (!st.empty()) {
        if (st.top() == '(' || st.top() == ')') {
            throw runtime_error("Invalid expression: mismatched parentheses");
        }
        out += st.top();
        st.pop();
    }
    return out;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s); // allow spaces
    try {
        cout << "Postfix: " << infixToPostfix(s) << "\n";
    } catch (const exception& e) {
        cout << "Error: " << e.what() << "\n";
    }
    return 0;
}
```
---

### üî¢ Token-Based Version (multi-digit numbers, identifiers)

If you want to support inputs like `12 + (x3 * 5) ^ 2`, we need tokenization.

* **Numbers**: collect consecutive digits as one token.
* **Identifiers**: collect letters/digits/underscore as names.
* **Spaces**: ignore.

```cpp
#include <bits/stdc++.h>
using namespace std;

int prec(char c) {
    if (c == '^') return 3;
    if (c == '*' || c == '/') return 2;
    if (c == '+' || c == '-') return 1;
    return -1;
}
bool isLeftAssociative(char c) { return c != '^'; }

bool isIdentStart(char c) { return isalpha(static_cast<unsigned char>(c)) || c=='_'; }
bool isIdentChar(char c)  { return isalnum(static_cast<unsigned char>(c)) || c=='_'; }

vector<string> tokenize(const string& s) {
    vector<string> tokens;
    for (size_t i = 0; i < s.size(); ) {
        char c = s[i];
        if (isspace(static_cast<unsigned char>(c))) { ++i; continue; }

        if (isdigit(static_cast<unsigned char>(c))) {
            size_t j = i;
            while (j < s.size() && isdigit(static_cast<unsigned char>(s[j]))) ++j;
            tokens.emplace_back(s.substr(i, j - i)); // number
            i = j;
        } else if (isIdentStart(c)) {
            size_t j = i;
            while (j < s.size() && isIdentChar(s[j])) ++j;
            tokens.emplace_back(s.substr(i, j - i)); // identifier
            i = j;
        } else if (string("()+-*/^").find(c) != string::npos) {
            tokens.emplace_back(string(1, c)); // operator or paren
            ++i;
        } else {
            throw runtime_error(string("Invalid character: ") + c);
        }
    }
    return tokens;
}

string infixToPostfixTokens(const string& s) {
    auto tokens = tokenize(s);
    stack<char> st;
    vector<string> out; // collect tokens

    for (const string& tk : tokens) {
        if (tk.size() > 1 || isalnum(static_cast<unsigned char>(tk[0]))) {
            // number or identifier
            out.push_back(tk);
        } else {
            char ch = tk[0];
            if (ch == '(') {
                st.push(ch);
            } else if (ch == ')') {
                while (!st.empty() && st.top() != '(') {
                    out.emplace_back(string(1, st.top()));
                    st.pop();
                }
                if (st.empty()) throw runtime_error("Invalid expression: mismatched parentheses");
                st.pop();
            } else { // operator
                while (!st.empty() && st.top() != '(') {
                    int pc = prec(ch), pt = prec(st.top());
                    if (pt > pc || (pt == pc && isLeftAssociative(ch))) {
                        out.emplace_back(string(1, st.top()));
                        st.pop();
                    } else break;
                }
                st.push(ch);
            }
        }
    }
    while (!st.empty()) {
        if (st.top() == '(' || st.top() == ')') throw runtime_error("Invalid expression: mismatched parentheses");
        out.emplace_back(string(1, st.top()));
        st.pop();
    }

    // join with spaces for clarity
    string res;
    for (size_t i = 0; i < out.size(); ++i) {
        if (i) res += ' ';
        res += out[i];
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s);
    try {
        cout << "Postfix: " << infixToPostfixTokens(s) << "\n";
    } catch (const exception& e) {
        cout << "Error: " << e.what() << "\n";
    }
}
```


### üß™ Examples

| Infix                         | Postfix                       |
| ----------------------------- | ----------------------------- |
| `A+B*C`                       | `ABC*+`                       |
| `(A+B)*C`                     | `AB+C*`                       |
| `A^B^C`                       | `ABC^^` *(right-associative)* |
| `a+(b*c-(d/e^f)*g)*h`         | `abc*def^/g*-h*+`             |
| `12 + (x3 * 5) ^ 2` *(token)* | `12 x3 5 * 2 ^ +`             |

---

### ‚è±Ô∏è Complexity

* **Time:** `O(n)` ‚Äî each token/char is pushed/popped at most once.
* **Space:** `O(n)` ‚Äî operator stack + output buffer.


### üß† Tips & Variations

* **Unary operators** (e.g., unary `-`) require extra handling (detect at tokenization time when `-` appears at start or after `(` or another operator).
* **Functions & commas** (e.g., `max(a,b)`) need the full Shunting-Yard extension (function stack, argument separators).
* **Error handling:** guard `stack.top()` with `!stack.empty()`, and validate mismatched parentheses.



### ‚ùì FAQs

**Q: Why is `^` right-associative?**
> Exponentiation groups from the right: `a^b^c = a^(b^c)`.

**Q: Why do we pop on equal precedence only if the incoming op is left-associative?**
> That preserves associativity: for `a^b^c`, we **don‚Äôt** pop the previous `^` when we see the next `^`, keeping right grouping.

**Q: Can we support multi-digit numbers and spaces?**
> Yes ‚Äî use the token-based version above.

