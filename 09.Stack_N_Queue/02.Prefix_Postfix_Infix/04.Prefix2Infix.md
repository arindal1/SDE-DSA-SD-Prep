# üîÅ Prefix ‚ûú Infix (fully parenthesized)

## üß© Problem Statement

Given a string `s` representing a **prefix** expression over binary operators (`+ - * / ^`) and alphanumeric operands, return the corresponding **infix** expression.
We‚Äôll output a **fully parenthesized** infix form to avoid ambiguity.

**Assumptions (baseline):**

* Operands are single alphanumeric characters (e.g., `a`, `Z`, `7`)
* Operators are binary: `+ - * / ^`
* Spaces may appear and should be ignored

---

### üß† Intuition

Prefix (operators before operands) can be reconstructed using a **stack** by scanning **right to left**:

* If you see an **operand** ‚Üí push it as a string.
* If you see an **operator** ‚Üí pop **two** strings `t1` and `t2` (these are the operator‚Äôs **left** and **right** operands in order), combine as `("(" + t1 + op + t2 + ")")`, and push back.
* At the end, the stack should contain exactly **one** string ‚Äî the answer.

Why right to left?
Because prefix lays operators first; scanning from the end lets us collect complete operand subexpressions in the correct order before combining.


### ‚öôÔ∏è Algorithm

1. Initialize an empty `stack<string>`.
2. Traverse the expression from **right to left**:

   * Skip whitespace.
   * If `isOperand(ch)`: push `string(1, ch)`.
   * Else if `isOperator(ch)`:

     * Ensure at least 2 items on the stack (validation).
     * Pop `t1` then `t2`.
     * Push `"(" + t1 + ch + t2 + ")"`.
   * Else: error (invalid character).
3. After scanning, the stack should have **exactly one** string; otherwise, the expression is invalid.


## ‚úÖ Clean & Commented Code (single-char operands)

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isOperand(char c) {
    return isalnum(static_cast<unsigned char>(c)); // A-Z, a-z, 0-9
}

bool isOperator(char c) {
    return c=='+' || c=='-' || c=='*' || c=='/' || c=='^';
}

string prefixToInfix(const string& s) {
    stack<string> st;

    for (int i = static_cast<int>(s.size()) - 1; i >= 0; --i) {
        unsigned char ch = static_cast<unsigned char>(s[i]);

        if (isspace(ch)) continue;

        if (isOperand(ch)) {
            st.push(string(1, s[i]));
        } else if (isOperator(ch)) {
            if (st.size() < 2)
                throw runtime_error("Invalid expression: insufficient operands for operator.");
            string t1 = st.top(); st.pop(); // left operand
            string t2 = st.top(); st.pop(); // right operand
            st.push("(" + t1 + s[i] + t2 + ")");
        } else {
            throw runtime_error(string("Invalid character in expression: '") + s[i] + "'");
        }
    }

    if (st.size() != 1)
        throw runtime_error("Invalid expression: leftover operands/operators.");

    return st.top();
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s);
    try {
        cout << "Infix: " << prefixToInfix(s) << "\n";
    } catch (const exception& e) {
        cout << "Error: " << e.what() << "\n";
    }
    return 0;
}
```


### üß™ Dry Run

Prefix: `*+abc`
Scan right‚Üíleft:

* `c` ‚Üí push `"c"`
* `b` ‚Üí push `"b"`
* `a` ‚Üí push `"a"`
* `+` ‚Üí pop `"a"`,`"b"` ‚Üí push `"(a+b)"`
* `*` ‚Üí pop `"(a+b)"`,`"c"` ‚Üí push `"((a+b)*c)"`

Stack ‚Üí `((a+b)*c)` ‚úÖ


### ‚è±Ô∏è Complexity

* **Time:** `O(n)` ‚Äî each char is processed once; each stack op is O(1)
* **Space:** `O(n)` ‚Äî stack holds up to O(n) partial strings

---

### üß† Tips, Pitfalls & Variations

#### Pitfalls

* **Underflow:** popping when stack has < 2 items ‚Üí invalid prefix.
* **Leftover items:** more than one string left after processing ‚Üí invalid prefix.
* **Blind operator detection:** don‚Äôt treat ‚Äúanything else‚Äù as operator; explicitly whitelist `+ - * / ^`.

### Minimal Parentheses

We output fully parenthesized infix for correctness.
If you want **minimal parentheses**, you‚Äôll need:

* Build an **AST** during reconstruction.
* Reprint with operator **precedence** and **associativity** (e.g., `^` right-associative).

### Unary Operators (advanced)

If you must support unary minus (`~` or unary `-`):

* Know the **arity** of each operator (1 or 2).
* On seeing a unary operator, pop only **one** operand before forming the subexpression.

---

### üî° Token-Based Variant (multi-digit numbers / identifiers)

Support inputs like: `- + 12 x1 * 3 y`  ‚Üí `((12+x1)-(3*y))`
We tokenize from **right to left**:

* **Numbers**: consecutive digits
* **Identifiers**: letter/underscore then letters/digits/underscore
* **Operators**: `+ - * / ^`
* **Spaces**: ignored

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isOperator(const string& tk) {
    return tk=="+" || tk=="-" || tk=="*" || tk=="/" || tk=="^";
}

vector<string> tokenizePrefix(const string& s) {
    vector<string> tokens;
    for (int i = static_cast<int>(s.size()) - 1; i >= 0; ) {
        unsigned char c = static_cast<unsigned char>(s[i]);
        if (isspace(c)) { --i; continue; }

        if (isdigit(c)) {
            int j = i;
            while (j >= 0 && isdigit(static_cast<unsigned char>(s[j]))) --j;
            tokens.emplace_back(s.substr(j+1, i - j));
            i = j;
        } else if (isalpha(c) || c == '_') {
            int j = i;
            while (j >= 0) {
                unsigned char d = static_cast<unsigned char>(s[j]);
                if (!isalnum(d) && d != '_') break;
                --j;
            }
            tokens.emplace_back(s.substr(j+1, i - j));
            i = j;
        } else if (string("+-*/^").find(c) != string::npos) {
            tokens.emplace_back(string(1, s[i]));
            --i;
        } else {
            throw runtime_error(string("Invalid character: ") + s[i]);
        }
    }
    // tokens are already in right-to-left scan order; we will process forward
    reverse(tokens.begin(), tokens.end()); // optional: normalize to left->right
    return tokens;
}

string prefixToInfixTokens(const string& s) {
    vector<string> toks = tokenizePrefix(s);
    // process right->left semantics by iterating tokens from end to beginning
    stack<string> st;
    for (int k = static_cast<int>(toks.size()) - 1; k >= 0; --k) {
        const string& tk = toks[k];
        if (isOperator(tk)) {
            if (st.size() < 2) throw runtime_error("Invalid expression: insufficient operands.");
            string t1 = st.top(); st.pop();
            string t2 = st.top(); st.pop();
            st.push("(" + t1 + tk + t2 + ")");
        } else {
            st.push(tk);
        }
    }
    if (st.size() != 1) throw runtime_error("Invalid expression: leftover operands/operators.");
    return st.top();
}
```


### üß™ Example Inputs

| Prefix            | Infix (fully parenthesized) |
| ----------------- | --------------------------- |
| `+ab`             | `(a+b)`                     |
| `*+abc`           | `((a+b)*c)`                 |
| `^a^bc`           | `(a^(b^c))`                 |
| `- + 12 x1 * 3 y` | `((12+x1)-(3*y))`           |

> Note: Prefix encodes grouping already, so this reconstruction is unambiguous.


### ‚ùì FAQs

**Q: Why scan from right to left?**
>So that when we see an operator, the stack already holds its two operand subexpressions in correct order.

**Q: Why fully parenthesize?**
>Simplicity and correctness ‚Äî no need to reason about precedence/associativity. For prettier output, build an AST and print with minimal parentheses.

**Q: How to support unary operators?**
> Track operator **arity**. For a unary operator, pop **one** operand when forming the subexpression.

**Q: Do we need to worry about `^` associativity?**
> Not for reconstruction ‚Äî prefix determines grouping. Associativity matters when *printing minimal parentheses*, not here.

