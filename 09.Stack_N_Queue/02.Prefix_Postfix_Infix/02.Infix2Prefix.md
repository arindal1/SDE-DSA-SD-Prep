# üîÅ Infix ‚Üí Prefix (using Reverse + Stack)

## üß© Problem Statement

Given an infix expression with operators `+ - * / ^` and parentheses `()`, output the equivalent **prefix** expression.

**Assumptions (baseline)**

* Operands are letters `A‚ÄìZ/a‚Äìz` or digits `0‚Äì9` (single-char).
* No unary operators (e.g., unary minus).
* Optional spaces in input.

---

### üß† Intuition (Reverse + Postfix-on-Reversed)

Classic method to convert **infix ‚Üí prefix**:

1. **Reverse** the infix string.
2. **Swap** every `(` with `)` and vice-versa.
3. Run **infix ‚Üí postfix** on this reversed string, but with a **tweak to associativity** (explained below).
4. **Reverse** the resulting postfix string ‚Üí that‚Äôs your prefix.

### ‚ö†Ô∏è Associativity tweak

* In normal infix‚Üípostfix, `^` is **right-associative** (don‚Äôt pop on equal precedence).
* After **reversing**, associativity **flips**.
  Therefore, when processing the reversed string:

  * For `^`, we **should pop on equal precedence** (treat it as left-associative **in this step**).
  * For `+ - * /`, we **should not** pop on equal precedence (they become right-associative **in this step**).

**In practice:**
Use this pop condition for an incoming operator `op = ch` and stack top `top`:

```cpp
while top != '(' and (prec(op) < prec(top) or (prec(op) == prec(top) and op == '^')) 
    pop top
```




### ‚úÖ clean code -- single-char operands

```cpp
#include <bits/stdc++.h>
using namespace std;

int prec(char c) {
    if (c == '^') return 3;
    if (c == '*' || c == '/') return 2;
    if (c == '+' || c == '-') return 1;
    return -1;
}

string infixToPrefix(string s) {
    // 1) reverse the string
    reverse(s.begin(), s.end());
    // 2) swap parentheses
    for (char &ch : s) {
        if (ch == '(') ch = ')';
        else if (ch == ')') ch = '(';
    }

    stack<char> st;
    string out;

    for (char ch : s) {
        if (isspace(static_cast<unsigned char>(ch))) continue;

        // operand
        if (isalnum(static_cast<unsigned char>(ch))) {
            out += ch;
        }
        // left parenthesis (which was ')' before swap)
        else if (ch == '(') {
            st.push(ch);
        }
        // right parenthesis (which was '(' before swap)
        else if (ch == ')') {
            while (!st.empty() && st.top() != '(') {
                out += st.top();
                st.pop();
            }
            if (st.empty()) return "Invalid Expression"; // mismatched
            st.pop(); // discard '('
        }
        // operator
        else {
            while (!st.empty() && st.top() != '(') {
                int pc = prec(ch), pt = prec(st.top());
                // KEY: pop on higher precedence, or equal precedence when ch == '^'
                if (pt > pc || (pt == pc && ch == '^')) {
                    out += st.top();
                    st.pop();
                } else break;
            }
            st.push(ch);
        }
    }

    // pop remaining operators
    while (!st.empty()) {
        if (st.top() == '(' || st.top() == ')')
            return "Invalid Expression";
        out += st.top();
        st.pop();
    }

    // 4) reverse the postfix-result to get prefix
    reverse(out.begin(), out.end());
    return out;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s);
    cout << "Prefix: " << infixToPrefix(s) << "\n";
    return 0;
}
```

---

### üî¢ Token-based variant (multi-digit numbers, identifiers)

If you want inputs like `12 + (x3 * 5) ^ 2`, tokenize first and run the same logic with string tokens.

Key ideas:

* Numbers: read contiguous digits as one token.
* Identifiers: letters/underscore followed by alnum/underscore.
* Operators: single-char `()+-*/^`.
* Use a `stack<string>` or `stack<char>` for operators; output as vector of tokens, then join and **reverse** at the end.



### üß™ Examples

| Infix                 | Prefix            | Notes                            |
| --------------------- | ----------------- | -------------------------------- |
| `A+B*C`               | `+A*BC`           | `*` before `+` due to precedence |
| `(A+B)*C`             | `*+ABC`           | Parentheses force `+` first      |
| `A^B^C`               | `^A^BC`           | Right-assoc: `A^(B^C)`           |
| `a+(b*c-(d/e^f)*g)*h` | `+a*-*bc*/d^efgh` | Complex nesting                  |


### ‚è±Ô∏è Complexity

* **Time:** `O(n)` ‚Äî each symbol/token is pushed/popped at most once.
* **Space:** `O(n)` ‚Äî operator stack + output buffer.


### üß† Tips & Variations

* **Unary minus / plus**: needs special handling at tokenization (when `-` appears at start or after `(` or another operator). Usually transform unary `-x` into `(0 - x)` or mark as a unary operator with higher precedence.
* **Functions & commas** (`max(a,b)`): requires full Shunting-Yard extension (function stack, argument separators).
* **Validation**: always guard `st.top()` with `!st.empty()` and detect leftover parentheses.


### ‚ùì FAQs

**Q: Why does associativity flip after reversing?**
> Reversal swaps the order of operators with equal precedence. To preserve the original grouping, you invert the ‚Äúpop on equal precedence‚Äù rule during the reversed pass.

**Q: Could I directly build prefix without reversal?**
> Yes, but it‚Äôs trickier. The reverse+postfix trick is simpler and widely used.

**Q: How to support multi-digit numbers and variables like `x10`?**
> Tokenize first; treat numbers/identifiers as atomic tokens in the algorithm.

