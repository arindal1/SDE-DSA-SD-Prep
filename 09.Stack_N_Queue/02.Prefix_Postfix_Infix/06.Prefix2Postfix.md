# ðŸ”„ Prefix âžœ Postfix

## ðŸ§© Problem Statement

Given a string `s` representing a **prefix** expression with **binary** operators (`+ - * / ^`) and alphanumeric operands, return the equivalent **postfix** expression.

**Assumptions (baseline):**

* Operands are single alphanumeric characters (e.g., `a`, `Z`, `7`)
* Operators are **binary** only
* Whitespace may appear and should be ignored

---
### ðŸ§  Intuition

Prefix places the **operator before its operands**. To convert to postfix (**operands before operator**), scan the prefix **right to left**:

* If you find an **operand**: push it as a string.
* If you find an **operator** `op`:

  * Pop two strings: `t1` (left operand), then `t2` (right operand).
  * Form the postfix subexpression: `t1 + t2 + op`.
  * Push the result back.
* At the end, the stack should have exactly **one** string (the final postfix).

Right-to-left ensures that when we meet an operator, both its operand subexpressions are already on the stack.


### âœ… Clean Code (single-char operands)

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isOperand(char c) {
    return isalnum(static_cast<unsigned char>(c)); // A-Z, a-z, 0-9
}

bool isOperator(char c) {
    return c=='+' || c=='-' || c=='*' || c=='/' || c=='^';
}

string prefixToPostfix(const string& s) {
    stack<string> st;

    for (int i = static_cast<int>(s.size()) - 1; i >= 0; --i) {
        unsigned char ch = static_cast<unsigned char>(s[i]);

        if (isspace(ch)) continue;

        if (isOperand(ch)) {
            st.push(string(1, s[i]));
        } else if (isOperator(ch)) {
            if (st.size() < 2)
                throw runtime_error("Invalid expression: insufficient operands for operator.");
            string t1 = st.top(); st.pop(); // left
            string t2 = st.top(); st.pop(); // right
            st.push(t1 + t2 + s[i]);        // postfix: left right op
        } else {
            throw runtime_error(string("Invalid character in expression: '") + s[i] + "'");
        }
    }

    if (st.size() != 1)
        throw runtime_error("Invalid expression: leftover operands/operators.");

    return st.top();
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s);
    try {
        cout << "Postfix: " << prefixToPostfix(s) << "\n";
    } catch (const exception& e) {
        cout << "Error: " << e.what() << "\n";
    }
    return 0;
}
```


### ðŸ§ª Dry Run

Prefix: `*+abc`
Scan right â†’ left:

* `c` â†’ push `"c"`
* `b` â†’ push `"b"`
* `a` â†’ push `"a"`
* `+` â†’ pop `"a"`, `"b"` â†’ push `"ab+"`
* `*` â†’ pop `"ab+"`, `"c"` â†’ push `"ab+c*"`

Result: `ab+c*` âœ…

---

### ðŸ”¡ Token-Based Version (multi-digit numbers / identifiers)

Support inputs like: `* + 12 x1 3` â†’ postfix: `12 x1 + 3 *`

Tokenization rules:

* **Numbers**: consecutive digits
* **Identifiers**: letter/underscore, followed by letters/digits/underscore
* **Operators**: `+ - * / ^`
* **Spaces**: ignored separators

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isOperator(const string& tk) {
    return tk=="+" || tk=="-" || tk=="*" || tk=="/" || tk=="^";
}

vector<string> tokenizePrefix(const string& s) {
    vector<string> tokens;
    for (int i = static_cast<int>(s.size()) - 1; i >= 0; ) {
        unsigned char c = static_cast<unsigned char>(s[i]);
        if (isspace(c)) { --i; continue; }

        if (isdigit(c)) {
            int j = i;
            while (j >= 0 && isdigit(static_cast<unsigned char>(s[j]))) --j;
            tokens.emplace_back(s.substr(j+1, i - j));
            i = j;
        } else if (isalpha(c) || c == '_') {
            int j = i;
            while (j >= 0) {
                unsigned char d = static_cast<unsigned char>(s[j]);
                if (!isalnum(d) && d != '_') break;
                --j;
            }
            tokens.emplace_back(s.substr(j+1, i - j));
            i = j;
        } else if (string("+-*/^").find(c) != string::npos) {
            tokens.emplace_back(string(1, s[i]));
            --i;
        } else {
            throw runtime_error(string("Invalid character: ") + s[i]);
        }
    }
    // We tokenized right->left; keep as-is and process forward to simulate right->left scan.
    reverse(tokens.begin(), tokens.end());
    return tokens;
}

string prefixToPostfixTokens(const string& s) {
    vector<string> toks = tokenizePrefix(s);
    stack<string> st;

    // Process tokens from end to start to simulate right->left
    for (int k = static_cast<int>(toks.size()) - 1; k >= 0; --k) {
        const string& tk = toks[k];
        if (isOperator(tk)) {
            if (st.size() < 2) throw runtime_error("Invalid expression: insufficient operands.");
            string t1 = st.top(); st.pop(); // left
            string t2 = st.top(); st.pop(); // right
            st.push(t1 + " " + t2 + " " + tk);
        } else {
            st.push(tk);
        }
    }
    if (st.size() != 1) throw runtime_error("Invalid expression: leftover operands/operators.");
    return st.top();
}
```

### â±ï¸ Complexity

* **Time:** `O(n)` â€” each symbol/token pushed and popped at most once
* **Space:** `O(n)` â€” stack stores partial strings


### ðŸ§  Edge Cases & Tips

* **Insufficient operands** for an operator â†’ error.
* **Leftover items** after processing â†’ error.
* **Unary operators** arenâ€™t handled; if needed, track operator **arity** and pop accordingly.
* Prefix already fixes grouping; precedence/associativity donâ€™t matter for reconstruction.


### ðŸ§ª Quick Tests

```txt
Input:  +ab          -> Postfix: ab+
Input:  *+abc        -> Postfix: ab+c*
Input:  ^a^bc        -> Postfix: abc^^
Input:  - + 12 x1 3  -> Postfix: 12 x1 + 3 -
```


### â“ FAQs

**Q: Why process right-to-left?**
>Because in prefix, the operator comes before its operands; scanning from the end ensures operands are ready when an operator appears.

**Q: Do I need parentheses in postfix?**
>No â€” postfix is unambiguous without them.

**Q: How to handle unary minus?**
>Youâ€™ll need to know operator **arity**. For unary, pop one operand and form `op operand` accordingly.
