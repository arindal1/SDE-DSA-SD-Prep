# ğŸ“ˆ Online Stock Span [#901](https://leetcode.com/problems/online-stock-span/description/)

## ğŸ§© Problem statement

Design a class `StockSpanner` that, for each daily price you call `next(price)` on, returns the **stock span** for that day.

* The **span** is the count of consecutive days up to today (including today) with price **less than or equal** to todayâ€™s price.
* Inputs arrive **online**. You only get todayâ€™s price when you call `next`.

Example: prices `[100, 80, 60, 70, 60, 75, 85]`

Spans are `[1, 1, 1, 2, 1, 4, 6]`.

---

### ğŸ’¡ Intuition

Think of todayâ€™s price looking backward asking:
â€œHow far can I go left while previous prices are less than or equal to me?â€

If you scan left naively each time, thatâ€™s slow. We want to remember useful information so we skip the smaller stuff fast.

This is where a **monotonic stack** helps:

* Keep a stack that stores information about previous days that could still be the next greater element to the left.
* For spans, we want a stack that is **strictly decreasing by price** from bottom to top.



### ğŸ¢ Brute force (why itâ€™s not great)

For each `next(price)`:

* Walk backward day by day until you find a price greater than todayâ€™s.
* Count how many steps you walked.

Worst case: strictly increasing prices like `[1, 2, 3, 4, ...]`
Each query walks many steps. Total can be O(nÂ²). Ouch.


### âš¡ Optimal approach : monotonic stack

We maintain a stack of items that help compute span in O(1) amortized per query.

Two common variants:

### Variant A: store `(price, index)`

* Pop while `top.price <= price`.
* The new span is `curr_index - (stack.empty() ? -1 : stack.top().index)`.
* Push `(price, curr_index)`.

### Variant B: store `(price, span)`  â† super clean

* Start `span = 1`.
* While stack not empty and `top.price <= price`

  * `span += top.span`
  * pop
* Push `(price, span)`.
* Return `span`.

Both are correct. Variant B avoids a separate index and is a tiny bit simpler.



### ğŸ§  Code : index-based approach

```cpp
#include <bits/stdc++.h>
using namespace std;

class StockSpanner {
private:
    stack<pair<int, int>> st; // {price, index}
    int ind;
public:
    StockSpanner() : ind(-1) {}

    int next(int price) {
        ++ind;
        while (!st.empty() && st.top().first <= price)
            st.pop();

        int prevGreaterIdx = st.empty() ? -1 : st.top().second;
        int span = ind - prevGreaterIdx;
        st.push({price, ind});
        return span;
    }
};
```



### ğŸŒŸ Alternative code : span-accumulation approach

This one is elegant and very popular:

```cpp
#include <bits/stdc++.h>
using namespace std;

class StockSpanner {
private:
    stack<pair<int, int>> st; // {price, span}
public:
    StockSpanner() {}

    int next(int price) {
        int span = 1;
        while (!st.empty() && st.top().first <= price) {
            span += st.top().second;
            st.pop();
        }
        st.push({price, span});
        return span;
    }
};
```

Why many people love it:

* No external index needed
* Span composes naturally as you pop smaller-or-equal prices

---

### ğŸ§­ Step-by-step example

Prices: `[100, 80, 60, 70, 60, 75, 85]`

Using the span-accumulation stack:

* 100 â†’ stack [], span = 1 â†’ push (100,1) â†’ answer 1
* 80  â†’ pop none â†’ push (80,1) â†’ answer 1
* 60  â†’ pop none â†’ push (60,1) â†’ answer 1
* 70  â†’ pop (60,1) â†’ span = 2 â†’ push (70,2) â†’ answer 2
* 60  â†’ pop none â†’ push (60,1) â†’ answer 1
* 75  â†’ pop (60,1), pop (70,2) â†’ span = 1+1+2 = 4 â†’ push (75,4) â†’ answer 4
* 85  â†’ pop (75,4), pop (80,1), pop (100,1)? no, since 100 > 85 â†’ span = 1+4+1 = 6 â†’ push (85,6) â†’ answer 6

Spans: `[1, 1, 1, 2, 1, 4, 6]` - Chefâ€™s kiss.


### ğŸ§ª Test cases you should try

1. Single price
   `[100], k implicit`
   Spans â†’ `[1]`

2. Strictly increasing
   `[10, 20, 30, 40]`
   Spans â†’ `[1, 2, 3, 4]`

3. Strictly decreasing
   `[40, 30, 20, 10]`
   Spans â†’ `[1, 1, 1, 1]`

4. With equals
   `[30, 30, 30, 30]`
   Spans â†’ `[1, 2, 3, 4]`
   (We use `<=`, so equals merge correctly)

5. Mixed
   `[31, 41, 48, 59, 79]`
   Spans â†’ `[1, 2, 3, 4, 5]`

6. Spiky
   `[100, 98, 99, 97, 101]`
   Spans â†’ `[1, 1, 2, 1, 5]`


### â± Complexity

* Time per `next`: **O(1) amortized**

  Each price is pushed once and popped at most once.

* Extra space: **O(n)** in the worst case

  Stack holds a chain when prices strictly decrease.


### ğŸ”§ Tips, tricks, pitfalls

* Use `<=` when popping so equal prices merge into a longer span.
* Store indices or spans, not just values. You need extra info to compute todayâ€™s span.
* The class should hold state across calls to `next`. Thatâ€™s the whole point of â€œonlineâ€.
* Very large inputs are fine. This is a classic streaming-friendly pattern.


### ğŸ”„ Variations you might see

* **Next Greater Element to the left/right**
* **Daily Temperatures** (span until a warmer day)
* **Online minimum window with monotonic deque**
* **K-window max** (Sliding Window Maximum) which uses a deque, not a stack


### â“ FAQs

**Q: Why keep a stack in decreasing price order?**
>So the nearest previous greater price is at the top after popping smaller-or-equal ones. That makes span easy to compute.

**Q: Which variant should I use, index or span?**
>Both are great. Span variant is slightly more compact for this problem.

**Q: Any integer overflow worries?**
>Spans are at most the number of days seen so far. If that can exceed `2e9` in your environment, use `long long`. Typical constraints are safe with `int`.

**Q: Is this truly online?**
>Yes. Each `next(price)` uses only past data and updates state in O(1) amortized.
