# üßä Sliding Window Maximum [#239](https://leetcode.com/problems/sliding-window-maximum/description/)


## üß© Problem Statement

You‚Äôre given an array `nums` and an integer `k`.
Your task is to find the **maximum element in every contiguous subarray (window) of size `k`**.

Return an array `ans` where `ans[i]` = maximum of `nums[i..i+k-1]`.

### Example

```cpp
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
```

Because the windows are:

| | |
|:-:|:-:|
| [1,3,-1] | max = 3 |
| [3,-1,-3] | max = 3 |
| [-1,-3,5] | max = 5 | 
| [-3,5,3] | max = 5 |
| [5,3,6] | max = 6 |
| [3,6,7] | max = 7 |

---

### üí≠ Intuition

Imagine sliding a window of size `k` across the array from left to right.
At each move, you want to know which number inside that window is the biggest.

If you do it **naively** (check all k elements every time), it‚Äôs too slow for large arrays.
We need a way to ‚Äúremember‚Äù which element was the biggest *and* know when it‚Äôs no longer inside the window.

This is where our hero enters... ü¶∏‚Äç‚ôÇÔ∏è the **Deque (Double-Ended Queue)!**


### üê¢ Brute Force (and why it‚Äôs meh)

Simple idea:

1. For every window of size `k`, loop through all `k` elements.
2. Find the max manually.
3. Append it to result.

#### Code sketch:

```cpp
for (int i = 0; i <= n - k; ++i) {
    int currMax = INT_MIN;
    for (int j = i; j < i + k; ++j)
        currMax = max(currMax, nums[j]);
    ans.push_back(currMax);
}
```

**Time Complexity:** `O(n*k)`

When `n = 10^5`, `k = 10^4` ‚Üí üí• 10‚Åπ operations! Way too slow.


### ‚ö° Optimal Approach: Using a Monotonic Deque

We‚Äôll use a **Deque** (double-ended queue) that stores **indices** of useful elements in decreasing order of their values.

Here‚Äôs the magic trick ü™Ñ:

* The **front** of the deque always holds the index of the *maximum* element for the current window.
* Before pushing a new element:

  * Remove indices that are *out of range* (i.e., `i - k` old).
  * Remove indices whose corresponding values are *smaller or equal* to `nums[i]` ‚Äî they‚Äôll never be needed again since a larger element has arrived!

So the deque stays *monotonic decreasing* (values get smaller as you go right).


### ‚ú® Step-by-Step Walkthrough

Let‚Äôs take an example:

```
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
```

| Step | i | nums[i] | Deque content (indices ‚Üí values)                                                             | Output             |
| ---- | - | ------- | -------------------------------------------------------------------------------------------- | ------------------ |
| 0    | 0 | 1       | [0 ‚Üí 1]                                                                                      | ‚Äî                  |
| 1    | 1 | 3       | pop 0 (1 ‚â§ 3), push 1 ‚Üí [1 ‚Üí 3]                                                              | ‚Äî                  |
| 2    | 2 | -1      | [1 ‚Üí 3, 2 ‚Üí -1]                                                                              | front(1)=3 ‚Üí **3** |
| 3    | 3 | -3      | out-of-range? no, pop none, push 3 ‚Üí [1 ‚Üí 3, 2 ‚Üí -1, 3 ‚Üí -3] ‚Üí pop front (1 ‚â§ 0)? no ‚Üí **3** |                    |
| 4    | 4 | 5       | pop 3 (-3 ‚â§ 5), pop 2 (-1 ‚â§ 5), pop 1 (3 ‚â§ 5) ‚Üí [4 ‚Üí 5] ‚Üí **5**                              |                    |
| 5    | 5 | 3       | [4 ‚Üí 5, 5 ‚Üí 3] ‚Üí **5**                                                                       |                    |
| 6    | 6 | 6       | pop 5 (3 ‚â§ 6), pop 4 (5 ‚â§ 6) ‚Üí [6 ‚Üí 6] ‚Üí **6**                                               |                    |
| 7    | 7 | 7       | pop 6 (6 ‚â§ 7) ‚Üí [7 ‚Üí 7] ‚Üí **7**                                                              |                    |

‚úÖ Output = `[3,3,5,5,6,7]`



### üß† The C++ Code


```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;        // stores indices of elements
    vector<int> ans;
    int n = nums.size();

    for (int i = 0; i < n; ++i) {
        // 1Ô∏è‚É£ Remove indices that are out of this window
        if (!dq.empty() && dq.front() <= i - k)
            dq.pop_front();

        // 2Ô∏è‚É£ Remove smaller elements (they can‚Äôt be max anymore)
        while (!dq.empty() && nums[dq.back()] <= nums[i])
            dq.pop_back();

        // 3Ô∏è‚É£ Add current index
        dq.push_back(i);

        // 4Ô∏è‚É£ Window ready? record the max (front of deque)
        if (i >= k - 1)
            ans.push_back(nums[dq.front()]);
    }

    return ans;
}
```

---

### üß© Why this works perfectly

* Each element is **added once** and **removed at most once** ‚Üí total `O(n)` time.
* The deque is always sorted in **decreasing order** of values.
* The front of deque always gives the **maximum** in the current window.
* Indices that go out of range get popped naturally.


### üß™ Test Cases

| Case | Input                      | Output             | Notes            |
| ---- | -------------------------- | ------------------ | ---------------- |
| 1    | `[1,3,-1,-3,5,3,6,7], k=3` | `[3,3,5,5,6,7]`    | Classic          |
| 2    | `[1], k=1`                 | `[1]`              | Single element   |
| 3    | `[9,8,7,6,5,4], k=2`       | `[9,8,7,6,5]`      | Descending order |
| 4    | `[1,2,3,4,5], k=3`         | `[3,4,5]`          | Ascending order  |
| 5    | `[5,5,5,5], k=2`           | `[5,5,5]`          | All same values  |
| 6    | `[10, -1, -2, -3], k=1`    | `[10, -1, -2, -3]` | k = 1 edge case  |


### ‚öôÔ∏è Complexity Analysis

| Type     | Complexity | Why                                        |
| -------- | ---------- | ------------------------------------------ |
| ‚è± Time   | **O(n)**   | Each element is pushed/popped at most once |
| üíæ Space | **O(k)**   | Deque stores at most k indices             |

Super efficient and scalable even for `n = 10^6` üöÄ

### üí° Tips, Tricks & Gotchas

‚ú® **Store indices, not values.**
That‚Äôs how we check if elements are out of window range.

‚ú® **Pop smaller elements before pushing.**
This ensures the deque is always in descending order.

‚ú® **Start recording results from i >= k-1.**
Before that, the window isn‚Äôt full yet.

‚ú® **`<=` vs `<` in comparison.**
Using `<=` ensures equal elements are handled properly (avoids duplicates in deque).

‚ú® **Deque > Priority Queue**
While max-heaps can also find max in `O(log k)`, removing outdated elements is hard.
Deque makes it clean and `O(1)` amortized per element.


### üîÑ Variations You‚Äôll Love

* **Sliding Window Minimum**: Just reverse the comparison (`>=` ‚Üí `<=`).
* **Sum of Sliding Window**: Maintain sum directly (easy).
* **Average of Sliding Window**: Maintain sum + divide by `k`.
* **Dynamic window problems**: Great for learning sliding window patterns.


### ‚ùì FAQs

**Q: Why not use a heap?**
A: Heaps don‚Äôt let you efficiently remove elements that move out of the window. You‚Äôd need lazy deletions ‚Äî which adds extra complexity.

**Q: What if there are duplicates?**
A: No worries! Deque stores *indices*, so equal values are treated correctly based on position.

**Q: What‚Äôs deque actually storing?**
A: Only the *indices* of potential maximums (in decreasing order of their `nums` value).

**Q: Can this be done in Python or Java?**
Absolutely! The logic is the same ‚Äî use `collections.deque` in Python or `LinkedList<Integer>` in Java.


## üèÅ Summary

| Concept   | Description                                    |
| --------- | ---------------------------------------------- |
| Problem   | Find maximum in every sliding window of size k |
| Trick     | Maintain decreasing deque of indices           |
| Core idea | Remove out-of-window & smaller elements        |
| Time      | O(n)                                           |
| Space     | O(k)                                           |
| Keywords  | Monotonic Deque, Sliding Window, Two Pointers  |
