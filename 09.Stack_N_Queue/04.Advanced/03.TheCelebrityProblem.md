# üé≠ The Celebrity Problem [[GFG](https://www.geeksforgeeks.org/problems/the-celebrity-problem/1)]

> **Problem statement**
>
> You're given an `n x n` matrix `mat` where `mat[i][j] == 1` means person `i` knows person `j`, and `0` otherwise.
> A **celebrity** is someone who:
>
> * is known by **everyone else** (every other person `i` has `mat[i][c] == 1`), and
> * **knows nobody** (for all `j`, `mat[c][j] == 0`, except possibly `mat[c][c]` which we ignore).
>
> Return the index of the celebrity if one exists, otherwise return `-1`.

---

### üí° Intuition

* If person `A` knows person `B`, then `A` cannot be the celebrity.
* If person `A` does **not** know `B`, then `B` cannot be the celebrity.
* Use this observation to eliminate candidates pairwise until 0 or 1 candidate remains.
* Finally, verify the candidate by scanning their row and column.

This gives an optimal two-phase approach:

1. **Candidate elimination** using two pointers (or a stack) ‚Äî `O(n)`.
2. **Verification** by checking the entire row and column of candidate ‚Äî `O(n)`.

Total time: `O(n)`, space: `O(1)`.


### üêå Brute force (for context)

Check every person `c`:

* Verify row `c` has all zeros (ignoring `mat[c][c]`).
* Verify every other person `i` has `mat[i][c] == 1`.
  This is `O(n^2)` and works, but we can do better with elimination.


### ‚ö° Optimal approach (two-pointer elimination)

Algorithm:

1. `i = 0`, `j = n-1`
2. While `i < j`:

   * If `mat[i][j] == 1` ‚Üí `i++` (i knows j ‚Üí i not celebrity)
   * Else ‚Üí `j--` (i does not know j ‚Üí j not celebrity)
3. Candidate is `i` (or `j` when loop ends)
4. Verify candidate by checking row and column conditions
5. Return candidate index or `-1`

This is `O(n)` time, `O(1)` extra space.


### clean C++ implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
  findCelebrity:
  Input: n x n matrix mat where mat[i][j] == 1 means i knows j.
  Output: index of celebrity (0..n-1) or -1 if none.
*/
int findCelebrity(const vector<vector<int>>& mat) {
    int n = mat.size();
    if (n == 0) return -1;
    // Optional safety: ensure square matrix
    for (const auto &row : mat) if ((int)row.size() != n) return -1;

    // 1) Candidate elimination
    int i = 0, j = n - 1;
    while (i < j) {
        if (mat[i][j] == 1) {
            // i knows j -> i cannot be celebrity
            ++i;
        } else {
            // i does NOT know j -> j cannot be celebrity
            --j;
        }
    }

    int cand = i; // candidate celebrity

    // 2) Verification: cand must know nobody, and everyone else must know cand
    for (int k = 0; k < n; ++k) {
        if (k == cand) continue;
        // cand should not know k
        if (mat[cand][k] == 1) return -1;
        // everyone else should know cand
        if (mat[k][cand] == 0) return -1;
    }

    return cand;
}

int main() {
    vector<vector<int>> mat = {
        {0, 1, 1, 0},
        {0, 0, 0, 0},
        {1, 1, 0, 0},
        {0, 1, 1, 0}
    };

    cout << "The celebrity: " << findCelebrity(mat) << endl;
    return 0;
}
```


### üß™ Walkthrough of corrected code on your example

Matrix:

```
0 1 1 0
0 0 0 0
1 1 0 0
0 1 1 0
```

* Start: `i=0, j=3`

  * `mat[0][3] == 0` ‚Üí `j--` ‚Üí `j=2`
* `i=0, j=2`

  * `mat[0][2] == 1` ‚Üí `i++` ‚Üí `i=1`
* `i=1, j=2`

  * `mat[1][2] == 0` ‚Üí `j--` ‚Üí `j=1`
* Loop stops (`i==j==1`), candidate = `1`

Verify candidate 1:

* Row 1: `[0,0,0,0]` ‚Üí candidate knows nobody ‚úì
* Column 1: `[1,0,1,1]` ‚Üí mat[0][1]==1, mat[2][1]==1, mat[3][1]==1 ‚Üí everyone else knows candidate ‚úì

So `1` is celebrity. Program prints `The celebrity: 1`.


### ‚è± Complexity

* **Time:** `O(n)` ‚Äî elimination loop `O(n)` + verification loop `O(n)`.
* **Space:** `O(1)` ‚Äî only a few indices.

This is optimal in time and space for this problem.

---

### ‚ö†Ô∏è Edge cases & pitfalls

* Non-square matrix: Problem assumes `n x n`, but verify input shape just in case.
* Empty matrix: return `-1`.
* Multiple potential celebrities: By definition there can be at most one celebrity (because if `A` and `B` are both celebrities, they must know each other? No ‚Äî celebrities know nobody, so both can't be known by everyone else simultaneously unless `n=1`).
* Self-entry `mat[i][i]`: usually ignored. Verification code ignores `k == cand`.


### üîÅ Variations & related problems

* Use a **stack-based** elimination: push all indices and repeatedly pop two, keep the possible celebrity ‚Äî same idea.
* **Find celebrity in a directed graph** (node with indegree `n-1` and outdegree `0`).
* **Generalized trust problem** where trust values might be weighted.


### ‚ùì FAQs (quick)

**Q: Could there be more than one celebrity?**
>No. If `c1` and `c2` were both celebrities, `c1` would have to know `c2` and `c2` would have to know `c1` to be "known by everyone", but celebrities know no one. Only possible when `n == 1`.

**Q: Why check the entire row and column?**
>Elimination gives a candidate but doesn't prove they satisfy the definition. We must verify that candidate knows no one and everyone else knows them.

**Q: Can we do it without extra memory?**
>Yes. The two-pointer method uses constant extra memory.

