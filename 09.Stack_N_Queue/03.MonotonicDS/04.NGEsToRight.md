# üî• Next Greater Element (to the Right)

## üß© Problem Statement

Given an integer array `arr`, for each index `i`, find the first element **strictly greater** than `arr[i]` that appears **to the right** of `i`.
If no such element exists, the answer for `i` is `-1`.

**Example**

```
arr   = [4, 5, 2, 10, 8]
ans   = [5,10,10,-1,-1]
```

---

### üí° Intuition

We want the first **strictly greater** value to the right.
Scan the array **from right to left** and maintain a **monotonic decreasing stack** (from top to bottom). The stack top is always the **nearest candidate** that is greater than the current number.

For each `x = arr[i]`:

* Pop while `st.top() <= x` (they can‚Äôt be the next **strictly** greater for `x` or anyone to its left).
* After popping:

  * If stack is empty ‚Üí answer is `-1`
  * Else ‚Üí answer is `st.top()` (nearest greater to the right)
* Push `x` (it might be the next greater for elements to the left).

> Using `<=` ensures we find **strictly** greater, not greater-or-equal.


### ‚úÖ Polished Code (value version, same approach)

```cpp
#include <bits/stdc++.h>
using namespace std;

// Next Greater Element to the Right (value version)
vector<int> nextGreaterElement(vector<int>& arr) {
    int n = (int)arr.size();
    stack<int> st;        // holds candidate values, strictly decreasing
    vector<int> ans(n);

    for (int i = n - 1; i >= 0; --i) {
        int x = arr[i];
        while (!st.empty() && st.top() <= x) st.pop();
        ans[i] = st.empty() ? -1 : st.top();
        st.push(x);
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    vector<int> v;
    string line;
    getline(cin, line);

    stringstream ss(line);
    int num;
    while (ss >> num) v.push_back(num);

    vector<int> ans = nextGreaterElement(v);
    for (int x : ans) cout << x << ' ';
    return 0;
}
```


### ‚è±Ô∏è Complexity

* **Time:** `O(n)` ‚Äî each element is pushed/popped at most once.
* **Space:** `O(n)` ‚Äî stack + result vector.


### üß™ Quick Tests

1. **Mixed**

```
arr = [4, 5, 2, 10, 8]
ans = [5,10,10,-1,-1]
```

2. **All increasing**

```
arr = [1, 2, 3, 4]
ans = [2, 3, 4, -1]
```

3. **All decreasing**

```
arr = [5, 4, 3, 2, 1]
ans = [-1, -1, -1, -1, -1]
```

4. **Duplicates**

```
arr = [2, 2, 2]
ans = [-1, -1, -1]   // strictly greater ‚Üí none
arr = [2, 1, 2, 1, 2]
ans = [-1, 2, -1, 2, -1]
```

5. **Single element**

```
arr = [7]
ans = [-1]
```

---
### üîÅ Useful Variations

#### 1) Return **indices** (for distances/ranges)

Store **indices** on the stack; compare with `arr[st.top()]`:

```cpp
vector<int> nextGreaterIndexRight(const vector<int>& arr) {
    int n = (int)arr.size();
    vector<int> ansIdx(n, -1);
    stack<int> st; // indices; arr[st.top()] is strictly decreasing

    for (int i = n - 1; i >= 0; --i) {
        while (!st.empty() && arr[st.top()] <= arr[i]) st.pop();
        ansIdx[i] = st.empty() ? -1 : st.top();
        st.push(i);
    }
    return ansIdx;
}
```

To get **values** from indices: replace `ansIdx[i]` with `st.empty() ? -1 : arr[st.top()]`.
To get **distance** to next greater: `dist[i] = st.empty() ? -1 : (st.top() - i)`.

#### 2) Next **Smaller** to the Right

Switch to a **monotonic increasing** stack and pop `>= x`.

#### 3) **Circular** array (NGE II)

Traverse the array **twice** with `i % n`. (You already did this in a prior solution.)


### ‚ö†Ô∏è Gotchas & Tips

* **Strictness matters:** Pop `<= x` to ensure the answer is **strictly** greater.
* **Duplicates:** Value-stack works if you only need the next greater **value**; for positions or more control, use the **index stack**.
* **Direction:** Right-to-left scan is natural for ‚Äúto the right‚Äù queries; flip direction for ‚Äúto the left‚Äù.


### ‚ùì FAQs

**Q: Why not scan left-to-right?**
> You can, but right-to-left makes it easy to maintain candidates that are *to the right* of the current index in a single pass.

**Q: Can I prefill with `-1`?**
> Yes. It‚Äôs common, especially for index-based variants: initialize `ans` with `-1` and assign when you find a candidate.

**Q: How is this different from ‚ÄúNext Greater Element I (subset)‚Äù**
> There, you precompute NGE for all elements in `nums2`, map values ‚Üí answers, and then answer queries for `nums1`. Same stack idea, extra map.

