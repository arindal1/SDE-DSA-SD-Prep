# â™¾ï¸ Next Greater Element II [#501](https://leetcode.com/problems/next-greater-element-ii/description/)

## ğŸ§© Problem Statement

Given a circular array `nums` of length `n`, for each index `i`, find the **next greater element** to the right considering circularity (i.e., after `n-1`, continue from `0`). If there is no such element, set `-1`.

**Example**

```
nums = [1, 2, 1]  â†’  answer = [2, -1, 2]
```

* For `nums[0]=1`, next greater is `2` (at index 1).
* For `nums[1]=2`, no greater value exists to the right even after wrapping â†’ `-1`.
* For `nums[2]=1`, wrap to `nums[0]=1` (not greater), then `nums[1]=2` â†’ `2`.

---

### ğŸ§  Intuition

For the non-circular version, we scan from **right to left** and keep a **strictly decreasing stack** of â€œcandidatesâ€ (values that might be the next greater for someone to the left).
For **circular**, we virtually **scan the array twice** so that positions near the start can â€œseeâ€ elements near the end.

Key invariants:

* The stack is **monotonic decreasing** (top is the nearest *greater* candidate).
* While current value `x` is **â‰¥** stack top, pop the stack (those cannot be the next greater for `x` or any element to its left).
* After popping, the top (if any) is the next greater for `x`.


### âœ… Cpp Code (polished + comments)

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> nextGreaterElements(vector<int>& nums) {
    int n = (int)nums.size();
    stack<int> st;          // holds candidate values (decreasing)
    vector<int> ans(n);     // answers for each index

    // Traverse twice (from right to left) to simulate circularity
    for (int i = 2 * n - 1; i >= 0; --i) {
        int x = nums[i % n];

        // Maintain strictly decreasing stack
        while (!st.empty() && st.top() <= x) st.pop();

        // Only fill answers in the first pass (i < n)
        if (i < n) ans[i] = st.empty() ? -1 : st.top();

        // Current element becomes a candidate for elements to its left
        st.push(x);
    }
    return ans;
}
```

### Why this works

* Scanning **twice** lets early indices see later indices (circular wrap).
* The **decreasing stack** ensures that the top is always the *nearest* greater to the right.
* Each element is **pushed once and popped at most once** â†’ linear time.


### â±ï¸ Complexity

* **Time:** `O(n)` â€” each element is pushed/popped at most once.
* **Space:** `O(n)` â€” stack can hold up to `n` elements in the worst case; `ans` is `O(n)`.


### ğŸ§ª Test Cases

```cpp
// 1) Basic mixed
nums = {1, 2, 1}           // -> {2, -1, 2}

// 2) All increasing
nums = {1, 2, 3, 4}        // -> {2, 3, 4, -1}

// 3) All decreasing (circular makes a big difference)
nums = {5, 4, 3, 2, 1}     // -> {-1, 5, 5, 5, 5}

// 4) Plateaus / duplicates
nums = {2, 2, 2}           // -> {-1, -1, -1}
nums = {2, 1, 2, 1, 2}     // -> {-1, 2, -1, 2, -1}

// 5) Single element
nums = {7}                 // -> {-1}

// 6) Empty (if allowed)
nums = {}                  // -> {}
```


### ğŸ’¡ Tips & Gotchas

* **Strictly greater** means we must pop `<= x`. Using `< x` would allow equal values to remain and produce incorrect results when duplicates exist.
* This implementation uses a **value stack** (not indices). Thatâ€™s fine since we only need the **value** of the next greater element.
  If you later need **indices** (e.g., to compute distances), store **indices** on the stack and compare `nums[st.top()]` with `x`.
* We only assign `ans[i]` when `i < n`; the first `n` iterations from the right are just to seed the stack.

---

### ğŸ” Variation: Index Stack (handy for distances / tie-breaking)

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> nextGreaterElementsIndexStack(vector<int>& nums) {
    int n = (int)nums.size();
    vector<int> ans(n, -1);
    stack<int> st; // stack of indices; nums[st.top()] is decreasing

    for (int i = 2 * n - 1; i >= 0; --i) {
        int idx = i % n;
        while (!st.empty() && nums[st.top()] <= nums[idx]) st.pop();
        if (i < n) ans[idx] = st.empty() ? -1 : nums[st.top()];
        st.push(idx);
    }
    return ans;
}
```

Use this when:

* You want the **index** of the next greater (change `ans[idx]` accordingly).
* You need to compute **distance** to the next greater:
  `dist[idx] = st.empty() ? -1 : (st.top() - idx + n) % n`.


### â“ FAQs

**Q: Why scan from right to left?**
>It lets us maintain a stack of candidates that lie **to the right**. When at `i`, everything in the stack corresponds to positions `> i` (modulo circular wrap).

**Q: Why scan twice?**
>The second pass supplies candidates beyond the end â€” simulating the circular array so early positions can see late positions.

**Q: Can we initialize `ans` with `-1`?**
>Yes, itâ€™s common. Here we fill `ans[i]` only when `i < n`, so initializing is optional but **safe** and clean in the index-based variant.

**Q: What about equal elements?**
>Weâ€™re looking for **strictly** greater, so equal values are **popped** and never considered as answers.

