# ðŸ’§ Trapping Rain Water [#42](https://leetcode.com/problems/trapping-rain-water/description/)


## ðŸ§© Problem Statement

Given `n` non-negative integers `height[i]` representing an elevation map (where the width of each bar is 1), compute how much water it can trap **after raining**.

**Example:**

```
Input:  height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```

The trapped water columns between bars can be visualized as:

![image](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

â†’ **Total trapped = 6 units**

---

### ðŸ§  Intuition

Water above any bar `i` depends on:

```
min(max height to the left, max height to the right) - height[i]
```

But computing `maxLeft` and `maxRight` for every bar separately is **O(nÂ²)**.
So we use a **two-pointer** approach to compute in **O(n)** time and **O(1)** space.


### ðŸ’¡ Two-Pointer Logic

* Initialize two pointers:

  * `l = 0`, `r = n-1`
* Track running max on both sides:

  * `maxL`, `maxR`
* Move the smaller height pointer inward:

  * Because the smaller side is the *limiting wall* for water height.
* For each position:

  * If `height[l] <= height[r]`:

    * If `height[l] < maxL`, we can trap `maxL - height[l]`
    * Else update `maxL = height[l]`
    * Move `l++`
  * Else (height on right smaller):

    * If `height[r] < maxR`, we can trap `maxR - height[r]`
    * Else update `maxR = height[r]`
    * Move `r--`
* Sum up all trapped amounts â†’ `totalSum`


### âœ… Polished Code (Two-Pointer Approach)

```cpp
#include <bits/stdc++.h>
using namespace std;

int trap(vector<int>& height) {
    int n = (int)height.size();
    int l = 0, r = n - 1;
    int maxL = 0, maxR = 0;
    int totalSum = 0;

    while (l <= r) {
        if (height[l] <= height[r]) {
            // Left is the limiting side
            if (height[l] < maxL)
                totalSum += maxL - height[l];
            else
                maxL = height[l];
            ++l;
        } else {
            // Right is the limiting side
            if (height[r] < maxR)
                totalSum += maxR - height[r];
            else
                maxR = height[r];
            --r;
        }
    }
    return totalSum;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    vector<int> h;
    string line;
    getline(cin, line);
    stringstream ss(line);
    int num;
    while (ss >> num) h.push_back(num);

    cout << trap(h) << "\n";
    return 0;
}
```


### ðŸ” Dry Run Example

Input:

```
height = [4,2,0,3,2,5]
```

| Step | l | r | maxL | maxR | Action                           | Water Added | Total |
| ---- | - | - | ---- | ---- | -------------------------------- | ----------- | ----- |
| 1    | 0 | 5 | 0    | 0    | height[l]=4 â‰¤ 5                  | maxL=4      | 0     |
| 2    | 1 | 5 | 4    | 0    | 2<4 â†’ add 2                      | 2           | 2     |
| 3    | 2 | 5 | 4    | 0    | 0<4 â†’ add 4                      | 4           | 6     |
| 4    | 3 | 5 | 4    | 0    | 3<4 â†’ add 1                      | 1           | 7     |
| 5    | 4 | 5 | 4    | 0    | 2<4 â†’ add 2                      | 2           | 9     |
| 6    | 5 | 5 | 4    | 0    | height[l]>height[r], shift right | done        | 9     |

âœ… **Output:** 9


### â±ï¸ Complexity Analysis

| Aspect    | Complexity | Explanation                      |
| --------- | ---------- | -------------------------------- |
| **Time**  | `O(n)`     | Each element processed once      |
| **Space** | `O(1)`     | Only pointers and constants used |


### ðŸ§ª Test Cases

```cpp
Input:  [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
// Diagrammatically, 6 units trapped

Input:  [4,2,0,3,2,5]
Output: 9

Input:  [1,2,3,4]
Output: 0  // No dips

Input:  [4,3,2,1]
Output: 0  // Descending; no left wall

Input:  [2,0,2]
Output: 2  // One simple valley
```

### ðŸ§  Tips & Edge Cases

* âœ… Works for all `n â‰¥ 0` â€” returns 0 for empty arrays or single bar.
* ðŸ’¡ Always update **maxL/maxR** before moving pointers.
* âš™ï¸ If scanning logic confuses you, imagine water flow from both ends toward the middle.
* ðŸš€ Unlike prefix/suffix arrays or stack-based approaches, this method uses **O(1)** memory and simple arithmetic.

---

## ðŸ§± Alternative Approaches

### 1ï¸âƒ£ Precomputed Max Arrays (Prefix + Suffix)

Compute:

```cpp
leftMax[i] = max(height[0..i])
rightMax[i] = max(height[i..n-1])
water[i] = min(leftMax[i], rightMax[i]) - height[i]
```

Then sum all `max(0, water[i])`.
**Time:** O(n), **Space:** O(n)

### 2ï¸âƒ£ Stack-Based Approach

Push indices onto a stack; whenever `height[cur] > height[st.top()]`, pop and compute trapped water using the *bounded wall* logic.
**Time:** O(n), **Space:** O(n) â€” More intricate but good for learning stack boundaries.

```cpp
#include <bits/stdc++.h>
using namespace std;

int trap(vector<int>& height) {
    int n = (int)height.size();
    stack<int> st;      // stack to store indices of the bars
    int totalWater = 0;

    for (int i = 0; i < n; ++i) {
        // While current bar is higher than the bar at stack top â†’ a "bounded valley" is found
        while (!st.empty() && height[i] > height[st.top()]) {
            int top = st.top();
            st.pop();

            // No left boundary â†’ can't trap water
            if (st.empty()) break;

            int distance = i - st.top() - 1;   // width between current and left boundary
            int boundedHeight = min(height[i], height[st.top()]) - height[top]; // height of water
            totalWater += distance * boundedHeight;
        }

        // Push current bar index
        st.push(i);
    }

    return totalWater;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    vector<int> height;
    string line;
    getline(cin, line);
    stringstream ss(line);
    int x;
    while (ss >> x) height.push_back(x);

    cout << trap(height) << "\n";
    return 0;
}

```

### â“ FAQs

**Q: Why two pointers?**
Because at each step, we can safely process the side with the smaller current height â€” its trapped water is bounded by its sideâ€™s max, not the far side.

**Q: Whatâ€™s the difference from stack method?**
Both are O(n), but the two-pointer approach is simpler, cleaner, and uses constant memory.

**Q: Can this handle large arrays?**
Yes, since itâ€™s O(n) time, O(1) space.

---

## ðŸ§­ Summary

| Approach           | Time     | Space    | Core Idea                             |
| ------------------ | -------- | -------- | ------------------------------------- |
| Prefix/Suffix      | O(n)     | O(n)     | Precompute left/right max             |
| Stack              | O(n)     | O(n)     | Track increasing heights to find dips |
| **Two Pointers âœ…** | **O(n)** | **O(1)** | Use local max boundaries              |
