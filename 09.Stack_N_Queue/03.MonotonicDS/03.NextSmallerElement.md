# â¬‡ï¸ Next Smaller Element (to the Right)

## ðŸ§© Problem Statement

Given an integer array `arr`, for each index `i`, find the first element **strictly smaller** than `arr[i]` that appears **to the right** of `i`.
If no such element exists, the answer for `i` is `-1`.

**Example**

```
arr = [4, 8, 5, 2, 25]
answer = [2, 5, 2, -1, -1]
```

---

### ðŸ’¡ Intuition

We need â€œfirst smaller on the rightâ€.
Scan the array **from right to left** while keeping a **monotonic increasing stack** (from top to bottom). The top should always be the **nearest candidate** smaller than the current number.

For the current value `x = arr[i]`:

* Pop while `st.top() >= x` (they cannot be the next **strictly** smaller).
* After popping:

  * If the stack is empty â†’ answer is `-1`
  * Else â†’ answer is `st.top()` (nearest smaller to the right)
* Push `x` to be a candidate for elements to its left.

> Using `>=` ensures we find **strictly** smaller. If the spec said â€œsmaller or equalâ€, youâ€™d pop only `>`.


### âœ… Polished Code (same approach, with comments)

```cpp
#include <bits/stdc++.h>
using namespace std;

// Next Smaller Element to the Right (value version)
vector<int> nextSmallerElement(vector<int>& arr) {
    int n = (int)arr.size();
    stack<int> st;        // holds candidate values, increasing (top is nearest)
    vector<int> ans(n);

    for (int i = n - 1; i >= 0; --i) {
        int x = arr[i];
        // Maintain strictly smaller at the top
        while (!st.empty() && st.top() >= x) st.pop();
        ans[i] = st.empty() ? -1 : st.top();
        st.push(x);
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    vector<int> v;
    string line;
    getline(cin, line);

    stringstream ss(line);
    int num;
    while (ss >> num) v.push_back(num);

    vector<int> ans = nextSmallerElement(v);
    for (int x : ans) cout << x << ' ';
    return 0;
}
```


### â±ï¸ Complexity

* **Time:** `O(n)` â€” each element is pushed/popped at most once.
* **Space:** `O(n)` â€” stack + result array.

### ðŸ§ª Test Cases

1. **Mixed values**

```
arr = [4, 8, 5, 2, 25]
ans = [2, 5, 2, -1, -1]
```

2. **All increasing**

```
arr = [1, 2, 3, 4]
ans = [-1, -1, -1, -1]
```

3. **All decreasing**

```
arr = [5, 4, 3, 2, 1]
ans = [4, 3, 2, 1, -1]
```

4. **With duplicates**

```
arr = [2, 2, 2]
ans = [-1, -1, -1]   // strictly smaller â†’ none
arr = [3, 3, 2, 2, 1]
ans = [2, 2, 1, 1, -1]
```

5. **Single element**

```
arr = [7]
ans = [-1]
```

6. **Empty input** (if allowed)

```
arr = []
ans = []
```

---

### ðŸ” Useful Variations

#### 1) Next Smaller Element **to the Left** (NSL)

Scan **left â†’ right** with a similar stack:

```cpp
vector<int> nextSmallerToLeft(const vector<int>& arr) {
    int n = (int)arr.size();
    stack<int> st;
    vector<int> ans(n);

    for (int i = 0; i < n; ++i) {
        int x = arr[i];
        while (!st.empty() && st.top() >= x) st.pop();
        ans[i] = st.empty() ? -1 : st.top();
        st.push(x);
    }
    return ans;
}
```

#### 2) Return **indices** (handy for distances / ranges)

Store **indices** on the stack to compute distances or to handle duplicates more robustly:

```cpp
vector<int> nextSmallerIndexRight(const vector<int>& arr) {
    int n = (int)arr.size();
    vector<int> ansIdx(n, -1);
    stack<int> st; // stack of indices

    for (int i = n - 1; i >= 0; --i) {
        while (!st.empty() && arr[st.top()] >= arr[i]) st.pop();
        ansIdx[i] = st.empty() ? -1 : st.top();
        st.push(i);
    }
    return ansIdx;
}
```

#### 3) Next **Greater** instead of Smaller

Flip the inequality to maintain a **decreasing** stack, pop `<=` to find **strictly greater**.

#### 4) Circular version (wrap-around)

Like Next Greater Element II, traverse **twice** with `i % n` to find next smaller in a **circular** array.


### âš ï¸ Gotchas & Tips

* **Strictness matters**: Using `>=` in the pop ensures the remaining top is **strictly** smaller.
* **Duplicates**: Value-stack is fine for just the next smaller **value**; switch to **index stack** if you need positions or have tricky duplicate handling.
* **Monotonic invariant**: For NSR we keep the stack **increasing** (nearest smaller must sit on top).
* **I/O**: Your main parses a space-separated line â€” good for quick testing.

### â“ FAQs

**Q: Why scan from right to left?**
>Because we want â€œto the rightâ€; scanning from the end ensures the stack contains only candidates to the right of the current index.

**Q: Why pop `>= x` and not just `> x`?**
>We want **strictly** smaller. If we left an equal value on the stack, we might incorrectly return it.

**Q: When do I need indices instead of values?**
>When you need distances, ranges (e.g., largest rectangle in histogram), or must disambiguate duplicates by position.

