# ğŸ§® Remove K Digits [#402](https://leetcode.com/problems/remove-k-digits/description/)

> **Problem:** Given a non-negative integer `num` as a string and an integer `k`, remove exactly `k` digits from `num` so that the resulting number is as **small** as possible. Return `"0"` if the result has leading zeros or is empty.

---

### ğŸš¦ Intuition

We want the lexicographically (and numerically) **smallest** number after deleting `k` digits.
If we scan leftâ†’right, whenever the current digit is **smaller** than the previous kept digit, we should **delete** that previous digit (if we still can). This is exactly the behavior of a **monotonic increasing stack** of digits:

* While `k > 0` and the stackâ€™s top digit is **greater** than the current digit, **pop** the stack (delete that larger digit).
* Push the current digit.
* After the pass, if `k > 0`, pop from the end (remove the largest trailing digits).
* Finally, **strip leading zeros**.

This greedy rule is optimal: deleting a larger digit earlier creates the smallest possible prefix, which dominates the value.


### ğŸ¢ Brute Force (why itâ€™s bad)

Try all ways to remove `k` digits (choose `k` positions).

* Combinations: `C(n, k)` (can be huge), and each check/compare costs more.
* **Time:** exponential/combintorial â€” infeasible for `n` up to 10âµ.


### âš¡ Optimal Approach â€” Greedy Monotonic Stack (O(n))

#### Key rules

1. **Pop while** `k > 0 && stack.top() > current_digit`.
2. **Push** current digit.
3. After the loop, if `k>0`, **pop** `k` digits from the end.
4. **Strip leading zeros**; if empty, return `"0"`.


### âœ¨ Polished, Fast Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    string removeKdigits(string num, int k) {
        string st;  // use as a monotonic stack of digits

        for (char c : num) {
            while (!st.empty() && k > 0 && st.back() > c) {
                st.pop_back();
                --k;
            }
            st.push_back(c);
        }

        // If k remains, remove from the end (largest trailing digits)
        while (k > 0 && !st.empty()) {
            st.pop_back();
            --k;
        }

        // Strip leading zeros
        size_t first = st.find_first_not_of('0');
        if (first == string::npos) return "0";

        return st.substr(first);
    }
};
```


### ğŸ” Dry Run

`num = "1432219", k = 3`

* Scan: `1` â†’ st=`1`
* `4` â†’ st=`14`
* `3`: pop `4` (k=2) â†’ st=`1`, push `3` â†’ `13`
* `2`: pop `3` (k=1) â†’ `1`, push `2` â†’ `12`
* `2`: `12 2` (no pop) â†’ `122`
* `1`: pop `2` (k=0) â†’ `12`, push `1` â†’ `121`
* `9`: push â†’ `1219`
* k=0, strip zeros â†’ `1219` âœ…

---

### â±ï¸ Complexity

| Aspect | Complexity | Notes                                    |
| ------ | ---------- | ---------------------------------------- |
| Time   | **O(n)**   | Each digit is pushed/popped at most once |
| Space  | **O(n)**   | For the stack/result string              |


### ğŸ§ª Test Cases

```txt
1) num="1432219", k=3  â†’ "1219"
2) num="10200",  k=1   â†’ "200"    (remove '1', strip leading '0')
3) num="10",     k=2   â†’ "0"      (all removed)
4) num="9",      k=1   â†’ "0"
5) num="112",    k=1   â†’ "11"     (keep earlier small prefix)
6) num="100200", k=1   â†’ "00200" â†’ "200"
7) num="12345",  k=2   â†’ "123"    (already increasing; drop from end)
8) num="7650283",k=3   â†’ "0283" â†’ "283"
```


### ğŸ’¡ Tips & Gotchas

* **Leading zeros:** Always strip them at the end (or skip pushing them when the stack is empty â€” but careful: zeros in the middle are valid).
* **k â‰¥ n:** Edge case; result is `"0"`.
* **Already increasing numbers:** No pops during scan; the last `k` digits will be removed.
* **Large inputs:** The O(n) approach handles 10âµ digits comfortably.


### ğŸ” Variations

* **Remove K digits to form the *largest*** number: reverse the comparison (`st.back() < c`) and similar cleanup.
* **Remove exactly K digits to minimize lexicographic order**: identical to this problem (numbersâ€™ lexicographic order equals numeric when same length after zero-trim).
* **Keep K digits (remove nâˆ’k)**: same logic, just change the stop condition.


### â“ FAQs

**Q: Why does greedy popping give a global optimum?**
>Because the first differing digit dominates numeric value. By ensuring the earliest digits are as small as possible (popping larger previous digits), you minimize the number.

**Q: Why pop from the end if k remains?**
>If you never found a smaller digit to the right, the number is non-decreasing; removing from the end minimizes the result.

**Q: Can we skip the final leading-zero strip?**
>Not safely. Intermediate operations may generate leading zeros; stripping ensures correct numeric representation.

