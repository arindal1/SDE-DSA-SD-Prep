# üß± Largest Rectangle in Histogram [#84](https://leetcode.com/problems/largest-rectangle-in-histogram/description/)

> **Goal:** Given bar heights of a histogram, find the area of the **largest rectangle** that can be formed within it.


## üß© Problem Statement

* Input: `vector<int> heights` of length `n`, where each bar has width `1` and height `heights[i] ‚â• 0`.
* Output: The maximum rectangular **area** contained in the histogram.

<br>

**Example**
`heights = [2,1,5,6,2,3]` ‚Üí **Output:** `10`

![image](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

*Explanation:* rectangle using bars of heights `5` and `6` (`[5,6]`) with width `2` ‚Üí `5√ó2=10` or `6√ó1 + 5√ó1 = 11?` No‚Äîbest is width 2 at height 5: actually the maximal is height 5 across bars 3 & 4 (index 2 and 3), but the classic max is **10** with height `5` across width `2` or height `2` across width `5` yields `10` as well (either way max is 10).

---

### üß† Intuition

For each bar as the **minimum height** of a rectangle, you want how far it can extend **left** and **right** until a shorter bar stops it. If you know:

* `prevSmaller[i]`: index of the previous **strictly smaller** bar to the left (or `-1`),
* `nextSmaller[i]`: index of the next **strictly smaller** bar to the right (or `n`),

then the widest rectangle where `heights[i]` is the limiting height has:

```
width  = nextSmaller[i] - prevSmaller[i] - 1
area   = heights[i] * width
```

A **monotonic increasing stack** (store indices) can find these boundaries in **O(n)**.


### üê¢ Brute Force (why not)

For each `i`, expand left and right until a smaller bar is found.

* Worst-case **O(n¬≤)** (e.g., strictly increasing heights).


### ‚ö° Optimal Approach ‚Äî Single Pass Monotonic Stack (O(n))

Maintain a stack of indices with **strictly increasing heights**.

* When you see a bar `heights[i]` that is **lower** than the stack‚Äôs top height, you‚Äôve just found the **right boundary** for the top.
* Pop the top `t`, compute:

  * `height = heights[t]`
  * `right = i - 1`
  * `left = st.empty() ? 0 : st.top() + 1`
  * `width = right - left + 1 = st.empty() ? i : i - st.top() - 1`
  * `area = height * width`
* Push current index `i` after popping all taller-or-equal bars.

Using ‚Äú**>=**‚Äù in the popping condition merges equal-height bars and prevents double-counting.


## ‚ú® Polished, Safe Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

int largestRectangleArea(vector<int>& heights) {
    const int n = (int)heights.size();
    stack<int> st; // stores indices, heights are strictly increasing on stack
    long long maxArea = 0;

    for (int i = 0; i < n; ++i) {
        // maintain increasing stack
        while (!st.empty() && heights[st.top()] >= heights[i]) {
            int h = heights[st.top()];
            st.pop();
            int leftIndex = st.empty() ? 0 : st.top() + 1;
            int width = i - leftIndex;
            maxArea = max(maxArea, 1LL * h * width);
        }
        st.push(i);
    }

    // clear remaining bars (as if a zero-height bar at the end)
    while (!st.empty()) {
        int h = heights[st.top()];
        st.pop();
        int leftIndex = st.empty() ? 0 : st.top() + 1;
        int width = n - leftIndex;
        maxArea = max(maxArea, 1LL * h * width);
    }

    return (int)maxArea;
}
```

> If you prefer a compact loop, you can also **append a sentinel 0** to `heights` and process in one pass; just remember not to read past original `n`.


### üîç Walkthrough Example

`heights = [2,1,5,6,2,3]`

* i=0 (2): push ‚Üí [0]
* i=1 (1): pop 0 (h=2), width = 1 ‚Üí area=2; push 1 ‚Üí [1]
* i=2 (5): push ‚Üí [1,2]
* i=3 (6): push ‚Üí [1,2,3]
* i=4 (2): pop 3 (h=6), width=1 ‚Üí 6; pop 2 (h=5), width=2 ‚Üí **10**; push 4 ‚Üí [1,4]
* i=5 (3): push ‚Üí [1,4,5]
* end: pop 5 (h=3), width=1 ‚Üí 3; pop 4 (h=2), width=4 ‚Üí 8; pop 1 (h=1), width=6 ‚Üí 6
  Max = **10** ‚úÖ


### ‚è±Ô∏è Complexity

* **Time:** `O(n)` ‚Äî each index pushed/popped at most once
* **Space:** `O(n)` ‚Äî for the stack

---

### üß™ Test Cases

1. Increasing
   `[1,2,3,4,5]` ‚Üí `9` (height=3, width=3 or height=4,width=2=8; actually best is 9 with [3,4,5] at min 3 ‚Üí 3*3=9)

2. Decreasing
   `[5,4,3,2,1]` ‚Üí `9` (height=3, width=3)

3. Mixed
   `[2,1,5,6,2,3]` ‚Üí `10`

4. Single bar
   `[7]` ‚Üí `7`

5. Zeros
   `[0,0,0]` ‚Üí `0`

6. Plateaus (equals)
   `[2,2,2]` ‚Üí `6` (height=2, width=3)

7. Large values (overflow guard)
   `[1000000000, 1000000000]` ‚Üí `2000000000` (fits in 32-bit return, but internal product uses 64-bit)


### üí° Tips & Gotchas

* Use **`>=`** in the while condition to pop equal heights; this merges plateaus and keeps boundaries correct.
* Prefer **indices** over values on the stack ‚Äî you need widths.
* Use **`long long`** for `area` calculations.
* Two common styles:

  * **No sentinel** (like above) with a final cleanup loop.
  * **Sentinel** `0` appended to heights and a single loop over `i in [0..n]`.


### üîÅ Variations

* **Maximal Rectangle in a Binary Matrix** (LeetCode 85): build histogram heights row-by-row; apply this function each row.
* **Largest Rectangle under Skyline** with different bar widths: requires prefix sums of widths and similar stack logic.
* **Prev/Next smaller arrays** approach: precompute `prevSmaller` and `nextSmaller` then compute each bar‚Äôs best area in O(1); still overall O(n).

### ‚ùì FAQs

**Q: Why does popping mean we found the right boundary?**
When a shorter bar is encountered, all taller/equal bars to its left can no longer extend to this index; this index marks the first right boundary where they fail.

**Q: Why use `>=` and not `>`?**
Using `>=` ensures equal-height bars are collapsed so the width is counted exactly once, preventing over/under counting.

**Q: Do I need to append a sentinel?**
No. The final cleanup loop handles remaining stack entries. The sentinel variant just folds that cleanup into the main loop.
