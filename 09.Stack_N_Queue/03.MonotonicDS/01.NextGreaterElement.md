# ğŸ”¥ Next Greater Element (Monotonic Stack) [#496](https://leetcode.com/problems/next-greater-element-i/description/)

## ğŸ§© Problem Statement

Given two integer arrays:

* `nums1`: a subset of `nums2`
* `nums2`: contains **distinct** elements

For each element `x` in `nums1`, find the **next greater element** of `x` in `nums2`:
the first element to the **right** of `x` in `nums2` that is **strictly greater** than `x`.
If it doesnâ€™t exist, return `-1`.

**Example**
`nums1 = [4,1,2], nums2 = [1,3,4,2]` â†’ Output: `[-1,3,-1]`

* `4` â†’ right side in `nums2`: `2` â‡’ no greater â‡’ `-1`
* `1` â†’ right side: `3,4,2` â‡’ first greater is `3`
* `2` â†’ right side: none â‡’ `-1`


### ğŸ’¡ Intuition

We want â€œfor each number, the first greater number to its right.â€
A **monotonic decreasing stack** from right to left is perfect:

* Traverse `nums2` from **right â†’ left**.
* Maintain a stack that is **strictly decreasing** (top is the nearest candidate next-greater).
* For current `x`, **pop** all `â‰¤ x` (they canâ€™t be next greater for `x` or anyone to its left).
* After popping:

  * If stack is empty â†’ next greater is `-1`
  * Else â†’ next greater is `st.top()`
* Push `x` onto stack.
* Store result in a map: `nextGreater[x] = ...`

Finally, answer each query in `nums1` by looking up `nextGreater[x]`.


### âœ… Code (polished + comments)

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    unordered_map<int, int> nextGreater; // value in nums2 -> its next greater to the right
    stack<int> st;                        // decreasing stack of candidates

    // Build mapping for all values in nums2
    for (int i = (int)nums2.size() - 1; i >= 0; --i) {
        int x = nums2[i];
        while (!st.empty() && st.top() <= x) st.pop();
        nextGreater[x] = st.empty() ? -1 : st.top();
        st.push(x);
    }

    // Answer queries for nums1
    vector<int> ans;
    ans.reserve(nums1.size());
    for (int v : nums1) {
        // If problem guarantees nums1 âŠ† nums2 and nums2 distinct, direct lookup is safe:
        // ans.push_back(nextGreater[v]);

        // Defensive (in case constraints donâ€™t hold):
        auto it = nextGreater.find(v);
        ans.push_back(it == nextGreater.end() ? -1 : it->second);
    }
    return ans;
}
```

**Why it works:**
By keeping a stack of â€œstrictly decreasingâ€ numbers, the top is always the nearest greater to the right for the current `x`. Popping removes impossible candidates.


### â±ï¸ Complexity

* **Time:** `O(n + m)` where `n = |nums2|`, `m = |nums1|`
  Each element is pushed/popped at most once.
* **Space:** `O(n)` for the stack + hashmap.

---

### ğŸ§ª Test Cases

1. **Basic**

```cpp
nums1 = {4,1,2};
nums2 = {1,3,4,2};
// -> {-1, 3, -1}
```

2. **All increasing**

```cpp
nums1 = {2,3};
nums2 = {1,2,3,4};
// -> {3,4}
```

3. **All decreasing**

```cpp
nums1 = {1,4};
nums2 = {5,4,3,2,1};
// -> {-1, -1}
```

4. **Single element**

```cpp
nums1 = {7};
nums2 = {7};
// -> {-1}
```

5. **Defensive (nums1 not subset)**

```cpp
nums1 = {10, 2};
nums2 = {2, 1};
// -> {-1, -1}   (10 not in nums2, 2 has no greater to right)
```


### ğŸ§  Tips & Gotchas

* **Distinctness matters**: The mapping by value works because `nums2` elements are **unique** in this problem.
  If duplicates can appear, you must index by **position** (store indices on the stack).
* **Right-to-left** is natural for â€œnext on the right.â€
  For â€œprevious greater,â€ scan left-to-right.
* **Reserve** `ans` capacity for minor perf gain (already included).


### ğŸ” Variations

* **Next Greater Element II (circular array)**
  Traverse the array **twice** with `i % n` and maintain a similar stack.
  Initialize answers with `-1`. Time remains `O(n)`.

* **Next Greater to Left**
  Scan **left â†’ right**, maintain decreasing stack; for each `x`, pop `â‰¤ x`, the **top** (if exists) is previous greater.

* **Next Smaller Element**
  Switch the monotonic condition: use an **increasing** stack and flip comparisons.

* **Indices + distances**
  Store indices in the stack to compute distances or to handle duplicates robustly.


### â“ FAQs

**Q: Why `<=` when popping?**
>We need **strictly greater**, so any `â‰¤ x` canâ€™t serve as next greater for `x` (or anyone to its left). Pop them.

**Q: Why map by value, not index?**
>LeetCode 496 guarantees `nums2` has **distinct** values and `nums1 âŠ† nums2`, so a valueâ†’nextGreater mapping is safe and convenient.

**Q: Can we avoid a map?**
>Yesâ€”precompute an array `nge` indexed by position in `nums2`, and use an auxiliary map from valueâ†’index only for lookups (also O(n)).

---

### ğŸ“¦ Alternative (index-based, good for duplicates)

```cpp
vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    int n = nums2.size();
    vector<int> nge(n, -1);
    stack<int> st; // stores indices, nums2[st.top()] is decreasing

    for (int i = n - 1; i >= 0; --i) {
        while (!st.empty() && nums2[st.top()] <= nums2[i]) st.pop();
        nge[i] = st.empty() ? -1 : nums2[st.top()];
        st.push(i);
    }

    unordered_map<int,int> pos;
    pos.reserve(n*2);
    for (int i = 0; i < n; ++i) pos[nums2[i]] = i;

    vector<int> ans;
    ans.reserve(nums1.size());
    for (int x : nums1) {
        auto it = pos.find(x);
        ans.push_back(it == pos.end() ? -1 : nge[it->second]);
    }
    return ans;
}
```

