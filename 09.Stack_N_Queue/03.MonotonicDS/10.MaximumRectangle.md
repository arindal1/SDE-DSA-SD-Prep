# Maximal Rectangle âœ…


## 1) Problem statement

> **Problem (LeetCode 85 : [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/description/))**
> Given a binary matrix filled with `'0'` and `'1'`, find the largest rectangle containing only `1`s and return its area.

Given an `m x n` binary matrix `matrix` of characters `'0'` and `'1'`, find the area of the largest rectangle within the matrix that contains only `'1'`s. Return the area (an integer).


> Example 1:

```
Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
```

![image](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)


**Output:** `6`

**Explanation:** The maximal rectangle is shown in the above picture.

---

### 2) Intuition

* Think row-by-row.
* For any row `i`, compute `heights[j]` = number of consecutive `'1'`s ending at row `i` in column `j` (i.e., count of vertical 1s up to that row).
* If you consider `heights` as the bar heights of a histogram, the problem reduces to finding the **largest rectangle in histogram** for that row.
* Repeat for every row and keep the maximum.

So the problem becomes: *for each row compute histogram heights, then compute largest rectangle in that histogram using an O(n) monotonic stack algorithm.*
Total time: `O(m * n)`.


### 3) Brute force (and why itâ€™s slow)

Brute force idea:

* For every possible submatrix (pick top, bottom, left, right), check if all entries are `'1'`, compute area, track max.
* Number of submatrices is `O(m^2 * n^2)` and checking each is `O(m*n)` naive â€” infeasible.

Better brute force:

* For each pair of rows `top` and `bottom`, compress columns by AND-ing rows to get a 1D array and find the longest consecutive ones â€” still `O(m^2 * n)` which is too slow for large inputs.

Hence need an `O(m*n)` approach.


### 4) Optimal approach : Histogram + Largest Rectangle in Histogram

**High-level algorithm:**

1. Keep a `vector<int> heights(n, 0)`.
2. For each row `i = 0..m-1`:

   * Update `heights[j] = (matrix[i][j] == '1') ? heights[j] + 1 : 0` for all columns `j`.
   * Compute largest rectangle area in the histogram `heights` using a monotonic stack (classic algorithm).
   * Update global maximum area.
3. Return the maximum area.

**Largest Rectangle in Histogram (monotonic stack) summary:**

* Use a stack of indices that stores indices of bars in increasing height order.
* Iterate `i = 0..n` (note: iterate to `n` inclusive â€” treat `i == n` as a sentinel with height `0` to flush stack).
* While current bar is lower than top-of-stack bar, pop the stack and compute area:

  * `height = arr[top]`
  * `width = (stack empty) ? i : i - stack.top() - 1`
  * `area = height * width`
* Push current index `i` to stack.
* Using `<=` or `>=` in comparison determines how equal heights are treated; `>=` is safe and avoids missing wider rectangles.


### 5) C++ code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Helper: largest rectangle in histogram (arr)
int largestRectangleInHistogram(const vector<int>& arr) {
    int n = arr.size();
    stack<int> st;
    int maxArea = 0;

    for (int i = 0; i <= n; ++i) {
        // When i == n, treat current height as 0 (sentinel)
        while (!st.empty() && (i == n || arr[st.top()] >= (i < n ? arr[i] : 0))) {
            int h = arr[st.top()]; st.pop();
            int width = st.empty() ? i : i - st.top() - 1;
            maxArea = max(maxArea, h * width);
        }
        st.push(i);
    }
    return maxArea;
}

int maximalRectangle(vector<vector<char>>& matrix) {
    if (matrix.empty() || matrix[0].empty()) return 0;
    int m = matrix.size();
    int n = matrix[0].size();

    vector<int> heights(n, 0);
    int maxArea = 0;

    for (int i = 0; i < m; ++i) {
        // Update heights
        for (int j = 0; j < n; ++j) {
            if (matrix[i][j] == '1') heights[j] += 1;
            else heights[j] = 0;
        }
        // Compute largest rectangle for this histogram
        maxArea = max(maxArea, largestRectangleInHistogram(heights));
    }
    return maxArea;
}
```
---

### 6) Worked example (small)

Matrix:

```
[
 ['1','0','1','0','0'],
 ['1','0','1','1','1'],
 ['1','1','1','1','1'],
 ['1','0','0','1','0']
]
```

Row by row heights:

* Row0 heights: `[1,0,1,0,0]` â†’ largest area = 1
* Row1 heights: `[2,0,2,1,1]` â†’ largest area = 3 (columns 2..4 heights `[2,1,1]` actually best area 3)
* Row2 heights: `[3,1,3,2,2]` â†’ largest area = 6 (columns 0..2 with heights `[3,1,3]` or columns 2..4 -> area 6)
* Row3 heights: `[4,0,0,3,0]` â†’ largest area = 4
  Global max = **6**.

This example appears in many explanations of LC85.

### 7) Important test cases

1. **Empty matrix:** `[]` â†’ answer `0`.
2. **Single row:** `[['1','1','0','1']]` â†’ areas: 2,1 -> answer `2`.
3. **Single column:** `[['1'],['1'],['0'],['1']]` â†’ answer `2`.
4. **All zeros:** all `'0'` â†’ answer `0`.
5. **All ones:** `m x n` all `'1'` â†’ area `m * n`.
6. **Checkerboard:** gives many small rectangles.
7. **Long narrow rectangles:** ensure stack algorithm handles tall bars.
8. **Rows with duplicate heights:** ensure `>=` logic correct.
9. **Max rectangle sits across multiple rows, not including row 0:** ensures heights track correctly.


### 8) Complexity analysis

* **Time complexity:** `O(m * n)`

  * For each of `m` rows, we update `n` heights (`O(n)`), and compute `largestRectangleInHistogram` in `O(n)` using stack. So `O(m*n)` total.
* **Space complexity:** `O(n)`

  * We maintain `heights` vector of length `n` and a stack that in worst-case holds `O(n)` indices.

This is asymptotically optimal for this problem.


### 9) Tips, tricks & pitfalls âš ï¸

* **Empty/malformed input**: Always check `if (matrix.empty() || matrix[0].empty()) return 0;`.
* **Character to integer**: `matrix[i][j] - '0'` converts `'0'/'1'` to `0/1`, but prefer explicit comparisons `matrix[i][j] == '1'` for clarity.
* **Sentinel technique**: Iterating `i` from `0..n` and treating `i==n` as height `0` simplifies final stack flushing. Make sure to *not* access `arr[n]` when `i == n`. Use a short-circuit condition `if (i == n || arr[st.top()] >= arr[i])`.
* **Equality in monotonic stack condition (`>=` vs `>`)**:

  * Using `>=` ensures that when heights are equal we pop earlier indices â€” this consolidates equal-height bars correctly and avoids undercounting widths.
  * Using `>` may also work but can change when equal heights are popped which might be subtle; `>=` is generally safe.
* **Avoid 2D memory if not necessary**: Original code built a full `mat[m][n]` of heights. You only need one `heights` vector updated row-by-row â†’ saves memory and is simpler.
* **Off-by-one errors** in width calculation: when popping `top`, width is:

  * if stack empty after pop: `i`
  * else: `i - stack.top() - 1`
* **Push indices, not heights**, so width calculation uses positions.


### 10) Variations & related problems ðŸ”€

* **Largest Rectangle in Histogram (LC 84)** â€” the subroutine used here.
* **Maximal Square (LC 221)** â€” find largest square of `1`s (use DP).
* **Maximum submatrix sum** (generalized Kadane 2D).
* **All ones submatrix with maximum perimeter/area under different constraints**.


### 11) FAQs

**Q: Why not store a 2D `mat` of heights like in the original code?**
A: You *can*, but it uses `O(m*n)` extra memory. A single `heights` vector updated in-place per row suffices and uses `O(n)` space.

**Q: Is monotonic stack tricky to implement?**
A: A little. Key points:

* Use indices on the stack.
* Use sentinel (iterate to `n` inclusive).
* While loop condition must short-circuit to avoid accessing `arr[n]`.
* Width computation uses `i` and the new top after popping.

**Q: What about time complexity? Could it be faster?**
A: `O(m*n)` is optimal since you must at least read all input `m*n`.

**Q: Are there integer overflow issues?**
A: Rectangle area is at most `m * n`. If `m` and `n` are up to `10^4`, `m*n` may exceed 32-bit signed int. Use `long long` if constraints are huge. For typical LeetCode constraints, `int` is fine.

**Q: Why is the `i==n` sentinel used instead of explicitly clearing stack after loop?**
A: Using `i==n` greatly simplifies code and ensures final bars are popped uniformly; it's the standard and elegant approach.

