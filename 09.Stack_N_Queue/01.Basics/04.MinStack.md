# üìâ MinStack ‚Äî O(1) [#155](https://leetcode.com/problems/min-stack/description/)

## üß© Problem statement

Design a data structure `MinStack` supporting:

* `push(x)`: push element x onto stack
* `pop()`: remove the top element
* `top()`: return the top element
* `getMin()`: return the minimum element in the stack

**All operations must be O(1).**

---

### üí° Intuition

We store the current minimum `mini` separately.
When pushing a new value `val`:

* If `val >= mini`: push `val` normally.
* If `val < mini`:
  we need to (1) remember this new min, and (2) remember the **old** min to restore on pop.
  So we **encode** and push a *marker* value:

  ```
  encoded = 2*val - mini
  ```

  Then set `mini = val`.

Why this works:

* The encoded number is **strictly less** than the new `mini`.
* Later, if `top()` shows a value `< mini`, we know it‚Äôs an encoded marker.
  When popping that marker, we can **reconstruct the previous minimum**:

  ```
  oldMini = 2*mini - encoded
  ```

  Then set `mini = oldMini`.

This makes `getMin()` **O(1)** without a second stack.


### ‚úÖ Clean, commented code

```cpp
#include <stack>
#include <climits>

class MinStack {
public:
    std::stack<long long> st; // store raw or encoded values
    long long mini;           // current minimum

    MinStack() : mini(LLONG_MAX) {}

    void push(int v) {
        long long val = v;
        if (st.empty()) {
            st.push(val);
            mini = val;
        } else {
            if (val < mini) {
                // push encoded marker; update min
                st.push(2LL * val - mini);
                mini = val;
            } else {
                st.push(val);
            }
        }
    }

    void pop() {
        if (st.empty()) return;

        long long el = st.top();
        st.pop();

        // If el < mini, it was an encoded marker: restore previous min
        if (el < mini) {
            // previous minimum before this push
            mini = 2LL * mini - el;
        }

        // If stack becomes empty, reset mini
        if (st.empty()) {
            mini = LLONG_MAX;
        }
    }

    int top() {
        if (st.empty()) return -1; // define behavior for empty
        long long el = st.top();

        // If encoded marker, logical top is current mini
        if (el < mini) return static_cast<int>(mini);
        return static_cast<int>(el);
    }

    int getMin() {
        if (st.empty()) return -1; // define behavior for empty
        return static_cast<int>(mini);
    }
};
```

> ‚ú® You already handled the critical detail of using `long long` to reduce overflow risk during `2*val - mini` and `2*mini - encoded`.

---

### üîç Correctness & invariants

* **Invariant**: `mini` always equals the true minimum of the logical stack.
* **Non-encoded entries** (`x >= mini`) are the actual values.
* **Encoded markers** (`x < mini`) signal, ‚ÄúAt this time a new minimum was set.‚Äù
  Their decoding on pop restores the previous `mini`.

**Why `encoded < mini` is guaranteed**:
If we push `val < mini`, then

```
encoded = 2*val - mini  <  val  <  mini
```

So checking `top < mini` reliably detects markers.


### üß™ Dry run

Consider pushing: `5, 3, 7, 2`

* Start: `mini = +‚àû`, stack = `[]`
* push(5): stack=`[5]`, mini=5
* push(3): val<mini ‚Üí push `2*3-5=1`; stack=`[5,1]`, mini=3
* push(7): val>=mini ‚Üí push `7`; stack=`[5,1,7]`, mini=3
* push(2): val<mini ‚Üí push `2*2-3=1`; stack=`[5,1,7,1]`, mini=2

Now `top()`:

* `top=1 < mini(2)` ‚Üí logical top is `mini=2`.

Pop:

* pop `1` (marker): `mini = 2*mini - encoded = 2*2 - 1 = 3` (restore old min).
* Next `top=7 >= mini(3)` ‚Üí top is 7.


### ‚è±Ô∏è Complexity

* `push`, `pop`, `top`, `getMin`: **O(1)** time.
* Extra space: **O(n)** for stack, **O(1)** extra for `mini`.



### üß† Edge cases & behavior choices

* **Empty stack:**

  * `top()` and `getMin()` return `-1` in this code.
    On platforms like LeetCode, that‚Äôs acceptable if specified; otherwise, consider throwing or using `std::optional<int>`.
* **Value range / overflow:**

  * Using `long long` helps. However, `2*val - mini` could still overflow if values approach `LLONG_MIN/LLONG_MAX`.
    If you need *provable* safety for extreme values, consider:

    * Using `__int128` for the arithmetic (compiler-dependent), or
    * Switching to the ‚Äútwo-stack‚Äù approach (see below).
* **Resetting `mini`:**

  * When the stack becomes empty, we reset `mini` to `LLONG_MAX`. That makes the next push behave like the first push again.

---

### üîÅ Alternative approaches

#### 1) Two stacks (simple & safe)

Keep a normal stack `st` and a `minSt` where each entry is the min **at that depth**.

* **Push**: `st.push(x)`, `minSt.push(min(x, minSt.top()))`
* **Pop**: pop both
* **getMin**: `minSt.top()`

Pros: simpler logic, no encoding, **no overflow risk**.
Cons: uses additional O(n) space (still O(n) total).

#### 2) Single stack of pairs

Store `{value, currentMin}` per node.
Also avoids encoding and overflow, but needs more memory per element.



### üß™ Suggested test cases

```cpp
MinStack ms;

// Basic
ms.push(3); ms.push(5);
assert(ms.getMin()==3 && ms.top()==5);

// New min
ms.push(2); ms.push(1);
assert(ms.getMin()==1 && ms.top()==1);

// Pop encoded min
ms.pop();
assert(ms.getMin()==2 && ms.top()==2);

// Back to previous values
ms.pop();
assert(ms.getMin()==3 && ms.top()==5);

// Empty behavior
ms.pop(); ms.pop();
assert(ms.getMin()==-1 && ms.top()==-1); // as per this implementation

// Duplicates
ms.push(2); ms.push(2); ms.push(2);
assert(ms.getMin()==2);
ms.pop(); ms.pop();
assert(ms.getMin()==2);
ms.pop();
assert(ms.getMin()==-1);
```

--- 

### üõ†Ô∏è Tips & gotchas

* Always check `st.empty()` before reading `top()`.
* Remember: `el < mini` is **the** marker check (don‚Äôt use `<=`).
* If your value domain can hit extremes, consider the two-stack solution to avoid overflow entirely.


### üì¶ Alternative full code (two stacks, amortized simple)

```cpp
#include <stack>
#include <climits>

class MinStack {
    std::stack<int> st, minSt;
public:
    void push(int x) {
        st.push(x);
        if (minSt.empty() || x <= minSt.top()) minSt.push(x);
        else minSt.push(minSt.top());
    }
    void pop() {
        if (st.empty()) return;
        st.pop(); minSt.pop();
    }
    int top() {
        return st.empty() ? -1 : st.top();
    }
    int getMin() {
        return minSt.empty() ? -1 : minSt.top();
    }
};
```


### üìö FAQ

**Q: Why does `encoded = 2*val - mini` restore the previous min?**
> Because when you set `mini = val`, you store a marker that encodes the delta from the previous min. On pop:

```
oldMini = 2*currentMini - encoded
       = 2*val - (2*val - oldMini)
       = oldMini
```

**Q: Is the encoding approach standard?**
> Yes‚Äîthis is a classic trick for O(1) min-stack with a single stack.

**Q: What if I push the same minimum multiple times?**
> Works fine. The encoding only happens when `val < mini`. If `val == mini`, it pushes normally.


### üß≠ Summary

| Approach                 | Extra Space | Overflow Risk   | Simplicity | getMin() |
| ------------------------ | ----------- | --------------- | ---------- | -------- |
| **Encoded single stack** | O(1)        | Possible (edge) | Medium     | O(1)     |
| Two stacks               | O(n)        | None            | Easiest    | O(1)     |
| Pair stack               | O(n)        | None            | Easy       | O(1)     |

> If you want bulletproof overflow guarantees for extreme ranges, prefer the **two-stack** or **pair** approach. Otherwise, the **encoded** method is elegant and memory-thrifty.
