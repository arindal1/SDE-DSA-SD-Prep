## **Remove Duplicates from a Sorted Array (In-Place)**

## üìã Problem Statement

Given a **sorted** integer array **`arr`** of size **`n`**, **remove all duplicates** in-place so that each element appears only **once**. Return the new **length** and print the first part of the array containing the **unique** elements.

> **Note:** You must do this with **O(1)** extra space‚Äîi.e., modify the input array directly.

---

## üöÄ Brute-Force Approach

1. **Use an auxiliary container** (e.g., `vector<int> unique;`).
2. **Traverse** the sorted array and **push** each element if it‚Äôs **different** from the last in `unique`.
3. **Copy** `unique` back into `arr`.
4. **Return** `unique.size()` and print.

```cpp
// O(n) time, O(n) extra space
int removeDupBrute(vector<int>& arr) {
    vector<int> unique;
    for (int x : arr) {
        if (unique.empty() || unique.back() != x)
            unique.push_back(x);
    }
    // Copy back
    for (int i = 0; i < unique.size(); i++)
        arr[i] = unique[i];
    return unique.size();
}
```

> **Drawbacks:**
>
> * Requires **O(n)** extra memory.
> * Not in-place as problem demands.

---

## ‚ö° Optimal Two-Pointer Approach

### **Key Insight**

Since the array is **sorted**, **all duplicates** of any value appear **consecutively**. We can keep one **slow pointer** (`i`) for the position of the **last unique** element, and one **fast pointer** (`j`) to scan ahead:

1. **Initialize** `i = 0` (first element is always unique).
2. For `j` from `1` to `n-1`:

   * If `arr[j] != arr[i]`, we‚Äôve found a **new unique** value:

     * **Advance** `i` by 1
     * **Copy** `arr[j]` into `arr[i]`
3. After the loop, **`i + 1`** is the **count** of unique elements; the subarray `arr[0‚Ä¶i]` contains them.

### **Why It‚Äôs Optimal**

* **Time:** O(n) ‚Äî exactly one pass.
* **Space:** O(1) ‚Äî only two integer variables.
* **In-Place:** Satisfies the requirement.

---

## üìù Pseudocode

```text
FUNCTION removeDuplicates(arr, n):
    IF n == 0:
        RETURN 0

    i ‚Üê 0    // slow pointer
    FOR j FROM 1 TO n‚àí1:   // fast pointer
        IF arr[j] ‚â† arr[i]:
            i ‚Üê i + 1
            arr[i] ‚Üê arr[j]

    RETURN (i + 1)   // new length of unique subarray
```

---

## üíæ Revised C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Removes duplicates in-place from a sorted arr of size n.
// Prints the new length and the unique elements.
void RemoveDuplicates(vector<int>& arr) {
    int n = arr.size();
    if (n == 0) {
        cout << 0 << "\n";
        return;
    }

    int i = 0;  // slow pointer
    for (int j = 1; j < n; j++) {
        if (arr[j] != arr[i]) {
            arr[++i] = arr[j];
        }
    }

    int newLength = i + 1;
    cout << newLength << "\n";
    for (int k = 0; k < newLength; k++) {
        cout << arr[k] << " ";
    }
    cout << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    // **Precondition:** arr must be sorted.
    // If not, uncomment below to sort first:
    // sort(arr.begin(), arr.end());

    RemoveDuplicates(arr);
    return 0;
}
```

---

## üìà Complexity Analysis

| Metric               | Value    |
| -------------------- | -------- |
| **Time Complexity**  | **O(n)** |
| **Space Complexity** | **O(1)** |

* Each element is visited **once** by pointer `j`.
* Only **two** additional integer variables (`i`, `j`) are used.

---

## ‚ú® Notes & Facts

* **Sorted Requirement:** This two-pointer trick **only** works if `arr` is **already sorted**.
* **Preserves Order:** The in-place scheme **retains the relative order** of unique elements.
* **Edge Cases:**

  * **Empty array** ‚Üí prints `0`.
  * **All elements identical** ‚Üí new length `1`.
* **LeetCode Equivalent:** Problem 26 ([Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)).

---

## ‚ö° Optimal Set-Based Approach

### **Key Idea**

A **`std::unordered_set`** (or `std::set`) can track which values have been **seen** in **O(1)** average time per insertion and lookup. As you traverse the array:

1. **Initialize** an empty `unordered_set<int> seen;`
2. **For each** `x` in `arr`:

   * If `x` **not** in `seen`, **insert** `x` into `seen` and **append** `x` to `result`.
3. **Print** or return `result`.

This runs in **O(n)** average time (with `unordered_set`) and **O(n log n)** if you use `std::set`. It uses **O(n)** extra space.

---

## üìù Algorithm

```text
FUNCTION removeDuplicatesWithSet(arr):
    seen ‚Üê empty unordered_set
    result ‚Üê empty list

    FOR each x IN arr:
        IF x not in seen:
            seen.insert(x)
            result.append(x)

    RETURN result
```

---

## üíæ C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Removes duplicates using an unordered_set (preserves first occurrence order)
void RemoveDuplicatesWithSet(const vector<int>& arr) {
    unordered_set<int> seen;
    vector<int> result;
    result.reserve(arr.size());

    for (int x : arr) {
        if (seen.insert(x).second) {
            // insertion succeeded ‚Üí x was not present
            result.push_back(x);
        }
    }

    // Print results
    cout << result.size() << "\n";
    for (int x : result) {
        cout << x << " ";
    }
    cout << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    RemoveDuplicatesWithSet(arr);
    return 0;
}
```

> **Note:**
>
> * To maintain **sorted** order of unique elements, replace `unordered_set` with `set`, then traverse the set (loses original order).

---

## üìà Complexity Analysis

| Approach                 | Time Complexity  | Space Complexity |
| ------------------------ | ---------------- | ---------------- |
| **Brute-Force**          | O(n¬≤)            | O(n) (result)    |
| **Set (unordered\_set)** | O(n) *amortized* | O(n)             |
| **Set (`std::set`)**     | O(n log n)       | O(n)             |

---

## ‚ú® Notes & Facts

* **Preserving Order:**

  * `unordered_set` + `vector` preserves the **first-seen** order of unique elements.
  * A plain `set` returns elements in **sorted** order instead.

* **Choice of Set:**

  * Use **`unordered_set`** for **average O(1)** insert/lookup.
  * Use **`set`** (balanced BST) for **guaranteed** O(log n) but with additional ordering.

* **Memory Trade-off:**

  * This approach uses **O(n)** extra memory, unlike the in-place two-pointer technique which is O(1).

---

---

## ‚ùì Frequently Asked Questions

**Q1: What if the array is not sorted?**

> You must **sort** it first‚Äîeither in-place (`sort(arr.begin(), arr.end())`) or via another method. That costs **O(n log n)**.

---

**Q2: How to handle duplicates beyond two?**

> The algorithm handles **any number** of consecutive duplicates, collapsing them into **one** copy.

---

**Q3: Can we remove elements physically (shrink the container)?**

> You could do `arr.resize(newLength)` after, but it‚Äôs **not required** if you only care about the prefix.

---

**Q4: How to modify for linked lists?**

> Use similar two-pointer logic on nodes, adjusting `next` pointers instead of array assignments.

---

**Q5: When is the set-based approach preferable?**

> When the array is **unsorted** or you want to **preserve insertion order** without extra sorting, and you can afford O(n) extra space.

---
