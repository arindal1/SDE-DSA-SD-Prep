# ğŸ”— Intersection of Two Sorted Arrays

---

## ğŸ“‹ Problem Statement

Given two **sorted** arrays `arr1` (size `n1`) and `arr2` (size `n2`), compute their **intersection**â€”the elements that appear in **both** arrays. Return these common elements in **sorted order**, without duplicates.

---

## ğŸ¢ Bruteâ€‘Force Approach (Using a Set)

1. **Insert** all elements of `arr1` into a `std::unordered_set<int>`.
2. **Traverse** `arr2`, and for each `x` in `arr2`, **if** `x` exists in the set, **insert** it into a result `std::set<int>` (to ensure order and uniqueness).
3. **Convert** the result `std::set` to a vector.

```cpp
// O(n1 + n2) average time, O(n1 + m) space
vector<int> intersectBrute(const vector<int>& arr1, const vector<int>& arr2) {
    unordered_set<int> s(arr1.begin(), arr1.end());
    set<int> resSet;
    for (int x : arr2) {
        if (s.count(x)) {
            resSet.insert(x);
        }
    }
    return vector<int>(resSet.begin(), resSet.end());
}
```

> **Pros:**
>
> * Simple to implement with STL.
>   **Cons:**
> * Uses **O(n1 + n2)** extra space.
> * `std::set` insertion is **O(log m)**.

---

## âš¡ Optimal Twoâ€‘Pointer Approach

### **Key Idea**

Since **both arrays are sorted**, use two indices `i` and `j`:

1. Initialize `i = 0`, `j = 0`.
2. While `i < n1 && j < n2`:

   * **If** `arr1[i] < arr2[j]`, **increment** `i`.
   * **Else if** `arr1[i] > arr2[j]`, **increment** `j`.
   * **Else** (equal), **append** `arr1[i]` to result (if **new**), then `i++`, `j++`.
3. Return the result vector.

This runs in **O(n1 + n2)** time, **O(1)** extra space (excluding output).

---

## ğŸ“ Twoâ€‘Pointer Pseudocode

```text
FUNCTION IntersectSorted(arr1, arr2):
    i â† 0; j â† 0
    res â† empty list

    WHILE i < n1 AND j < n2:
        IF arr1[i] < arr2[j]:
            i â† i + 1
        ELSE IF arr1[i] > arr2[j]:
            j â† j + 1
        ELSE:
            // Equal elements
            IF res is empty OR res.back() â‰  arr1[i]:
                res.push_back(arr1[i])
            i â† i + 1
            j â† j + 1

    RETURN res
```

---

## ğŸ’¾ C++ Code (Twoâ€‘Pointer)

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the intersection of two sorted arrays arr1 and arr2.
 */
vector<int> IntersectSorted(const vector<int>& arr1, const vector<int>& arr2) {
    int n1 = arr1.size(), n2 = arr2.size();
    int i = 0, j = 0;
    vector<int> res;

    while (i < n1 && j < n2) {
        if (arr1[i] < arr2[j]) {
            i++;
        } else if (arr1[i] > arr2[j]) {
            j++;
        } else {
            if (res.empty() || res.back() != arr1[i]) {
                res.push_back(arr1[i]);
            }
            i++;
            j++;
        }
    }

    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n1, n2;
    cin >> n1 >> n2;
    vector<int> arr1(n1), arr2(n2);
    for (int i = 0; i < n1; i++) cin >> arr1[i];
    for (int j = 0; j < n2; j++) cin >> arr2[j];

    vector<int> inter = IntersectSorted(arr1, arr2);
    for (int x : inter) {
        cout << x << ' ';
    }
    cout << '\n';
    return 0;
}
```

---

## ğŸ“ˆ Complexity Analysis

| Approach                  | Time Complexity | Space Complexity       |
| ------------------------- | --------------- | ---------------------- |
| **Setâ€‘Based Brute**       | O(n1 + n2) avg. | O(n1 + n2)             |
| **Twoâ€‘Pointer (Optimal)** | **O(n1 + n2)**  | **O(1)** (plus output) |

---

## âœ¨ Notes & Facts

* **Sorted Property:** Twoâ€‘pointer approach relies on sorted input for linear-time intersection.
* **Duplicates Handling:** The check `res.back() != arr1[i]` avoids duplicate entries in the result.
* **Empty Arrays:** If either array is empty, result is empty.

---

## â“ Frequently Asked Questions

**Q1: How to handle unsorted arrays?**

> Sort both arrays first (O(n log n)), then apply twoâ€‘pointer method, for total O(n log n + m log m + n + m).

**Q2: Can we use a hash map instead?**

> Yesâ€”insert smaller array into `unordered_set`, then scan larger one. Comparable to bruteâ€‘force set approach above.

**Q3: How to find the **union** instead?**

> Use the union algorithm (mergeâ€‘like) ensuring uniqueness as shown in previous notes.

**Q4: Extend to k arrays?**

> Merge intersections pairwise or generalize with a frequency map across all arrays.

---