# 🔗 Union of Two Sorted Arrays

---

## 📋 Problem Statement

Given two **sorted** arrays `arr1` (size `n1`) and `arr2` (size `n2`), compute their **union**—all unique elements present in **either** array—**in sorted order**.

---

## 🐢 Brute‑Force Approach (Using a Set)

1. **Insert** every element of `arr1` into a `std::set<int>`.
2. **Insert** every element of `arr2` into the same set.
3. The set now contains all **unique** elements in **ascending** order.
4. **Copy** the set’s contents into a result vector.

```cpp
#include <bits/stdc++.h>
using namespace std;

// O((n1+n2)·log(n1+n2)) time, O(n1+n2) space
vector<int> unionBrute(const vector<int>& arr1, const vector<int>& arr2) {
    set<int> s;
    for (int x : arr1) s.insert(x);
    for (int x : arr2) s.insert(x);
    vector<int> result(s.begin(), s.end());
    return result;
}
```

> **Pros:**
>
> * Simplicity—leverages STL.
>   **Cons:**
> * **Extra O(n1+n2) space** for the set.
> * **Logarithmic**-insertion overhead.

---

## ⚡ Optimal Two‑Pointer Approach

### **Key Idea**

Since both arrays are **already sorted**, we can traverse them with two pointers **without extra sorting**:

1. Initialize `i = 0`, `j = 0`.
2. While neither pointer is at the end:

   * **If** `arr1[i] < arr2[j]`, append `arr1[i]` if it’s **new**, then `i++`.
   * **Else if** `arr2[j] < arr1[i]`, append `arr2[j]` if **new**, then `j++`.
   * **Else** (equal), append either one (if **new**), then `i++` and `j++`.
3. **Exhaust** the remainder of `arr1` or `arr2` similarly, only appending **distinct** values.

This yields **O(n1 + n2)** time and **O(1)** extra space (ignoring the output vector).

---

## 📝 Two‑Pointer Pseudocode

```text
FUNCTION UnionSorted(arr1, arr2):
    i ← 0; j ← 0
    res ← empty list

    WHILE i < n1 AND j < n2:
        IF arr1[i] < arr2[j]:
            val ← arr1[i]; i++
        ELSE IF arr2[j] < arr1[i]:
            val ← arr2[j]; j++
        ELSE:  // arr1[i] == arr2[j]
            val ← arr1[i]; i++; j++

        IF res is empty OR res.back() ≠ val:
            res.push_back(val)

    // Append remaining from arr1
    WHILE i < n1:
        IF res.back() ≠ arr1[i]:
            res.push_back(arr1[i])
        i++

    // Append remaining from arr2
    WHILE j < n2:
        IF res.back() ≠ arr2[j]:
            res.push_back(arr2[j])
        j++

    RETURN res
```

---

## 💾 C++ Code (Two‑Pointer)

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> UnionSorted(const vector<int>& arr1, const vector<int>& arr2) {
    int n1 = arr1.size(), n2 = arr2.size();
    int i = 0, j = 0;
    vector<int> res;

    while (i < n1 && j < n2) {
        int val;
        if (arr1[i] < arr2[j]) {
            val = arr1[i++];
        } else if (arr2[j] < arr1[i]) {
            val = arr2[j++];
        } else {
            val = arr1[i];
            i++; j++;
        }
        if (res.empty() || res.back() != val)
            res.push_back(val);
    }

    while (i < n1) {
        if (res.empty() || res.back() != arr1[i])
            res.push_back(arr1[i]);
        i++;
    }

    while (j < n2) {
        if (res.empty() || res.back() != arr2[j])
            res.push_back(arr2[j]);
        j++;
    }

    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n1, n2;
    cin >> n1 >> n2;
    vector<int> arr1(n1), arr2(n2);
    for (int i = 0; i < n1; i++) cin >> arr1[i];
    for (int j = 0; j < n2; j++) cin >> arr2[j];

    vector<int> uni = UnionSorted(arr1, arr2);
    for (int x : uni) cout << x << ' ';
    cout << '\n';
    return 0;
}
```

---

## 📈 Complexity Analysis

| Approach               | Time Complexity       | Space Complexity        |
| ---------------------- | --------------------- | ----------------------- |
| **Set (Brute)**        | O((n1+n2)·log(n1+n2)) | O(n1 + n2)              |
| **Two‑Pointer (Opt.)** | **O(n1 + n2)**        | **O(n1 + n2)** (output) |

---

## ✨ Notes & Facts

* **Sorted prerequisite:** The two‑pointer method requires **sorted** inputs.
* **Stable union:** Maintains sorted order and uniqueness.
* **Duplicates within one array:** Also collapsed by the `res.back() != val` check.

---

## ❓ FAQs

1. **Q:** What if the input arrays contain duplicates internally?
   **A:** The `res.back() != val` guard ensures each value appears **once** in the result.

2. **Q:** Can we union more than two arrays?
   **A:** Yes—either iteratively pairwise union, or push all into a `set` (for simplicity).

3. **Q:** How to find the **intersection** instead?
   **A:** Similar two‑pointer scan, but only append when `arr1[i] == arr2[j]`.

4. **Q:** What if arrays are unsorted?
   **A:** Sort them first (O(n log n)), or use a set-based brute approach.

---
