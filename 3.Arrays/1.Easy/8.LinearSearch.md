# 🔍 Linear Search in an Array

---

## 📋 Problem Statement

Given an array **`arr`** of size **`n`** and a target value **`num`**, **find** and **return** the **index** of the **first occurrence** of `num` in `arr`. If `num` is **not found**, return **`-1`**.

---

## 🐢 Brute‑Force (Linear) Search

1. **Scan** the array from **left to right**.
2. **Compare** each element `arr[i]` with `num`.
3. **If** `arr[i] == num`, **return** `i`.
4. **If** the loop ends without a match, **return** `-1`.

```cpp
// O(n) time, O(1) space
int LinearSearch(const vector<int>& arr, int num) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == num)
            return i;
    }
    return -1;  // not found
}
```

> **Characteristics:**
>
> * **Time Complexity:** O(n)
> * **Space Complexity:** O(1)
> * Does **not** require the array to be sorted.

---

## ⚡ When to Use Binary Search Instead

If `arr` is **sorted**, you can achieve **O(log n)** search time with **Binary Search**:

1. Maintain two pointers `low = 0`, `high = n−1`.
2. Compute `mid = (low + high) / 2`.
3. **If** `arr[mid] == num` → return `mid`.
4. **Else if** `arr[mid] < num` → search in `[mid+1...high]`.
5. **Else** → search in `[low...mid−1]`.
6. Repeat until `low > high` → not found.

---

## 📝 Pseudocode for Linear Search

```text
FUNCTION LinearSearch(arr, n, num):
    FOR i FROM 0 TO n−1:
        IF arr[i] == num:
            RETURN i
    RETURN -1
```

---

## 💾 C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Performs a linear search for 'num' in 'arr' of size 'n'.
 * Returns the index of the first match, or -1 if not found.
 */
int Search(const vector<int>& arr, int num) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == num)
            return i;
    }
    return -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, num;
    cin >> n >> num;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    cout << Search(arr, num);
    return 0;
}
```

> **Note:** Passing `arr` as `const vector<int>&` avoids an unnecessary copy.

---

## 📈 Complexity Analysis

| Metric               | Value |
| -------------------- | ----- |
| **Time Complexity**  | O(n)  |
| **Space Complexity** | O(1)  |

---

## ✨ Notes & Facts

* **First Occurrence**: This returns the **earliest** index of `num`.
* **Unsorted Arrays**: Only linear search applies; binary search requires **sorted** data.
* **All Matches**: To collect **all** indices of `num`, maintain a list, scan entire array, and push back every match.
* **Early Exit**: Returns immediately on first match, minimizing comparisons when `num` is near the front.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: What if we need to search multiple queries on the same array?**

> Preprocess into a **hash map** (`value → list of indices`) for **O(1)** (amortized) lookup per query at the cost of O(n) extra space.

---

**Q2: Can linear search be parallelized?**

> Yes, in theory you can split the array across threads, but overhead usually outweighs benefit for small arrays.

---

**Q3: How to search in a 2D matrix?**

> If each row and column is sorted, you can start at top-right corner and “walk” inward in O(n + m) time. Otherwise, treat row-by-row or flatten.

---

**Q4: Is there any better-than-O(n) worst‑case search for unsorted data?**

> No—unsorted data requires O(n) in the worst case, by the **comparison model** lower bound.

---
