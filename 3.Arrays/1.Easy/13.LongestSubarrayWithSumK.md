# 🔍 Longest Subarray with Sum Equals **k** (Sliding Window)

---

## 📋 Problem Statement

Given an array of **positive** integers `nums` of length **`n`** and a target sum **`k`**, find the **maximum length** of a **contiguous** subarray whose elements sum exactly to `k`. If no such subarray exists, return **0**.

---

## 🐢 Brute‑Force Approach (O(n²) Time)

1. **For** each starting index `i` from `0` to `n−1`:

   * Initialize `sum = 0`.
   * **For** each ending index `j` from `i` to `n−1`:

     * `sum += nums[j]`.
     * **If** `sum == k`, update `maxLen = max(maxLen, j−i+1)`.
2. Return `maxLen`.

```cpp
int longestSubarrayBrute(const vector<int>& nums, long long k) {
    int n = nums.size(), maxLen = 0;
    for (int i = 0; i < n; ++i) {
        long long sum = 0;
        for (int j = i; j < n; ++j) {
            sum += nums[j];
            if (sum == k)
                maxLen = max(maxLen, j - i + 1);
            else if (sum > k)
                break;  // early break works since nums are positive
        }
    }
    return maxLen;
}
```

> 🔴 **Drawbacks:**
>
> * Quadratic time still too slow for large `n` (e.g., 10⁵).
> * Even with an early break, worst-case near O(n²).

---

## ⚡ Optimal Sliding‑Window Approach (O(n) Time)

### **Key Insight**

When all array elements are **positive**, you can maintain a **window** `[left…right]` and its **sum**:

* **Expand** the window by moving `right` forward and adding `nums[right]`.
* While **`sum > k`**, **shrink** the window from the left: subtract `nums[left]` and `left++`.
* After each expansion (and any necessary shrink), if **`sum == k`**, update `maxLen`.

This two-pointer technique runs in **O(n)** time and **O(1)** extra space.

---

## 📝 Algorithm

```text
FUNCTION longestSubarray(nums, n, k):
    left ← 0
    right ← 0
    sum ← nums[0]
    maxLen ← 0

    WHILE right < n:
        // Shrink until sum ≤ k
        WHILE left ≤ right AND sum > k:
            sum ← sum − nums[left]
            left ← left + 1

        // Check for sum == k
        IF sum == k:
            maxLen ← max(maxLen, right − left + 1)

        // Expand window
        right ← right + 1
        IF right < n:
            sum ← sum + nums[right]

    RETURN maxLen
```

**Precondition:** All `nums[i]` must be **non-negative** (or positive) for correctness.

---

## 📦 Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the length of the longest contiguous subarray of 'nums'
 * that sums to k. Assumes all nums[i] ≥ 0.
 */
int subArray(const vector<int>& nums, long long k) {
    int n = nums.size();
    int left = 0, right = 0, maxLen = 0;
    long long sum = (n > 0 ? nums[0] : 0);

    while (right < n) {
        // Shrink window while sum exceeds k
        while (left <= right && sum > k) {
            sum -= nums[left];
            ++left;
        }
        // Check for equality
        if (sum == k) {
            maxLen = max(maxLen, right - left + 1);
        }
        // Expand window
        ++right;
        if (right < n) {
            sum += nums[right];
        }
    }
    return maxLen;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    long long k;
    cin >> n >> k;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    cout << subArray(nums, k) << "\n";
    return 0;
}
```

---

## 📈 Complexity Analysis

| Approach              | Time Complexity | Space Complexity |
| --------------------- | --------------- | ---------------- |
| Brute‑Force           | O(n²)           | O(1)             |
| Sliding‑Window (Opt.) | **O(n)**        | **O(1)**         |

* Each element is visited at most twice (once by `right`, once by `left`).
* Only constant extra variables.

---

## ✨ Notes & Facts

* **Only for non-negative arrays:**

  * If the array contains **negatives**, the sliding‑window technique **fails**, and you must use a **hash‑map prefix‑sum** approach (O(n) with O(n) space).

* **Hash‑Map Alternative (handles negatives):**

  1. Build running prefix sum `pref[i]`.
  2. Store earliest index of each prefix sum in a map.
  3. For each `i`, if `(pref[i] - k)` exists, update `maxLen = max(maxLen, i - index[pref[i] - k])`.

* **Edge Cases:**

  * **Empty array** (`n = 0`) → return `0`.
  * **All elements > k** → return `0`.
  * **Sum of entire array == k** → return `n`.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Can we handle negative values?**

> Use a prefix-sum + hash‑map strategy to achieve O(n) time but O(n) space.

---

**Q2: Why does sliding window fail on negatives?**

> Because shrinking the window when `sum > k` may skip valid subarrays if negative numbers reduce the sum later.

---

**Q3: How to find the actual subarray, not just its length?**

> Track the `start` and `end` whenever you update `maxLen`.

---
