# 🗑️ Remove All Occurrences of a Value In‑Place

---

## 📋 Problem Statement

Given a **vector** of integers `nums` and an integer `val`, **remove all instances** of `val` **in‑place** and return the new length `k` of the modified array.
After removal, the first `k` elements of `nums` should contain the remaining values in **any order**. You do **not** need to preserve the original order.

---

## 🐢 Brute‑Force Approach (Shifting)

1. **Scan** the array from left to right.
2. When you encounter `nums[i] == val`, **shift** every subsequent element left by one.
3. **Decrease** the effective length `n` by one, and continue from the same `i`.

```cpp
// O(n²) time in the worst case, O(1) extra space
int removeValBrute(vector<int>& nums, int val) {
    int n = nums.size();
    for (int i = 0; i < n; /* no increment here */) {
        if (nums[i] == val) {
            // shift all elements after i to the left
            for (int j = i + 1; j < n; ++j) {
                nums[j - 1] = nums[j];
            }
            --n;  // reduce array length
        } else {
            ++i; // only advance i if no removal
        }
    }
    return n;
}
```

> **Drawbacks:**
>
> * **O(n²)** in cases where many elements equal `val`.
> * Repeated element moves.

---

## ⚡ Optimal Two‑Pointer (Swap With End)

### **Key Idea**

Use **two pointers**, `i` scanning from the front and `j` from the back:

1. **Initialize**

   * `i = 0` (current index to inspect)
   * `j = nums.size() - 1` (last valid index)

2. **Loop** while `i ≤ j`:

   * If `nums[i] == val`, **swap** it with `nums[j]` and **decrement** `j`.

     * This moves the unwanted value to the end.
     * Do **not** increment `i`—we need to re‑check the swapped‑in element.
   * Else, **increment** `i`.

3. **Return** `i` as the new length (`k`): indices `0…i-1` are free of `val`.

This runs in **O(n)** time and **O(1)** space.

---

## 🔁 Algorithm

```text
FUNCTION removeVal(nums, val):
    i ← 0
    j ← nums.size() − 1

    WHILE i ≤ j:
        IF nums[i] == val:
            nums[i] ← nums[j]    // overwrite
            j ← j − 1            // shrink window from right
        ELSE:
            i ← i + 1            // accept and move on

    RETURN i
```

---

## 💾 C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Removes all occurrences of 'val' from 'nums' in-place.
 * Returns the new length k. The first k elements of nums
 * are the kept values, in any order.
 */
int removeVal(vector<int>& nums, int val) {
    int i = 0, j = (int)nums.size() - 1;
    while (i <= j) {
        if (nums[i] == val) {
            nums[i] = nums[j];
            j--;
        } else {
            i++;
        }
    }
    return i;  // new length
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, val;
    cin >> n >> val;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    int k = removeVal(arr, val);
    cout << k << "\n";
    for (int idx = 0; idx < k; idx++)
        cout << arr[idx] << (idx+1<k ? ' ' : '\n');

    return 0;
}
```

---

## 📈 Complexity Analysis

| Metric               | Value |
| -------------------- | ----- |
| **Time Complexity**  | O(n)  |
| **Space Complexity** | O(1)  |

* **One pass** with at most `n` swaps and checks.
* **No extra** data structures.

---

## ✨ Notes & Facts

* **Order Doesn’t Matter:** Because we swap unwanted elements to the back, the relative order of kept elements may change.
* **Alternate Strategy:** If **order must be preserved**, use the two‑pointer overwrite approach:

  ```cpp
  int i = 0;
  for (int x : nums)
      if (x != val)
          nums[i++] = x;
  return i;
  ```

  * This also runs in O(n) time and O(1) space, but **maintains order**.
* **Edge Cases:**

  * **All elements equal** to `val` → returns `0`.
  * **No element equal** to `val` → returns original length.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Why swap with the end rather than shift?**

> Swapping avoids **O(n)** shifts per removal. Each element is moved at most **once** → overall O(n).

---

**Q2: What if the array is empty?**

> `i = 0`, `j = -1`, the loop never runs → returns `0`.

---

**Q3: Can this be done recursively?**

> Yes, but recursion adds **O(n)** call‑stack overhead. Iteration is simpler and stack‑safe.

---

**Q4: How to remove multiple different values?**

> Extend the condition:

```cpp
if (nums[i] == val1 || nums[i] == val2) { ... }
```

or check membership in a small set.

---
