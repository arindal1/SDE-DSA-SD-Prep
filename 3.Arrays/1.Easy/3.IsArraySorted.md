# ✅ Checking If an Array Is Sorted (Ascending)

---

## 📋 Problem Statement

Given an integer array **`arr`** of size **`n`**, determine whether it is **sorted in non-decreasing order** (each element ≥ the previous). Print `"true"` if sorted, otherwise `"false"`.

---

## 🔍 Brute‑Force Approach

1. **Generate all pairs** `(i, j)` with `i < j`.
2. **Check** for any violation `arr[i] > arr[j]`.
3. If any violation exists → **not** sorted. Otherwise → sorted.

```cpp
// O(n²) time, O(1) space
bool isSortedBrute(const vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if (arr[i] > arr[j])
                return false;
        }
    }
    return true;
}
```

> **Drawbacks:**
>
> * Quadratic time → too slow for large `n`.
> * Wasteful comparisons.

---

## ⚡ Optimal Linear Scan

### **Key Idea**

In a **single pass**, compare each element to its **immediate predecessor**:

1. For `i` from `1` to `n−1`:

   * If `arr[i] < arr[i−1]`, **return false** immediately.
2. If no violation found, **return true** at the end.

This is **O(n)** time and **O(1)** extra space.

---

## 📝 Pseudocode

```text
FUNCTION isArraySorted(arr, n):
    FOR i FROM 1 TO n−1:
        IF arr[i] < arr[i−1]:
            RETURN false
    RETURN true
```

---

## 💾 C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Returns true if arr[0..n-1] is sorted non-decreasingly
bool isArraySorted(const vector<int>& arr, int n) {
    // Edge case: empty or single-element arrays are trivially sorted
    if (n <= 1) return true;

    for (int i = 1; i < n; i++) {
        if (arr[i] < arr[i-1]) {
            return false;
        }
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    cout << (isArraySorted(arr, n) ? "true" : "false");
    return 0;
}
```

---

## 🧩 Dry‑Run Example

| `arr`             | Comparisons                | Result    |
| ----------------- | -------------------------- | --------- |
| `[1, 2, 2, 4, 5]` | 2 ≥ 1, 2 ≥ 2, 4 ≥ 2, 5 ≥ 4 | **true**  |
| `[3, 1, 4, 2]`    | 1 ≥ 3 **fails** at i=1     | **false** |

---

## 📈 Complexity Analysis

| Metric               | Value    |
| -------------------- | -------- |
| **Time Complexity**  | **O(n)** |
| **Space Complexity** | **O(1)** |

* Single traversal of length `n`.
* Constant extra variables.

---

## ✨ Notes & Facts

* **Empty** or **single-element** arrays are considered **sorted** by convention.
* Checks **non-decreasing** order; to enforce **strictly increasing**, use `<=` → `<`.
* Very **cache-friendly** and **branch-predictable**—practical for large arrays.
* If you need to know the **first violation index**, return `i` instead of `false`.

---

## 🛠️ Variations

1. **Recursive Check**:

   ```cpp
   bool isSortedRec(const vector<int>& arr, int i, int n) {
       if (i >= n-1) return true;
       if (arr[i+1] < arr[i]) return false;
       return isSortedRec(arr, i+1, n);
   }
   // Call with isSortedRec(arr, 0, n)
   ```
2. **Check Descending Order**: Flip the comparison to `arr[i] > arr[i-1]`.

---

## ❓ Frequently Asked Questions

**Q1: Can we stop early?**

> Yes—the moment you find `arr[i] < arr[i−1]`, you can return **false** without checking further.

---

**Q2: Is this algorithm stable?**

> *Stability* applies to sorting; here we only *check* order, so the concept doesn’t apply.

---

**Q3: How to handle floating-point arrays?**

> Use the same logic; beware of **precision** issues when comparing.

---

**Q4: Can this be vectorized?**

> Modern CPUs can compare multiple pairs in parallel using SIMD, but the linear scan is already very fast.

---

