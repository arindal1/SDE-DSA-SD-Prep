# üß© Group Anagrams

---

## üìã Problem Statement

Given a list of strings **`strs`**, group the **anagrams** together. An **anagram** is a word formed by rearranging the letters of another, using all original letters exactly once.

> **Example:**
> Input: `["eat","tea","tan","ate","nat","bat"]`
> Output (order of groups or words within a group can vary):
>
> ```
> [
>   ["eat","tea","ate"],
>   ["tan","nat"],
>   ["bat"]
> ]
> ```

---

## üê¢ Brute-Force Approach: Pairwise Comparison (O(n¬≤ ¬∑ m log m))

1. **Initialize** an array `used[n] = {false}` and an empty `result`.
2. For each **i** from `0‚Ä¶n-1`:

   * If `used[i]` continue.
   * Create a new group `[ strs[i] ]`, mark `used[i] = true`.
   * For each **j** from `i+1‚Ä¶n-1`:

     * If `!used[j]` and `isAnagram(strs[i], strs[j])`, append `strs[j]` to group, mark `used[j] = true`.
   * Append group to `result`.

```cpp
bool isAnagram(const string& a, const string& b) {
    if (a.size() != b.size()) return false;
    string sa = a, sb = b;
    sort(sa.begin(), sa.end());
    sort(sb.begin(), sb.end());
    return sa == sb;
}

vector<vector<string>> groupAnagramsBrute(vector<string>& strs) {
    int n = strs.size();
    vector<bool> used(n, false);
    vector<vector<string>> result;
    for (int i = 0; i < n; ++i) {
        if (used[i]) continue;
        vector<string> group = { strs[i] };
        used[i] = true;
        for (int j = i + 1; j < n; ++j) {
            if (!used[j] && isAnagram(strs[i], strs[j])) {
                group.push_back(strs[j]);
                used[j] = true;
            }
        }
        result.push_back(move(group));
    }
    return result;
}
```

* **Time Complexity:** O(n¬≤ ¬∑ m log m) (m = average string length)
* **Space Complexity:** O(n ¬∑ m) for sorting temporary strings
* **Drawbacks:** Slow for large n.

---

## ‚ö° Optimal Hash-Map Approach (O(n ¬∑ m log m))

### **Key Idea**

Two strings are anagrams **iff** their **sorted** forms are identical. Use the sorted string as a **key** in a hash map:

1. **Initialize** an `unordered_map<string, vector<string>> mp`.
2. **For each** string **`s`** in `strs`:

   * Compute `key = s` then `sort(key)`.
   * `mp[key].push_back(s)`.
3. **Collect** all `mp[key]` vectors into the result.

This reduces the pairwise checks to a single pass with sorting per string.

```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> mp;
    mp.reserve(strs.size());
    for (auto& s : strs) {
        string key = s;
        sort(key.begin(), key.end());
        mp[key].push_back(s);
    }
    vector<vector<string>> result;
    result.reserve(mp.size());
    for (auto& kv : mp) {
        result.push_back(move(kv.second));
    }
    return result;
}
```

* **Time Complexity:** O(n ¬∑ m log m)

  * Sorting each string costs O(m log m), done n times.
* **Space Complexity:** O(n ¬∑ m) for storing grouped strings and hash keys.

---

## üìà Complexity Analysis

| Approach                  | Time Complexity | Space Complexity |
| ------------------------- | --------------- | ---------------- |
| Brute-Force (pairwise)    | O(n¬≤ ¬∑ m log m) | O(n¬∑m)           |
| Hash-Map + Sorting (opt.) | O(n ¬∑ m log m)  | O(n¬∑m)           |

* *n* = number of strings, *m* = maximum string length.

Below is a more in-depth walkthrough of the **hash-map + sorting** solution, complete with additional test cases, a detailed dry-run, and explanations of each piece.

---

## High-Level Overview

We want to **group together** all strings that are anagrams of one another. Two strings are anagrams if they contain exactly the same letters (possibly in a different order).

### Core Idea

1. **Normalize** each string by sorting its characters.

   * e.g. `"eat"` ‚Üí `"aet"`, `"tea"` ‚Üí `"aet"`.
2. Use an **unordered map** (`mp`) from this *sorted form* ‚Üí *list of original strings*.
3. At the end, the values of the map are exactly our anagram-groups.

This runs in

$$
O\bigl(\underbrace{n}_{\#\text{strings}}\times\underbrace{m\log m}_{\substack{\text{sorting each}\\\text{string of length }m}}\bigr)
$$

which is efficient for $n\le10^4$, $m\le100$.

---

## Dry-Run on `["eat","tea","tan","ate","nat","bat"]`

| Iteration | `s`     | `key` (sorted) | Map State (`key` ‚Üí list)                         |
| :-------: | :------ | :------------- | :----------------------------------------------- |
|     1     | `"eat"` | `"aet"`        | `{ "aet": ["eat"] }`                             |
|     2     | `"tea"` | `"aet"`        | `{ "aet": ["eat","tea"] }`                       |
|     3     | `"tan"` | `"ant"`        | `{ "aet": [...], "ant": ["tan"] }`               |
|     4     | `"ate"` | `"aet"`        | `{ "aet": ["eat","tea","ate"], "ant": ["tan"] }` |
|     5     | `"nat"` | `"ant"`        | `{ "aet": [...], "ant": ["tan","nat"] }`         |
|     6     | `"bat"` | `"abt"`        | `{ "aet": [...], "ant": [...], "abt": ["bat"] }` |

After the loop, the map has three keys:

* `"aet"` ‚Üí `["eat","tea","ate"]`
* `"ant"` ‚Üí `["tan","nat"]`
* `"abt"` ‚Üí `["bat"]`

We then move each vector into our final `result` array, giving something like:

```cpp
[ ["eat","tea","ate"],
  ["tan","nat"],
  ["bat"] ]
```

(Order within each sub-vector or of the sub-vectors themselves is not guaranteed.)

---

## 4. Additional Test Cases

| Input                             | Output (one possible grouping)           |
| --------------------------------- | ---------------------------------------- |
| `[""]`                            | `[ [""] ]`                               |
| `["a"]`                           | `[ ["a"] ]`                              |
| `["ab","ba","abc","cba","bac"]`   | `[ ["ab","ba"], ["abc","cba","bac"] ]`   |
| `["eat","tea","tan","ate","nat"]` | `[ ["eat","tea","ate"], ["tan","nat"] ]` |

---

## 5. Why This Is Optimal

* **Single pass** through the input array.
* Each string is sorted **once** (O(m log m)).
* Hash-map insertion and lookup average O(1).
* No nested loops over all prior buckets, unlike the brute-force approach.

---

## ‚ú® Notes & Tips

* **Avoid Rehashes:** Use `mp.reserve(strs.size())` to minimize rehashing.
* **Move Semantics:** When collecting results, `move(kv.second)` avoids copying the inner vectors.
* **Alternate Keys:**

  * You can also use a **character‚Äêcount signature** (array of 26 counts) serialized into a string as the key, achieving O(n ¬∑ m) time at the cost of O(26) key construction per string.

---

## ‚ùì Frequently Asked Questions (FAQs)

**Q1: Why sort the string as a key?**

> Sorting normalizes all anagrams to the same representation, letting us group in O(1) hash lookups.

---

**Q2: Can we group without sorting?**

> Yes‚Äîby counting letter frequencies: build a 26-length array `count[26]` per string and serialize it (e.g., `"a1#b0#c2#..."`) as a hash key. Time becomes O(n ¬∑ (m + 26)) ‚âà O(n¬∑m).

---

**Q3: How to ensure order within groups?**

> The problem usually allows any order. If you need lexicographic order, sort each group before returning.

---
