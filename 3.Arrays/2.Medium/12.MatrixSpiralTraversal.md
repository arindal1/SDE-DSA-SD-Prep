# 🔁 Spiral Matrix Traversal – C++ Implementation

---

## 🧩 Problem Statement

Given a `n x m` matrix, print its elements in **spiral order**, starting from the top-left element and proceeding clockwise.

---

## 📥 Input Format

* First line: two integers `n` and `m` (number of rows and columns).
* Next `n` lines: `m` integers each, representing the matrix.

### 🧾 Sample Input

```
3 4
1  2  3  4
5  6  7  8
9 10 11 12
```

### ✅ Expected Output

```
1 2 3 4 8 12 11 10 9 5 6 7
```

---

## ✅ Spiral Order Strategy

To traverse the matrix in a spiral, follow these steps:

### ⏩ Directions of Movement

* Move **left → right** (top row)
* Move **top → bottom** (right column)
* Move **right → left** (bottom row)
* Move **bottom → top** (left column)

### 🎯 Use Boundaries

We maintain four boundary pointers:

* `top`: the first row not yet traversed
* `bottom`: the last row not yet traversed
* `left`: the first column not yet traversed
* `right`: the last column not yet traversed

At every layer of the spiral, we:

1. Traverse from `left` to `right` on `top` row
2. Traverse from `top+1` to `bottom` on `right` column
3. Traverse from `right-1` to `left` on `bottom` row (if `top <= bottom`)
4. Traverse from `bottom-1` to `top+1` on `left` column (if `left <= right`)

Then move the pointers inward and repeat.

---

## 🧠 Time & Space Complexity

| Complexity Type | Value      |                           |
| --------------- | ---------- | ------------------------- |
| **Time**        | `O(n × m)` |                           |
| **Space**       | `O(n × m)` | *(for the result vector)* |

---

## 🧮 Dry Run Example

```
Matrix:
1  2  3  4
5  6  7  8
9 10 11 12

Spiral order:
→  1 2 3 4
↓        8 12
←       11 10 9
↑    5
→    6 7
```

---

## 🔧 Code Walkthrough

```cpp
vector<int> spiralOrder(vector<vector<int>>& matrix, int n, int m) {
    int left = 0, right = m - 1;
    int top = 0, bottom = n - 1;
    vector<int> ans;

    while (top <= bottom && left <= right) {
        // Traverse top row
        for (int i = left; i <= right; i++)
            ans.push_back(matrix[top][i]);
        top++;

        // Traverse right column
        for (int i = top; i <= bottom; i++)
            ans.push_back(matrix[i][right]);
        right--;

        // Traverse bottom row (check needed)
        if (top <= bottom) {
            for (int i = right; i >= left; i--)
                ans.push_back(matrix[bottom][i]);
            bottom--;
        }

        // Traverse left column (check needed)
        if (left <= right) {
            for (int i = bottom; i >= top; i--)
                ans.push_back(matrix[i][left]);
            left++;
        }
    }

    return ans;
}
```

---

## 🚀 Main Function

```cpp
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    if (n <= 0 || m <= 0) {
        cerr << "Invalid matrix size\n";
        return 1;
    }

    vector<vector<int>> matrix(n, vector<int>(m));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> matrix[i][j];

    vector<int> ans = spiralOrder(matrix, n, m);

    for (int num : ans)
        cout << num << " ";
    cout << '\n';

    return 0;
}
```

---

## 📌 Edge Cases

| Case                                | Handled? |
| ----------------------------------- | -------- |
| Empty matrix (`n == 0` or `m == 0`) | ✅        |
| Matrix with 1 row                   | ✅        |
| Matrix with 1 column                | ✅        |
| Square matrix (n == m)              | ✅        |

---

## ❓ FAQs

### Q1: Can I do this without extra space?

**A:** Only if you directly print values instead of storing them in a result vector.

---

### Q2: What happens if matrix is not rectangular?

**A:** As long as each row has `m` elements, it works. Ensure uniform row sizes.

---

### Q3: Can this be done recursively?

**A:** Yes, but it’s more complex. Iterative version is easier and more space-efficient.

---
