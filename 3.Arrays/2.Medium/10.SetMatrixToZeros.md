# ‚úñÔ∏è **Set Matrix Zeroes**

## üìã Problem Statement

Given an **`n √ó m`** matrix, if an element is **0**, set its entire **row** and **column** to **0**. Do this **in-place**, with **constant extra space** (apart from the input matrix).

---

## üîé Example

```text
Input:
[
  [1, 1, 2],
  [3, 0, 5],
  [6, 7, 8]
]
Output:
[
  [1, 0, 2],
  [0, 0, 0],
  [6, 0, 8]
]
```

---

## üê¢ Brute‚ÄëForce Approach: Using Extra Memory (O(n¬∑m) Time, O(n + m) Space)

1. **Allocate** two boolean arrays `zeroRow[n]` and `zeroCol[m]`, initialized to `false`.
2. **Scan** the matrix:

   * Whenever `matrix[i][j] == 0`, set `zeroRow[i] = true` and `zeroCol[j] = true`.
3. **Second pass**: For each cell `(i,j)`, if `zeroRow[i]` **or** `zeroCol[j]` is true, set `matrix[i][j] = 0`.

```cpp
void setZeroesExtra(vector<vector<int>>& A) {
    int n = A.size(), m = A[0].size();
    vector<bool> zeroRow(n, false), zeroCol(m, false);
    // 1) Mark rows and cols
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (A[i][j] == 0) {
                zeroRow[i] = true;
                zeroCol[j] = true;
            }
    // 2) Zero out
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (zeroRow[i] || zeroCol[j])
                A[i][j] = 0;
}
```

* **Time Complexity:** O(n¬∑m)
* **Space Complexity:** O(n + m)

---

## ‚ö° Optimal In-Place Approach (O(n¬∑m) Time, O(1) Space)

### **Key Idea**

Use the **first row** and **first column** of the matrix as the marker arrays, plus one extra variable (`col0`) to track whether the **first column** itself should be zeroed.

1. **First pass** over the matrix:

   * If `matrix[i][j] == 0`, set

     * `matrix[i][0] = 0` ‚Üí mark row *i*,
     * **if** `j > 0` then `matrix[0][j] = 0` ‚Üí mark column *j*,
     * **else** (j == 0) set `col0 = 0` ‚Üí first column needs zero.

2. **Second pass** *in reverse order* (bottom‚Äëright to top‚Äëleft), skipping the first row/column for now:

   * For `(i = n-1‚Ä¶1)` and `(j = m-1‚Ä¶1)`, if `matrix[i][0] == 0 || matrix[0][j] == 0`, set `matrix[i][j] = 0`.

3. **Finally**, handle the **first row** (if `matrix[0][0] == 0`) and **first column** (if `col0 == 0`).

Reversing ensures our markers in row¬†0 and col¬†0 remain intact until used.

---

### üìù Pseudocode

```text
FUNCTION setZeroes(matrix, n, m):
    col0 ‚Üê 1

    // First pass: set markers
    FOR i FROM 0 TO n-1:
        FOR j FROM 0 TO m-1:
            IF matrix[i][j] == 0:
                matrix[i][0] = 0
                IF j > 0:
                    matrix[0][j] = 0
                ELSE:
                    col0 = 0

    // Second pass: apply markers in reverse
    FOR i FROM n-1 DOWNTO 1:
        FOR j FROM m-1 DOWNTO 1:
            IF matrix[i][0] == 0 OR matrix[0][j] == 0:
                matrix[i][j] = 0

    // Handle first row
    IF matrix[0][0] == 0:
        FOR j FROM 0 TO m-1:
            matrix[0][j] = 0

    // Handle first column
    IF col0 == 0:
        FOR i FROM 0 TO n-1:
            matrix[i][0] = 0
```

---

## üíæ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

void setZeroes(vector<vector<int>>& matrix, int n, int m) {
    int col0 = 1;

    // 1) First pass: use first row/col as markers
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;            // mark row i
                if (j > 0)
                    matrix[0][j] = 0;        // mark column j
                else
                    col0 = 0;               // first column needs zero
            }
        }
    }

    // 2) Second pass: apply markers (skip first row/col)
    for (int i = n - 1; i >= 1; i--) {
        for (int j = m - 1; j >= 1; j--) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0)
                matrix[i][j] = 0;
        }
    }

    // 3) Zero out the first row if needed
    if (matrix[0][0] == 0) {
        for (int j = 0; j < m; j++)
            matrix[0][j] = 0;
    }

    // 4) Zero out the first column if needed
    if (col0 == 0) {
        for (int i = 0; i < n; i++)
            matrix[i][0] = 0;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m; 
    cin >> n >> m;
    vector<vector<int>> matrix(n, vector<int>(m));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> matrix[i][j];

    setZeroes(matrix, n, m);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            cout << matrix[i][j] << ' ';
        cout << '\n';
    }
    return 0;
}
```

---

## üìà Complexity Analysis

| Metric               | Value        |
| -------------------- | ------------ |
| **Time Complexity**  | **O(n ¬∑ m)** |
| **Space Complexity** | **O(1)**     |

* Two passes over the matrix.
* Only one extra integer (`col0`) used.

---

## ‚ú® Notes & Tips

* **Why reverse order?** Ensures that we don‚Äôt overwrite markers in the first row/column before using them.
* **`col0` Flag:** Separately tracks whether the **first column** should be zeroed, because `matrix[0][0]` doubles as the first-row marker.
* **Edge Cases:**

  * Single row (`n=1`) or single column (`m=1`) still works correctly.
  * All zeros ‚Üí entire matrix becomes zero.

---

## ‚ùì Frequently Asked Questions (FAQs)

**Q1: Why not use two extra arrays?**

> That‚Äôs the simpler O(n¬†+¬†m) space solution. The in-place approach reduces space to O(1) by reusing the matrix.

---

**Q2: Can we mark with a sentinel value instead of using row/col?**

> You could pick a unique sentinel (e.g., `INT_MIN‚àí1`) if out of input range‚Äîbut then zeroing becomes a two‚Äëstage process and risks conflicts.

---

**Q3: Does the row/column marker scheme generalize?**

> Yes‚Äîto similar ‚Äúset entire row/column‚Äù problems by reusing boundary storage.

---
