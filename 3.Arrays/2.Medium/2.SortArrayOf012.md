# 🌈 Dutch National Flag / Sort Colors

---

## 📋 Problem Statement

Given an array **`arr`** of size **`n`**, where each element is **0**, **1**, or **2**, sort the array **in-place** so that all 0’s come first, then all 1’s, then all 2’s. This is also known as the **Dutch National Flag** problem.

---

## 🐢 Brute-Force Counting Approach (Two Passes)

1. **Count** the number of 0’s, 1’s, and 2’s in one pass.
2. **Overwrite** the array in a second pass: fill with that many 0’s, then 1’s, then 2’s.

```cpp
void sortColorsCount(vector<int>& arr) {
    int n = arr.size();
    int count0 = 0, count1 = 0, count2 = 0;
    for (int x : arr) {
        if (x == 0) count0++;
        else if (x == 1) count1++;
        else count2++;
    }
    int idx = 0;
    while (count0--) arr[idx++] = 0;
    while (count1--) arr[idx++] = 1;
    while (count2--) arr[idx++] = 2;
}
```

* **Time Complexity:** O(n)
* **Space Complexity:** O(1)
* **Drawback:** Two passes and overwrites every element; doesn’t preserve “in-place one-pass” spirit.

---

## ⚡ Optimal One-Pass (Dutch National Flag)

### **Key Idea**

Maintain three pointers:

* `low`   → boundary for 0’s region (everything left of `low` is 0).
* `mid`   → current element under examination.
* `high`  → boundary for 2’s region (everything right of `high` is 2).

Invariant during processing:

```
[0 … low-1]   = all 0’s
[low … mid-1] = all 1’s
[mid … high]  = unknown
[high+1 … n-1]= all 2’s
```

Algorithm:

1. Initialize `low = 0`, `mid = 0`, `high = n−1`.
2. While `mid ≤ high`:

   * **If** `arr[mid] == 0`:

     * `swap(arr[low], arr[mid])`
     * `low++`, `mid++`
   * **Else if** `arr[mid] == 1`:

     * `mid++`
   * **Else** (`arr[mid] == 2`):

     * `swap(arr[mid], arr[high])`
     * `high--`
3. At termination, all 0’s, 1’s, and 2’s are partitioned correctly.

---

## 📝 Algorithm Pseudocode

```text
FUNCTION sortColors(arr, n):
    low ← 0
    mid ← 0
    high ← n − 1

    WHILE mid ≤ high:
        IF arr[mid] == 0:
            swap(arr[low], arr[mid])
            low ← low + 1
            mid ← mid + 1
        ELSE IF arr[mid] == 1:
            mid ← mid + 1
        ELSE:  // arr[mid] == 2
            swap(arr[mid], arr[high])
            high ← high − 1
```

---

## 💾 Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Sorts array 'arr' containing only 0,1,2 in-place.
 */
void SortColors(vector<int>& arr) {
    int n = arr.size();
    int low = 0, mid = 0, high = n - 1;

    while (mid <= high) {
        if (arr[mid] == 0) {
            swap(arr[low], arr[mid]);
            low++; mid++;
        } else if (arr[mid] == 1) {
            mid++;
        } else {
            swap(arr[mid], arr[high]);
            high--;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    SortColors(arr);

    for (int x : arr) {
        cout << x << " ";
    }
    cout << "\n";
    return 0;
}
```

---

## 📈 Complexity Analysis

| Approach                   | Time Complexity | Space Complexity |
| -------------------------- | --------------- | ---------------- |
| Counting (two-pass)        | O(n)            | O(1)             |
| Dutch National Flag (opt.) | **O(n)**        | **O(1)**         |

* **One pass** over the array, each element is swapped at most once.

---

## ✨ Notes & Facts

* **In-Place & One-Pass:** Achieves sorting without extra arrays or multiple scans.
* **Stable?** Not stable for equal elements, but stability isn’t required when sorting colors.
* **Generalization:** The Dutch National Flag technique extends to three-way partitioning problems by pivot.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Why does the swap in the `2` case not increment `mid`?**

> Because the element swapped from `high` into `mid` is unprocessed—it might be 0, 1, or 2—so we re-examine `arr[mid]`.

---

**Q2: Can this handle other three-category sorting tasks?**

> Yes—for any problem where you partition into three regions based on a “color” or category.

---

**Q3: What if the input isn’t guaranteed to have only 0,1,2?**

> You would first validate or filter; the algorithm assumes only three distinct values.

---
