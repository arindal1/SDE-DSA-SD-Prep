# 🛥️ Boats to Save People


## 📄 Problem Statement

You are given an array `people` where `people[i]` is the weight of the *i*th person, and an integer `limit` representing the maximum weight each boat can carry. Each boat can carry at most **two** people at the same time, provided the sum of their weights is at most `limit`. Return the **minimum number of boats** to carry every given person.

* **Input:**

  * `n`: number of people
  * `people`: array of `n` positive integers
  * `limit`: maximum weight capacity per boat
* **Output:**

  * Minimum number of boats needed

---

## 💡 Intuition

* To minimize boats, pair the **lightest** person with the **heaviest** possible partner.
* Sort the array so you can use a **two-pointer** approach:

  1. `left` at the **lightest** end (`0`), `right` at the **heaviest** end (`n-1`).
  2. If `people[left] + people[right] ≤ limit`, they share a boat → `left++`, `right--`.
  3. Otherwise the heaviest goes alone → `right--`.
  4. In either case, increment the boat count.

This greedy strategy ensures you never “waste” capacity that could have fit the lightest person.

---

## 🐢 Brute‑Force Approach

Try all possible pairings (exponential) or use a frequency map and combinatorially match light with heavy, but both are **inefficient** for large `n`.

```cpp
// Conceptual only — too slow for n up to 10^5
int numRescueBoatsBrute(vector<int>& people, int limit) {
    int n = people.size(), ans = INT_MAX;
    // Try all subsets of pairs via backtracking, tracking min boats…
    return ans;
}
```

* **Time Complexity:** exponential
* **Space Complexity:** exponential

> ❌ Not feasible for n ≥ 10⁴.

---

## 🚀 Optimal Two‑Pointer Greedy Approach

```cpp
int numRescueBoats(vector<int>& people, int limit) {
    sort(people.begin(), people.end());
    int left = 0, right = people.size() - 1, boats = 0;
    while (left <= right) {
        if (people[left] + people[right] <= limit) {
            left++;
            right--;
        } else {
            right--;
        }
        boats++;
    }
    return boats;
}
```

### Steps

1. **Sort** `people` in non-decreasing order.
2. **Initialize** two pointers:

   * `left = 0`
   * `right = n - 1`
3. **While** `left ≤ right`:

   * If the lightest (`people[left]`) can pair with the heaviest (`people[right]`), move **both** pointers inward.
   * Otherwise, the heaviest goes alone: move `right--`.
   * In all cases, one **boat** is used (`boats++`).
4. **Return** `boats`.

This runs in **O(n log n)** due to sorting and **O(n)** for the two-pointer sweep.

---

## ✏️ Full Corrected Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;


int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(), people.end());
        int left = 0, right = people.size() - 1, boats = 0;
        while (left <= right) {
            if (people[left] + people[right] <= limit) {
                left++;
                right--;
            } else {
                right--;
            }
            boats++;
        }
        return boats;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, limit;
    cin >> n >> limit;
    vector<int> people(n);
    for (int i = 0; i < n; i++) {
        cin >> people[i];
    }

    Solution sol;
    cout << sol.numRescueBoats(people, limit) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase             | Time Complexity | Space Complexity |
| ----------------- | --------------- | ---------------- |
| Sorting           | *O(n log n)*    | *O(1)*\*         |
| Two-pointer sweep | *O(n)*          | *O(1)*           |
| **Overall**       | **O(n log n)**  | **O(1)**         |

> *\* Sorting in C++ may use O(log n) stack space.*

---

## ✅ Test Cases

| `people`    | `limit` | Output | Explanation                            |
| ----------- | ------- | ------ | -------------------------------------- |
| `[3,2,2,1]` | `3`     | `3`    | Boats: (1,2), (2), (3)                 |
| `[3,5,3,4]` | `5`     | `4`    | Each heavy person except (3,2) pairing |
| `[1,2]`     | `3`     | `1`    | Both fit in one boat                   |
| `[1,1,1,1]` | `2`     | `2`    | Two boats: each carries (1,1)          |
| `[5,1,4,2]` | `6`     | `2`    | Boats: (1,5), (2,4)                    |

---

## 🎯 Tips & Tricks

* **Always sort** when you need to match smallest with largest under a constraint.
* Two‑pointer patterns often solve “pairing” problems in **O(n)** post-sort.
* Swapping pointers inward avoids extra memory usage.

---

## 🔄 Variations

1. **Unlimited people per boat** with sum constraint: use sliding window or deque.
2. **Different boat capacities**: assign people to variable‑capacity boats via greedy.
3. **K boats available**: maximize the number of people saved.

---

## ❓ FAQs

> **Q1. Why not use a multiset or priority queue?** <br>
> Sorting + two pointers is simpler and faster in practice.

> **Q2. Can we pair more than two people per boat?** <br>
> This problem restricts to at most two; generalizing requires knapsack‑like methods.

> **Q3. What about odd number of people?** <br>
> The last person always takes a boat alone if no valid partner remains.

> **Q4. Is the sort stable?** <br>
> Stability isn’t required since only weights matter, not original indices.

---

