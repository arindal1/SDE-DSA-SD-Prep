# üíπ Best Time to Buy and Sell Stock (Max Profit)

---

## üìã Problem Statement

Given an array **`prices`** of length **`n`**, where `prices[i]` is the price of a stock on day `i`, find the **maximum profit** you can achieve by buying on one day and selling on a later day. If no profit is possible, return **0**.

---

## üê¢ Brute-Force Approach (O(n¬≤) Time)

1. **Iterate** over all possible **buy** days `i` from `0‚Ä¶n‚àí2`.
2. For each, **iterate** over all **sell** days `j` from `i+1‚Ä¶n‚àí1`.
3. **Compute** profit `prices[j] ‚àí prices[i]` and track the **maximum**.

```cpp
// O(n¬≤) time, O(1) extra space
int maxProfitBrute(const vector<int>& prices) {
    int n = prices.size();
    int best = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            best = max(best, prices[j] - prices[i]);
        }
    }
    return best;
}
```

> **Drawbacks:**
>
> * Quadratic time is too slow for large `n` (e.g., n up to 10‚Åµ).

---

## ‚ö° Optimal One-Pass Approach (O(n) Time, O(1) Space)

### **Key Idea**

As we scan once through the array, keep track of:

* **`minPrice`** = the **lowest** price seen so far (best buy price).
* **`maxProfit`** = the **highest** profit achievable up to the current day.

For each price `p = prices[i]`:

1. **Potential profit** if sold today: `p ‚àí minPrice`.
2. **Update** `maxProfit = max(maxProfit, p ‚àí minPrice)`.
3. **Update** `minPrice = min(minPrice, p)` for future days.

This ensures we always buy at the best past price and sell at the optimal moment.

---

## üìù Algorithm Pseudocode

```text
FUNCTION MaxProfit(prices, n):
    IF n < 2:
        RETURN 0

    minPrice  ‚Üê prices[0]
    maxProfit ‚Üê 0

    FOR i FROM 1 TO n‚àí1:
        // 1) Compute profit if sold today
        profit ‚Üê prices[i] ‚àí minPrice
        // 2) Update best profit so far
        IF profit > maxProfit:
            maxProfit ‚Üê profit
        // 3) Update best buy price so far
        IF prices[i] < minPrice:
            minPrice ‚Üê prices[i]

    RETURN maxProfit
```

---

## üíæ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the maximum profit from a single buy-sell transaction.
 * Traverses prices in one pass, tracking the minimum price so far
 * and the maximum profit achievable.
 */
int MaxProfit(const vector<int>& prices) {
    int n = prices.size();
    if (n < 2) return 0;

    int minPrice  = prices[0];
    int maxProfit = 0;

    for (int i = 1; i < n; ++i) {
        int profit = prices[i] - minPrice;
        maxProfit = max(maxProfit, profit);
        minPrice  = min(minPrice, prices[i]);
    }
    return maxProfit;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> prices(n);
    for (int i = 0; i < n; i++) {
        cin >> prices[i];
    }

    cout << MaxProfit(prices) << "\n";
    return 0;
}
```

---

## üìà Complexity Analysis

| Metric               | Value    |
| -------------------- | -------- |
| **Time Complexity**  | **O(n)** |
| **Space Complexity** | **O(1)** |

* **Single pass** over the array.
* Only two extra variables (`minPrice`, `maxProfit`).

---

## ‚ú® Notes & Facts

* **No Transaction**: If prices always **decrease**, `maxProfit` remains **0**, matching ‚Äúno profit‚Äù.
* **Single Transaction**: Only one buy and one sell allowed.
* **Edge Cases:**

  * **`n = 0` or `1`** ‚Üí return `0`.
  * **All equal prices** ‚Üí profit `0`.
* **Generalizations:**

  * **Multiple transactions** allowed ‚Üí use dynamic programming or greedy for unlimited transactions.
  * **Transaction fee**, **cooldown**, and **at most k transactions** are common variants.

---

## ‚ùì Frequently Asked Questions

**Q1: Why update `minPrice` after computing profit?**

> Ensures you compare current price against the best buy price **up to** the previous day.

---

**Q2: Can we do better than O(n)?**

> No‚Äîa single pass is optimal. Lower bound ‚Ñ¶(n) for one transaction.

---

**Q3: How to handle multiple buy-sell transactions?**

> For unlimited trades, sum all positive `prices[i] ‚àí prices[i‚àí1]`.
> For at most k trades, use DP with states.

---
