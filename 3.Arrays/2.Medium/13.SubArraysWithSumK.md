# 🪻 **Count of Subarrays with Sum = k**

## 📋 Problem Statement

Given an integer array **`arr`** of length **`n`** and an integer **`k`**, count the number of **contiguous subarrays** whose sum equals **`k`**.

> **Example:**
> Input: `arr = [1, 2, 3, -1, 2]`, `k = 3`
> Subarrays summing to 3: `[1,2]`, `[3]`, `[3,-1,2]` → **3** total.

---

## 🚀 Brute‑Force Approach (O(n²) Time)

1. **For** each start index `i` from `0…n−1`:

   * Initialize `sum = 0`.
   * **For** each end index `j` from `i…n−1`:

     * `sum += arr[j]`.
     * **If** `sum == k`, **increment** count.

```cpp
int countSubarraysBrute(const vector<int>& arr, int k) {
    int n = arr.size(), cnt = 0;
    for (int i = 0; i < n; ++i) {
        int sum = 0;
        for (int j = i; j < n; ++j) {
            sum += arr[j];
            if (sum == k)
                cnt++;
        }
    }
    return cnt;
}
```

* **Time Complexity:** O(n²)
* **Space Complexity:** O(1)

> 🔴 *Too slow when n ≈ 10⁵.*

---

## ⚡ Optimal Prefix‐Sum + Hash Map (O(n) Time)

### **Key Insight**

Define **prefix sum** up to index `i` as

$$
\text{pre}[i] = \sum_{t=0}^{i} arr[t].
$$

A subarray `(j+1…i)` sums to `k` exactly when

$$
\text{pre}[i] - \text{pre}[j] = k  
\quad\Longleftrightarrow\quad
\text{pre}[j] = \text{pre}[i] - k.
$$

As we iterate `i` from `0…n−1`, we keep a **map** of how many times each prefix‐sum has occurred (`mpp[prefix]`). At step `i`:

1. Compute `preSum += arr[i]`.
2. Let `need = preSum - k`.
3. **Add** `mpp[need]` to the answer (those earlier prefixes that form sum `k`).
4. **Increment** `mpp[preSum]++` for future subarrays.

Initialize `mpp[0] = 1` so that a prefix itself equal to `k` (i.e. `preSum == k`) is counted.

---

## 📝 Algorithm Pseudocode

```text
FUNCTION countSubarraysWithSumK(arr, n, k):
    mpp ← empty map from int→int
    mpp[0] = 1         // one way to have sum 0 before start
    preSum ← 0
    count  ← 0

    FOR i FROM 0 TO n−1:
        preSum ← preSum + arr[i]
        need   ← preSum − k
        IF need IN mpp:
            count ← count + mpp[need]
        mpp[preSum] ← mpp[preSum] + 1

    RETURN count
```

---

## 💾 Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the number of contiguous subarrays summing to k.
 * Uses a hash map of prefix sums for O(n) time.
 */
int countSubarraysWithSumK(const vector<int>& arr, int k) {
    unordered_map<long long,int> mpp;
    mpp.reserve(arr.size());
    mpp[0] = 1;                // one prefix-sum zero before starting

    long long preSum = 0;
    int count = 0;

    for (int x : arr) {
        preSum += x;          
        long long need = preSum - k;
        auto it = mpp.find(need);
        if (it != mpp.end()) {
            count += it->second;
        }
        mpp[preSum]++;        // record this prefix for future
    }
    return count;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    cin >> n >> k;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    cout << countSubarraysWithSumK(arr, k) << "\n";
    return 0;
}
```

---

## 📈 Complexity Analysis

| Metric               | Value                         |
| -------------------- | ----------------------------- |
| **Time Complexity**  | **O(n)** (average)            |
| **Space Complexity** | **O(n)** (map of prefix sums) |

* Each element processed once.
* Hash‐map operations are O(1) on average.

---

## ✨ Notes & Extensions

* Works for **negative** and **positive** values.
* If **all** elements are non-negative, a two-pointer sliding window might suffice, but this general method handles arbitrary signs.
* Can be adapted to count subarrays with sum **≤ k** or **divisible** by k with slight modifications.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Why initialize `mpp[0] = 1`?**

> It accounts for subarrays that **start** at index 0 and sum exactly to `k`.

---

**Q2: What if `k = 0`?**

> The same logic counts zero‐sum subarrays.

---

**Q3: Can we use `map` instead of `unordered_map`?**

> Yes, but `map` is O(log n) per operation, making overall O(n log n).

---
