# 🔀 Merge Sorted Array


## 📄 Problem Statement

Given two **sorted** integer arrays, `nums1` of size `m + n` (with the first `m` elements initialized) and `nums2` of size `n`, **merge** `nums2` into `nums1` in-place so that `nums1` becomes one sorted array of size `m + n`.

* **Inputs:**

  * `nums1`: vector<int> of length `m + n`, where only the first `m` elements are valid sorted values and the rest are placeholders (e.g. zeros).
  * `m`: the number of valid elements in `nums1`.
  * `nums2`: vector<int> of length `n`, sorted.
  * `n`: the number of elements in `nums2`.
* **Output:**

  * `nums1` modified in-place to be the fully merged sorted array.

---

## 💡 Intuition

* We need to merge **without** extra storage beyond the input arrays.
* Since both are sorted, the **largest** elements are at the **ends**.
* We can fill `nums1` from **back to front**:

  1. Maintain three pointers:

     * `i = m-1` (end of valid part of `nums1`)
     * `j = n-1` (end of `nums2`)
     * `k = m + n - 1` (end of `nums1` buffer)
  2. Compare `nums1[i]` and `nums2[j]`. Place the **larger** at `nums1[k]`, then decrement that pointer and `k`.
  3. Once one array is exhausted, copy any remaining elements from the other (only `nums2` can have leftovers).

---

## 🐢 Brute‑Force Approach

1. **Copy** all valid `m` elements of `nums1` to a temporary array `tmp`.
2. **Append** all `n` elements of `nums2` to `tmp`.
3. **Sort** `tmp`.
4. **Copy** back into `nums1`.

```cpp
void mergeBrute(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    vector<int> tmp;
    tmp.reserve(m + n);
    for (int i = 0; i < m; ++i) tmp.push_back(nums1[i]);
    for (int j = 0; j < n; ++j) tmp.push_back(nums2[j]);
    sort(tmp.begin(), tmp.end());
    for (int k = 0; k < m + n; ++k) nums1[k] = tmp[k];
}
```

* **Time:** *O((m+n) log(m+n))*
* **Space:** *O(m+n)*

> ❌ Violates “in-place” constraint by using extra *O(m+n)* storage.

---

## 🚀 Optimal In‑Place Two‑Pointer Approach

```cpp
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i = m - 1;          // last valid in nums1
    int j = n - 1;          // last in nums2
    int k = m + n - 1;      // write position in nums1

    // Merge from back to front
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];
        } else {
            nums1[k--] = nums2[j--];
        }
    }
    // If nums2 still has elements, copy them
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}
```

* **Why it works:**
  We always write the largest remaining element into the free slot at the end of `nums1`, ensuring we never overwrite unprocessed data.

---

## ✅ Test Cases

| nums1 (m valid)      | nums2          | Output nums1    |
| -------------------- | -------------- | --------------- |
| `[1,2,3,0,0,0]`, m=3 | `[2,5,6]`, n=3 | `[1,2,2,3,5,6]` |
| `[4,5,6,0,0,0]`, m=3 | `[1,2,3]`, n=3 | `[1,2,3,4,5,6]` |
| `[1]`, m=1           | `[]`, n=0      | `[1]`           |
| `[0]`, m=0           | `[1]`, n=1     | `[1]`           |
| `[2,0]`, m=1         | `[1]`, n=1     | `[1,2]`         |

---

## ✏️ Full Corrected Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Merges nums2 into nums1 in-place.
 */
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i = m - 1;
    int j = n - 1;
    int k = m + n - 1;

    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];
        } else {
            nums1[k--] = nums2[j--];
        }
    }
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int m, n;
    cin >> m >> n;
    vector<int> nums1(m + n), nums2(n);

    // Read first m elements of nums1
    for (int i = 0; i < m; ++i) {
        cin >> nums1[i];
    }
    // The remaining n slots are assumed unused (could be zero or any placeholder)
    // Read nums2
    for (int j = 0; j < n; ++j) {
        cin >> nums2[j];
    }

    merge(nums1, m, nums2, n);

    // Output merged nums1
    for (int x : nums1) {
        cout << x << " ";
    }
    cout << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Step                   | Time Complexity | Space Complexity |
| ---------------------- | --------------- | ---------------- |
| Two-pointer merge loop | *O(m + n)*      | *O(1)*           |
| **Overall**            | **O(m + n)**    | **O(1)**         |

---

## 🎯 Tips & Tricks

* 🖊️ **Back‑to‑front** merging prevents overwriting unprocessed elements.
* 🔢 Always check edge-cases: one array empty, all elements of one smaller than the other.
* 📚 In C++, you can also use `std::inplace_merge` but it may not meet the exact in-place memory guarantees.

---

## 🔄 Variations

1. **K-way Merge**: Merge `k` sorted arrays using a min‑heap in *O(N log k)* time.
2. **Merge without placeholders**: Allocate a new array of size `m+n` and merge forward.
3. **Linked-List Merge**: Similar logic for merging two sorted linked lists in-place.

---

## ❓ FAQs

> **Q1. Why merge from the back?**
> So we don’t overwrite the unmerged elements in `nums1`—we always write into the unused tail space.

> **Q2. What if nums1’s extra slots aren’t zero?**
> They’re placeholders; their initial value doesn’t matter since we overwrite them all.

> **Q3. Can I use STL?**
> You could use `merge` into a new vector, but that uses extra space.

> **Q4. What about descending order?**
> Reverse the comparison (`<` vs `>`) and adjust pointers accordingly.

---

✨ *Happy merging!* 🚀
