# 📏 Partition Labels


## 📄 Problem Statement

You are given a string `s` consisting of lowercase English letters. A **partition** of `s` is a division into contiguous substrings such that each letter appears in **at most one** substring. Return a list of integers representing the **sizes** of these substrings in the order they appear.

* **Input:**

  * A single string `s` (length `n`, `1 ≤ n ≤ 10⁵`).
* **Output:**

  * A vector of integers, where each integer is the size of one partition.

---

## 💡 Intuition

* We want to split `s` into as many parts as possible, but each character can **only** appear in **one** part.
* Key idea: for each character, know its **last index** in the string.
* As we scan left to right, maintain a **current partition end** (`end`) which is the farthest last-occurrence of any character seen so far.
* Once our iteration index `i` **reaches** `end`, we can safely cut a partition—no future occurrences of the characters in this partition remain.

---

## 🐢 Brute‑Force Approach

Try all possible partition points and check validity:

1. For each index `i`, assume a cut there.
2. Ensure that no character in the left segment appears **after** `i`.
3. Recursively partition the remainder.

```cpp
// Conceptual only—exponential in worst-case
vector<int> brutePartition(string s) {
    int n = s.size();
    vector<int> ans;
    function<bool(int,int)> validCut = [&](int l, int r) {
        set<char> st(s.begin()+l, s.begin()+r+1);
        for (char c : st) {
            for (int j = r+1; j < n; ++j)
                if (s[j] == c) return false;
        }
        return true;
    };
    function<void(int)> dfs = [&](int start) {
        if (start >= n) return;
        for (int cut = start; cut < n; ++cut) {
            if (validCut(start, cut)) {
                ans.push_back(cut - start + 1);
                dfs(cut + 1);
                return;  // take the earliest valid cut
            }
        }
    };
    dfs(0);
    return ans;
}
```

* **Time Complexity:** exponential (checking validity for each cut).
* **Space Complexity:** exponential (recursion & sets).

> ❌ Not feasible for `n` up to 10⁵.

---

## 🚀 Optimal One‑Pass Approach

1. **Precompute** the **last occurrence** of each character:

   ```cpp
   vector<int> last(26);
   for (int i = 0; i < n; ++i)
     last[s[i] - 'a'] = i;
   ```
2. **Iterate** the string with two pointers:

   * `start = 0` (begin of current partition)
   * `end = 0`   (current max last-occurrence within the partition)
3. At index `i`, update `end = max(end, last[s[i] - 'a'])`.
4. If `i == end`, we found a partition `[start…end]`:

   * Append `end - start + 1` to the result.
   * Set `start = i + 1` for the next partition.

```cpp
vector<int> partitionLabels(string s) {
    int n = s.size();
    vector<int> last(26, 0);
    for (int i = 0; i < n; ++i)
        last[s[i] - 'a'] = i;

    vector<int> res;
    int start = 0, end = 0;
    for (int i = 0; i < n; ++i) {
        end = max(end, last[s[i] - 'a']);
        if (i == end) {
            res.push_back(end - start + 1);
            start = i + 1;
        }
    }
    return res;
}
```

* **Time Complexity:** *O(n)* (single pass + precompute)
* **Space Complexity:** *O(1)* (array of size 26 + output list)

---

## ✅ Test Cases

| `s`                          | Output          | Explanation                                                    |
| ---------------------------- | --------------- | -------------------------------------------------------------- |
| `"ababcbacadefegdehijhklij"` | `[9,7,8]`       | Partitions: `"ababcbaca"`, `"defegde"`, `"hijhklij"`           |
| `"eccbbbbdec"`               | `[10]`          | All letters interleave → one big partition                     |
| `"qwerty"`                   | `[1,1,1,1,1,1]` | All unique → each char in its own partition                    |
| `"aaabbbccc"`                | `[9]`           | Repeats blockwise, but last occurrences at end → one partition |
| `"abac"`                     | `[3,1]`         | `"aba"`, `"c"`                                                 |

---

## ✏️ Full Corrected Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;


vector<int> partitionLabels(const string& s) {
    int n = s.size();
    vector<int> last(26, 0);
    for (int i = 0; i < n; ++i)
        last[s[i] - 'a'] = i;

    vector<int> res;
    int start = 0, end = 0;
    for (int i = 0; i < n; ++i) {
        end = max(end, last[s[i] - 'a']);
        if (i == end) {
            res.push_back(end - start + 1);
            start = i + 1;
        }
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s);  // read the input string, may contain no spaces

    vector<int> result = partitionLabels(s);
    for (int len : result) {
        cout << len << " ";
    }
    cout << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                    | Time Complexity | Space Complexity                   |
| ------------------------ | --------------- | ---------------------------------- |
| Precompute last indices  | *O(n)*          | *O(1)*                             |
| Single pass to partition | *O(n)*          | *O(1)*                             |
| **Overall**              | **O(n)**        | **O(1)** (extra) + **O(k)** output |

---

## 🎯 Tips & Tricks

* 🔍 Precomputing **last occurrences** reduces repeated scans.
* 📌 Track only the **farthest reach** (`end`) to decide cuts.
* ✨ No nested loops → linear time guaranteed.

---

## 🔄 Variations

1. **General Alphabet:** Extend to Unicode by using a hashmap instead of a fixed-size array.
2. **Merge Adjacent Partitions:** Post-process to combine small partitions under a size threshold.
3. **Minimize Number of Partitions:** Equivalent—maximizes cuts greedily under the same rule.

---

## ❓ FAQs

> **Q1. What if `s` is empty?** <br>
> Return an empty vector (`[]`).

> **Q2. Can partitions be of size 0?** <br>
> No—each partition has at least one character.

> **Q3. Why is space *O(1)*?** <br>
> `last` uses fixed size 26, independent of `n`. The result list is output space.

> **Q4. Is this always the maximum number of partitions?** <br>
> Yes—the greedy cut at the earliest `end` maximizes the number of pieces.

---
