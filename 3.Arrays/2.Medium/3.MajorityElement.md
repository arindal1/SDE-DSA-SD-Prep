# üó≥Ô∏è Finding the Majority Element (Boyer‚ÄìMoore Voting)

---

## üìã Problem Statement

Given an array **`arr`** of size **`n`**, a **majority element** is the element that appears **more than** ‚åän/2‚åã times. Implement a function to **find** this element, or return **`-1`** if no majority exists.

---

## üê¢ Brute-Force Approaches

### 1Ô∏è‚É£ Sorting

1. **Sort** the array (O(n log n)).
2. **Check** the middle element `arr[n/2]`; if it truly appears > n/2 times, it‚Äôs the majority.

```cpp
int majorityBySort(vector<int> arr) {
    sort(arr.begin(), arr.end());             // O(n‚Äâlog‚Äân)
    int candidate = arr[arr.size()/2];
    int count = 0;
    for (int x : arr)
        if (x == candidate) ++count;
    return (count > arr.size()/2) ? candidate : -1;
}
```

* **Time:** O(n log n)
* **Space:** O(1) (in-place sort) or O(n) if copying

### 2Ô∏è‚É£ Hash‚ÄêMap Counting

1. Traverse and **count frequencies** in an `unordered_map<int,int>`.
2. **Scan** entries to find any with count > n/2.

```cpp
int majorityByHash(const vector<int>& arr) {
    unordered_map<int,int> freq;
    for (int x : arr) {
        if (++freq[x] > arr.size()/2)
            return x;
    }
    return -1;
}
```

* **Time:** O(n) average
* **Space:** O(n) extra

---

## ‚ö° Optimal Boyer‚ÄìMoore Voting Algorithm

### **Key Insight**

If a majority element **exists**, it will **survive** a process of **pairwise cancellation**:

1. **Candidate Selection** (first pass):

   * Maintain a **counter** `count = 0` and a **candidate** `el`.
   * For each `x` in `arr`:

     * If `count == 0`, set `el = x` and `count = 1`.
     * Else if `x == el`, increment `count`.
     * Else decrement `count`.
   * After one pass, `el` is the **potential** majority.

2. **Verification** (second pass):

   * Count occurrences of `el` in `arr`.
   * If `count > n/2`, **return** `el`; otherwise **return** `-1`.

This runs in **O(n)** time and **O(1)** space.

---

## üìù Algorithm Pseudocode

```text
FUNCTION MajorityElement(arr, n):
    // 1. Find candidate
    el = 0
    count = 0
    FOR i = 0 to n-1:
        IF count == 0:
            el = arr[i]
            count = 1
        ELSE IF arr[i] == el:
            count = count + 1
        ELSE:
            count = count - 1

    // 2. Verify candidate
    occurrences = 0
    FOR x IN arr:
        IF x == el:
            occurrences = occurrences + 1

    IF occurrences > n/2:
        RETURN el
    ELSE:
        RETURN -1
```

---

## üíæ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Finds and returns the majority element (> n/2 occurrences),
 * or -1 if none exists, using Boyer‚ÄìMoore Voting.
 */
int MajorityElement(const vector<int>& arr) {
    int n = arr.size();
    int el = 0, count = 0;

    // 1) Candidate selection
    for (int x : arr) {
        if (count == 0) {
            el = x;
            count = 1;
        } else if (x == el) {
            ++count;
        } else {
            --count;
        }
    }

    // 2) Verification
    int occurrences = 0;
    for (int x : arr) {
        if (x == el) ++occurrences;
    }
    return (occurrences > n/2) ? el : -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    cout << MajorityElement(arr) << "\n";
    return 0;
}
```

---

## üìà Complexity Analysis

| Approach                         | Time Complexity | Space Complexity |
| -------------------------------- | --------------- | ---------------- |
| **Sorting**                      | O(n log n)      | O(1)/O(n)        |
| **Hash‚ÄêMap Counting**            | O(n) average    | O(n)             |
| **Boyer‚ÄìMoore Voting (optimal)** | **O(n)**        | **O(1)**         |

---

## ‚ú® Notes & Facts

* **Single Majority Guarantee:** If guaranteed that a majority exists, the *verification* pass can be omitted.
* **Extension:** For finding elements appearing > n/3 times, a generalized Boyer‚ÄìMoore (Boyer‚ÄìMoore majority vote II) tracks **two** candidates.
* **Edge Cases:**

  * **Empty array** ‚Üí returns `-1`.
  * **All distinct** ‚Üí no majority, returns `-1`.

---

## ‚ùì Frequently Asked Questions

**Q1: Why does Boyer‚ÄìMoore work?**

> Pairwise cancellation ensures that if one element appears more than all others combined, it cannot be fully canceled out.

---

**Q2: Can we stream data?**

> Yes‚Äîthe algorithm processes elements one by one, making it suitable for streaming/online settings.

---

**Q3: What if no majority exists?**

> The algorithm still yields a candidate, so a second pass is **mandatory** to verify in that case.

---
