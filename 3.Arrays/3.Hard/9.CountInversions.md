# ğŸš‚ Count Inversions

## ğŸ“„ Problem Statement

> **Count the number of inversions** in an array.
> An **inversion** is a pair of indices `(i, j)` such that `i < j` and `arr[i] > arr[j]`.
> Given an array `a` of size `n`, return the total inversion count.

### ğŸ” Example

```text
Input:  a = [2, 4, 1, 3, 5]
Output: 3

Inversions are:
  (2,1), (4,1), (4,3)
```

---

## ğŸ’¡ Intuition

* Every time a **larger** element appears **before** a **smaller** one, thatâ€™s an inversion.
* Naively checking all pairs is *O(nÂ²)*, too slow for large `n`.
* **Mergeâ€‘Sort** can count â€œcrossâ€‘inversionsâ€ while merging two sorted halves in *O(nâ€¯logâ€¯n)*.

---

## ğŸ¢ Bruteâ€‘Force Approach

```cpp
long long countInversionsBrute(vector<int>& a) {
    int n = a.size();
    long long cnt = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if (a[i] > a[j])
                ++cnt;
        }
    }
    return cnt;
}
```

* **Time Complexity:** *O(nÂ²)*
* **Space Complexity:** *O(1)*

> âš ï¸ Too slow once `n` > 10âµ.

---

## ğŸš€ Optimal Approach: Mergeâ€‘Sort with Inversion Count

1. **Divide** the array into two halves.
2. **Recursively** count inversions in each half.
3. **Merge** sorted halves, and while merging:

   * Whenever you take an element from the **right** half (say `arr[j]`) because `arr[j] < arr[i]` from the left, you add `(mid â€“ i + 1)` to the inversion count (all remaining left elements are > `arr[j]`).

### ğŸ”„ Merge Function with Count

```cpp
int merge(vector<int>& arr, int low, int mid, int high) {
    vector<int> temp;
    int left = low, right = mid + 1;
    int cnt = 0;

    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {
            temp.push_back(arr[left++]);
        } else {
            temp.push_back(arr[right++]);
            cnt += (mid - left + 1);  // All arr[left..mid] > arr[right-1]
        }
    }
    // Append leftovers
    while (left <= mid)  temp.push_back(arr[left++]);
    while (right <= high) temp.push_back(arr[right++]);

    // Copy back
    for (int i = low; i <= high; i++)
        arr[i] = temp[i - low];

    return cnt;
}
```

### ğŸ” Recursive Mergeâ€‘Sort

```cpp
int mergeSort(vector<int>& arr, int low, int high) {
    if (low >= high) 
        return 0;
    int mid = low + (high - low) / 2;
    int cnt = 0;
    cnt += mergeSort(arr, low, mid);
    cnt += mergeSort(arr, mid + 1, high);
    cnt += merge(arr, low, mid, high);
    return cnt;
}
```

---

## âœï¸ Full Corrected Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Merge two sorted subarrays [low..mid] and [mid+1..high],
 * count and return the number of cross inversions.
 */
int merge(vector<int>& arr, int low, int mid, int high) {
    vector<int> temp;
    int left = low, right = mid + 1, cnt = 0;

    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {
            temp.push_back(arr[left++]);
        } else {
            temp.push_back(arr[right++]);
            cnt += (mid - left + 1);
        }
    }
    while (left <= mid)  temp.push_back(arr[left++]);
    while (right <= high) temp.push_back(arr[right++]);

    for (int i = low; i <= high; i++)
        arr[i] = temp[i - low];

    return cnt;
}

/**
 * Recursively sort arr[low..high] and count inversions.
 */
int mergeSort(vector<int>& arr, int low, int high) {
    if (low >= high) return 0;
    int mid = low + (high - low) / 2;
    int cnt = mergeSort(arr, low, mid);
    cnt    += mergeSort(arr, mid + 1, high);
    cnt    += merge(arr, low, mid, high);
    return cnt;
}

/**
 * Main API: returns total inversions in a[0..n-1].
 */
long long numberOfInversions(vector<int>& a) {
    return mergeSort(a, 0, int(a.size()) - 1);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) 
        cin >> arr[i];

    cout << numberOfInversions(arr) << "\n";
    return 0;
}
```

---

## ğŸ“Š Complexity Analysis

| Phase              | Time Complexity   | Space Complexity      |
| ------------------ | ----------------- | --------------------- |
| Divide & mergeSort | *T(n/2) + T(n/2)* | *O(logâ€¯n)* recursion  |
| Merge + count      | *O(n)*            | *O(n)* for temp array |
| **Overall**        | **O(nâ€¯logâ€¯n)**    | **O(n)**              |

> â˜… The extra **O(n)** tempâ€‘vector is necessary for merging.

---

## âœ… Test Cases

| Input                  | Output | Explanation                                         |
| ---------------------- | ------ | --------------------------------------------------- |
| `n=5, a=[2,4,1,3,5]`   | 3      | Inversions: (2,1), (4,1), (4,3)                     |
| `n=3, a=[3,2,1]`       | 3      | All pairs inverted                                  |
| `n=4, a=[1,2,3,4]`     | 0      | Already sorted, no inversions                       |
| `n=6, a=[5,5,5,5,5,5]` | 0      | Equal elements arenâ€™t counted (`<=` in merge check) |

---

## ğŸ¯ Tips & Tricks

* ğŸ” **Stable Merge Sort**: Using `<=` in the comparison ensures stability (equal elements stay in order).
* ğŸ› ï¸ **Avoid Overflow**: compute `mid` as `low + (highâ€“low)/2` instead of `(low+high)/2`.
* ğŸ§© **Inâ€‘Place?**: True inâ€‘place merge is trickyâ€”here we use *O(n)* aux space for simplicity.

---

## ğŸ”„ Variations

1. **Fenwick Tree (BIT)**

   * Compress values, then iterate rightâ†’left, count how many smaller seen so far.
   * Time: *O(nâ€¯logâ€¯n)*, extra *O(n)* for BIT.

2. **Orderâ€‘Statistic Tree**

   * Balanced BST that tracks subtree sizes.
   * Query â€œhow many < xâ€ in *O(logâ€¯n)*.

3. **CDQ Divideâ€‘Conquer** (for 2D inversions / higherâ€‘dim problems).

---

## â“ FAQs

> **Q1. Why canâ€™t we count during the first half?** <br>
> You **canâ€™t** count crossâ€‘inversions until you know both halvesâ€™ sorted orderâ€”hence the merge step.

> **Q2. Can I reuse one global temp array?** <br>
> Yes! Allocate once outside recursion to save some memory churn.

> **Q3. Do equal pairs count?** <br>
> Noâ€”only strict `arr[i] > arr[j]`. We use `<=` to avoid counting equals.

> **Q4. What about very large `n`?** <br>
> For `n` up to 10â·, recursion may overflowâ€”consider an **iterative** mergeâ€sort or increase recursion limit.

---
