# 🚂 Count Inversions

## 📄 Problem Statement

> **Count the number of inversions** in an array.
> An **inversion** is a pair of indices `(i, j)` such that `i < j` and `arr[i] > arr[j]`.
> Given an array `a` of size `n`, return the total inversion count.

### 🔍 Example

```text
Input:  a = [2, 4, 1, 3, 5]
Output: 3

Inversions are:
  (2,1), (4,1), (4,3)
```

---

## 💡 Intuition

* Every time a **larger** element appears **before** a **smaller** one, that’s an inversion.
* Naively checking all pairs is *O(n²)*, too slow for large `n`.
* **Merge‑Sort** can count “cross‑inversions” while merging two sorted halves in *O(n log n)*.

---

## 🐢 Brute‑Force Approach

```cpp
long long countInversionsBrute(vector<int>& a) {
    int n = a.size();
    long long cnt = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if (a[i] > a[j])
                ++cnt;
        }
    }
    return cnt;
}
```

* **Time Complexity:** *O(n²)*
* **Space Complexity:** *O(1)*

> ⚠️ Too slow once `n` > 10⁵.

---

## 🚀 Optimal Approach: Merge‑Sort with Inversion Count

1. **Divide** the array into two halves.
2. **Recursively** count inversions in each half.
3. **Merge** sorted halves, and while merging:

   * Whenever you take an element from the **right** half (say `arr[j]`) because `arr[j] < arr[i]` from the left, you add `(mid – i + 1)` to the inversion count (all remaining left elements are > `arr[j]`).

### 🔄 Merge Function with Count

```cpp
int merge(vector<int>& arr, int low, int mid, int high) {
    vector<int> temp;
    int left = low, right = mid + 1;
    int cnt = 0;

    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {
            temp.push_back(arr[left++]);
        } else {
            temp.push_back(arr[right++]);
            cnt += (mid - left + 1);  // All arr[left..mid] > arr[right-1]
        }
    }
    // Append leftovers
    while (left <= mid)  temp.push_back(arr[left++]);
    while (right <= high) temp.push_back(arr[right++]);

    // Copy back
    for (int i = low; i <= high; i++)
        arr[i] = temp[i - low];

    return cnt;
}
```

### 🔁 Recursive Merge‑Sort

```cpp
int mergeSort(vector<int>& arr, int low, int high) {
    if (low >= high) 
        return 0;
    int mid = low + (high - low) / 2;
    int cnt = 0;
    cnt += mergeSort(arr, low, mid);
    cnt += mergeSort(arr, mid + 1, high);
    cnt += merge(arr, low, mid, high);
    return cnt;
}
```

---

## ✏️ Full Corrected Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Merge two sorted subarrays [low..mid] and [mid+1..high],
 * count and return the number of cross inversions.
 */
int merge(vector<int>& arr, int low, int mid, int high) {
    vector<int> temp;
    int left = low, right = mid + 1, cnt = 0;

    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {
            temp.push_back(arr[left++]);
        } else {
            temp.push_back(arr[right++]);
            cnt += (mid - left + 1);
        }
    }
    while (left <= mid)  temp.push_back(arr[left++]);
    while (right <= high) temp.push_back(arr[right++]);

    for (int i = low; i <= high; i++)
        arr[i] = temp[i - low];

    return cnt;
}

/**
 * Recursively sort arr[low..high] and count inversions.
 */
int mergeSort(vector<int>& arr, int low, int high) {
    if (low >= high) return 0;
    int mid = low + (high - low) / 2;
    int cnt = mergeSort(arr, low, mid);
    cnt    += mergeSort(arr, mid + 1, high);
    cnt    += merge(arr, low, mid, high);
    return cnt;
}

/**
 * Main API: returns total inversions in a[0..n-1].
 */
long long numberOfInversions(vector<int>& a) {
    return mergeSort(a, 0, int(a.size()) - 1);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) 
        cin >> arr[i];

    cout << numberOfInversions(arr) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase              | Time Complexity   | Space Complexity      |
| ------------------ | ----------------- | --------------------- |
| Divide & mergeSort | *T(n/2) + T(n/2)* | *O(log n)* recursion  |
| Merge + count      | *O(n)*            | *O(n)* for temp array |
| **Overall**        | **O(n log n)**    | **O(n)**              |

> ★ The extra **O(n)** temp‑vector is necessary for merging.

---

## ✅ Test Cases

| Input                  | Output | Explanation                                         |
| ---------------------- | ------ | --------------------------------------------------- |
| `n=5, a=[2,4,1,3,5]`   | 3      | Inversions: (2,1), (4,1), (4,3)                     |
| `n=3, a=[3,2,1]`       | 3      | All pairs inverted                                  |
| `n=4, a=[1,2,3,4]`     | 0      | Already sorted, no inversions                       |
| `n=6, a=[5,5,5,5,5,5]` | 0      | Equal elements aren’t counted (`<=` in merge check) |

---

## 🎯 Tips & Tricks

* 🔍 **Stable Merge Sort**: Using `<=` in the comparison ensures stability (equal elements stay in order).
* 🛠️ **Avoid Overflow**: compute `mid` as `low + (high–low)/2` instead of `(low+high)/2`.
* 🧩 **In‑Place?**: True in‑place merge is tricky—here we use *O(n)* aux space for simplicity.

---

## 🔄 Variations

1. **Fenwick Tree (BIT)**

   * Compress values, then iterate right→left, count how many smaller seen so far.
   * Time: *O(n log n)*, extra *O(n)* for BIT.

2. **Order‑Statistic Tree**

   * Balanced BST that tracks subtree sizes.
   * Query “how many < x” in *O(log n)*.

3. **CDQ Divide‑Conquer** (for 2D inversions / higher‑dim problems).

---

## ❓ FAQs

> **Q1. Why can’t we count during the first half?** <br>
> You **can’t** count cross‑inversions until you know both halves’ sorted order—hence the merge step.

> **Q2. Can I reuse one global temp array?** <br>
> Yes! Allocate once outside recursion to save some memory churn.

> **Q3. Do equal pairs count?** <br>
> No—only strict `arr[i] > arr[j]`. We use `<=` to avoid counting equals.

> **Q4. What about very large `n`?** <br>
> For `n` up to 10⁷, recursion may overflow—consider an **iterative** merge‐sort or increase recursion limit.

---
