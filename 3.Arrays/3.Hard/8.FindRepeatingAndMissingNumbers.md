# 🚚 Find the Repeating and Missing Number

## 📄 Problem Statement

> **Find the one repeating and one missing number** in an array of size `n` containing numbers from `1` to `n`.
> One element in the range `[1…n]` is **missing**, and exactly one appears **twice**.
> Return the pair `{repeating, missing}`.

---

## 💡 Intuition

We have two unknowns:

1. **r** = the repeating number
2. **m** = the missing number

Let

* **S** = sum of all elements in `arr`
* **P** = sum of squares of all elements in `arr`

Compare with the ideal sums for `1…n`:

* **Sₙ** = `n*(n+1)/2`
* **Pₙ** = `n*(n+1)*(2n+1)/6`

We form two equations:

1. **S – Sₙ = r – m** ⇒ call this **diff**
2. **P – Pₙ = r² – m² = (r–m)(r+m)** ⇒ ⇒ **(P–Pₙ)/diff = r + m** ⇒ call this **sum**

Solving:

```
r = (diff + sum) / 2
m = r – diff
```

---

## 🐢 Brute‑Force Approach

1. **Count** frequencies in a hash‑map or extra array of size `n+1`.
2. **Scan** `1…n`:

   * If freq\[x] == 2 → **repeating** = x
   * If freq\[x] == 0 → **missing**   = x

```cpp
vector<int> brute(const vector<int>& arr, int n) {
    vector<int> freq(n+1, 0);
    for (int x : arr) freq[x]++;
    int r = -1, m = -1;
    for (int i = 1; i <= n; i++) {
        if (freq[i] == 2) r = i;
        if (freq[i] == 0) m = i;
    }
    return {r, m};
}
```

* **Time Complexity:** *O(n)*
* **Space Complexity:** *O(n)*

> ⚠️ Uses extra *O(n)* space—can we do better? Yes!

---

## 🚀 Optimal Math‑Based Approach

1. **Compute**

   * `S = Σ arr[i]`
   * `P = Σ arr[i]²`
2. **Compute** ideal sums:

   * `Sₙ = n(n+1)/2`
   * `Pₙ = n(n+1)(2n+1)/6`
3. **Let**

   * `diff = S – Sₙ = r – m`
   * `sum  = (P – Pₙ) / diff = r + m`
4. **Solve** for `r` and `m`:

   ```cpp
   long long r = (diff + sum) / 2;
   long long m = r - diff;
   ```

*No extra data structures*, just a few 64‑bit accumulators.

---

## ✏️ Full Corrected Code

> **Notes / Enhancements**
>
> * Use `long long` to avoid overflow on sums/squares.
> * Check for `diff != 0` to avoid division by zero (guaranteed here since one repeats and one missing).

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns {repeating, missing} from arr[0..n-1],
 * where numbers are in the range [1..n].
 */
vector<int> repeatingMissing(const vector<int>& arr, int n) {
    long long S = 0, P = 0;
    for (int x : arr) {
        S += x;
        P += 1LL * x * x;
    }

    long long N   = n;
    long long S_N = N * (N + 1) / 2;              // ideal sum
    long long P_N = N * (N + 1) * (2*N + 1) / 6;  // ideal sum of squares

    long long diff = S - S_N;                     // r – m
    long long sum  = (P - P_N) / diff;            // (r^2 – m^2)/(r – m) = r + m

    long long r = (diff + sum) / 2;               // repeating
    long long m = r - diff;                       // missing

    return { (int)r, (int)m };
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    auto ans = repeatingMissing(arr, n);
    cout << ans[0] << " " << ans[1] << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                    | Time     | Space    |
| ------------------------ | -------- | -------- |
| Summing & squaring loop  | *O(n)*   | *O(1)*   |
| Constant‑time arithmetic | *O(1)*   | *O(1)*   |
| **Overall**              | **O(n)** | **O(1)** |

> 🎯 Only one pass over `arr`, no extra arrays.

---

## ✅ Test Cases

| `arr`                | Output | Explanation          |
| -------------------- | ------ | -------------------- |
| `[3, 1, 2, 5, 3]`    | `3 4`  | 3 repeats, 4 missing |
| `[4, 3, 6, 2, 1, 6]` | `6 5`  | 6 repeats, 5 missing |
| `[1, 1]`             | `1 2`  | smallest n=2 example |
| `[2, 2]`             | `2 1`  | inverse of above     |

---

## 🎯 Tips & Tricks

* 💾 **Overflow Safety:** Always use 64‑bit (`long long`) when summing up to `n≈10⁵` or more.
* 🧮 **Division by Zero:** In theory, `diff = 0` would mean no change in sum—but impossible here (one repeats, one missing).
* 🎲 **Extensions:** You can generalize to **multiple** missing/repeating by using higher moments (`Σx³`, etc.)—but it gets tricky.

---

## 🔄 Variations

1. **XOR‑Based**

   * Use `xorAll = XOR(arr) ^ XOR(1…n)`.
   * Partition numbers by a set bit, then separate two unknowns.
2. **Hash‑Map Tracking**

   * Simply track counts in a map (O(n) time, O(n) space).
3. **Cycle Detection (Floyd’s Tortoise & Hare)**

   * Interpret array as linked-list pointers for repeating detection.

---

## ❓ FAQs

> **Q1. Why use sums and squares?**
> They give two independent equations in `r` and `m`, enough to solve both.

> **Q2. Does this work if more than one repeats or misses?**
> No—only exactly **one** missing and **one** repeating.

> **Q3. What about negative or zero values?**
> The formula assumes values `1…n`. For arbitrary ranges, you’d shift/normalize.

> **Q4. Can floating‑point help?**
> Avoid floats—rounding errors break integer invariants. Stick to integers.

---
