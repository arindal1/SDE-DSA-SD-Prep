# ğŸšš Find the Repeating and Missing Number

## ğŸ“„ Problem Statement

> **Find the one repeating and one missing number** in an array of size `n` containing numbers from `1` to `n`.
> One element in the range `[1â€¦n]` is **missing**, and exactly one appears **twice**.
> Return the pair `{repeating, missing}`.

---

## ğŸ’¡ Intuition

We have two unknowns:

1. **r** = the repeating number
2. **m** = the missing number

Let

* **S** = sum of all elements in `arr`
* **P** = sum of squares of all elements in `arr`

Compare with the ideal sums for `1â€¦n`:

* **Sâ‚™** = `n*(n+1)/2`
* **Pâ‚™** = `n*(n+1)*(2n+1)/6`

We form two equations:

1. **S â€“ Sâ‚™ = r â€“ m** â‡’ call this **diff**
2. **P â€“ Pâ‚™ = rÂ² â€“ mÂ² = (râ€“m)(r+m)** â‡’ â‡’ **(Pâ€“Pâ‚™)/diff = r + m** â‡’ call this **sum**

Solving:

```
r = (diff + sum) / 2
m = r â€“ diff
```

---

## ğŸ¢ Bruteâ€‘Force Approach

1. **Count** frequencies in a hashâ€‘map or extra array of size `n+1`.
2. **Scan** `1â€¦n`:

   * If freq\[x] == 2 â†’ **repeating** = x
   * If freq\[x] == 0 â†’ **missing**   = x

```cpp
vector<int> brute(const vector<int>& arr, int n) {
    vector<int> freq(n+1, 0);
    for (int x : arr) freq[x]++;
    int r = -1, m = -1;
    for (int i = 1; i <= n; i++) {
        if (freq[i] == 2) r = i;
        if (freq[i] == 0) m = i;
    }
    return {r, m};
}
```

* **Time Complexity:** *O(n)*
* **Space Complexity:** *O(n)*

> âš ï¸ Uses extra *O(n)* spaceâ€”can we do better? Yes!

---

## ğŸš€ Optimal Mathâ€‘Based Approach

1. **Compute**

   * `S = Î£ arr[i]`
   * `P = Î£ arr[i]Â²`
2. **Compute** ideal sums:

   * `Sâ‚™ = n(n+1)/2`
   * `Pâ‚™ = n(n+1)(2n+1)/6`
3. **Let**

   * `diff = S â€“ Sâ‚™ = r â€“ m`
   * `sum  = (P â€“ Pâ‚™) / diff = r + m`
4. **Solve** for `r` and `m`:

   ```cpp
   long long r = (diff + sum) / 2;
   long long m = r - diff;
   ```

*No extra data structures*, just a few 64â€‘bit accumulators.

---

## âœï¸ Full Corrected Code

> **Notes / Enhancements**
>
> * Use `long long` to avoid overflow on sums/squares.
> * Check for `diff != 0` to avoid division by zero (guaranteed here since one repeats and one missing).

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns {repeating, missing} from arr[0..n-1],
 * where numbers are in the range [1..n].
 */
vector<int> repeatingMissing(const vector<int>& arr, int n) {
    long long S = 0, P = 0;
    for (int x : arr) {
        S += x;
        P += 1LL * x * x;
    }

    long long N   = n;
    long long S_N = N * (N + 1) / 2;              // ideal sum
    long long P_N = N * (N + 1) * (2*N + 1) / 6;  // ideal sum of squares

    long long diff = S - S_N;                     // r â€“ m
    long long sum  = (P - P_N) / diff;            // (r^2 â€“ m^2)/(r â€“ m) = r + m

    long long r = (diff + sum) / 2;               // repeating
    long long m = r - diff;                       // missing

    return { (int)r, (int)m };
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    auto ans = repeatingMissing(arr, n);
    cout << ans[0] << " " << ans[1] << "\n";
    return 0;
}
```

---

## ğŸ“Š Complexity Analysis

| Phase                    | Time     | Space    |
| ------------------------ | -------- | -------- |
| Summing & squaring loop  | *O(n)*   | *O(1)*   |
| Constantâ€‘time arithmetic | *O(1)*   | *O(1)*   |
| **Overall**              | **O(n)** | **O(1)** |

> ğŸ¯ Only one pass over `arr`, no extra arrays.

---

## âœ… Test Cases

| `arr`                | Output | Explanation          |
| -------------------- | ------ | -------------------- |
| `[3, 1, 2, 5, 3]`    | `3 4`  | 3 repeats, 4 missing |
| `[4, 3, 6, 2, 1, 6]` | `6 5`  | 6 repeats, 5 missing |
| `[1, 1]`             | `1 2`  | smallest n=2 example |
| `[2, 2]`             | `2 1`  | inverse of above     |

---

## ğŸ¯ Tips & Tricks

* ğŸ’¾ **Overflow Safety:** Always use 64â€‘bit (`long long`) when summing up to `nâ‰ˆ10âµ` or more.
* ğŸ§® **Division by Zero:** In theory, `diff = 0` would mean no change in sumâ€”but impossible here (one repeats, one missing).
* ğŸ² **Extensions:** You can generalize to **multiple** missing/repeating by using higher moments (`Î£xÂ³`, etc.)â€”but it gets tricky.

---

## ğŸ”„ Variations

1. **XORâ€‘Based**

   * Use `xorAll = XOR(arr) ^ XOR(1â€¦n)`.
   * Partition numbers by a set bit, then separate two unknowns.
2. **Hashâ€‘Map Tracking**

   * Simply track counts in a map (O(n) time, O(n) space).
3. **Cycle Detection (Floydâ€™s Tortoise & Hare)**

   * Interpret array as linked-list pointers for repeating detection.

---

## â“ FAQs

> **Q1. Why use sums and squares?**
> They give two independent equations in `r` and `m`, enough to solve both.

> **Q2. Does this work if more than one repeats or misses?**
> Noâ€”only exactly **one** missing and **one** repeating.

> **Q3. What about negative or zero values?**
> The formula assumes values `1â€¦n`. For arbitrary ranges, youâ€™d shift/normalize.

> **Q4. Can floatingâ€‘point help?**
> Avoid floatsâ€”rounding errors break integer invariants. Stick to integers.

---
