# âš¡ Count of Subarrays with XOR = K

---

## ğŸ“‹ Problem Statement

Given an integer array **`arr`** of length **`n`** and an integer **`target`**, count the number of **contiguous subarrays** whose bitwise **XOR** equals **`target`**.

> Recall:
>
> $$
> \text{prefixXOR}[i] = arr[0] \oplus arr[1] \oplus \cdots \oplus arr[i].
> $$
>
> A subarray `(j+1â€¦i)` has XOR equal to `target` if
>
> $$
> \text{prefixXOR}[i] \;\oplus\; \text{prefixXOR}[j] \;=\; \text{target}.
> $$

---

## ğŸ” Examples

| `arr`         | `target` | Subarrays with XOR = target | Count |
| ------------- | :------: | --------------------------- | :---: |
| `[4,2,2,6,4]` |    `6`   | `[4,2]`, `[2,2,6]`, `[6]`   |   3   |
| `[0,0,0,0]`   |    `0`   | every subarray              |   10  |
| `[5,1,2,3]`   |    `7`   | `[5,1,2,3]`                 |   1   |

---

## ğŸ¢ Bruteâ€‘Force Approach (O(nÂ²) Time)

1. For each **start** index `i` from `0â€¦nâˆ’1`:

   * Initialize `xr = 0`.
   * For each **end** index `j` from `iâ€¦nâˆ’1`:

     * `xr = xr âŠ• arr[j]`.
     * If `xr == target`, increment `count`.

```cpp
int countXorSubarraysBrute(const vector<int>& arr, int target) {
    int n = arr.size(), cnt = 0;
    for (int i = 0; i < n; ++i) {
        int xr = 0;
        for (int j = i; j < n; ++j) {
            xr ^= arr[j];
            if (xr == target)
                cnt++;
        }
    }
    return cnt;
}
```

* **Time Complexity:** O(nÂ²)
* **Space Complexity:** O(1)
* **Drawback:** Too slow for large `n` (e.g., 10âµ).

---

## âš¡ Optimal Prefixâ€‘XOR + Hash Map (O(n) Time)

### **Key Insight**

Define prefix XOR up to index `i` as

$$
\text{px}[i] = arr[0]\oplus\cdots\oplus arr[i].
$$

A subarray `(j+1â€¦i)` has XOR = `target` exactly when

$$
\text{px}[i] \;\oplus\; \text{px}[j] = \text{target} 
\quad\Longrightarrow\quad
\text{px}[j] = \text{px}[i] \;\oplus\; \text{target}.
$$

As we iterate `i` from `0â€¦nâˆ’1`, we maintain a **map** of counts of each prefix XOR seen so far (`mpp[px]`). At each step:

1. Compute `px ^= arr[i]`.
2. Let `need = px âŠ• target`.
3. **Add** `mpp[need]` to the answer (number of previous prefixes that yield `target`).
4. **Increment** `mpp[px]++` for future subarrays.

Initialize `mpp[0] = 1` to count subarrays starting at index 0.

---

## ğŸ“ Algorithm Pseudocode

```text
FUNCTION countSubarraysWithXorK(arr, n, target):
    mpp â† empty map intâ†’int
    mpp[0] = 1           // one prefix-xor zero before any elements
    px    â† 0
    count â† 0

    FOR each x IN arr:
        px â† px XOR x
        need â† px XOR target
        count â† count + mpp[need]
        mpp[px] â† mpp[px] + 1

    RETURN count
```

---

## ğŸ’¾ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the number of contiguous subarrays whose XOR equals target.
 */
int XorK(const vector<int>& arr, int target) {
    unordered_map<int,int> mpp;
    mpp.reserve(arr.size());
    mpp[0] = 1;          // prefix XOR zero before starting

    int px = 0, cnt = 0;
    for (int x : arr) {
        px ^= x;
        int need = px ^ target;
        auto it = mpp.find(need);
        if (it != mpp.end())
            cnt += it->second;
        mpp[px]++;
    }
    return cnt;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, target;
    cin >> n >> target;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    cout << XorK(arr, target) << "\n";
    return 0;
}
```

---

## ğŸ“ˆ Complexity Analysis

| Metric               | Value    |
| -------------------- | -------- |
| **Time Complexity**  | **O(n)** |
| **Space Complexity** | **O(n)** |

* Each element processed once.
* Hashâ€‘map stores up to `n` distinct prefix XORs.

---

## â“ Frequently Asked Questions (FAQs)

**Q1: Why initialize `mpp[0] = 1`?**

> To count subarrays that start at index 0 and have prefix XOR = `target` immediately.

---

**Q2: Can we use `map` instead of `unordered_map`?**

> Yesâ€”gives O(logâ€¯n) per operation â†’ O(nâ€¯logâ€¯n) overall.

---

**Q3: Does this handle negative numbers?**

> XOR is bitwise; works for any 32â€‘bit signed integers.

---

