

# 🧮 Pascal's Triangle and Combinatorics – Explained

---

## 📌 i. Generate Entire Pascal’s Triangle up to `numRows`

### ✅ Code Overview

```cpp
vector<vector<int>> generate(int numRows) { 
    vector<vector<int>> ans;
    for (int i = 1; i <= numRows; i++) {
        ans.push_back(generateRow(i));
    }
    return ans;
}
```

### 🔍 Supporting Function

```cpp
vector<int> generateRow(int row) {
    long long ans = 1;
    vector<int> ansRow;
    ansRow.push_back(1);

    for (int col = 1; col < row; col++) {
        ans = ans * (row - col);
        ans = ans / col;
        ansRow.push_back(ans);
    }
    return ansRow;
}
```

### 🧠 Logic Behind Pascal’s Triangle

Each row in Pascal’s Triangle represents the **binomial coefficients**:

$$
\text{Row } n: \quad \binom{n-1}{0}, \binom{n-1}{1}, \ldots, \binom{n-1}{n-1}
$$

Where each element is calculated using:

$$
\binom{n}{r} = \frac{n!}{r!(n-r)!}
$$

To avoid factorials (which can overflow or be inefficient), we compute each next value using:

$$
\binom{n}{r+1} = \binom{n}{r} \cdot \frac{n - r}{r + 1}
$$

That’s what’s happening in:

```cpp
ans = ans * (row - col);
ans = ans / col;
```

This helps compute combinations in O(r) time with **O(1) extra space**.

---

## Full Code:

```cpp
#include <bits/stdc++.h>

using namespace std;

vector<int> generateRow(int row) {
    long long ans = 1;
    vector<int> ansRow;
    ansRow.push_back(1);

    for (int col = 1; col < row; col++) {
        ans = ans * (row - col);
        ans = ans / col;
        ansRow.push_back(ans);
    }
    return ansRow;
}

vector<vector<int>> generate(int numRows) { 
    vector<vector<int>> ans;
    for (int i = 1; i <= numRows; i++) {
        ans.push_back(generateRow(i));
    }
    return ans;
}

int main() {
    int n;
    cin >> n;
    vector<vector<int>> ans;

    ans = generate(n);

    for (int i = 0; i < ans.size(); i++) {
        for (int j = 0; j < ans[i].size(); j++) {
            cout << ans[i][j] << ' ';
        }
        cout << '\n';
    }

    return 0;
}
```

## 🧪 Sample Output for `generate(5)`

```text
[1]
[1 1]
[1 2 1]
[1 3 3 1]
[1 4 6 4 1]
```

---

## 📌 ii. Single Row of Pascal’s Triangle

```cpp
vector<int> generateRow(int row) {
    long long ans = 1;
    vector<int> ansRow;
    ansRow.push_back(1);

    for (int col = 1; col < row; col++) {
        ans = ans * (row - col);
        ans = ans / col;
        ansRow.push_back(ans);
    }
    return ansRow;
}
```

### ✅ Purpose

* Efficiently generates **a specific row** of Pascal's Triangle.
* Uses **combinatorics** (`nCr`) based recurrence relation without using `factorial()`.

### 🧠 Time & Space

| Metric           | Value                           |
| ---------------- | ------------------------------- |
| Time Complexity  | O(n)                            |
| Space Complexity | O(n)                            |
| Overflow Safe?   | ✅ if `long long` used carefully |

---

## 📌 iii. Direct `nCr` Calculation

```cpp
int nCr(int r) {
    int res = 1;
    for (int i = 0; i < r; i++) {
        res = res * (n - i);
        res = res / (i + 1);
    }
    return res;
}
```

### ✅ Purpose

Calculates:

$$
\binom{n}{r} = \frac{n!}{r!(n-r)!}
$$

... efficiently using iterative formula to avoid large intermediate values.

### ✅ Explanation

This uses the recurrence:

$$
\binom{n}{r+1} = \binom{n}{r} \cdot \frac{n - r}{r + 1}
$$

### ❗ Note

* You **must pass `n` as a parameter**, otherwise `nCr(r)` will not compile as written.
* Use `long long` if values can be large.

---

## ⚖️ Comparison Table

| Approach        | Purpose                    | Time  | Space | Strength                                                                 |
| --------------- | -------------------------- | ----- | ----- | ------------------------------------------------------------------------ |
| `generate()`    | Full Pascal’s Triangle     | O(n²) | O(n²) | Easy to print all rows at once                                           |
| `generateRow()` | Single row of Pascal's     | O(n)  | O(n)  | Efficient for printing a single row                                      |
| `nCr()`         | Specific combination `nCr` | O(r)  | O(1)  | Fast for solving combination-related problems (like subset counts, etc.) |

---

## ❓ FAQs

### Q: Why use `long long`?

> To prevent overflow when calculating large values of combinations like `C(30,15)`.

---

### Q: Can Pascal’s Triangle be used in DP?

> Absolutely. It's the backbone for solving problems involving binomial coefficients, subset sums, DP on grids, and more.

---

### Q: Is recursion used anywhere?

> Not in this implementation. But Pascal's Triangle is naturally defined recursively:

$$
\text{Pascal}[r][c] = \text{Pascal}[r-1][c-1] + \text{Pascal}[r-1][c]
$$

---