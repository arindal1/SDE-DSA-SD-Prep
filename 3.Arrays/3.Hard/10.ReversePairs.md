# 🔀 Reverse Pairs

## 📄 Problem Statement

> **Count Reverse Pairs in an Array**
> Given an array `arr` of size `n`, find the number of **reverse pairs**. A reverse pair is a pair of indices `(i, j)` such that:
>
> 1. `0 ≤ i < j < n`, and
> 2. `arr[i] > 2 * arr[j]`.

---

## 💡 Intuition

* A naïve double loop checks all pairs `(i, j)` in *O(n²)*, but that’s too slow for large `n`.
* We can leverage **merge sort**’s divide‑and‑conquer strategy:

  1. **Split** the array into two halves.
  2. **Count** cross‑pairs `(i, j)` where `i` is in the left half and `j` in the right, **before** we merge them.
  3. **Merge** the two sorted halves back together.
* Because each half is sorted when we count, we can use a **two‑pointer** scan in linear time to count all valid `arr[i] > 2*arr[j]`.

---

## 🐢 Brute‑Force Approach

```cpp
long long countReversePairsBrute(const vector<int>& arr) {
    int n = arr.size();
    long long cnt = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if ((long long)arr[i] > 2LL * arr[j])
                ++cnt;
        }
    }
    return cnt;
}
```

* **Time Complexity:** *O(n²)*
* **Space Complexity:** *O(1)*

> ❌ Too slow when `n` is up to 10⁵.

---

## 🚀 Optimal Merge‑Sort Approach

1. **Divide** the array into `[low…mid]` and `[mid+1…high]`.
2. **Recursively** count reverse pairs in each half.
3. **Count cross‑pairs** between the two halves *before* merging:

   * Use two pointers `i` over the left half and `j` over the right.
   * For each `i`, advance `j` while `arr[i] > 2LL * arr[j]`.
   * All positions from `mid+1` up to `j-1` form valid pairs with `i`.
4. **Merge** the two sorted halves back together in *O(n)* time.

*Highlights*:

* We count cross‑pairs on **already sorted** halves → linear scan.
* The overall recurrence is *T(n) = 2 T(n/2) + O(n)* ⇒ **O(n log n)**.

---

### 🔄 Counting Cross‑Pairs

```cpp
int countPairs(vector<int>& arr, int low, int mid, int high) {
    int cnt = 0;
    int j = mid + 1;
    for (int i = low; i <= mid; ++i) {
        while (j <= high && (long long)arr[i] > 2LL * arr[j]) {
            ++j;
        }
        cnt += (j - (mid + 1));
    }
    return cnt;
}
```

* Casting to `long long` avoids overflow when `arr[j]` is large.

---

### ✏️ Merge Function

```cpp
void merge(vector<int>& arr, int low, int mid, int high) {
    vector<int> temp;
    temp.reserve(high - low + 1);
    int i = low, j = mid + 1;

    // Standard merge of two sorted halves
    while (i <= mid && j <= high) {
        if (arr[i] <= arr[j]) temp.push_back(arr[i++]);
        else                 temp.push_back(arr[j++]);
    }
    while (i <= mid)  temp.push_back(arr[i++]);
    while (j <= high) temp.push_back(arr[j++]);

    // Copy back
    for (int k = low; k <= high; ++k) {
        arr[k] = temp[k - low];
    }
}
```

---

### 🔁 Recursive Merge‑Sort Skeleton

```cpp
int mergeSort(vector<int>& arr, int low, int high) {
    if (low >= high) return 0;
    int mid = low + (high - low) / 2;
    int cnt = 0;
    cnt += mergeSort(arr, low, mid);
    cnt += mergeSort(arr, mid + 1, high);
    cnt += countPairs(arr, low, mid, high);
    merge(arr, low, mid, high);
    return cnt;
}
```

---

## ✏️ Full Corrected Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Count reverse pairs between arr[low..mid] and arr[mid+1..high]:
 * pairs (i, j) such that arr[i] > 2*arr[j].
 */
int countPairs(vector<int>& arr, int low, int mid, int high) {
    int cnt = 0;
    int j = mid + 1;
    for (int i = low; i <= mid; ++i) {
        while (j <= high && (long long)arr[i] > 2LL * arr[j]) {
            ++j;
        }
        cnt += (j - (mid + 1));
    }
    return cnt;
}

/**
 * Merge two sorted subarrays arr[low..mid] and arr[mid+1..high].
 */
void merge(vector<int>& arr, int low, int mid, int high) {
    vector<int> temp;
    temp.reserve(high - low + 1);
    int i = low, j = mid + 1;

    while (i <= mid && j <= high) {
        if (arr[i] <= arr[j]) temp.push_back(arr[i++]);
        else                 temp.push_back(arr[j++]);
    }
    while (i <= mid)  temp.push_back(arr[i++]);
    while (j <= high) temp.push_back(arr[j++]);

    for (int k = low; k <= high; ++k) {
        arr[k] = temp[k - low];
    }
}

/**
 * Recursively sort and count reverse pairs in arr[low..high].
 */
int mergeSort(vector<int>& arr, int low, int high) {
    if (low >= high) return 0;
    int mid = low + (high - low) / 2;
    int cnt = mergeSort(arr, low, mid);
    cnt    += mergeSort(arr, mid + 1, high);
    cnt    += countPairs(arr, low, mid, high);
    merge(arr, low, mid, high);
    return cnt;
}

/**
 * API: returns the number of reverse pairs in the entire array.
 */
int reversePairs(vector<int>& arr) {
    return mergeSort(arr, 0, int(arr.size()) - 1);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    cout << reversePairs(arr) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                | Time           | Space                 |
| -------------------- | -------------- | --------------------- |
| Recursive division   | 2 T(n/2)       | *O(log n)* call stack |
| Counting cross‑pairs | *O(n)*         | *O(1)*                |
| Merging              | *O(n)*         | *O(n)* temp buffer    |
| **Overall**          | **O(n log n)** | **O(n)**              |

---

## ✅ Test Cases

| Input                    | Output | Explanation                      |
| ------------------------ | ------ | -------------------------------- |
| `n=5`, `arr=[1,3,2,3,1]` | 4      | Pairs: (3,1),(3,1),(2,1),(3,1)   |
| `n=4`, `arr=[2,4,3,5,1]` | 5      | Various cross‑pairs              |
| `n=3`, `arr=[5,4,3]`     | 3      | (5,4),(5,3),(4,3)                |
| `n=3`, `arr=[1,2,3]`     | 0      | Already small → no reverse pairs |

---

## 🎯 Tips & Tricks

* 🔍 **Two‑pointer scan** over sorted halves makes cross‑count linear.
* 🛠️ **Overflow guard:** Cast to `long long` when computing `2*arr[j]`.
* 📦 **Temp buffer reuse:** You could allocate one global vector to avoid repeated allocations.

---

## 🔄 Variations

1. **Fenwick Tree / BIT:**

   * Process from right to left, track counts of values using coordinate compression.
   * Query how many elements < `arr[i]/2`.
   * Time: *O(n log n)* + compression.

2. **Order‑Statistic Tree (PBDS):**

   * Insert and query counts in *O(log n)* per element.

3. **Divide‑and‑Conquer in-place:**

   * Harder—requires in‑place merge with count, but avoids extra *O(n)* buffer.

---

## ❓ FAQs

> **Q1. Why cast to `long long`?**
> To prevent overflow when `arr[j]` is near `INT_MAX` and multiplied by 2.

> **Q2. Can we do this in pure O(n) time?**
> Not without additional constraints or data structures—Ω(n log n) is optimal in the comparison model.

> **Q3. Why count before merging?**
> Because counting relies on the **sorted** order of each half; merging would disturb that.

> **Q4. What if array size is huge (≈10⁷)?**
> Watch out for recursion depth—either raise the limit or switch to an iterative merge‑sort.

---
