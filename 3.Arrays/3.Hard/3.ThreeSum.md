# 📌 3Sum – Find All Unique Triplets Summing to Zero

---

## 📋 Problem Statement

Given an integer array **`arr`** of length **`n`**, return all **unique** triplets `[a, b, c]` such that

$$
a + b + c = 0.
$$

No duplicate triplets should appear in the result.

---

## 🔎 Examples

| Input              | Output                           |
| ------------------ | -------------------------------- |
| `[-1,0,1,2,-1,-4]` | `[[-1,-1,2],[-1,0,1]]`           |
| `[0,1,1]`          | `[]` *— no triplet sums to zero* |
| `[0,0,0]`          | `[[0,0,0]]`                      |

---

## 🐢 Brute‑Force Approach (O(n³) Time)

1. Triple‑nest loops over indices `i < j < k`.
2. Check if `arr[i] + arr[j] + arr[k] == 0`.
3. Collect the triplet, **sort** it and insert into a `set` to avoid duplicates.
4. Convert the set of vectors back to a list.

```cpp
vector<vector<int>> threeSumBrute(vector<int>& arr) {
    int n = arr.size();
    set<vector<int>> seen;
    for (int i = 0; i < n; ++i)
        for (int j = i+1; j < n; ++j)
            for (int k = j+1; k < n; ++k)
                if (arr[i] + arr[j] + arr[k] == 0) {
                    vector<int> trip = {arr[i], arr[j], arr[k]};
                    sort(trip.begin(), trip.end());
                    seen.insert(trip);
                }
    return vector<vector<int>>(seen.begin(), seen.end());
}
```

* **Time Complexity:** O(n³)
* **Space Complexity:** O(n³) for the set in the worst case
* **Drawback:** Too slow for `n` up to 10⁴.

---

## ⚡ Optimal Two‑Pointer Approach (O(n²) Time)

### **Key Steps**

1. **Sort** the array: O(n log n).
2. **Fix** the first element at index `i`, iterate `i = 0…n−3`.

   * **Skip duplicates**: if `i > 0 && arr[i] == arr[i-1]`, continue.
3. **Two‑pointer** on the subarray `i+1…n−1` with pointers `left = i+1`, `right = n−1`:

   * Compute `sum = arr[i] + arr[left] + arr[right]`.
   * If `sum < 0`, **increment** `left`.
   * If `sum > 0`, **decrement** `right`.
   * If `sum == 0`, record `[arr[i], arr[left], arr[right]]`, then advance `left` and `right` **past duplicates**.

This visits each pair `(i, left, right)` at most once, yielding **O(n²)** time and **O(1)** extra space for pointers (excluding output).

---

## 📝 Pseudocode

```text
FUNCTION threeSum(arr, n):
    sort(arr)
    ans ← empty list

    FOR i FROM 0 TO n−3:
        IF i>0 AND arr[i]==arr[i−1]:
            CONTINUE   // skip duplicate first elements
        left ← i+1
        right ← n−1

        WHILE left < right:
            sum ← arr[i] + arr[left] + arr[right]
            IF sum < 0:
                left ← left + 1
            ELSE IF sum > 0:
                right ← right − 1
            ELSE:
                ans.append([arr[i], arr[left], arr[right]])
                left ← left + 1
                right ← right − 1
                // skip duplicates for second and third elements
                WHILE left<right AND arr[left]==arr[left−1]:
                    left ← left + 1
                WHILE left<right AND arr[right]==arr[right+1]:
                    right ← right − 1

    RETURN ans
```

---

## 💾 Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns all unique triplets [a,b,c] in arr that sum to zero.
 */
vector<vector<int>> threeSum(vector<int>& arr, int n) {
    vector<vector<int>> ans;
    sort(arr.begin(), arr.end());

    for (int i = 0; i < n; i++) {
        // Skip duplicate fixed elements
        if (i > 0 && arr[i] == arr[i-1]) 
            continue;

        int left = i + 1;
        int right = n - 1;
        while (left < right) {
            int sum = arr[i] + arr[left] + arr[right];
            if (sum < 0) {
                left++;
            } else if (sum > 0) {
                right--;
            } else {
                ans.push_back({arr[i], arr[left], arr[right]});
                left++;
                right--;
                // Skip duplicates for left pointer
                while (left < right && arr[left] == arr[left - 1])
                    left++;
                // Skip duplicates for right pointer
                while (left < right && arr[right] == arr[right + 1])
                    right--;
            }
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    vector<vector<int>> res = threeSum(arr, n);
    for (auto& trip : res) {
        cout << trip[0] << " " << trip[1] << " " << trip[2] << "\n";
    }
    return 0;
}
```

---

## 📈 Complexity Analysis

| Metric               | Value                             |
| -------------------- | --------------------------------- |
| **Time Complexity**  | O(n²)                             |
| **Space Complexity** | O(log n) (for sort) + O(k) output |

* Sorting costs O(n log n).
* Two‑pointer scan per `i` costs O(n).

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Why skip duplicates at each step?**

> To ensure **unique** triplets. After finding a valid triple, we move pointers past all equal values to avoid generating the same combination again.

---

**Q2: What if the array is very large?**

> O(n²) is the best known for 3Sum without extra constraints. For specialized distributions, hashing or integer tricks may help, but worst‑case remains O(n²).

---

**Q3: Can this be generalized to 4Sum, kSum?**

> Yes—use recursion to fix `k−2` elements and two‑pointer for the last two, yielding O(n^{k−1}) time.

---
