# 📲 Merge Sorted Arrays


## 📄 Problem Statement

> **Merge two sorted arrays in-place**
> You are given two sorted arrays, `arr1` of size `n` and `arr2` of size `m`.
> Merge them into sorted order, **without using any extra space** beyond the input arrays.
> Finally, print the combined sequence of `n + m` elements.

---

## 💡 Intuition

1. Since both arrays are already sorted:

   * The largest elements of `arr1` live at its **end**.
   * The smallest elements of `arr2` live at its **front**.
2. If any element in `arr1`’s back is **greater** than an element in `arr2`’s front, swap them.
3. After doing all useful swaps, each array individually may be “nearly sorted” but needs a final `sort()`.
4. Print both arrays in sequence.

This **avoids** extra buffers of size `n+m`, trading a few swaps + sorts (total extra space *O(1)*).

---

## 🐢 Brute‑Force Approach

1. **Concatenate** both arrays into a new vector `all`.
2. **Sort** `all`.
3. **Print** all elements.

```cpp
vector<int> all;
all.reserve(n+m);
for (int x : arr1) all.push_back(x);
for (int x : arr2) all.push_back(x);
sort(all.begin(), all.end());
for (int x : all) cout << x << ' ';
```

* **Time Complexity**: *O((n+m)·log(n+m))*
* **Space Complexity**: *O(n+m)*

Although simple, this **breaks** the “no extra space” requirement.

---

## 🚀 Optimal (In‑Place) Approach

1. **Initialize** two pointers:

   * `left = n‑1` (last index of `arr1`)
   * `right = 0`  (first index of `arr2`)
2. **While** `left >= 0 && right < m`:

   * If `arr1[left] > arr2[right]`, **swap** them, then `left--, right++`.
   * Else, **break** (because further left are even smaller).
3. **Sort** each array individually:

   ```cpp
   sort(arr1.begin(), arr1.end());
   sort(arr2.begin(), arr2.end());
   ```
4. **Print** `arr1` then `arr2` in order.

> **Why it works:**
> Every time we swap a too‑large element from `arr1` with a too‑small one from `arr2`, we push elements closer to their final zones. Final sorts fix the remainder.

---

### ✏️ Full Code


```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Merge two sorted arrays arr1 and arr2 in-place (O(1) extra space).
 */
void mergeArrays(vector<int>& arr1, vector<int>& arr2, int n, int m) {
    int left = n - 1;
    int right = 0;

    // Step 1: Swap out‑of‑place elements
    while (left >= 0 && right < m) {
        if (arr1[left] > arr2[right]) {
            swap(arr1[left], arr2[right]);
            left--;
            right++;
        } else {
            break;  // Remaining elements are correctly ordered
        }
    }

    // Step 2: Final sort of each array
    sort(arr1.begin(), arr1.end());
    sort(arr2.begin(), arr2.end());

    // Step 3: Print merged result
    for (int x : arr1)
        cout << x << ' ';
    for (int x : arr2)
        cout << x << ' ';
    cout << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;
    vector<int> arr1(n), arr2(m);
    for (int i = 0; i < n; i++) cin >> arr1[i];
    for (int i = 0; i < m; i++) cin >> arr2[i];

    mergeArrays(arr1, arr2, n, m);
    return 0;
}
```

---

## 📊 Complexity Analysis

| Step           | Time                   | Space  |
| -------------- | ---------------------- | ------ |
| Swapping loop  | *O(min(n, m))*         | *O(1)* |
| Sorting `arr1` | *O(n·log n)*           | *O(1)* |
| Sorting `arr2` | *O(m·log m)*           | *O(1)* |
| **Total**      | *O(n·log n + m·log m)* | *O(1)* |

---

## ✅ Test Cases

| Input                                              | Output            | Explanation                         |
| -------------------------------------------------- | ----------------- | ----------------------------------- |
| `n=3, m=4`<br>`arr1=[1,5,9]`<br>`arr2=[2,3,10,12]` | `1 2 3 5 9 10 12` | ✓ Simple interleaving               |
| `n=2, m=3`<br>`arr1=[2,4]`<br>`arr2=[1,3,5]`       | `1 2 3 4 5`       | ✓ Full merge                        |
| `n=4, m=3`<br>`arr1=[1,2,3,4]`<br>`arr2=[5,6,7]`   | `1 2 3 4 5 6 7`   | ✓ No swaps needed                   |
| `n=3, m=3`<br>`arr1=[7,8,9]`<br>`arr2=[1,2,3]`     | `1 2 3 7 8 9`     | ✓ All arr1 elements > arr2 elements |

---

## 🎯 Tips & Tricks

* 🔍 **Observation:** Only **boundary** elements ever need swapping—once those are corrected, a full sort finishes the job.
* 🛠️ **In-place is key:** Always ask, “*Can I do this without extra arrays?*” Many problems can be massaged similarly.
* 📈 **Final sort:** Even if it feels “expensive,” sorting two smaller arrays often beats handling one huge temporary buffer.

---

## 🔄 Variations

1. **Gap Method** (Shell sort–inspired) to avoid two full sorts:

   * Start with a “gap” of `ceil((n+m)/2)`, compare elements `gap` apart, reduce gap → 1.
2. **Merge without sorts** by merging from the back:

   * If there’s extra space at the end of `arr1`, you can merge in one pass (classic “merge” in merge‑sort) as seen in **Leetcode 88**.

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1; 
        int j = n - 1;
        int k = m + n - 1;

        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
};
```

3. **K‑sorted arrays**: Generalize to merging *k* sorted arrays in-place (more advanced).

---

## ❓ FAQs

> **Q1. Why not just use a new array?** <br>
> *Because the challenge is often to do it **in-place** with no extra or with *O(1)* space.*

> **Q2. Is using `sort()` allowed?** <br>
> *Yes—here we only require **constant** extra space. Standard library sort is *in-place* (introsort).*

> **Q3. What if arrays aren’t sorted initially?** <br>
>
> 1. Sort them individually first (*O(n·log n + m·log m)*).
> 2. Then apply this in‑place merge.

> **Q4. Can this be done in pure *O(n + m)* time?** <br>
>
> * Only if you have a buffer of size `n+m` **or** extra vacant slots at one end of an array.

---


