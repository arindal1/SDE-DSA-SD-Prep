# 🔎 4Sum – Find All Unique Quadruplets Summing to Target

---

## 📋 Problem Statement

Given an integer array **`arr`** of length **`n`** and an integer **`target`**, return all **unique** quadruplets `[a, b, c, d]` such that

$$
a + b + c + d = \text{target}.
$$

No duplicate quadruplets should appear in the result, and the numbers within each quadruplet should be in non‑decreasing order.

---

## 🔍 Key Idea: Generalize 3Sum with Two Pointers

1. **Sort** the array → allows skipping duplicates and two-pointer scans.
2. **Fix** the first two elements with nested loops `i` and `j`.

   * Skip duplicates for both.
3. Apply a **two-pointer** search on the subarray to the right of `j`:

   * Initialize `left = j+1`, `right = n−1`.
   * Compute `sum = arr[i] + arr[j] + arr[left] + arr[right]`.
   * If `sum < target`, **increment** `left`.
   * If `sum > target`, **decrement** `right`.
   * If `sum == target`, record quadruplet, advance `left`/`right` **past duplicates**.

This yields **O(n³)** time: two fixed loops plus a two-pointer scan of O(n).

---

## 📈 Complexity Analysis

| Metric               | Value                    |
| -------------------- | ------------------------ |
| **Time Complexity**  | O(n³)                    |
| **Space Complexity** | O(1) extra (plus output) |

* Sorting: O(n log n)
* Triple loop + two-pointer: O(n² · n) = O(n³)

---

## 📝 Pseudocode

```text
FUNCTION fourSum(arr, n, target):
    sort(arr)
    ans ← empty list

    FOR i FROM 0 TO n−4:
        IF i>0 AND arr[i]==arr[i−1]: CONTINUE  // skip duplicate a
        FOR j FROM i+1 TO n−3:
            IF j>i+1 AND arr[j]==arr[j−1]: CONTINUE  // skip duplicate b

            left  ← j+1
            right ← n−1
            WHILE left < right:
                sum4 ← arr[i] + arr[j] + arr[left] + arr[right]
                IF sum4 < target:
                    left ← left + 1
                ELSE IF sum4 > target:
                    right ← right − 1
                ELSE:
                    ans.add([arr[i],arr[j],arr[left],arr[right]])
                    left ← left + 1
                    right ← right − 1
                    // skip duplicates for c and d
                    WHILE left<right AND arr[left]==arr[left−1]:
                        left ← left + 1
                    WHILE left<right AND arr[right]==arr[right+1]:
                        right ← right − 1
    RETURN ans
```

---

## 💾 Full C++ Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns all unique quadruplets [a,b,c,d] in arr that sum to target.
 */
vector<vector<int>> fourSum(vector<int>& arr, int n, int target) {
    vector<vector<int>> ans;
    sort(arr.begin(), arr.end());

    for (int i = 0; i < n; i++) {
        if (i > 0 && arr[i] == arr[i-1]) 
            continue;  // skip duplicate a

        for (int j = i + 1; j < n; j++) {
            if (j > i + 1 && arr[j] == arr[j-1]) 
                continue;  // skip duplicate b

            int left  = j + 1;
            int right = n - 1;
            while (left < right) {
                long long sum4 = (long long)arr[i] + arr[j] + arr[left] + arr[right];
                if (sum4 < target) {
                    left++;
                } else if (sum4 > target) {
                    right--;
                } else {
                    ans.push_back({arr[i], arr[j], arr[left], arr[right]});
                    left++;
                    right--;
                    // skip duplicates for c
                    while (left < right && arr[left] == arr[left - 1]) 
                        left++;
                    // skip duplicates for d
                    while (left < right && arr[right] == arr[right + 1]) 
                        right--;
                }
            }
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, target;
    cin >> n >> target;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) 
        cin >> arr[i];

    auto result = fourSum(arr, n, target);
    for (auto& quad : result) {
        for (int x : quad) 
            cout << x << " ";
        cout << "\n";
    }
    return 0;
}
```

---

## 🔑 Highlights & Tips

* **Sorting** is essential for:

  * Efficient two-pointer scanning
  * Skipping **duplicate** values to ensure unique quadruplets.
* **Use `long long`** when summing four ints to avoid overflow.
* **Duplicate checks**:

  * Before entering each loop level (`i`, `j`) skip if same as previous.
  * After finding a valid quad, advance pointers past equal values.

---

## ❓ Frequently Asked Questions

**Q1:** *Can this be generalized to k‑sum?*

> Yes—use recursion: fix the first element, then solve (k−1)-sum on the remaining array. Time becomes O(n^{k−1}).

---

**Q2:** *What if `n` is small or `target` is large?*

> For small `n` (≤200), O(n³) is fine. For large `n`, there is no known sub‑cubic worst‑case solution without extra constraints.

---

**Q3:** *Why skip duplicates at both ends?*

> To avoid generating the same combination multiple times, thus ensuring **unique** results.

---

