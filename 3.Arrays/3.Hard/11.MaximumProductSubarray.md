# *️⃣ Maximum Product Subarray

## 📄 Problem Statement

> **Maximum Product Subarray** <br>
> Given an integer array `arr` of size `n`, find the **contiguous subarray** (containing at least one number) which has the **largest product**, and return that product.

---

## 💡 Intuition

Finding the maximum product is trickier than the maximum sum because multiplying by a **negative** flips signs, and multiplying by **zero** resets everything. To handle this:

1. **Traverse** from left to right, keeping track of:

   * `pre`: the product of the subarray ending at the current index.
   * `suf`: the product of the subarray starting at the current index (from the right).
2. **Reset** `pre` or `suf` to `1` whenever you hit a zero, because any subarray across a zero splits into two independent parts.
3. At each step, the **maximum** among `pre`, `suf`, and the current best `ans` is a candidate.

By scanning **both directions in one pass**, you capture subarrays that might start or end anywhere, including those “bridging” a zero.

---

## 🐢 Brute‑Force Approach

```cpp
int maxProductBrute(const vector<int>& arr) {
    int n = arr.size();
    int ans = INT_MIN;
    for (int i = 0; i < n; ++i) {
        int prod = 1;
        for (int j = i; j < n; ++j) {
            prod *= arr[j];
            ans = max(ans, prod);
        }
    }
    return ans;
}
```

* **Time Complexity:** *O(n²)*
* **Space Complexity:** *O(1)*

> ❌ Too slow for `n` up to 10⁵.

---

## 🚀 Optimal Two‑Pass Approach

1. **Initialize**

   ```cpp
   int pre = 1, suf = 1;
   int ans = INT_MIN;
   ```
2. **Single loop** for `i` from `0` to `n−1`:

   * If `pre == 0`, reset `pre = 1`.
   * If `suf == 0`, reset `suf = 1`.
   * Update

     ```cpp
     pre = pre * arr[i];
     suf = suf * arr[n-i-1];
     ans = max(ans, max(pre, suf));
     ```
3. **Return** `ans`.

This handles **negatives** (two negatives make a positive) and **zeros** (split subarrays).

---

## ✏️ Full Corrected & Enhanced Code

> **Enhancements / Notes**
>
> * Handles all-negative arrays and zeros correctly.
> * Uses `long long` if products may overflow 32‑bit (optional).

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the maximum product of any contiguous subarray.
 */
int maximumProduct(const vector<int>& arr, int n) {
    int pre = 1, suf = 1;
    int ans = INT_MIN;

    for (int i = 0; i < n; i++) {
        // Reset on zero to start a new subarray
        if (pre == 0)  pre = 1;
        if (suf == 0)  suf = 1;

        pre *= arr[i];
        suf *= arr[n - 1 - i];
        ans = max(ans, max(pre, suf));
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    cout << maximumProduct(arr, n) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Step                | Time     | Space    |
| ------------------- | -------- | -------- |
| Single two‑way loop | *O(n)*   | *O(1)*   |
| **Overall**         | **O(n)** | **O(1)** |

---

## ✅ Test Cases

| Input                    | Output | Explanation                                              |
| ------------------------ | ------ | -------------------------------------------------------- |
| `arr = [2,3,-2,4]`       | `6`    | Subarray `[2,3]` → product `6`                           |
| `arr = [-2,0,-1]`        | `0`    | Best is `[0]` (both `-2` and `-1` alone give `-2`, `-1`) |
| `arr = [-2,3,-4]`        | `24`   | Subarray `[-2,3,-4]` → product `24` (two negatives)      |
| `arr = [0,2]`            | `2`    | Subarray `[2]`                                           |
| `arr = [-1,-3,-10,0,60]` | `60`   | `[60]` is best; negatives \* reset at zero \*            |
| `arr = [6,-3,-10,0,2]`   | `180`  | Subarray `[6,-3,-10]` → `180`                            |

---

## 🎯 Tips & Tricks

* 🔍 **Two‑pass trick:** Scanning forward and backward in one loop captures all sign‑flip scenarios.
* 🛠️ **Zero reset:** Always reset running product on zero to avoid contaminating across splits.
* 📈 **Overflow guard:** For large magnitudes, consider `long long pre, suf, ans;`.

---

## 🔄 Variations

1. **Dynamic Programming**

   * Keep both `maxEndingHere` and `minEndingHere` at each index to handle negatives.
2. **Divide & Conquer**

   * Recursively compute max prefix/suffix/product in each half, then combine.
3. **Kadane‑style**

   * Adapt Kadane’s algorithm by tracking both max and min up to each index.

---

## ❓ FAQs

> **Q1. Why track both `pre` and `suf`?** <br>
> Forward pass misses subarrays that end before a strong negative; backward pass fills that gap.

> **Q2. Can a single forward DP work?** <br>
> Yes—by storing both current max and min at each step:
>
> ```cpp
> maxProd = max({arr[i], maxProd*arr[i], minProd*arr[i]});
> minProd = min({arr[i], maxProd_old*arr[i], minProd*arr[i]});
> ans = max(ans, maxProd);
> ```

> **Q3. Does the two‑pass always work?** <br>
> It works because any subarray’s product is either captured in a forward or backward cumulative product, reset at zeros.

> **Q4. What about floating‑point?** <br>
> Stick to integers, floating errors on positives/negatives can misorder maxima.

---
