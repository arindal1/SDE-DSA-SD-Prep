# ⚡ Quick Sort – Complete Guide

---

## 📌 Problem Statement

> Given an unsorted array of integers, sort it using the **Quick Sort** algorithm — a classic and efficient **Divide and Conquer** sorting technique.

---

## 🚀 What is Quick Sort?

**Quick Sort** is an in-place, divide-and-conquer sorting algorithm. It works by:

* Choosing a **pivot** element,
* **Partitioning** the array such that elements smaller than the pivot go left, and larger go right,
* Recursively sorting the left and right halves.

It's known for its **speed and low memory usage**.

---

## 🧠 Quick Sort Algorithm

### 🔄 High-Level Steps:

1. **Choose a pivot** (typically the last or middle element).
2. **Partition** the array:

   * Elements less than pivot go to the left.
   * Elements greater go to the right.
3. **Recursively apply** the above steps to left and right subarrays.

---

## ✅ Code Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

// Function to perform partition
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // choose the last element as pivot
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }

    // Place pivot in its correct sorted position
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// Recursive function for quicksort
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high); // partition index
        quickSort(arr, low, pi - 1);        // sort left of pivot
        quickSort(arr, pi + 1, high);       // sort right of pivot
    }
}

// Driver Code
int main() {
    int arr[] = {7, 2, 1, 6, 8, 5, 3, 4};
    int n = sizeof(arr) / sizeof(arr[0]);

    quickSort(arr, 0, n - 1);

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;

    return 0;
}
```

---

## 🧩 Step-by-Step Example

Given:

```
arr = [7, 2, 1, 6, 8, 5, 3, 4]
```

### Step 1:

* Choose pivot = 4
* Partition around 4 → `[2, 1, 3] 4 [7, 8, 5, 6]`

### Step 2:

* Recursively sort left and right subarrays:

  * Left of 4 → `[2, 1, 3]` → sorted to `[1, 2, 3]`
  * Right of 4 → `[7, 8, 5, 6]` → sorted to `[5, 6, 7, 8]`

### Result:

Final sorted array:

```
[1, 2, 3, 4, 5, 6, 7, 8]
```

---

## 📊 Time and Space Complexity

| Case         | Time Complexity            | Space Complexity |
| ------------ | -------------------------- | ---------------- |
| Best Case    | O(n log n)                 | O(log n)         |
| Average Case | O(n log n)                 | O(log n)         |
| Worst Case   | O(n²) *(unbalanced pivot)* | O(log n)         |

🔔 *Worst case occurs when pivot is the smallest or largest element consistently (like in already sorted arrays).*

---

## 📌 Characteristics of Quick Sort

| Property                                 | Value   |
| ---------------------------------------- | ------- |
| **In-place**                             | ✅ Yes   |
| **Stable**                               | ❌ No    |
| **Recursive**                            | ✅ Yes   |
| **Divide & Conquer**                     | ✅ Yes   |
| **Memory Efficient**                     | ✅ Yes   |
| **Faster than Merge Sort (in practice)** | ✅ Often |

---

## 🛠️ Tips for Better Quick Sort

* **Random Pivoting**: Choosing a random pivot avoids worst-case performance on sorted inputs.
* **Tail Recursion Optimization**: Can help reduce stack depth.
* **Hybrid with Insertion Sort**: For small arrays (n < 10), use insertion sort.

---

## ❓ Frequently Asked Questions

#### ❓ Q1: Is Quick Sort stable?

❌ No. It may not preserve the original order of equal elements.

---

#### ❓ Q2: Why is Quick Sort faster than Merge Sort in practice?

🔸 It uses less memory (no auxiliary array) and exhibits better **cache locality**.

---

#### ❓ Q3: Can we make Quick Sort stable?

🔸 Not easily. It requires significant changes that often eliminate its advantages.

---

#### ❓ Q4: What are the common applications of Quick Sort?

* Efficient sorting in-memory
* Database sorting
* Competitive programming

---

## 🧪 Test Case Suggestions

| Input         | Output        |
| ------------- | ------------- |
| \[1, 2, 3]    | \[1, 2, 3]    |
| \[3, 2, 1]    | \[1, 2, 3]    |
| \[4, 4, 4, 4] | \[4, 4, 4, 4] |
| \[]           | \[]           |

---

# 🔚 Final Thoughts

**Quick Sort** is a beautiful and elegant sorting algorithm that dominates in practice for its **speed**, **in-place sorting**, and **low memory usage** — though it trades off stability.

---

## 📊 Comparison Table: Sorting Algorithms

| Algorithm          | Time Complexity (Best) | Time Complexity (Average) | Time Complexity (Worst) | Space Complexity | Stable | In-Place |
| ------------------ | ---------------------- | ------------------------- | ----------------------- | ---------------- | ------ | -------- |
| **Bubble Sort**    | O(n)                   | O(n²)                     | O(n²)                   | O(1)             | ✅ Yes  | ✅ Yes    |
| **Selection Sort** | O(n²)                  | O(n²)                     | O(n²)                   | O(1)             | ❌ No   | ✅ Yes    |
| **Insertion Sort** | O(n)                   | O(n²)                     | O(n²)                   | O(1)             | ✅ Yes  | ✅ Yes    |
| **Merge Sort**     | O(n log n)             | O(n log n)                | O(n log n)              | O(n)             | ✅ Yes  | ❌ No     |
| **Quick Sort**     | O(n log n)             | O(n log n)                | O(n²)                   | O(log n)         | ❌ No   | ✅ Yes    |

---

