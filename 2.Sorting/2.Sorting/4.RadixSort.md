# 🔢 Radix Sort – In-Depth Guide

---

## 📌 Problem Statement

Sort an array of non-negative integers **`arr`** of size **`n`** in **ascending** order using the **Radix Sort** algorithm.

Radix Sort processes integer digits **from least significant to most significant** (LSD) or vice versa (MSD). Here we use **LSD** (base-10) as a concrete example.

---

## 🔍 Why Radix Sort?

* **Non-comparison** sorting algorithm
* **Linear** time O(n·k) where k = number of digits
* Suitable when keys have fixed length (e.g., 32-bit integers)
* **Stable** per-digit sort (using Counting Sort)

---

## 🐢 Brute-Force (Comparison) vs. Radix Sort

| Method           | Time Complexity | Space     | Notes                          |
| ---------------- | --------------- | --------- | ------------------------------ |
| Quick/Heap/Merge | O(n log n)      | O(1)–O(n) | Comparison-based lower bound   |
| **Radix Sort**   | **O(n·k)**      | O(n + b)  | k = digits, b = base (10 here) |

For 32-bit integers, k = ⌈32/ log₂10⌉ ≈ 10, so O(10n) = O(n).

---

## 🔄 High-Level Steps (LSD, Base-10)

1. **Find** the maximum number `maxVal` in the array → determines number of digits `d`.
2. For **digit place** `exp = 1; exp ≤ maxVal; exp *= 10`:

   * **Perform** a **stable Counting Sort** on `arr` based on the digit `(arr[i] / exp) % 10`.
3. After processing all digits, `arr` is sorted.

---

## 📝 Counting Sort by Digit (Helper)

```cpp
void countingSortByDigit(vector<int>& arr, int exp) {
    int n = arr.size();
    vector<int> output(n), count(10, 0);

    // 1) Count occurrences of each digit (0-9)
    for (int x : arr) {
        int digit = (x / exp) % 10;
        count[digit]++;
    }
    // 2) Accumulate counts (prefix sums)
    for (int i = 1; i < 10; ++i) {
        count[i] += count[i - 1];
    }
    // 3) Build output array in **reverse** for stability
    for (int i = n - 1; i >= 0; --i) {
        int digit = (arr[i] / exp) % 10;
        output[--count[digit]] = arr[i];
    }
    // 4) Copy back to arr
    for (int i = 0; i < n; ++i)
        arr[i] = output[i];
}
```

---

## 💾 Complete Radix Sort Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Stable counting sort by digit (LSD)
void countingSortByDigit(vector<int>& arr, int exp) {
    int n = arr.size();
    vector<int> output(n), count(10, 0);

    // Count digit occurrences
    for (int x : arr) {
        int digit = (x / exp) % 10;
        count[digit]++;
    }
    // Prefix sums
    for (int i = 1; i < 10; ++i)
        count[i] += count[i - 1];

    // Build output (reverse for stability)
    for (int i = n - 1; i >= 0; --i) {
        int digit = (arr[i] / exp) % 10;
        output[--count[digit]] = arr[i];
    }
    // Copy back
    for (int i = 0; i < n; ++i)
        arr[i] = output[i];
}

// Main Radix Sort (LSD, base 10)
void radixSort(vector<int>& arr) {
    if (arr.empty()) return;
    // 1) Find maximum to know digit count
    int maxVal = *max_element(arr.begin(), arr.end());
    // 2) Do counting sort for each digit
    for (int exp = 1; maxVal / exp > 0; exp *= 10) {
        countingSortByDigit(arr, exp);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    radixSort(arr);

    for (int x : arr)
        cout << x << " ";
    cout << "\n";
    return 0;
}
```

---

## 📈 Complexity Analysis

| Metric               | Value                          |
| -------------------- | ------------------------------ |
| **Time Complexity**  | O(n·k + b·k) ≈ O(n·k)          |
|                      | n = number of elements         |
|                      | k = number of digits in maxVal |
|                      | b = base (10)                  |
| **Space Complexity** | O(n + b)                       |
|                      | output array O(n), count O(b)  |

---

## ✨ Characteristics & Notes

* **Stable**: Maintains relative order of equal-digit elements per pass.
* **Non-Comparison**: Doesn’t compare keys, instead distributes by digit.
* **Works for Positive Integers**: Can be extended to handle negative by offset or separate buckets.
* **Memory**: Uses auxiliary arrays of size n and base.

---

## ❓ Frequently Asked Questions

**Q1: Can Radix Sort handle negative integers?**

> Yes—split into negatives and positives, sort each by absolute value, then combine (negatives in reverse).

---

**Q2: Why LSD vs. MSD?**

> LSD is simpler with stable sort per digit; MSD can sort by most significant first but requires recursion.

---

**Q3: When is Radix Sort preferable?**

> When **n** is large and **k** (digit length) is small/constant (e.g., 32-bit ints), yielding near-linear performance.

---
