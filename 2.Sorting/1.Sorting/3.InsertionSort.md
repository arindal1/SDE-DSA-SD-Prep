# 📝 Insertion Sort in C++

---

## 🚩 Problem Statement

Given an array of `n` integers, sort the array using **Insertion Sort** algorithm.

---

## 💡 What is Insertion Sort?

**Insertion Sort** is a simple and intuitive comparison-based sorting algorithm. It builds the sorted array **one element at a time**, like how people sort playing cards in their hand.

At each step, it **inserts the current element into its correct position** among the previously sorted elements.

---

## 🔢 Code Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

void InsertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int current = arr[i];
        int j = i - 1;
        
        // Shift elements of the sorted part to the right
        while (j >= 0 && arr[j] > current) {
            arr[j + 1] = arr[j];
            j--;
        }

        // Insert the current element at its correct position
        arr[j + 1] = current;
    }
}

int main() {
    int arr[] = {5, 3, 4, 1, 2};
    int n = sizeof(arr) / sizeof(arr[0]);

    InsertionSort(arr, n);

    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    return 0;
}
```

---

## 🧠 How It Works

* We start from the second element (`i = 1`).
* For each element, we compare it with elements before it.
* Shift all **greater elements to the right** to make space.
* Insert the current element at its **correct position** in the sorted part.

---

## 📊 Dry Run Example

Input:

```
arr = [5, 3, 4, 1, 2]
```

Process:

```
i = 1 → current = 3 → insert before 5 → [3, 5, 4, 1, 2]
i = 2 → current = 4 → insert before 5 → [3, 4, 5, 1, 2]
i = 3 → current = 1 → insert at start → [1, 3, 4, 5, 2]
i = 4 → current = 2 → insert after 1 → [1, 2, 3, 4, 5]
```

Output:

```
1 2 3 4 5
```

---

## 📈 Time & Space Complexity

| Scenario         | Time Complexity | Explanation                         |
| ---------------- | --------------- | ----------------------------------- |
| **Best Case**    | O(n)            | Already sorted, only comparisons    |
| **Average Case** | O(n²)           | Shifts and comparisons in each step |
| **Worst Case**   | O(n²)           | Reversed array, full shifting       |
| **Space**        | O(1)            | In-place sorting                    |

---

## 🧠 Characteristics of Insertion Sort

| Property     | Value                                           |
| ------------ | ----------------------------------------------- |
| **Stable**   | ✅ Yes                                           |
| **In-Place** | ✅ Yes                                           |
| **Adaptive** | ✅ Yes                                           |
| **Best for** | Small arrays                                    |
| **Real Use** | Limited use (educational, nearly sorted arrays) |

---

## 📌 Real-Life Analogy

> Like sorting cards in your hand:
>
> * Pick the next card.
> * Shift all larger cards to the right.
> * Insert the card in its correct place.

---

## ❓ FAQs

#### Q1: Is Insertion Sort better than Bubble Sort?

✅ Yes, on nearly sorted arrays, **Insertion Sort is faster** than Bubble Sort.

---

#### Q2: Can we use it on linked lists?

✅ Yes! It’s actually more efficient on **linked lists** than on arrays because insertion doesn’t require shifting elements.

---

#### Q3: Is Insertion Sort stable?

✅ Yes. Equal elements maintain their relative order.

---

#### Q4: When to use Insertion Sort?

* When data is **almost sorted**
* For **small datasets**
* As part of more complex algorithms like **Tim Sort**

---

## 🧠 Tip: Early Termination

Insertion sort is naturally adaptive. It automatically minimizes work on already-sorted portions of the array — **no need for extra checks like in Bubble Sort.**

---

## 🔚 Final Thoughts

* Great educational sorting algorithm.
* Easy to implement and visualize.
* Not ideal for large datasets due to O(n²) worst-case time.

---
