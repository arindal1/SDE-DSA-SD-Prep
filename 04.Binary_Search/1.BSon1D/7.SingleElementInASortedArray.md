# 🙎🏼‍♂️ Single Element in a Sorted Array


## 📄 Problem Statement

You are given a **sorted** array `arr` of size `n` where every element appears **exactly twice**, except for one element which appears **only once**. Find that **single** element in **O(log n)** time and **O(1)** extra space.

* **Input:**

  * Integer `n`, the size of the array.
  * A sorted vector `arr` of length `n`, where `n` is odd and all elements except one appear twice.
* **Output:**

  * The value of the element that appears only once.

---

## 💡 Intuition

Because the array is sorted, duplicates appear in **adjacent** positions. If we index from `0`:

* Before the single element, pairs start at **even** indices: `(0,1), (2,3), …`.
* After the single element, the pattern **shifts** by one: pairs start at **odd** indices.

Use a **binary search** on the index range `[1…n-2]` (we handle edges separately):

1. Check if `arr[mid]` is **not** equal to neighbors → it’s the single.
2. Else, determine which side of `mid` the single lies by comparing pair alignment:

   * If `mid` is **odd** and `arr[mid] == arr[mid-1]`, or `mid` is **even** and `arr[mid] == arr[mid+1]`, the single is **to the right** → `low = mid + 1`.
   * Otherwise, it’s **to the left** → `high = mid - 1`.

This runs in **O(log n)**.

---

## 🐢 Brute‑Force Approach

Scan the array comparing neighbors:

```cpp
int singleNonDuplicateBrute(const vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; i += 2) {
        // If the next element is different, this is the single
        if (i + 1 == n || arr[i] != arr[i + 1]) {
            return arr[i];
        }
    }
    return -1; // should never happen
}
```

* **Time Complexity:** *O(n)*
* **Space Complexity:** *O(1)*

> ❌ Linear scan not optimal when we can do logarithmic.

---

## 🚀 Optimal Approach: Binary Search on Pairs

```cpp
int singleNonDuplicate(vector<int>& arr) {
    int n = arr.size();
    // Edge cases
    if (n == 1) return arr[0];
    if (arr[0] != arr[1]) return arr[0];
    if (arr[n-1] != arr[n-2]) return arr[n-1];

    int low = 1, high = n - 2;
    while (low <= high) {
        int mid = (low + high) / 2;
        // Check if mid is the single element
        if (arr[mid] != arr[mid-1] && arr[mid] != arr[mid+1]) {
            return arr[mid];
        }
        // Determine which side to search
        bool isPairLeft = (mid % 2 == 1 && arr[mid] == arr[mid-1]);
        bool isPairRight = (mid % 2 == 0 && arr[mid] == arr[mid+1]);
        if (isPairLeft || isPairRight) {
            low = mid + 1;   // single is to the right
        } else {
            high = mid - 1;  // single is to the left
        }
    }
    return -1; // unreachable
}
```

* **Time Complexity:** *O(log n)*
* **Space Complexity:** *O(1)*

---

## ✏️ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Finds the single non-duplicate element in a sorted array where every other
 * element appears exactly twice.
 */
int singleNonDuplicate(vector<int>& arr) {
    int n = arr.size();
    // Handle edge cases
    if (n == 1) return arr[0];
    if (arr[0] != arr[1]) return arr[0];
    if (arr[n-1] != arr[n-2]) return arr[n-1];

    int low = 1, high = n - 2;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        // If arr[mid] differs from both neighbors, it's the answer
        if (arr[mid] != arr[mid-1] && arr[mid] != arr[mid+1]) {
            return arr[mid];
        }
        // Check pair alignment
        bool pairOnLeft  = (mid % 2 == 1 && arr[mid] == arr[mid-1]);
        bool pairOnRight = (mid % 2 == 0 && arr[mid] == arr[mid+1]);
        if (pairOnLeft || pairOnRight) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1; // Should not reach here
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    cout << singleNonDuplicate(arr) << "\n";
    return 0;
}
```

---

## ✅ Test Cases

| `arr`                 | Output | Explanation               |
| --------------------- | ------ | ------------------------- |
| `[1,1,2,3,3,4,4,8,8]` | `2`    | 2 appears once.           |
| `[3,3,7,7,10,11,11]`  | `10`   | 10 appears once.          |
| `[1]`                 | `1`    | Single element.           |
| `[0,0,1,1,2,2,3]`     | `3`    | Last element is single.   |
| `[5,5,6,6,7,8,8]`     | `7`    | Middle element is single. |

---

## 🎯 Tips & Tricks

* Use **index parity** (even/odd) plus **neighbor equality** to decide search direction.
* Always handle **edges** (`0` and `n-1`) separately since they lack two neighbors.
* Compute `mid` as `low + (high - low)/2` to avoid overflow.

---

## 🔄 Variations

1. **Every element appears *k* times except one**: Use bitwise counting per bit position.
2. **Unsorted array**: Use XOR of all elements to find the single in *O(n)* time.
3. **Multiple singletons**: Use a hash map or sorting to find all elements appearing once.

---

## ❓ FAQs

> **Q1. Why start `low` at 1 and `high` at `n−2`?** <br>
> We handle the first and last elements as edge cases separately, so the binary search always has valid neighbors.

> **Q2. What if the array length is even?** <br>
> By problem constraint, `n` must be odd (pairs + one). For even `n`, behavior is undefined.

> **Q3. Can this work on an unsorted array?** <br>
> No, it relies on sorting to guarantee adjacent duplicates.

> **Q4. Why check both `(mid % 2 == 1 && arr[mid] == arr[mid-1])` and `(mid % 2 == 0 && arr[mid] == arr[mid+1])`?** <br>
> That determines whether the pairing pattern is “normal” at `mid`; if so, the single lies to the right.

---
