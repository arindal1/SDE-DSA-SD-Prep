# 🔍 Search Insert Position


## 📄 Problem Statement

Given a **sorted** array of distinct integers `nums` and a **target** value, return *the index* if the target is found.
If not, return the index where it would be **inserted** in order to maintain sorted order.

* **Input:**

  * `nums`: sorted vector of `n` distinct integers
  * `target`: integer to search/insert
* **Output:**

  * Integer index in `[0…n]`

---

## 💡 Intuition

Because the array is **sorted**, we can locate the target (or its insertion point) in **O(log n)** time using **binary search**:

1. Maintain a search window `[l, r)` (half-open).
2. Repeatedly check the **middle** `m = l + (r-l)/2`.
3. If `nums[m] < target`, the insertion point lies to the **right** → `l = m + 1`.
4. Else (≥), it lies at or to the **left** → `r = m`.
5. Loop until `l == r`. That index is the answer.

---

## 🐢 Brute‑Force Approach

Scan linearly from left to right, find the first `i` with `nums[i] >= target`, or return `n` if none.

```cpp
int searchInsertBrute(const vector<int>& nums, int target) {
    int n = nums.size();
    for (int i = 0; i < n; i++) {
        if (nums[i] >= target)
            return i;
    }
    return n;
}
```

* **Time:** *O(n)*
* **Space:** *O(1)*

---

## 🚀 Optimal Approach: Binary Search

By halving the search space each step, we achieve *O(log n)*:

```cpp
int searchInsert(vector<int>& nums, int target) {
    int l = 0, r = nums.size();           // [l, r)
    while (l < r) {
        int m = l + (r - l) / 2;          // avoid overflow
        if (nums[m] < target) {
            l = m + 1;                   // target is right of m
        } else {
            r = m;                       // target at or left of m
        }
    }
    return l;                             // insertion point
}
```

---

## ✅ Test Cases

| `nums`      | `target` | Output | Explanation                        |
| ----------- | -------- | ------ | ---------------------------------- |
| `[1,3,5,6]` | `5`      | `2`    | Found at index 2                   |
| `[1,3,5,6]` | `2`      | `1`    | Would insert before `3`            |
| `[1,3,5,6]` | `7`      | `4`    | Greater than all → append at end   |
| `[1,3,5,6]` | `0`      | `0`    | Smaller than all → insert at start |
| `[]`        | `4`      | `0`    | Empty array → index 0              |

---

## ✏️ Full Corrected Code


```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the index to search for target, or insertion point if not found.
 */
int searchInsert(const vector<int>& nums, int target) {
    int l = 0, r = nums.size();     // search space [l, r)
    while (l < r) {
        int m = l + (r - l) / 2;
        if (nums[m] < target) {
            l = m + 1;
        } else {
            r = m;
        }
    }
    return l;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, target;
    cin >> n >> target;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    cout << searchInsert(arr, target) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase              | Time Complexity | Space Complexity |
| ------------------ | --------------- | ---------------- |
| Binary search loop | *O(log n)*      | *O(1)*           |
| **Overall**        | **O(log n)**    | **O(1)**         |

---

## 🎯 Tips & Tricks

* ✨ **Half-open intervals** `[l, r)` often simplify insertion-point logic.
* 🛡️ **Overflow-safe mid:** use `l + (r-l)/2` instead of `(l+r)/2`.
* 📚 Familiarize with variants: `lower_bound` vs. `upper_bound` in C++ STL.

---

## 🔄 Variations

1. **Find First ≥ X**

   * Same as “lower bound” → `lower_bound(nums.begin(), nums.end(), target)`
2. **Find Last ≤ X**

   * Use `upper_bound(...) - 1` after bounds checks.
3. **Custom Key**

   * Binary search over a computed key (e.g. search by first element of pair).

---

## ❓ FAQs

> **Q1. Why `r = nums.size()` instead of `n-1`?** <br>
> We want the insertion position to range from `0` to `n` (inclusive at start, exclusive at end).

> **Q2. What if duplicates exist?** <br>
> This finds the **first** index where `nums[i] ≥ target`. For last occurrence, adjust conditions.

> **Q3. Can I use STL?** <br>
> Yes:
>
> ```cpp
> int idx = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
> ```

> **Q4. Why not recursion?** <br>
> Iterative binary search avoids extra call-stack overhead and is simpler for insertion logic.

---
