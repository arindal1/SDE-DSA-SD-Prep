# 🎯 Find First and Last Position of Element in Sorted Array


## 📄 Problem Statement

Given a **sorted** array of integers `nums` and an integer `target`, return the **starting and ending position** of `target` in the array.
If `target` is **not found**, return `[-1, -1]`.

### Constraints:

* The array is **non-decreasing** (sorted).
* You must write an algorithm with **O(log n)** runtime complexity.

### Input

```cpp
nums = [5,7,7,8,8,10]
target = 8
```

### Output

```cpp
[3, 4]
```

---

## 💡 Intuition

This is a classic **Binary Search variation**:

To find the **first** and **last** occurrence of a value in a sorted array, we tweak the binary search condition slightly:

* For **first occurrence**, keep going **left** even after finding the target.
* For **last occurrence**, keep going **right** even after finding the target.

---

## 🐢 Brute-Force Approach

Loop through the array:

1. Track the **first index** where `nums[i] == target`.
2. Continue until the **last index** where `nums[i] == target`.

```cpp
vector<int> searchRangeBrute(vector<int>& nums, int target) {
    int n = nums.size(), start = -1, end = -1;
    for (int i = 0; i < n; i++) {
        if (nums[i] == target) {
            if (start == -1) start = i;
            end = i;
        }
    }
    return {start, end};
}
```

* ⏱️ Time: O(n)
* ❌ Not acceptable for large arrays when `O(log n)` is required.

---

## 🚀 Optimal Approach: Modified Binary Search

We do **two** binary searches:

1. One to find the **first occurrence**.
2. One to find the **last occurrence**.

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        return {binarySearch(nums, target, true), binarySearch(nums, target, false)};
    }

    int binarySearch(vector<int>& nums, int target, bool isSearchingLeft) {
        int low = 0, high = nums.size() - 1, idx = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (nums[mid] > target)
                high = mid - 1;
            else if (nums[mid] < target)
                low = mid + 1;
            else {
                idx = mid;
                // Narrow to left or right based on the flag
                if (isSearchingLeft)
                    high = mid - 1;
                else
                    low = mid + 1;
            }
        }

        return idx;
    }
};
```

---

## ✅ Full Code with `main()` Function

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        return {binarySearch(nums, target, true), binarySearch(nums, target, false)};
    }

    int binarySearch(vector<int>& nums, int target, bool isSearchingLeft) {
        int low = 0, high = nums.size() - 1;
        int idx = -1;

        while (low <= high) {
            int mid = low + (high - low) / 2;

            if (nums[mid] > target)
                high = mid - 1;
            else if (nums[mid] < target)
                low = mid + 1;
            else {
                idx = mid;
                if (isSearchingLeft)
                    high = mid - 1;
                else
                    low = mid + 1;
            }
        }

        return idx;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, target;
    cin >> n >> target;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i) cin >> nums[i];

    Solution sol;
    vector<int> ans = sol.searchRange(nums, target);
    cout << ans[0] << " " << ans[1] << "\n";

    return 0;
}
```

---

## 📊 Complexity Analysis

| Operation             | Time Complexity | Space Complexity      |
| --------------------- | --------------- | --------------------- |
| Binary Search (twice) | `O(log n)`      | `O(1)`                |
| Input/Output          | `O(n)`          | `O(n)` (input vector) |

---

## ✅ Test Cases

| `nums`           | `target` | Output    | Explanation                 |
| ---------------- | -------- | --------- | --------------------------- |
| `[5,7,7,8,8,10]` | `8`      | `[3, 4]`  | First at 3, last at 4       |
| `[5,7,7,8,8,10]` | `6`      | `[-1,-1]` | Target not present          |
| `[1]`            | `1`      | `[0,0]`   | Only one element, match     |
| `[]`             | `0`      | `[-1,-1]` | Empty array                 |
| `[2,2,2,2,2]`    | `2`      | `[0,4]`   | All elements same as target |

---

## 🎯 Tips & Tricks

* Use **two binary searches** for range problems.
* Store the index when found, and **continue search** to the left or right.
* Don’t break the loop immediately after a match—**keep narrowing**!

---

## 🔄 Variations

1. **First/Last Occurrence of K in Sorted Array** – standard interview favorite.
2. **Count occurrences of `target`** – `last - first + 1` if both exist.
3. **Floating-point precision version** – for non-integer elements.

---

## ❓ FAQs

> **Q: What if the array is not sorted?** <br>
> This binary search solution **only works** on sorted arrays. Unsorted arrays need linear scan.

> **Q: Can we use STL?** <br>
> Yes, use `lower_bound` and `upper_bound`, but writing binary search from scratch shows deep understanding.

> **Q: Can there be multiple ranges for target?** <br>
> No. Since the array is sorted, all `target`s appear contiguously—only one continuous range.

---

