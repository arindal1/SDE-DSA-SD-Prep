# 🔄 Search in Rotated Sorted Array


## 📄 Problem Statement

You are given a **rotated** sorted array `nums` of **distinct** integers and a target value `target`. Implement a function to **search** `target` in `nums`. If `target` exists, return its index; otherwise, return `-1`.

The array was originally sorted in ascending order, then **rotated** at an unknown pivot. For example, `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`.

---

## 💡 Intuition

A rotated array consists of **two sorted subarrays**. At each step in binary search:

1. Compute `mid = low + (high - low)/2`.
2. If `nums[mid] == target`, **return** `mid`.
3. Otherwise, determine **which half** is properly sorted:

   * If `nums[low] ≤ nums[mid]`, the **left** half `[low…mid]` is sorted.
   * Else, the **right** half `[mid…high]` is sorted.
4. Check if `target` lies **within** that sorted half:

   * If **yes**, **narrow** to that half.
   * If **no**, search the **other** half.
5. Repeat until `low > high`.

This still runs in **O(log n)** time and **O(1)** space.

---

## 🐢 Brute‑Force Approach

Scan the entire array:

```cpp
int searchBrute(const vector<int>& nums, int target) {
    for (int i = 0; i < nums.size(); ++i) {
        if (nums[i] == target)
            return i;
    }
    return -1;
}
```

* **Time:** *O(n)*
* **Space:** *O(1)*

> ❌ Not optimal when a logarithmic solution is expected.

---

## 🚀 Optimal Approach: Modified Binary Search

```cpp
int search(vector<int>& nums, int target) {
    int low = 0, high = nums.size() - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target)
            return mid;

        // Determine which half is sorted
        if (nums[low] <= nums[mid]) {
            // Left half [low..mid] is sorted
            if (nums[low] <= target && target < nums[mid])
                high = mid - 1;
            else
                low = mid + 1;
        } else {
            // Right half [mid..high] is sorted
            if (nums[mid] < target && target <= nums[high])
                low = mid + 1;
            else
                high = mid - 1;
        }
    }
    return -1;
}
```

* **Key**: At each step, one side of the array is guaranteed to be sorted. Decide where `target` fits.

---

## ✅ Test Cases

| `nums`            | `target` | Output | Explanation                     |
| ----------------- | -------- | ------ | ------------------------------- |
| `[4,5,6,7,0,1,2]` | `0`      | `4`    | Found at index 4.               |
| `[4,5,6,7,0,1,2]` | `3`      | `-1`   | `3` not present.                |
| `[1]`             | `0`      | `-1`   | Single-element array, no match. |
| `[1,3]`           | `3`      | `1`    | Two elements, rotated or not.   |
| `[5,1,3]`         | `5`      | `0`    | Rotation pivot in the middle.   |

---

## ✏️ Full Corrected Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Searches for target in a rotated sorted array.
 * Returns index if found, otherwise -1.
 */
int search(vector<int>& nums, int target) {
    int low = 0, high = nums.size() - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target)
            return mid;

        // Identify sorted half
        if (nums[low] <= nums[mid]) {
            // Left half is sorted
            if (nums[low] <= target && target < nums[mid])
                high = mid - 1;
            else
                low = mid + 1;
        } else {
            // Right half is sorted
            if (nums[mid] < target && target <= nums[high])
                low = mid + 1;
            else
                high = mid - 1;
        }
    }
    return -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, target;
    cin >> n >> target;
    vector<int> nums(n);
    for (int i = 0; i < n; i++)
        cin >> nums[i];

    cout << search(nums, target) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                  | Time Complexity | Space Complexity |
| ---------------------- | --------------- | ---------------- |
| Modified binary search | *O(log n)*      | *O(1)*           |
| **Overall**            | **O(log n)**    | **O(1)**         |

---

## 🎯 Tips & Tricks

* 🔄 **Check sorted half** carefully: use `≤` and `<` to avoid infinite loops.
* 🛡️ **Overflow‑safe mid**: always compute `mid = low + (high - low)/2`.
* 🔍 For duplicates, the logic changes—this works for **distinct** elements.

---

## 🔄 Variations

1. **With Duplicates**: Requires extra checks when `nums[low] == nums[mid]`.
2. **Find Minimum in Rotated Array**: Similar approach, but look for pivot.
3. **Search in Rotated Matrix**: 2D extension using row/column pivots.

---

## ❓ FAQs

> **Q1. Why not do two binary searches (find pivot then search)?** <br>
> You can, but this single-pass method is more concise and still *O(log n)*.

> **Q2. What if the array isn’t rotated?** <br>
> The code still works: one half always appears sorted and contains the target if present.

> **Q3. Can we handle duplicates?** <br>
> With duplicates, if `nums[low] == nums[mid]`, you must increment `low` to skip equal values.

> **Q4. What if `n` is 0?** <br>
> Return `-1`. You can add a guard:
>
> ```cpp
> if (nums.empty()) return -1;
> ```

---
