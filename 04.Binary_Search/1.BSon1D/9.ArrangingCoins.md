# 💰 Arranging Coins



## 📄 Problem Statement

> You have `n` coins and want to build a staircase with these coins.
> The staircase consists of rows where the `k`‑th row must contain exactly `k` coins.
> Given `n`, return the **total number of full rows** you can build.

```text
Example:
n = 5 → rows: 1 + 2 = 3 coins used, third row incomplete
Answer = 2
```

---

## 💡 Intuition

* The total coins needed for `k` full rows is the sum of the first `k` natural numbers:

  $$
    S(k) = 1 + 2 + … + k = \frac{k (k+1)}{2}.
  $$
* We seek the **largest** integer `k` such that

  $$
    \frac{k (k+1)}{2} \le n.
  $$
* Since `S(k)` grows **quadratically**, we can binary‑search for `k` in `[0…n]`.

---

## ❌ Brute‑Force Approach

Increment `k` from 1 until `S(k)` exceeds `n`:

```cpp
int arrangeCoinsBrute(int n) {
    long long sum = 0;
    int k = 0;
    while (sum + (k+1) <= n) {
        ++k;
        sum += k;
    }
    return k;
}
```

* **Time Complexity:** *O(√n)* (since k \~ √(2n))
* **Space Complexity:** *O(1)*

> Still too slow if `n` up to 2³¹.

---

## 🚀 Optimal Approach: Binary Search on k

```cpp
int arrangeCoins(int n) {
    long long low = 0, high = n, ans = 0;
    while (low <= high) {
        long long mid = low + (high - low) / 2;
        long long coins = mid * (mid + 1) / 2;
        if (coins == n) {
            return (int)mid;           // exact fit
        } else if (coins < n) {
            ans = mid;                // mid rows possible
            low = mid + 1;            // try more rows
        } else {
            high = mid - 1;           // too many coins, reduce
        }
    }
    return (int)ans;
}
```

* **Key:** Use **64‑bit** arithmetic (`long long`) to avoid overflow when computing `mid*(mid+1)/2`.

* **Time Complexity:** *O(log n)*

* **Space Complexity:** *O(1)*

---

## ✅ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the number of complete staircase rows
 * that can be formed with n coins.
 */
int arrangeCoins(int n) {
    long long low = 0, high = n, ans = 0;
    while (low <= high) {
        long long mid = low + (high - low) / 2;
        long long needed = mid * (mid + 1) / 2;
        if (needed == n) {
            return (int)mid;
        } else if (needed < n) {
            ans = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return (int)ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    long long n;
    cin >> n;

    cout << arrangeCoins((int)n) << "\n";
    return 0;
}
```

---

## ✅ Test Cases

| `n`          | Output  | Explanation                                              |
| ------------ | ------- | -------------------------------------------------------- |
| `5`          | `2`     | Rows: 1 + 2 = 3 coins, 3<5; 3rd row only 2 coins.        |
| `8`          | `3`     | Rows: 1 + 2 + 3 = 6; 4th row needs 4 coins, only 2 left. |
| `1`          | `1`     | Only one coin → one row.                                 |
| `0`          | `0`     | No coins → zero rows.                                    |
| `2147483647` | `65535` | \~√(2·n) fits within int.                                |

---

## 📊 Complexity Analysis

| Aspect    | Complexity |
| --------- | ---------- |
| **Time**  | *O(log n)* |
| **Space** | *O(1)*     |

---

## 🎯 Tips & Tricks

* **Overflow guard:** always compute `mid*(mid+1)/2` in **64‑bit**.
* **Bounds:** low can start at 0, high at `n`.
* **Exact match:** early return if `coins == n`.

---

## 🔄 Variations

1. **Closed‑form solution:** solve `k² + k – 2n = 0` ⇒

   $$
     k = \bigl\lfloor \frac{-1 + \sqrt{1 + 8n}}{2} \bigr\rfloor
   $$
2. **Generalized stacking:** variable coins per row.
3. **Inverse triangular numbers.**

---

## ❓ FAQs

> **Q:** Why binary search instead of direct formula?
> 
> **A:** Formula involves `sqrt` on very large `n`; floating‑point errors might occur. Binary search ensures exact integer result.

> **Q:** Can `n` exceed `2³¹-1`?
> 
> **A:** Problem constraints usually limit to 32‑bit. Use 64‑bit if needed.

> **Q:** What if we need to count incomplete rows differently?
> 
> **A:** You’d adjust the final accumulation logic in the brute‑force method.

---
