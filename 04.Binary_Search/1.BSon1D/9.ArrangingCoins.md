# ğŸ’° Arranging Coins



## ğŸ“„ Problem Statement

> You have `n` coins and want to build a staircase with these coins.
> The staircase consists of rows where the `k`â€‘th row must contain exactly `k` coins.
> Given `n`, return the **total number of full rows** you can build.

```text
Example:
n = 5 â†’ rows: 1 + 2 = 3 coins used, third row incomplete
Answer = 2
```

---

## ğŸ’¡ Intuition

* The total coins needed for `k` full rows is the sum of the first `k` natural numbers:

  $$
    S(k) = 1 + 2 + â€¦ + k = \frac{k (k+1)}{2}.
  $$
* We seek the **largest** integer `k` such that

  $$
    \frac{k (k+1)}{2} \le n.
  $$
* Since `S(k)` grows **quadratically**, we can binaryâ€‘search for `k` in `[0â€¦n]`.

---

## âŒ Bruteâ€‘Force Approach

Increment `k` from 1 until `S(k)` exceeds `n`:

```cpp
int arrangeCoinsBrute(int n) {
    long long sum = 0;
    int k = 0;
    while (sum + (k+1) <= n) {
        ++k;
        sum += k;
    }
    return k;
}
```

* **Time Complexity:** *O(âˆšn)* (since k \~ âˆš(2n))
* **Space Complexity:** *O(1)*

> Still too slow if `n` up to 2Â³Â¹.

---

## ğŸš€ Optimal Approach: Binary Search on k

```cpp
int arrangeCoins(int n) {
    long long low = 0, high = n, ans = 0;
    while (low <= high) {
        long long mid = low + (high - low) / 2;
        long long coins = mid * (mid + 1) / 2;
        if (coins == n) {
            return (int)mid;           // exact fit
        } else if (coins < n) {
            ans = mid;                // mid rows possible
            low = mid + 1;            // try more rows
        } else {
            high = mid - 1;           // too many coins, reduce
        }
    }
    return (int)ans;
}
```

* **Key:** Use **64â€‘bit** arithmetic (`long long`) to avoid overflow when computing `mid*(mid+1)/2`.

* **Time Complexity:** *O(logâ€¯n)*

* **Space Complexity:** *O(1)*

---

## âœ… Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the number of complete staircase rows
 * that can be formed with n coins.
 */
int arrangeCoins(int n) {
    long long low = 0, high = n, ans = 0;
    while (low <= high) {
        long long mid = low + (high - low) / 2;
        long long needed = mid * (mid + 1) / 2;
        if (needed == n) {
            return (int)mid;
        } else if (needed < n) {
            ans = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return (int)ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    long long n;
    cin >> n;

    cout << arrangeCoins((int)n) << "\n";
    return 0;
}
```

---

## âœ… Test Cases

| `n`          | Output  | Explanation                                              |
| ------------ | ------- | -------------------------------------------------------- |
| `5`          | `2`     | Rows: 1 + 2 = 3 coins, 3<5; 3rd row only 2 coins.        |
| `8`          | `3`     | Rows: 1 + 2 + 3 = 6; 4th row needs 4 coins, only 2 left. |
| `1`          | `1`     | Only one coin â†’ one row.                                 |
| `0`          | `0`     | No coins â†’ zero rows.                                    |
| `2147483647` | `65535` | \~âˆš(2Â·n) fits within int.                                |

---

## ğŸ“Š Complexity Analysis

| Aspect    | Complexity |
| --------- | ---------- |
| **Time**  | *O(logâ€¯n)* |
| **Space** | *O(1)*     |

---

## ğŸ¯ Tips & Tricks

* **Overflow guard:** always compute `mid*(mid+1)/2` in **64â€‘bit**.
* **Bounds:** low can start at 0, high at `n`.
* **Exact match:** early return if `coins == n`.

---

## ğŸ”„ Variations

1. **Closedâ€‘form solution:** solve `kÂ² + k â€“ 2n = 0` â‡’

   $$
     k = \bigl\lfloor \frac{-1 + \sqrt{1 + 8n}}{2} \bigr\rfloor
   $$
2. **Generalized stacking:** variable coins per row.
3. **Inverse triangular numbers.**

---

## â“ FAQs

> **Q:** Why binary search instead of direct formula?
> 
> **A:** Formula involves `sqrt` on very large `n`; floatingâ€‘point errors might occur. Binary search ensures exact integer result.

> **Q:** Can `n` exceed `2Â³Â¹-1`?
> 
> **A:** Problem constraints usually limit to 32â€‘bit. Use 64â€‘bit if needed.

> **Q:** What if we need to count incomplete rows differently?
> 
> **A:** Youâ€™d adjust the final accumulation logic in the bruteâ€‘force method.

---
