# 🔎 Binary Search in a Sorted Array


## 📄 Problem Statement

Given a **sorted** array of distinct integers `nums` and a target value `target`, implement a function to **search** for `target`.

* **If** `target` exists in the array, **return** its index.
* **Otherwise**, return `-1`.

You must write an algorithm with **O(log n)** runtime complexity.

---

## 💡 Intuition

A sorted array allows us to **halve** the search space at each step:

1. Compute the **middle** index `mid = low + (high - low)/2`.
2. Compare `nums[mid]` with `target`:

   * If equal, we’ve found it → **return** `mid`.
   * If `target` is **greater**, it must lie in the **right** half → set `low = mid + 1`.
   * If `target` is **smaller**, it must lie in the **left** half → set `high = mid - 1`.
3. Repeat until `low > high`. If we exit the loop, the target isn’t present.

This guarantees **O(log n)** time and **O(1)** extra space.

---

## 🐢 Brute‑Force Approach

Scan the array from left to right until you find the target:

```cpp
int searchBrute(const vector<int>& nums, int target) {
    for (int i = 0; i < nums.size(); ++i) {
        if (nums[i] == target)
            return i;
    }
    return -1;
}
```

* **Time Complexity:** *O(n)*
* **Space Complexity:** *O(1)*

> ❌ Too slow when `n` is large and a logarithmic solution is required.

---

## 🚀 Optimal Approach: Iterative Binary Search

```cpp
int search(vector<int>& nums, int target) {
    int low = 0, high = nums.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;  // overflow-safe
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            low = mid + 1;   // search right half
        } else {
            high = mid - 1;  // search left half
        }
    }
    return -1;  // not found
}
```

* **Key Details:**

  * Use `low + (high - low) / 2` to avoid integer overflow.
  * Maintain the invariant that the target, if present, is always within `[low…high]`.

---

## ✏️ Full Corrected Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Performs binary search on a sorted array.
 * Returns index of target if found, otherwise -1.
 */
int search(vector<int>& nums, int target) {
    int low = 0, high = nums.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, target;
    cin >> n >> target;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    cout << search(nums, target) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase              | Time Complexity | Space Complexity |
| ------------------ | --------------- | ---------------- |
| Binary search loop | *O(log n)*      | *O(1)*           |
| **Overall**        | **O(log n)**    | **O(1)**         |

---

## ✅ Test Cases

| `nums`            | `target` | Output | Explanation             |
| ----------------- | -------- | ------ | ----------------------- |
| `[-1,0,3,5,9,12]` | `9`      | `4`    | `nums[4] == 9`          |
| `[-1,0,3,5,9,12]` | `2`      | `-1`   | `2` is not in the array |
| `[1,2,3,4,5]`     | `1`      | `0`    | first element match     |
| `[1,2,3,4,5]`     | `5`      | `4`    | last element match      |
| `[]`              | `10`     | `-1`   | empty array             |

---

## 🎯 Tips & Tricks

* Always ensure the **midpoint** calculation is overflow-safe.
* Keep the loop condition `low ≤ high` to cover all cases, including single-element subarrays.
* After the loop, if no return occurred, the target is **not present**.

---

## 🔄 Variations

1. **First or Last Occurrence:**  Find the first/last index of a target in a sorted array with duplicates.
2. **Search in Rotated Sorted Array:**  Handle an additional rotation pivot.
3. **Kth Smallest Element in a Matrix:**  Use value-based binary search over possible values.

---

## ❓ FAQs

> **Q1. Why not use recursion?** <br>
> Iterative binary search is simpler and avoids call-stack overhead. A recursive version is similar in logic but uses additional space.

> **Q2. Can this handle duplicate elements?** <br>
> This returns **any** index where `nums[mid] == target`. For first/last occurrence, adjust boundaries when you find a match.

> **Q3. What happens if the array isn’t sorted?** <br>
> Results are **undefined**; binary search requires a sorted array.

> **Q4. Why not use STL?** <br>
> You can use `std::binary_search` to check existence or `std::lower_bound` to find the insertion point, but the explicit implementation is good for interview practice.

---
