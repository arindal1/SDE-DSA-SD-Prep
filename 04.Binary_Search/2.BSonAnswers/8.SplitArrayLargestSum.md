# 🔢 Split Array into `k` Subarrays to Minimize the Largest Sum

---

## 📄 Problem Statement

Given an integer array `a` of length `n` and an integer `k`, split the array into **`k` non‑empty contiguous subarrays** such that the **maximum** sum among these subarrays is **minimized**. Return this minimized maximum subarray sum.

* **Input:**

  * `n`: number of elements in `a`
  * `a`: vector of `n` positive integers
  * `k`: desired number of contiguous partitions
* **Output:**

  * The smallest possible value of

    $$
       \max_{1 \le i \le k} \bigl(\text{sum of subarray}_i\bigr)
    $$

---

## 💡 Intuition

* If you choose an **upper bound** `M` on the subarray sums, you can **greedily** cut the array:

  1. Accumulate elements into the current subarray until adding the next element would exceed `M`.
  2. Start a new subarray (increment partition count) with that element.
  3. Continue until the end—count how many partitions you needed.
* If you need **more than** `k` partitions, then `M` is **too small**.
* If you can do it in **≤ k** partitions, `M` is **feasible** and you can try a **smaller** bound.
* Since increasing `M` only **reduces** the number of partitions needed (monotonic), you can **binary search** on `M` in the range:

  $$
    [\,\max(a)\;\dots\;\sum(a)\,]
  $$

  to find the minimal feasible `M`.

---

## 🐢 Brute‑Force Approach

Try every candidate maximum `M` from `max(a)` up to `sum(a)`:

```cpp
int countPartitionsBrute(const vector<int>& a, int M) {
    int parts = 1, sum = 0;
    for (int x : a) {
        if (sum + x <= M) sum += x;
        else {
            parts++;
            sum = x;
        }
    }
    return parts;
}

int splitArrayBrute(vector<int>& a, int k) {
    int lo = *max_element(a.begin(), a.end());
    int hi = accumulate(a.begin(), a.end(), 0);
    for (int M = lo; M <= hi; ++M) {
        if (countPartitionsBrute(a, M) <= k)
            return M;
    }
    return hi;
}
```

* **Time Complexity:** *O((sum–max) · n)*
* **Space Complexity:** *O(1)*

> ❌ Too slow when sums or values are large.

---

## 🚀 Optimal Approach: Binary Search on Maximum Sum

1. **Bounds**:

   ```cpp
   int low  = *max_element(a.begin(), a.end());
   int high = accumulate(a.begin(), a.end(), 0);
   ```
2. **Helper** `countPartitions(M)` returns the number of subarrays needed if no subarray-sum exceeds `M`:

   ```cpp
   int parts = 1, curr = 0;
   for (int x : a) {
     if (curr + x <= M) curr += x;
     else {
       parts++;
       curr = x;
     }
   }
   return parts;
   ```
3. **Binary search**:

   ```cpp
   while (low <= high) {
     int mid = low + (high - low) / 2;
     if (countPartitions(mid) <= k)
       high = mid - 1;  // mid is feasible, try smaller
     else
       low = mid + 1;   // mid too small, need larger
   }
   return low;  // minimal feasible maximum subarray sum
   ```

This runs in **O(n log S)** where *S* = sum of all elements.

---

## ✅ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Counts how many contiguous partitions are needed
 * if no partition sum exceeds 'M'.
 */
int countPartitions(const vector<int>& a, int M) {
    int parts = 1;
    long long curr = 0;
    for (int x : a) {
        if (curr + x <= M)
            curr += x;
        else {
            parts++;
            curr = x;
        }
    }
    return parts;
}

/**
 * Splits 'a' into exactly k contiguous subarrays,
 * minimizing the maximum subarray sum. Returns that sum.
 */
int largestSubarraySumMinimized(vector<int>& a, int k) {
    int n = a.size();
    int low  = *max_element(a.begin(), a.end());
    int high = accumulate(a.begin(), a.end(), 0);

    while (low <= high) {
        int mid = low + (high - low) / 2;
        int needed = countPartitions(a, mid);
        if (needed > k)
            low = mid + 1;    // mid too small → more partitions than k
        else
            high = mid - 1;   // mid feasible → try smaller
    }
    return low;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    cin >> n >> k;
    vector<int> a(n);
    for (int i = 0; i < n; ++i)
        cin >> a[i];

    cout << largestSubarraySumMinimized(a, k) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                       | Time Complexity | Space Complexity |
| --------------------------- | --------------- | ---------------- |
| `countPartitions` per check | *O(n)*          | *O(1)*           |
| Binary search (\~log S)     | *O(n log S)*    | *O(1)*           |
| **Overall**                 | **O(n log S)**  | **O(1)**         |

* *n* = number of elements
* *S* = sum of all elements in `a`

---

## ✅ Test Cases

| `a`             | `k` | Output | Explanation                                                        |
| --------------- | --- | ------ | ------------------------------------------------------------------ |
| `[7,2,5,10,8]`  | `2` | `18`   | Split as \[7,2,5] (sum=14) and \[10,8] (sum=18).                   |
| \`.             |     |        |                                                                    |
| `[1,4,4]`       | `3` | `4`    | Three partitions, each single element, max=4.                      |
| `[2,3,1,2,4,3]` | `5` | `4`    | Partition into \[2],\[3],\[1],\[2,4],\[3]. max=6? actually best=4. |
| `[5,5,5,5]`     | `2` | `10`   | Two groups of two fives.                                           |

---

## 🎯 Tips & Tricks

* **Lower bound**: the **largest single** element (no subarray can be smaller).
* **Upper bound**: the **sum** of all elements (one subarray).
* Greedy `countPartitions` aligns with “contiguous” requirement.

---

## 🔄 Variations

1. **Painter’s Partition**: minimize the maximum paint-time instead of pages.
2. **Split Array Largest Sum** (Leetcode #410): identical problem.
3. **Minimize maximum segment sum** in other contexts (network traffic, workload).

---

## ❓ FAQs

> **Q1. Why binary‑search on the answer?** <br>
> The feasibility of a candidate maximum sum is monotonic: higher limit → fewer needed partitions.

> **Q2. Can elements be zero or negative?** <br>
> Standard problem uses **positive** integers. Negative values break monotonicity of partitions.

> **Q3. What if `k > n`?** <br>
> You can’t make more partitions than elements if each must be non-empty—behavior here returns the single-element max.

> **Q4. Can you reconstruct the actual partitions?** <br>
> Yes—after finding the optimal `M`, re-run the greedy assignment and record cut points.

---

