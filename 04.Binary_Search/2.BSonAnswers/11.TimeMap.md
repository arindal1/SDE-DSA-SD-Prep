# ‚è±Ô∏è Time Map

## üìù Problem Statement

Implement a `TimeMap` type that supports:

* `void set(string key, string value, int timestamp)` ‚Äî store the pair `(value, timestamp)` for `key`.
* `string get(string key, int timestamp)` ‚Äî return the value associated with `key` at the largest timestamp `t'` such that `t' ‚â§ timestamp`. If there is no such `t'`, return `""`.

Assumptions commonly used (and important):

* Timestamps are non-decreasing *per key* in many problem statements (so you can `push_back`).
* Keys and values are strings, timestamps are integers.


## üí° Intuition & Approach

* For each `key`, keep a time-ordered list of `(timestamp, value)` pairs.
* When setting, append to the list (if timestamps are non-decreasing) - `O(1)` amortized.
* When getting, find the rightmost pair whose `timestamp ‚â§ query`, binary search on the per-key vector - `O(log m)`.

Why binary search? Because we only ever need the most recent timestamp ‚â§ query, which is exactly a predecessor search in an ordered array - `upper_bound` (first > query) then step back one index.


## üê¢ Brute force (for context)

Keep an unsorted list of pairs per key and on every `get` scan the entire list to find the best timestamp ‚â§ query - `O(m)` per `get`. This is correct but too slow when many versions exist (m large).


## üöÄ Optimal (practical) Approach

* Use `unordered_map<string, vector<pair<int,string>>> mp;`
* `set`: `mp[key].emplace_back(timestamp, value);` - *assumes timestamps arrive in non-decreasing order per key*.
* `get`: binary-search `mp[key]` to find the index `i` with largest `arr[i].first <= timestamp`. Return `arr[i].second` or `""` if none.


If timestamps **aren‚Äôt** guaranteed ordered, either:

* Insert into sorted position (costly: `O(m)` per insert due to shifting), or
* Use `map<int,string>` (balanced BST) per key to allow `set` `O(log m)` and predecessor query `O(log m)`, or
* Keep a vector and sort lazily before first binary search (complicates implementation).


## üõ†Ô∏è Full C++ Code

```cpp
unordered_map<string, vector<pair<int, string>>> mp;

TimeMap() {}

void set(string key, string value, int timestamp) {
    mp[key].push_back({timestamp, value});
}

string get(string key, int timestamp) {
    if (!mp.count(key)) return "";

    auto &arr = mp[key];
    int low = 0, high = arr.size() - 1;
    string res = "";

    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid].first <= timestamp) {
            res = arr[mid].second;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return res;
}
``` 


> **Note about `upper_bound` comparator**: `upper_bound` has a few overloads; using the `int vs pair` comparator above is convenient and avoids constructing temporary pairs.


### üîÅ Alternative (cleaner `upper_bound` approach)

A simpler and safe pattern is to binary-search on timestamps directly:

```cpp
string get(const string &key, int timestamp) {
    auto it = mp.find(key);
    if (it == mp.end()) return "";
    const auto &arr = it->second;
    int l = 0, r = (int)arr.size() - 1, ans = -1;
    while (l <= r) {
        int m = l + (r - l) / 2;
        if (arr[m].first <= timestamp) { ans = m; l = m + 1; }
        else r = m - 1;
    }
    return (ans == -1) ? "" : arr[ans].second;
}
```

This is essentially the same as the above code but avoids repeated `mp[key]` usage.


## üìä Complexity Analysis

Let:

* `k` = number of distinct keys
* `m_k` = number of `set` operations recorded for key `k`
* `N = sum over keys of m_k` (total `set` calls stored)

**Time**

* `set`: amortized `O(1)` per call (vector append), assuming timestamps per key arrive in non-decreasing order.
* `get`: `O(log m_k)` for binary search on key `k`'s vector.

**Space**

* `O(N * (lengths of stored strings + timestamp ints))` ‚Äî you store all versions. More simply `O(N)` pairs.

---

## ‚ö†Ô∏è Edge cases & Pitfalls

* **Timestamps out of order**: If the caller may call `set` with earlier timestamps later, `push_back` will leave vectors unsorted ‚áí binary search breaks. *Fixes:* sort on demand, use `map<int,string>` per key, or insert in correct position (slow).
* **Duplicate timestamps**: If multiple `set` calls for the same key and timestamp exist, decide which to return ‚Äî last one or first one? The `upper_bound`-then-decrement approach returns the last one inserted with that timestamp if you append duplicates.
* **Memory usage**: this stores all values forever. If you have many versions across many keys, memory grows accordingly.
* **String copies**: passing `value` by value into `set` copies it. Use `const string&` or `emplace_back`/`move` to reduce copies.
* **Thread-safety**: not thread-safe; concurrent `set`/`get` require locks or concurrent data structures.

---

## üîé Test Cases

1. Basic

   ```
   set("foo", "bar", 1)
   get("foo", 1) -> "bar"
   get("foo", 3) -> "bar"
   set("foo", "bar2", 4)
   get("foo", 4) -> "bar2"
   get("foo", 5) -> "bar2"
   ```

2. No record

   ```
   get("unknown", 5) -> ""
   ```

3. Query before any timestamp

   ```
   set("a", "x", 5)
   get("a", 4) -> ""
   ```

4. Duplicate timestamp (behavior: latest returned)

   ```
   set("k","v1", 2)
   set("k","v2", 2)
   get("k", 2) -> "v2"  // if appended; or depends on spec if overwrite needed
   ```

5. Many versions

   * Insert timestamps `1..1000`, query many random timestamps ‚Äî performance should be `O(log m)` per get.

6. Timestamps unordered (invalid for push\_back approach)

   ```
   set("k","a", 10)
   set("k","b", 5)   // unordered; vector is now [ (10,a), (5,b) ]
   get("k", 6) -> ???  // incorrect if we assume sorted
   ```



## üîÅ Variations & Extensions

* **Overwrite on same timestamp**: store per key an `unordered_map<int,string>` or `map<int,string>` to overwrite old value at same timestamp. `map` allows predecessor query via `upper_bound`.
* **Memory-limited TimeMap**: periodically compact or evict old versions (LRU-style or TTL).
* **Persistent TimeMap**: if snapshots or rollbacks are needed, keep persistent structures.
* **Non-integer timestamps**: use `long long` or comparable type for timestamp keys.
* **Multi-threaded**: add synchronization primitives or use concurrent hash maps.


## üõ†Ô∏è Implementation tips & Micro-optimizations 

* Use `mp.reserve(expected_keys)` if you know roughly how many keys you'll have to avoid rehashes.
* Use `arr.emplace_back(timestamp, value)` to construct in-place, avoids an extra copy.
* If values are large and caller no longer needs them after `set`, accept `value` by value then `mp[key].emplace_back(timestamp, std::move(value))`.
* If thousands of `get` calls and relatively few `set`s, `vector` + binary-search is excellent. If many out-of-order sets occur, prefer a `map<int,string>` or `std::vector` + `inplace insertion with binary_search` (costly shifting).


### üß™ Example: complete runnable demonstration

```cpp
#include <bits/stdc++.h>
using namespace std;

class TimeMap {
private:
    unordered_map<string, vector<pair<int,string>>> mp;
public:
    TimeMap() = default;

    void set(const string &key, const string &value, int timestamp) {
        mp[key].emplace_back(timestamp, value);
    }

    string get(const string &key, int timestamp) {
        auto it = mp.find(key);
        if (it == mp.end()) return "";
        const auto &arr = it->second;
        int l = 0, r = (int)arr.size() - 1, ans = -1;
        while (l <= r) {
            int m = l + (r - l) / 2;
            if (arr[m].first <= timestamp) { ans = m; l = m + 1; }
            else r = m - 1;
        }
        return (ans == -1) ? "" : arr[ans].second;
    }
};

int main() {
    TimeMap tm;
    tm.set("foo", "bar", 1);
    cout << tm.get("foo", 1) << "\n"; // bar
    cout << tm.get("foo", 3) << "\n"; // bar
    tm.set("foo", "bar2", 4);
    cout << tm.get("foo", 4) << "\n"; // bar2
    cout << tm.get("foo", 5) << "\n"; // bar2
    cout << tm.get("nope", 1) << "\n"; // (empty line)
    return 0;
}
```


## ‚ùì FAQs

**Q: Do timestamps have to be unique?**
> A: Not necessarily. If duplicates occur and you `push_back`, the get function will return the last appended value at that timestamp (since it finds the rightmost ‚â§ timestamp). If you need to *overwrite* the value at the same timestamp, check the last element and replace it when timestamps equal.

**Q: What if `set` calls are not in chronological order?**
> A: The vector approach requires sorted timestamps for binary search. If order isn't guaranteed you must either:
> * insert in sorted order (costly),
> * use `map<int,string>` per key (`O(log m)` for set & get), or
> * buffer and sort before first `get` (complex).

**Q: Is this memory-efficient?**
> A: You persist all versions. If you have many sets, memory grows. If that‚Äôs a problem, implement retention/eviction policies.

**Q: Can `get` be done in `O(1)`?**
> A: Only if you precompute answers for all possible timestamps (impractical), or if timestamps are small and you use array indexing. For general integer timestamps, `O(log m)` is optimal for predecessor queries.

