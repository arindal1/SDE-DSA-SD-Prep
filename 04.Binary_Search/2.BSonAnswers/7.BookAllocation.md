# 📚 Book Allocation


## 📄 Problem Statement

You have `n` books with `arr[i]` pages in the i‑th book (books are in a fixed order). You want to allocate these books **contiguously** to `m` students. Each student gets a consecutive sequence of books, and the **maximum** number of pages assigned to any student should be **minimized**. Return that minimum possible maximum pages per student. If `m > n`, return `-1` (impossible).

* **Input:**

  * Integer `n` — number of books
  * Vector `arr` of length `n`, where `arr[i]` = pages in book `i`
  * Integer `m` — number of students
* **Output:**

  * Minimum largest page‑load per student, or `-1` if not possible

---

## 💡 Intuition

* If you set a candidate limit `L` on pages per student, you can **greedily** assign books:

  1. Start with the first student and accumulate pages until adding the next book would exceed `L`.
  2. Then move to the next student, repeat.
  3. Count how many students needed.
* If you need **more** than `m` students, then `L` is **too small**.
* If you can do it in **≤ m** students, `L` is **feasible** and you can try a **smaller** limit.
* The predicate “can allocate using ≤ m students” is **monotonic** in `L`, so **binary search** on `L` in `[max(arr)…sum(arr)]` finds the minimum feasible limit.

---

## 🐢 Brute‑Force Approach

Try every limit `L` from `max(arr)` up to `sum(arr)`:

```cpp
bool canAllocateBrute(const vector<int>& arr, int m, int L) {
    int students = 1, pages = 0;
    for (int x : arr) {
        if (pages + x <= L)
            pages += x;
        else {
            students++;
            pages = x;
        }
    }
    return students <= m;
}

int findPagesBrute(vector<int>& arr, int m) {
    int maxPages = *max_element(arr.begin(), arr.end());
    int sumPages = accumulate(arr.begin(), arr.end(), 0);
    for (int L = maxPages; L <= sumPages; ++L) {
        if (canAllocateBrute(arr, m, L))
            return L;
    }
    return -1;
}
```

* **Time Complexity:** *O((sum–max) · n)*
* **Space Complexity:** *O(1)*

> ❌ Too slow when sums are large.

---

## 🚀 Optimal Approach: Binary Search on Page Limit

1. **Bounds**:

   ```cpp
   int low  = *max_element(arr.begin(), arr.end());
   int high = accumulate(arr.begin(), arr.end(), 0);
   ```
2. **Helper** `countStudents(L)` returns the number of students needed if each can read up to `L` pages:

   ```cpp
   int students = 1, pages = 0;
   for (int x : arr) {
     if (pages + x <= L) pages += x;
     else {
       students++;
       pages = x;
     }
   }
   return students;
   ```
3. **Binary search**:

   ```cpp
   while (low <= high) {
     int mid = low + (high - low) / 2;
     if (countStudents(mid) <= m)
       high = mid - 1;  // feasible → try smaller
     else
       low  = mid + 1;  // not feasible → increase
   }
   return (m > n ? -1 : low);
   ```

This runs in *O(n log sum)*.

---

## ✅ Test Cases

| `arr`           | `m` | Output | Explanation                               |
| --------------- | --- | ------ | ----------------------------------------- |
| `[10,20,30,40]` | `2` | `60`   | Split as \[10,20,30] and \[40], max = 60. |
| `[10,10,10,10]` | `2` | `20`   | \[10,10], \[10,10].                       |
| `[12,34,67,90]` | `2` | `113`  | \[12,34,67] and \[90].                    |
| `[5,17,100,11]` | `4` | `100`  | Each student one book, max = 100.         |
| `[5,17,100,11]` | `5` | `-1`   | More students than books.                 |

---

## ✏️ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the number of students needed if each reads at most 'L' pages.
 */
int countStudents(const vector<int>& arr, int L) {
    int students = 1;
    long long pages = 0;
    for (int x : arr) {
        if (pages + x <= L)
            pages += x;
        else {
            students++;
            pages = x;
        }
    }
    return students;
}

/**
 * Finds the minimum largest pages per student, or -1 if m > n.
 */
int findPages(vector<int>& arr, int n, int m) {
    if (m > n) return -1;

    int low  = *max_element(arr.begin(), arr.end());
    int high = accumulate(arr.begin(), arr.end(), 0);

    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (countStudents(arr, mid) <= m)
            high = mid - 1;  // mid is feasible
        else
            low = mid + 1;   // mid too small
    }
    return low;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    cout << findPages(arr, n, m) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                     | Time Complexity | Space Complexity |
| ------------------------- | --------------- | ---------------- |
| `countStudents` per check | *O(n)*          | *O(1)*           |
| Binary search (\~log S)   | *O(n log S)*    | *O(1)*           |
| **Overall**               | **O(n log S)**  | **O(1)**         |

* *n* = number of books
* *S* = sum of pages

---

## 🎯 Tips & Tricks

* **Lower bound** must be at least the **max single book**, since you can’t split a book.
* **Upper bound** is the **sum**, giving one student all books.
* Greedy count of students aligns with contiguous allocation requirement.

---

## 🔄 Variations

1. **Painter’s Partition Problem:** Same logic with paint times instead of pages.
2. **Split Array Largest Sum:** Generalizes to any non-negative array.
3. **Allocate Tasks to Workers:** Even distribution, minimizing maximum load.

---

## ❓ FAQs

> **Q1. Why check `m > n` first?** <br>
> You can’t assign more students than books if each student must get at least one book.

> **Q2. Does order of books matter?** <br>
> Yes—it must be contiguous. If order were arbitrary, you’d sort.

> **Q3. Could pages be zero?** <br>
> Zero‑page books don’t affect the maximum and follow the same logic.

> **Q4. What if `n` or sums are huge?** <br>
> Use 64‑bit `long long` for sums and mid computations.

---
