# â— Find the Smallest Divisor Given a Threshold


## ğŸ“„ Problem Statement

Given an array of positive integers `arr` and an integer `limit`, find the **smallest** positive integer divisor `d` such that the **sum** of each element in `arr` divided by `d`â€”rounded **up**â€”is **at most** `limit`. Formally:

$$
\sum_{x \in arr} \Big\lceil \frac{x}{d} \Big\rceil \;\le\; limit
$$

Return `d`. If no such divisor exists, return `-1`.

---

## ğŸ’¡ Intuition

* As `d` **increases**, each term $\lceil x / d\rceil$ **non-increases**, so the total sum is a **monotonic** function of `d`.
* We can therefore **binary search** on `d` over `[1 â€¦ max(arr)]`.
* For a candidate `d`, compute

  $$
    \text{total} = \sum_{i=0}^{n-1} \Big\lceil \frac{arr[i]}{d} \Big\rceil.
  $$

  If `total â‰¤ limit`, we can try a **smaller** `d`; otherwise we must use a **larger** `d`.

---

## ğŸ¢ Bruteâ€‘Force Approach

Try every possible divisor from `1` up to `max(arr)`:

```cpp
int smallestDivisorBrute(vector<int>& arr, int limit) {
    int M = *max_element(arr.begin(), arr.end());
    for (int d = 1; d <= M; ++d) {
        long long total = 0;
        for (int x : arr)
            total += (x + d - 1) / d;  // integer ceil
        if (total <= limit)
            return d;
    }
    return -1;
}
```

* **Time Complexity:** *O(MÂ·n)* where *M = max(arr)*
* **Space Complexity:** *O(1)*

> âŒ Too slow when `max(arr)` is large (e.g. up to 10â¹).

---

## ğŸš€ Optimal Approach: Binary Search on Divisor

1. **Bounds**:

   ```cpp
   int low  = 1;
   int high = *max_element(arr.begin(), arr.end());
   ```
2. **Predicate** `sumByD(d)`:

   ```cpp
   int total = 0;
   for (int x : arr)
     total += (x + d - 1) / d;
   return total;
   ```
3. **Binary search**:

   ```cpp
   while (low <= high) {
     int mid = low + (high - low) / 2;
     if (sumByD(mid) <= limit)
       high = mid - 1;   // feasible: try smaller
     else
       low  = mid + 1;   // too small: increase d
   }
   return (low <= max(arr) ? low : -1);
   ```
4. **Edge case**: If `n > limit`, even at `d = max(arr)`, you'll need at least `n` (each term â‰¥ 1) which exceeds `limit`, so you can return `-1` early.

This runs in *O(nâ€¯logâ€¯M)*.

---

## âœ… Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the sum of ceil(arr[i]/d) over the array.
 */
long long sumByD(const vector<int>& arr, int d) {
    long long total = 0;
    for (int x : arr)
        total += (x + d - 1) / d;  // integer ceil
    return total;
}

/**
 * Finds the smallest divisor d such that the sum of ceil(arr[i]/d)
 * is at most limit, or -1 if impossible.
 */
int smallestDivisor(vector<int>& arr, int limit) {
    int n = arr.size();
    // If we need more terms than limit, impossible
    if (n > limit) 
        return -1;

    int low  = 1;
    int high = *max_element(arr.begin(), arr.end());
    int ans   = -1;

    while (low <= high) {
        int mid = low + (high - low) / 2;
        long long total = sumByD(arr, mid);
        if (total <= limit) {
            ans  = mid;        // mid is feasible
            high = mid - 1;    // try to find a smaller one
        } else {
            low = mid + 1;     // mid too small, increase divisor
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, limit;
    cin >> n >> limit;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    cout << smallestDivisor(arr, limit) << "\n";
    return 0;
}
```

---

## ğŸ“Š Complexity Analysis

| Phase                   | Time Complexity | Space Complexity |
| ----------------------- | --------------- | ---------------- |
| `sumByD` calculation    | *O(n)*          | *O(1)*           |
| Binary search (â‰ˆ logâ€¯M) | *O(nâ€¯logâ€¯M)*    | *O(1)*           |
| **Overall**             | **O(nâ€¯logâ€¯M)**  | **O(1)**         |

* *n* = size of `arr`
* *M* = maximum element in `arr`

---

## ğŸ¯ Tips & Tricks

* **Ceil division** trick:

  $$
    \lceil x/d \rceil = \frac{x + d - 1}{d}
  $$
* Always **tighten** your binaryâ€‘search bounds to remove unnecessary iterations.
* **Early exit** if `n > limit`, since the smallest possible sum is *n*.

---

## ğŸ”„ Variations

1. **Sum of floor division** constraints: different monotonic shape, but similar binary search.
2. **Exact equality** constraint (`sum = limit`): binary search plus postâ€‘check for exact match.
3. **Minimize maximum group sum**: partitionâ€‘based binary search on subarray sums.

---

## â“ FAQs

> **Q1. Why check `n > limit`?** <br>
> Even with the largest divisor, each term â‰¥ 1, so the sum â‰¥ n. If n > limit, you canâ€™t get the sum down.

> **Q2. What if all elements are 1?** <br>
> Then at any `d â‰¥ 1`, each term = 1, so you need `n â‰¤ limit`. The smallest divisor is always 1.

> **Q3. Can elements be zero?** <br>
> Problem assumes positive integers. If zeros appear, treat them as contributing 0 regardless of `d`.

> **Q4. How to handle huge `M` (up to 10â¹)?** <br>
> Even then *logâ‚‚(M)* â‰ˆ 30, so *O(nÂ·30)* is efficient for n up to 10âµ.

---
