# 🧠 Find the Row with Maximum Number of 1s in a Binary Matrix



## 📌 Problem Statement

> You are given a **`n x m` binary matrix** (only containing `0`s and `1`s) in which **each row is sorted in non-decreasing order** (all 0s appear before 1s).
> Your task is to **find the index of the row** that has the **maximum number of 1s**.
> If no such row exists (i.e., all rows have 0s), return `-1`.

---

## 🧠 Intuition

* Since **each row is sorted**, the `1`s will always be clustered toward the right.

* That means, the number of `1`s in any row is equal to:

  ```
  count of 1s = total columns - index of first 1
  ```

* So, we need a way to quickly find the first `1` in each row.

> And guess what? Binary Search works perfectly here 😄

---

## 🧪 Example

**Input:**

```
n = 4, m = 5
matrix = [
    [0, 0, 0, 1, 1],
    [0, 1, 1, 1, 1],
    [0, 0, 1, 1, 1],
    [0, 0, 0, 0, 0]
]
```

**Output:**

```
1
```

**Explanation:**

* Row 1 has `4` ones, which is the maximum among all rows.

---

## ❌ Brute Force Approach

* Iterate through each row and count the number of `1`s.
* Keep track of the row with the maximum count.

### Code:

```cpp
int maximumOnes(vector<vector<int>> &matrix, int n, int m) {
    int maxCnt = 0, index = -1;

    for (int i = 0; i < n; i++) {
        int cnt = 0;
        for (int j = 0; j < m; j++) {
            if (matrix[i][j] == 1) cnt++;
        }
        if (cnt > maxCnt) {
            maxCnt = cnt;
            index = i;
        }
    }

    return index;
}
```

### ⏱ Time Complexity:

* **O(N × M)**

---

## ✅ Optimal Approach (Binary Search)

### 💡 Observation:

Since each row is **sorted**, we can find the **first 1** using binary search.

### Algorithm:

1. For each row:

   * Use binary search to find the first index of `1`.
   * Calculate number of 1s = `m - index_of_first_1`.
2. Track the row with maximum number of 1s.

---

## 🔍 Binary Search Helper Function

```cpp
int countOnes(vector<int> arr, int m, int k) {
    int low = 0, high = m - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] >= k)
            high = mid - 1;
        else
            low = mid + 1;
    }

    return m - low;
}
```

* **Goal:** Find the **first occurrence of 1**
* **Trick:** We search for the **first element >= 1**.
* The number of 1s is `m - index_of_first_1`.

---

## 🚀 Final Code (With Input/Output)

```cpp
#include <bits/stdc++.h>
using namespace std;

int countOnes(vector<int> arr, int m, int k) {
    int low = 0, high = m-1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] >= k)
            high = mid - 1;
        else low = mid + 1;
    }

    return m - low;
}

int maximumOnes(vector<vector<int>> matrix, int n, int m) {
    int maxCnt = 0, index = -1;

    for (int i = 0; i < n; i++) {
        int cnt = countOnes(matrix[i], m, 1);
        if (cnt > maxCnt) {
            maxCnt = cnt;
            index = i;
        }
    }

    return index;
}

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> matrix(n, vector<int>(m));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> matrix[i][j];
        }
    }

    cout << maximumOnes(matrix, n, m);
    return 0;
}
```

---

## 🧮 Time and Space Complexity

| Component        | Complexity            |
| ---------------- | --------------------- |
| Time Complexity  | O(N × logM)           |
| Space Complexity | O(1) (ignoring input) |

---

## 🧠 Tips & Tricks

* This binary search trick is often used to count:

  * number of elements greater than `k`
  * number of elements less than or equal to `k`
* Try edge cases like:

  * All 0s
  * All 1s
  * Single row / column

---

## 🔁 Variations

* 🟦 **Maximum 1s in an unsorted matrix?**
  → You’ll need to brute-force or count in every row.

* 🟥 **Matrix is sorted column-wise instead of row-wise?**
  → Use a different traversal (like top-right to bottom-left).

---

## ❓ FAQs

### Q: What if two rows have same maximum number of 1s?

> A: Return the one with the **lower index** (as done in the current code).

### Q: Can we make it even faster?

> A: If allowed to modify traversal strategy, yes—like starting from the top-right and moving left/down in **O(N + M)**.

---

## ✅ Test Cases

### 🔹 Test 1

```
Input:
3 3
0 0 1
0 1 1
1 1 1

Output:
2
```

### 🔹 Test 2

```
Input:
2 4
0 0 0 0
1 1 1 1

Output:
1
```

### 🔹 Test 3

```
Input:
2 3
0 0 0
0 0 0

Output:
-1
```

---
