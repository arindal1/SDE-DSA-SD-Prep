# 🔎 Search a 2D Matrix I

## 📄 Problem Statement

> You are given an `n x m` integer matrix `matrix` where:
>
> 1. Each row is sorted in **ascending** order.
> 2. The **first** integer of each row is **greater** than the **last** integer of the **previous** row.
>
> Write a function that returns `true` if a given `target` exists in the matrix, or `false` otherwise.

```text
matrix     = [
  [ 1,  3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3 → true
target = 13 → false
```

---

## 💡 Intuition

Because the entire matrix in row‑major order behaves like one **sorted** array of length `n*m`, we can:

1. **Flatten** the 2D indices `(r,c)` into a single index `i ∈ [0…n*m−1]`.
2. Perform a **classic binary search** on `[0…n*m−1]`.
3. Map back:

   ```
   row = i / m
   col = i % m
   ```

This yields **O(log(nm))** time and **O(1)** space.

---

## 🐢 Brute‑Force Approach

Scan every cell:

```cpp
bool searchMatrixBrute(const vector<vector<int>>& matrix, int target) {
    for (auto &row : matrix)
        for (int x : row)
            if (x == target) return true;
    return false;
}
```

* **Time Complexity:** *O(n·m)*
* **Space Complexity:** *O(1)*

---

## 🚀 Optimal Approach: Row‑Major Binary Search

```cpp
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    if (matrix.empty() || matrix[0].empty()) 
        return false;

    int n = matrix.size(), m = matrix[0].size();
    int low = 0, high = n * m - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;
        int row = mid / m;
        int col = mid % m;
        int val = matrix[row][col];

        if (val == target)
            return true;
        else if (val < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return false;
}
```

### Key Steps

1. **Bounds**: `low = 0`, `high = n*m - 1`
2. **Mid index**: `mid = (low + high)/2` (use overflow‑safe form)
3. **Map to 2D**:

   ```
   row = mid / m
   col = mid % m
   ```
4. **Compare** `matrix[row][col]` with `target` and shrink `[low, high]`.

---

## ✅ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Searches in a row‑major sorted matrix by treating it as a flat array.
 */
bool searchMatrix(const vector<vector<int>>& matrix, int target) {
    int n = matrix.size();
    if (n == 0) return false;
    int m = matrix[0].size();
    if (m == 0) return false;

    int low = 0, high = n * m - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        int row = mid / m;
        int col = mid % m;
        int val = matrix[row][col];

        if (val == target)
            return true;
        else if (val < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, target;
    cin >> n >> m >> target;

    vector<vector<int>> matrix(n, vector<int>(m));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> matrix[i][j];

    cout << (searchMatrix(matrix, target) ? "true" : "false") << "\n";
    return 0;
}
```

---

## 🕵️ Complexity Analysis

| Metric    | Complexity    |
| --------- | ------------- |
| **Time**  | *O(log(n·m))* |
| **Space** | *O(1)*        |

---

## 🎯 Tips & Tricks

* **Flattening trick**: treat 2D as 1D using `/` and `%`.
* Always **check** for empty matrix or rows to avoid runtime errors.
* Use **overflow‑safe** mid: `low + (high−low)/2`.

---

## 🔄 Variations

1. **Search in Row‑Column Sorted Matrix** (`Search Matrix II`): use the *staircase* approach in *O(n+m)*.
2. **kth Smallest in Row‑Major Sorted Matrix**: binary search on value domain or min‑heap of size `n`.
3. **Find Insert Position** in a sorted matrix (lower bound style).

---

## ❓ FAQs

> **Q1. Why not merge all rows into a vector and then binary search?**
> That uses *O(n·m)* extra space. Flattening by index mapping is O(1).

> **Q2. Can this handle duplicates?**
> Yes—it will find one occurrence and return `true`.

> **Q3. What if the row beginnings aren’t strictly greater than the previous row’s end?**
> Then the matrix isn’t fully row‑major sorted—this method no longer applies.

> **Q4. How to adapt if it’s sorted column‑major?**
> You’d map 2D → 1D as `i + j*n` instead of `i*m + j`.

---
