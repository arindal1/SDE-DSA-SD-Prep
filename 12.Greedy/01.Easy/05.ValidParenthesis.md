# ðŸ§µ Valid Parenthesis String [#678](https://leetcode.com/problems/valid-parenthesis-string/description/)


## ðŸ“Œ Problem Statement

You are given a string `s` containing only:

* `'('`
* `')'`
* `'*'`

Rules for `'*'`:

* It can act as `'('`
* Or as `')'`
* Or as an empty string `""`

ðŸŽ¯ **Goal:**
Return `true` if the string can be interpreted as a **valid parentheses string**, otherwise `false`.


### What is a valid parentheses string?

* Parentheses must be balanced.
* At no point can `')'` exceed `'('`.
* Total `'('` must equal total `')'`.


## ðŸ§  Intuition

This problem is tricky because `'*'` is **flexible**.

Instead of deciding what each `'*'` is immediately, we:

> Track the **range of possible open parentheses counts**.

At every point:

* `minOpen` = minimum number of open `'('` we *must* have
* `maxOpen` = maximum number of open `'('` we *could* have

If at any point:

* `maxOpen < 0` â†’ too many closing brackets â†’ impossible

At the end:

* If `minOpen == 0` â†’ we can fully balance parentheses


## ðŸªœ Why Not Brute Force?

Brute force would:

* Try every combination of `'*'` â†’ `'('`, `')'`, or `""`
* Exponential time: `O(3^n)` ðŸ˜µ

DP also exists but is more complex.

Greedy gives:

* `O(n)` time
* `O(1)` space


## ðŸš€ Greedy Strategy (Key Insight)

Think in **ranges**:

* `'('` â†’ definitely increases open count
* `')'` â†’ definitely decreases open count
* `'*'` â†’ could increase, decrease, or do nothing

So:

| Character | minOpen | maxOpen |
| --------- | ------- | ------- |
| `'('`     | +1      | +1      |
| `')'`     | âˆ’1      | âˆ’1      |
| `'*'`     | âˆ’1      | +1      |

We clamp `minOpen` to `0` because:

* You canâ€™t have negative open parentheses in a valid interpretation.


## ðŸ§© Code Walkthrough

Your solution:

```cpp
class Solution {
public:
    bool checkValidString(string s) {
        int minOpen = 0, maxOpen = 0;

        for (char c : s) {
            if (c == '(') {
                minOpen++;
                maxOpen++;
            } else if (c == ')') {
                minOpen--;
                maxOpen--;
            } else {
                minOpen--;
                maxOpen++;
            }
            if (maxOpen < 0) return false;
            minOpen = max(minOpen, 0);
        }
        return minOpen == 0;
    }
};
```

Letâ€™s unpack this step by step ðŸ‘‡


### 1ï¸âƒ£ Initialization

```cpp
int minOpen = 0, maxOpen = 0;
```

* Both start at zero (no open brackets yet).


### 2ï¸âƒ£ Iterate Through String

```cpp
for (char c : s)
```

Process one character at a time.


### 3ï¸âƒ£ Handle Each Character

#### Case `'('`

```cpp
minOpen++;
maxOpen++;
```

Must open a bracket.


#### Case `')'`

```cpp
minOpen--;
maxOpen--;
```

Must close a bracket.


#### Case `'*'`

```cpp
minOpen--;
maxOpen++;
```

* `'*'` could be `')'` â†’ decreases open count
* Or `'('` â†’ increases open count
* Or empty â†’ stays same (handled implicitly by range)


### 4ï¸âƒ£ Early Failure Check

```cpp
if (maxOpen < 0) return false;
```

Even in the **best case**, we have more closing brackets than opening ones â†’ invalid.


### 5ï¸âƒ£ Clamp Minimum Open Count

```cpp
minOpen = max(minOpen, 0);
```

We never allow `minOpen` to go negative:

* Negative opens mean we assume some `'*'` acted as empty or `'('`.


### 6ï¸âƒ£ Final Check

```cpp
return minOpen == 0;
```

If the **minimum possible open parentheses** is `0`, then:

* There exists at least one interpretation that balances perfectly.


## ðŸ§ª Dry Run Examples

### Example 1

```cpp
s = "()"
```

| char | minOpen | maxOpen |
| ---- | ------- | ------- |
| '('  | 1       | 1       |
| ')'  | 0       | 0       |

âœ” `minOpen == 0` â†’ valid


### Example 2

```cpp
s = "(*)"
```

| char | minOpen | maxOpen |
| ---- | ------- | ------- |
| '('  | 1       | 1       |
| '*'  | 0       | 2       |
| ')'  | 0       | 1       |

âœ” valid


### Example 3

```cpp
s = "(*))"
```

| char | minOpen | maxOpen |
| ---- | ------- | ------- |
| '('  | 1       | 1       |
| '*'  | 0       | 2       |
| ')'  | 0       | 1       |
| ')'  | 0       | 0       |

âœ” valid


### Example 4 (Invalid)

```cpp
s = "())*"
```

At some point:

```cpp
maxOpen < 0
```

âŒ invalid


## â±ï¸ Time & Space Complexity

| Metric | Value    |
| ------ | -------- |
| Time   | **O(n)** |
| Space  | **O(1)** |

Optimal.


## ðŸ§  Why This Greedy Works (Proof Intuition)

* `minOpen` tracks the **worst-case** (most closing usage of `'*'`)
* `maxOpen` tracks the **best-case** (most opening usage of `'*'`)
* If `0` lies inside this range at the end, a valid configuration exists.

We delay decisions until the end â€” the essence of greedy correctness.


## ðŸ™‹ FAQs

### â“ Why do we only check `maxOpen < 0`?

If even the **best-case scenario** is invalid, no interpretation can work.

### â“ Why clamp `minOpen` to zero?

Because negative opens donâ€™t make sense â€” we assume `'*'` compensated.

### â“ Is stack needed?

Nope. This greedy solution replaces stack logic completely.

### â“ Can this be solved using DP?

Yes, but DP is `O(nÂ²)` and unnecessary.

