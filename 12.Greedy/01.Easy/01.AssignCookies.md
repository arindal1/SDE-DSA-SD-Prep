# ğŸª Assign Cookies [#455](https://leetcode.com/problems/assign-cookies/description/)


## ğŸ“Œ Problem Statement

Youâ€™re given:

* An array `g` where `g[i]` is the **greed factor** of the `i`-th child.
* An array `s` where `s[j]` is the **size of the j-th cookie**.

Rules:

* A child `i` will be satisfied **only if** they get a cookie of size `â‰¥ g[i]`.
* Each child can receive **at most one** cookie.
* Each cookie can be assigned to **at most one** child.

ğŸ¯ **Goal:**
Maximize the number of *content* (satisfied) children and return that count.


## ğŸ§  Intuition

This is a perfect greedy setup:

* Some kids are *more* greedy than others.
* Bigger cookies can satisfy more demanding kids.
* If you give a big cookie to a kid who wouldâ€™ve been fine with a small one, you might waste it.

So the idea is:

> Always try to satisfy the **least greedy** child with the **smallest possible** cookie that works.

This way, you:

* Use small cookies for small greed.
* Save large cookies for large greed.
* Maximize total satisfied kids.

Thatâ€™s basically how you survive in a hostel mess line too ğŸ˜†


## ğŸªœ Brute Force Idea (Not Optimal)

### Approach

For each child:

* Try all available cookies.
* Assign a suitable one (size â‰¥ greed) not already used.
* Count satisfied children.

This is basically:

* Matching children to cookies in a nested loop.

### Complexity

* `O(n * m)` in worst case (n = number of children, m = number of cookies).

Still okay for small sizes, but not great when both are large.

We can do much better using sorting + two pointers.


## ğŸš€ Optimal Greedy Approach (Your Code)

### High-Level Strategy

1. Sort `g` (children's greed) in ascending order.
2. Sort `s` (cookies sizes) in ascending order.
3. Use two pointers:

   * `l` â†’ index on `g` (current child)
   * `r` â†’ index on `s` (current cookie)
4. While both pointers are in range:

   * If `s[r] >= g[l]` â†’ cookie can satisfy child:

     * Assign cookie: `l++`, `r++`, `cnt++`
   * Else â†’ cookie is too small, move to next cookie: `r++`
5. Return `cnt`.

Greedy logic:

* Always try to satisfy the **current smallest greed** child.
* Always use the **smallest cookie** that can satisfy them.
* If a cookie is too small even for the *least* greedy child â†’ itâ€™s useless â†’ skip it.


## ğŸ§© Code Walkthrough

Letâ€™s break it down ğŸ‘‡


### 1ï¸âƒ£ Sorting

```cpp
sort(g.begin(), g.end());
sort(s.begin(), s.end());
```

After sorting:

* `g` is from **least greedy** to **most greedy**.
* `s` is from **smallest cookie** to **largest cookie**.

This lets us try to match the smallest requirements first.


### 2ï¸âƒ£ Two Pointers

```cpp
int l = 0, r = 0;
```

* `l` â†’ index over `g` (children)
* `r` â†’ index over `s` (cookies)


### 3ï¸âƒ£ Main Loop

```cpp
while (l < n && r < m) {
    if (s[r] >= g[l]) {
        l++;
        r++;
        cnt++;
    } else {
        r++;
    }
}
```

Case analysis:

* **If `s[r] >= g[l]`**
  Current cookie can satisfy the current child.

  So we:

  * Assign it â†’ `cnt++`
  * Move to next child â†’ `l++`
  * Move to next cookie â†’ `r++`

* **Else (`s[r] < g[l]`)**
  Even the *least* greedy remaining child canâ€™t be satisfied by this cookie â†’ itâ€™s too small.

  So:

  * We skip the cookie â†’ `r++`

Loop stops when:

* We run out of children (`l == n`), or
* We run out of cookies (`r == m`).


### 4ï¸âƒ£ Final Answer

```cpp
return cnt;
```

`cnt` holds the number of children we managed to satisfy ğŸªğŸ˜„


## ğŸ§ª Example Dry Run

### Example

```cpp
g = [1, 2, 3]
s = [1, 1]
```

After sorting (already sorted here):

* `g = [1, 2, 3]`
* `s = [1, 1]`

Start:

* `l = 0` (child with greed 1)
* `r = 0` (cookie size 1)
* `cnt = 0`

Step-by-step:

1ï¸âƒ£ `s[0] = 1`, `g[0] = 1` â†’ `1 >= 1` âœ…
â†’ satisfy child 0
â†’ `l = 1`, `r = 1`, `cnt = 1`

2ï¸âƒ£ `s[1] = 1`, `g[1] = 2` â†’ `1 >= 2` âŒ
â†’ cookie too small
â†’ `r = 2`

Now `r == m`, loop ends.

Answer: `cnt = 1` â†’ only 1 child satisfied.


Another one:

```cpp
g = [10, 9, 8, 7]
s = [5, 6, 7, 8]
```

Sorted:

* `g = [7, 8, 9, 10]`
* `s = [5, 6, 7, 8]`

Matches:

* `5` < `7` â†’ skip cookie
* `6` < `7` â†’ skip cookie
* `7` â‰¥ `7` â†’ satisfy 1
* `8` â‰¥ `8` â†’ satisfy 2

Final result: `2` satisfied children.


## â±ï¸ Time & Space Complexity

Let:

* `n = g.size()` (children)
* `m = s.size()` (cookies)

### Time

* Sorting `g`: `O(n log n)`
* Sorting `s`: `O(m log m)`
* Single pass with two pointers: `O(n + m)`

ğŸ‘‰ **Total:** `O(n log n + m log m)`

### Space

* Sorting in-place â†’ `O(1)` extra (ignoring sortâ€™s internal stack)


### âœ… Correctness Intuition (Greedy Proof Sketch)

Why is this greedy strategy correct?

* By sorting both arrays, we always try to satisfy the **minimum greed** child first.
* We give them the **smallest cookie** that can satisfy them.
* If a cookie cannot satisfy the current child, it cannot satisfy any later child (since later children are more greedy), so itâ€™s safe to skip.

We never â€œregretâ€ assigning a cookie this way.
Thatâ€™s what greedy correctness is about.


## ğŸ™‹ FAQs

### ğŸ“ Q1: What if there are more cookies than children?

No problem.

* The loop stops once we run out of children (`l == n`).
* Extra cookies are unused.


### ğŸ“ Q2: What if there are more children than cookies?

We just satisfy as many as we can.

* Loop ends when `r == m` (out of cookies).
* `cnt` is simply the max number of children we can satisfy.


### ğŸ“ Q3: Why not start from the end (most greedy / biggest cookie)?

You *could* also:

* Sort both arrays ascending.
* Start from the **end** (largest greed and largest cookie).
* Try to satisfy the greediest child first.

That works too. Your approach (smallest-first) is just as valid and often feels more natural.


### ğŸ“ Q4: Can this work with negative values?

In classic constraints, `g[i]` and `s[j]` are non-negative.
If they were negative (weird interpretation), the logic still works as long as comparison `s[r] >= g[l]` is meaningful.

