# ğŸ‹ Lemonade Change [#860](https://leetcode.com/problems/lemonade-change/description/)

## ğŸ“Œ Problem Statement

You run a lemonade stand. Each lemonade costs **$5**.

Customers come one by one, and each pays with:

* `$5`
* `$10`
* or `$20`

You must give back **the correct change** using the bills you currently have.

ğŸ¯ Goal:
Return **true** if you can give correct change to every customer, otherwise **false**.


## ğŸ§  Intuition

Every lemonade costs **$5**, so possible scenarios:

| Customer pays | Needed change |
| ------------- | ------------- |
| $5            | $0            |
| $10           | $5            |
| $20           | $15           |

This is purely a **change-making** problem â€” and the key insight is:

> Use **greedy** choices to always give change using the largest bills possible.

Why?
Because giving bigger bills preserves small ($5) bills for future transactions.

## ğŸ” Change Strategy

For a **$10 bill**:

* Must give back **one $5**.

For a **$20 bill**:

* Prefer giving **$10 + $5**
  (conserves more $5 bills)
* If not possible â†’ give **three $5s**
* Otherwise â†’ fail


## ğŸš« Brute Force

Simulate all possible ways of giving change.
This explodes combinatorially - very inefficient.

## ğŸš€ Optimal Greedy Approach

Track only:

* number of **$5** bills (`five`)
* number of **$10** bills (`ten`)

We **never** store $20 bills because they are not useful for making change.

Process each bill:

1. If customer pays with **$5** â†’ no change needed â†’ `five++`
2. If pays with **$10** â†’ must give back one `$5`
3. If pays with **$20**:

   * Prefer `$10 + $5`
   * Else try `3 Ã— $5`
   * Otherwise fail

This greedy logic is optimal and standard.


## ğŸ§± Code Walkthrough

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0, n = bills.size();

        for (int i = 0; i < n; ++i) {
            if (bills[i] == 5)
                five++;
            
            else if (bills[i] == 10) {
                if (five) {
                    five--;
                    ten++;
                } else
                    return false;
            } 
            
            else { // 20-dollar bill
                if (five && ten) {
                    five--;
                    ten--;
                } else if (five >= 3) {
                    five -= 3;
                } else {
                    return false;
                }
            }
        }

        return true;
    }
};
```


## ğŸ§© Dry Run Example

### Input:

```
bills = [5, 5, 5, 10, 20]
```

### Simulation

| Step | Customer pays | Action      | five | ten |
| ---- | ------------- | ----------- | ---- | --- |
| 1    | 5             | take        | 1    | 0   |
| 2    | 5             | take        | 2    | 0   |
| 3    | 5             | take        | 3    | 0   |
| 4    | 10            | give 5      | 2    | 1   |
| 5    | 20            | give 10 + 5 | 1    | 0   |

Result â†’ **true** âœ”


## ğŸ§ª More Test Cases

### Case 1

`[5,5,10,10,20]`

Fails because when last 20 comes:

* Must give `$10 + $5` but no $5 is left
* `$5 Ã— 3` also not possible
  â†’ return **false**



### Case 2

`[5,10,5,20]`

Works:

* 5 â†’ no change
* 10 â†’ give 5
* 5 â†’ no change
* 20 â†’ give `10 + 5`


### Case 3

`[10]`

Fails immediately â†’ return **false** (no $5)



## â±ï¸ Time & Space Complexity

| Complexity | Value                    |
| ---------- | ------------------------ |
| Time       | **O(n)** â€” single pass   |
| Space      | **O(1)** â€” only counters |

Super efficient.



## ğŸ™‹ FAQ

### â“ Why always give `$10 + $5` before `3 Ã— $5`?

Because:

* $5 bills are needed for many future payments (especially for $10 customers)
* Using a $10 bill now is optimal because it reduces immediate 5-bill consumption

This is the key greedy insight.


### â“ Why donâ€™t we store $20 bills?

You canâ€™t use a $20 bill to give change for anyone, so storing them is pointless.


### â“ Can this fail even if total money is enough?

Yes!
You need **exact denominations**, not total value.

Example:

```
[5,5,20,20]
```

Total cash is 50, but you lack the correct change for the second 20.
