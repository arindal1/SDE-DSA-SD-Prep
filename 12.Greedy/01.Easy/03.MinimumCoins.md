# üí∞ Minimum Number of Coins / Notes [[TuF](https://takeuforward.org/plus/dsa/problems/minimum-coins)]


## üìå Problem Statement

Given a value `V`, you are provided with currency denominations:

```
{1, 2, 5, 10, 20, 50, 100, 500, 1000}
```

üéØ **Goal:**
Find the **minimum number of coins/notes** required to make the value `V`.


## üß† Intuition

This is a classic **greedy coin change** problem.

Key idea:

> Always pick the **largest denomination** that does not exceed the remaining value.

Why this works (for these denominations):

* Indian currency is a **canonical coin system**
* Greedy choice always leads to an optimal solution

Think like an ATM üí≥:

* It gives you the largest notes first to minimize total notes.


## ü™ú Brute Force / DP Approach (Not Needed Here)

General coin change can be solved with:

* Dynamic Programming: `O(V √ó n)`

But for **fixed canonical denominations**, greedy is:

* Faster
* Simpler
* Optimal


## ‚úÖ Clean Final Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int coinChange(int V) {
    vector<int> notes = {1, 2, 5, 10, 20, 50, 100, 500, 1000};
    int n = notes.size();
    
    int cnt = 0;
    int val = V;
    int i = n - 1;  // start from largest denomination

    while (i >= 0 && val > 0) {
        if (notes[i] <= val) {
            val -= notes[i];
            cnt++;
        } else {
            i--;
        }
    }

    return cnt;
}

int main() {
    int V = 121;
    cout << coinChange(V) << endl;
    return 0;
}
```


## üß© Code Walkthrough

### 1Ô∏è‚É£ Denominations

```cpp
vector<int> notes = {1, 2, 5, 10, 20, 50, 100, 500, 1000};
```

Sorted in ascending order (already).

### 2Ô∏è‚É£ Start from Largest Note

```cpp
int i = n - 1;
```

We always try the **largest possible note first**.


### 3Ô∏è‚É£ Greedy Loop

```cpp
while (i >= 0 && val > 0) {
```

Continue while:

* Notes remain
* Value is not fully constructed


### 4Ô∏è‚É£ Take Note or Move On

```cpp
if (notes[i] <= val) {
    val -= notes[i];
    cnt++;
} else {
    i--;
}
```

* If current note fits ‚Üí take it
* Else ‚Üí try next smaller note


### 5Ô∏è‚É£ Return Answer

```cpp
return cnt;
```

Total number of notes used.


## üß™ Dry Run Example

### Input

```cpp
V = 121
```

### Step-by-step

| Remaining Value | Note Used | Count |
| --------------- | --------- | ----- |
| 121             | 100       | 1     |
| 21              | 20        | 2     |
| 1               | 1         | 3     |
| 0               | done      |       |

### Output

```
3
```

‚úî Correct


### Another Example

```cpp
V = 2753
```

Breakdown:

* 1000 √ó 2 ‚Üí 2000
* 500 √ó 1 ‚Üí 2500
* 100 √ó 2 ‚Üí 2700
* 50 √ó 1 ‚Üí 2750
* 2 √ó 1 ‚Üí 2752
* 1 √ó 1 ‚Üí 2753

Total notes = **8**

## ‚è±Ô∏è Time & Space Complexity

| Metric | Value                                  |
| ------ | -------------------------------------- |
| Time   | **O(n)** (n = number of denominations) |
| Space  | **O(1)**                               |

Super efficient.


## üß† Why Greedy Works Here

Greedy coin change works **only** for special coin systems.

Indian currency is **canonical**, meaning:

* Any optimal solution can be built by greedy choices.

‚ö†Ô∏è Counter-example (where greedy fails):

```cpp
Coins = {1, 3, 4}
Value = 6
```

Greedy:

* 4 + 1 + 1 ‚Üí 3 coins ‚ùå

Optimal:

* 3 + 3 ‚Üí 2 coins ‚úÖ

So greedy is **not universally correct**, but it *is* correct here.


## üôã FAQs

### ‚ùì Why not use DP?

DP is overkill when denominations are fixed and canonical.


### ‚ùì Can this return wrong answer for other coin systems?

Yes. Greedy works **only** for certain systems.


### ‚ùì Why count notes one by one instead of division?

We *can* optimize:

```cpp
cnt += val / notes[i];
val %= notes[i];
```

But our approach is still correct and simple.


## ‚ú® Optimized Version (Optional)

```cpp
int coinChange(int V) {
    vector<int> notes = {1,2,5,10,20,50,100,500,1000};
    int cnt = 0;

    for (int i = notes.size() - 1; i >= 0; --i) {
        cnt += V / notes[i];
        V %= notes[i];
    }

    return cnt;
}
```

Same logic, fewer iterations.
