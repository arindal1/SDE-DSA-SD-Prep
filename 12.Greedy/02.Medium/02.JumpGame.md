# ğŸ¦˜ Jump Game [#55](https://leetcode.com/problems/jump-game/description/)

## ğŸ“Œ Problem Statement

You are given an integer array `nums` where:

* `nums[i]` represents the **maximum jump length** you can make from index `i`.

You start at index `0`.

ğŸ¯ **Goal:**
Return `true` if you can reach the **last index**, otherwise return `false`.


### Example

```text
Input: nums = [2,3,1,1,4]
Output: true
Explanation: 0 â†’ 1 â†’ 4
```

```text
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You get stuck at index 3
```


## ğŸ§  Intuition

Think of this as **range expansion**.

* At every index `i`, you can reach up to `i + nums[i]`.
* The key idea is:

> Track the **farthest index** you can reach so far.

If at any point:

* Your current index `i` is **beyond** the farthest reachable index â†’ youâ€™re stuck â†’ return `false`.

Otherwise:

* Keep updating the farthest reach.

This greedy idea works because:

* If an index is reachable, then **all indices before it are also reachable**.
* You donâ€™t need to care *how* you got there â€” only **how far you can go**.


## ğŸªœ Brute Force Approach (Why We Donâ€™t Use It)

### Idea

From each index, recursively try all jumps from `1` to `nums[i]`.

### Complexity

* Exponential time: `O(2^n)` in worst case.
* Causes TLE for large inputs.

Even with memoization (DP), youâ€™d get `O(n^2)`.

Greedy is better and simpler ğŸ˜Œ


## ğŸš€ Optimal Greedy Approach

### Strategy

* Maintain a variable `ind` = **farthest index reachable so far**.
* Start from index `0`.
* Iterate through the array:

  * If `i > ind` â†’ unreachable â†’ return `false`.
  * Update `ind = max(ind, i + nums[i])`.
  * If `ind >= n - 1` â†’ we can reach the end â†’ return `true`.

Thatâ€™s it. One pass.


## ğŸ§© Code Walkthrough

Your solution:

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size(), ind = 0;

        if (n == 1)
            return true;

        for (int i = 0; i < n; ++i) {
            if (i > ind) {
                return false;
            }
            if (ind == n - 1)
                return true;

            ind = max(ind, i + nums[i]);
        }

        return true;
    }
};
```

Letâ€™s break this down ğŸ‘‡


### 1ï¸âƒ£ Initialization

```cpp
int n = nums.size(), ind = 0;
```

* `ind` = farthest index reachable so far.
* Initially, weâ€™re at index `0`.


### 2ï¸âƒ£ Base Case

```cpp
if (n == 1)
    return true;
```

Only one element â†’ already at the end.


### 3ï¸âƒ£ Main Loop

```cpp
for (int i = 0; i < n; ++i) {
```

We iterate index by index, expanding reach.


### 4ï¸âƒ£ Stuck Condition

```cpp
if (i > ind) {
    return false;
}
```

If current index is beyond our reach:

* We canâ€™t even stand here.
* So reaching the end is impossible.

Immediate failure ğŸš«


### 5ï¸âƒ£ Early Exit Optimization

```cpp
if (ind == n - 1)
    return true;
```

If weâ€™ve already reached the last index, stop early.

*(This check is optional â€” logic still works without it.)*


### 6ï¸âƒ£ Update Reach

```cpp
ind = max(ind, i + nums[i]);
```

From index `i`, the farthest we can reach is `i + nums[i]`.

We keep the maximum over all indices visited so far.


### 7ï¸âƒ£ Final Return

```cpp
return true;
```

If the loop completes without getting stuck â†’ we reached the end.


## ğŸ§ª Dry Run Examples

### Example 1

```cpp
nums = [2,3,1,1,4]
```

| i | nums[i] | ind (before) | ind (after)      |
| - | ------- | ------------ | ---------------- |
| 0 | 2       | 0            | 2                |
| 1 | 3       | 2            | 4                |
| â†’ | â†’       | â†’            | reach last index |

Return **true** âœ…


### Example 2

```cpp
nums = [3,2,1,0,4]
```

| i | nums[i] | ind         |
| - | ------- | ----------- |
| 0 | 3       | 3           |
| 1 | 2       | 3           |
| 2 | 1       | 3           |
| 3 | 0       | 3           |
| 4 | -       | âŒ `i > ind` |

Return **false** ğŸš«


## â±ï¸ Time & Space Complexity

| Metric | Value    |
| ------ | -------- |
| Time   | **O(n)** |
| Space  | **O(1)** |

One pass. Constant space. Perfect.


## ğŸ§  Why Greedy Works (Proof Sketch)

At any index `i`:

* If `i` is reachable, then any jump from `i` contributes to expanding the reachable range.
* Only the **farthest reach** matters â€” not the exact path.
* If an index is unreachable, no future index can help.

Thus, greedy tracking of max reach is optimal.


## ğŸ” Cleaner (Slightly Simplified) Version

Your code is correct.
Hereâ€™s a slightly cleaner variant commonly used in interviews:

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int reach = 0;

        for (int i = 0; i < nums.size(); ++i) {
            if (i > reach) return false;
            reach = max(reach, i + nums[i]);
        }
        return true;
    }
};
```

Same logic, fewer checks.


## ğŸ™‹ FAQs

### â“ Why not use DP?

DP works but is slower (`O(n^2)`) and unnecessary.


### â“ Can we stop early?

Yes! As soon as `reach >= n - 1`, you can return `true`.


### â“ What about negative values?

Problem constraints guarantee non-negative integers.


### â“ Is this related to Jump Game II?

Yes!

* **Jump Game I** â†’ *can you reach the end?*
* **Jump Game II** â†’ *minimum number of jumps to reach the end*

Both use greedy, but with different logic.
