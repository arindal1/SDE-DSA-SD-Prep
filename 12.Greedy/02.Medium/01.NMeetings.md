

# ğŸ¢ N Meetings in One Room



## ğŸ“Œ Problem Statement

You are given:

* An array `start[]` where `start[i]` is the start time of the `i-th` meeting
* An array `end[]` where `end[i]` is the end time of the `i-th` meeting
* An integer `n` = number of meetings

ğŸ“Œ **Rules:**

* Only **one meeting** can take place at a time.
* A meeting can start **only after** the previous one ends.

ğŸ¯ **Goal:**
Select the **maximum number of non-overlapping meetings** that can be scheduled in one room.

Return the **indices (1-based)** of the selected meetings.



## ğŸ§  Intuition

This is a pure **greedy scheduling** problem.

Key insight:

> To attend the maximum number of meetings, always pick the meeting that **ends earliest**.

Why?

* An early finishing meeting leaves **more room** for future meetings.
* Choosing a long meeting early blocks multiple short ones.

This is the same logic as:

* Movie scheduling ğŸ¬
* Classroom booking ğŸ«
* CPU task scheduling â±ï¸



## ğŸªœ Brute Force Approach (Why Not)

* Try all subsets of meetings.
* Check which subsets have no overlaps.
* Pick the largest valid subset.

â›” Complexity: `O(2^n)` â€” completely impractical.



## ğŸš€ Optimal Greedy Approach

### Strategy

1. Pair each meeting as:

   ```
   (end_time, start_time, index)
   ```
2. Sort meetings by **end time (ascending)**.
3. Pick the first meeting.
4. For each next meeting:

   * If its start time is **greater than** the last selected meetingâ€™s end time:

     * Select it.

This greedy choice guarantees the maximum number of meetings.



## ğŸ§© Code Walkthrough

Your implementation ğŸ‘‡

```cpp
vector<int> meetings(vector<int> &start, vector<int> &end, int n) {
    vector<tuple<int, int, int>> meeting;

    for (int i = 0; i < n; ++i) {
        meeting.push_back({end[i], start[i], i+1});
    }

    sort(meeting.begin(), meeting.end());
    vector<int> result;
    int lastEnd = -1;

    for (auto& m : meeting) {
        int e = get<0>(m);
        int s = get<1>(m);
        int ind = get<2>(m);

        if (s > lastEnd) {
            result.push_back(ind);
            lastEnd = e;
        }
    }

    return result;
}
```

Letâ€™s break this down step by step ğŸ‘‡



### 1ï¸âƒ£ Store Meetings as Tuples

```cpp
meeting.push_back({end[i], start[i], i+1});
```

Each meeting is stored as:

```
(end_time, start_time, meeting_index)
```

Why?

* Sorting by `end_time` becomes easy.
* `i+1` ensures **1-based indexing** in output.



### 2ï¸âƒ£ Sort by Ending Time

```cpp
sort(meeting.begin(), meeting.end());
```

Since tuples are sorted lexicographically:

* Primary key â†’ `end_time`
* Secondary key â†’ `start_time`

This ensures:

* Meetings finishing earlier come first.



### 3ï¸âƒ£ Initialize Tracking Variables

```cpp
vector<int> result;
int lastEnd = -1;
```

* `lastEnd` tracks the end time of the **last selected meeting**.
* Initialized to `-1` so the first meeting always fits.



### 4ï¸âƒ£ Select Meetings Greedily

```cpp
if (s > lastEnd) {
    result.push_back(ind);
    lastEnd = e;
}
```

We select a meeting if:

* Its start time is **strictly greater** than the last selected meetingâ€™s end time.

This avoids overlap.



### 5ï¸âƒ£ Return Selected Meetings

```cpp
return result;
```

The vector contains indices of meetings that can be scheduled.



## ğŸ§ª Dry Run Example

### Input

```cpp
start = {1, 3, 0, 5, 8, 5}
end   = {2, 4, 5, 7, 9, 9}
```

### Step 1: Create Tuples

```
(2,1,1)
(4,3,2)
(5,0,3)
(7,5,4)
(9,8,5)
(9,5,6)
```

### Step 2: Sort by End Time

```
(2,1,1)
(4,3,2)
(5,0,3)
(7,5,4)
(9,8,5)
(9,5,6)
```

### Step 3: Select Meetings

| Meeting | Start | End | Selected?    |
| - | -- | --- | --- |
| 1       | 1     | 2   | âœ…            |
| 2       | 3     | 4   | âœ…            |
| 3       | 0     | 5   | âŒ (overlaps) |
| 4       | 5     | 7   | âœ…            |
| 5       | 8     | 9   | âœ…            |
| 6       | 5     | 9   | âŒ            |

### Output

```
1 2 4 5
```

âœ” Maximum meetings = **4**



## â±ï¸ Time & Space Complexity

### Time Complexity

* Creating tuples â†’ `O(n)`
* Sorting â†’ `O(n log n)`
* Selection loop â†’ `O(n)`

ğŸ‘‰ **Total:** `O(n log n)`



### Space Complexity

* Extra storage for meetings â†’ `O(n)`
* Result array â†’ `O(n)`



## ğŸ§  Why Greedy Works (Proof Intuition)

* Suppose we pick a meeting that ends later than another available meeting.
* The later-ending meeting blocks future meetings unnecessarily.
* Replacing it with the earlier-ending meeting **never reduces** the number of meetings possible.

Thus:

> Choosing the meeting with the **earliest finish time** is always optimal.



## ğŸ™‹ FAQs

### â“ Why not sort by start time?

Because a meeting that starts early might end very late and block others.



### â“ Why `s > lastEnd` and not `s >= lastEnd`?

Depends on problem definition:

* If meetings that start exactly when another ends are allowed â†’ use `>=`
* Your code assumes **strict non-overlap**, which is fine.



### â“ Can multiple optimal answers exist?

Yes. Any valid maximum set is acceptable unless order is specified.



### â“ Is this related to interval scheduling?

Yes â€” this is the **classic interval scheduling problem**.



## âœ¨ Cleaner Version (Optional)

```cpp
vector<int> meetings(vector<int>& start, vector<int>& end, int n) {
    vector<pair<int,int>> v;
    for (int i = 0; i < n; i++) {
        v.push_back({end[i], i});
    }

    sort(v.begin(), v.end());

    vector<int> res;
    int lastEnd = -1;

    for (auto &p : v) {
        if (start[p.second] > lastEnd) {
            res.push_back(p.second + 1);
            lastEnd = end[p.second];
        }
    }

    return res;
}
```

Same idea, different representation.
