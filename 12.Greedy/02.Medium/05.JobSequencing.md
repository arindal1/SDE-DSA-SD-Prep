# üßë‚Äçüíº Job Sequencing with Deadlines [[TuF](https://takeuforward.org/plus/dsa/problems/job-sequencing-problem)]


## üìå Problem Statement

You are given `n` jobs.
Each job has:

* `id` ‚Üí job identifier
* `dead` ‚Üí deadline (latest time slot the job can be completed)
* `profit` ‚Üí profit earned if the job is completed before or on its deadline

üìå **Rules:**

* Each job takes **exactly 1 unit of time**.
* Only **one job can be done at a time**.
* A job must be completed **on or before its deadline** to earn profit.

üéØ **Goal:**
Schedule jobs to **maximize total profit** and return:

1. Number of jobs done
2. Maximum profit


## üß† Intuition

This is a **greedy scheduling** problem.

Key observations:

* If two jobs conflict (same time slot), you should do the one with **higher profit**.
* Deadlines restrict *when* a job can be done, not *how long* it takes.
* To maximize profit:

  > Always try to schedule **high-profit jobs first**, as late as possible before their deadlines.

Think of deadlines as parking slots:

* Each job wants a parking slot before its deadline.
* We give premium parking to the highest-paying customers üòÑ


## ü™ú Brute Force Approach (Why Not)

* Try all subsets of jobs.
* Try all permutations of each subset.
* Check which schedules are valid.
* Pick the one with max profit.

‚õî Time complexity: **O(n! √ó n)**
Totally impractical.


## üöÄ Optimal Greedy Approach

### Strategy

1. **Sort jobs by profit (descending)**.
2. Track available time slots.
3. For each job (highest profit first):

   * Try to schedule it in the **latest free slot ‚â§ deadline**.
4. If a slot is found:

   * Assign job
   * Add profit
   * Increase job count

Why latest slot?

* Leaves earlier slots free for jobs with smaller deadlines.


## üß© Code Walkthrough

Your implementation üëá

```cpp
struct Job {
    int id;
    int dead;
    int profit;
};
```

Each job has:

* `id`
* `dead` ‚Üí deadline
* `profit`


### 1Ô∏è‚É£ Sorting by Profit

```cpp
bool static comparison(Job a, Job b) {
    return (a.profit > b.profit);
}
```

Sort jobs so that:

* Highest profit job is considered first.


### 2Ô∏è‚É£ Sort the Jobs

```cpp
sort(arr, arr + n, comparison);
```

After sorting:

* Jobs are processed from **highest profit ‚Üí lowest profit**.


### 3Ô∏è‚É£ Find Maximum Deadline

```cpp
int maxi = arr[0].dead;
for (int i = 1; i < n; ++i) {
    maxi = max(maxi, arr[i].dead);
}
```

Why?

* We need to know how many time slots are required.
* Time slots range from `1` to `max_deadline`.


### 4Ô∏è‚É£ Slot Array Initialization

```cpp
int slot[maxi + 1];
for (int i = 0; i <= maxi; ++i) {
    slot[i] = -1;
}
```

* `slot[i] = -1` ‚Üí free
* `slot[i] = j` ‚Üí job index `j` assigned to time `i`

Index `0` is unused (jobs start from time `1`).


### 5Ô∏è‚É£ Schedule Jobs

```cpp
int countJobs = 0, jobProfit = 0;

for (int i = 0; i < n; ++i) {
    for (int j = arr[i].dead; j > 0; --j) {
        if (slot[j] == -1) {
            slot[j] = i;
            countJobs++;
            jobProfit += arr[i].profit;
            break;
        }
    }
}
```

For each job:

* Try slots from `deadline ‚Üí 1`
* Pick the **latest available slot**
* Assign job and update:

  * Job count
  * Total profit


### 6Ô∏è‚É£ Return Result

```cpp
return make_pair(countJobs, jobProfit);
```

Returns:

* Number of jobs done
* Maximum profit earned


## üß™ Example Dry Run

### Input

```cpp
Job arr[] = {
    {1, 4, 20},
    {2, 1, 10},
    {3, 2, 40},
    {4, 2, 30}
};
```

### Step 1: Sort by Profit

| Job | Deadline | Profit |
| --- | -------- | ------ |
| 3   | 2        | 40     |
| 4   | 2        | 30     |
| 1   | 4        | 20     |
| 2   | 1        | 10     |

### Step 2: Scheduling

| Job | Deadline | Slot Chosen               |
| --- | -------- | ------------------------- |
| 3   | 2        | 2                         |
| 4   | 2        | 1                         |
| 1   | 4        | 4                         |
| 2   | 1        | ‚ùå (slot 1 already filled) |

### Result

* Jobs done = **3**
* Profit = **40 + 30 + 20 = 90**

‚úî Output: `3 90`


## ‚è±Ô∏è Time & Space Complexity

### Time Complexity

* Sorting jobs: `O(n log n)`
* Slot assignment:

  * Worst case: `O(n * maxDeadline)`

Overall:

```
O(n log n + n * maxDeadline)
```


### Space Complexity

* Slot array: `O(maxDeadline)`
* No extra heavy structures


## üß† Why Greedy Works (Proof Intuition)

* If two jobs conflict for a time slot:

  * Picking the one with higher profit is always better.
* Scheduling jobs **as late as possible** avoids blocking earlier deadlines.

This ensures:

* Maximum utilization of slots
* Maximum profit


## ‚ú® Cleaner / Optimized Version (Using DSU ‚Äì Optional)

If deadlines are large, you can optimize slot search using **Disjoint Set Union (Union-Find)** to achieve:

```
O(n log n)
```

But for interviews, **our version is perfectly acceptable and clear** üëç


## üôã FAQs

### ‚ùì Why not schedule earliest deadline first?

Because profit matters more than deadline.
EDF optimizes completion time, not profit.


### ‚ùì Why check slots backward?

To preserve earlier slots for jobs with tighter deadlines.


### ‚ùì What if deadlines are huge?

Use:

* DSU optimization, or
* Priority queue-based scheduling.


### ‚ùì Can jobs have equal profit?

Yes ‚Äî order among equal-profit jobs doesn‚Äôt affect correctness.

