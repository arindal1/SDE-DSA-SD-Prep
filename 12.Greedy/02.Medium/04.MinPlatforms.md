# ðŸš‰ Minimum Number of Stations / Platforms



## ðŸ“Œ Problem Statement

You are given two arrays:

* `arr[]` â†’ arrival times of trains
* `dep[]` â†’ departure times of trains

ðŸ“Œ **Rules:**

* A train needs a station from its arrival until its departure.
* No train can wait â€” if a station isnâ€™t available, you must build a new one.

ðŸŽ¯ **Goal:**
Find the **minimum number of stations (platforms)** required so that **no train has to wait**.



### Example

```text
Arrival:   [900, 945, 955, 1100, 1500, 1800]
Departure: [920, 1200, 1130, 1150, 1900, 2000]

Output: 3
```



## ðŸ§  Intuition

This problem is really about **overlaps**.

Key idea:

> The minimum number of stations needed is the **maximum number of trains present at the station at the same time**.

So what do we do?

* When a train **arrives**, we need **one more station**
* When a train **departs**, we free up **one station**

If we track this carefully in time order, the **maximum number of simultaneous trains** is the answer.



## ðŸªœ Brute Force Approach (Inefficient)

For every train:

* Check how many other trains overlap with it.
* Track the maximum overlap.

â›” Time complexity: `O(nÂ²)`
Not scalable.



## ðŸš€ Optimal Greedy Approach

### Strategy

1. Sort arrival times.
2. Sort departure times.
3. Use **two pointers**:

   * `i` â†’ next arriving train
   * `j` â†’ next departing train
4. Maintain:

   * `stations` â†’ currently occupied stations
   * `result` â†’ maximum stations needed so far
5. Move pointers greedily based on which event happens next:

   * Arrival â†’ increment `stations`
   * Departure â†’ decrement `stations`



## ðŸ§© Code Walkthrough


```cpp
int numStations(vector<int> &arr, vector<int> &dep) {
    int n = arr.size(), stations = 1, result = 1;
    int i = 1, j = 0;

    sort(arr.begin(), arr.end());
    sort(dep.begin(), dep.end());

    while (i < n && j < n) {
        if (arr[i] <= dep[j]) {
            stations++;
            i++;
        } else {
            stations--;
            j++;
        }
        result = max(result, stations);
    }

    return result;
}
```

Letâ€™s break it down ðŸ‘‡



### 1ï¸âƒ£ Sort Arrival & Departure Times

```cpp
sort(arr.begin(), arr.end());
sort(dep.begin(), dep.end());
```

This allows us to process **events in chronological order**.



### 2ï¸âƒ£ Initialize Counters

```cpp
int stations = 1, result = 1;
int i = 1, j = 0;
```

* First train always needs one station.
* `i` points to the next arrival.
* `j` points to the earliest departure.



### 3ï¸âƒ£ Main Loop (Two Pointers)

```cpp
while (i < n && j < n) {
```

We process arrivals and departures in sorted order.



### 4ï¸âƒ£ Arrival Case

```cpp
if (arr[i] <= dep[j]) {
    stations++;
    i++;
}
```

If next train arrives **before or exactly when** another departs:

* We need a **new station**
* Increase `stations`



### 5ï¸âƒ£ Departure Case

```cpp
else {
    stations--;
    j++;
}
```

If a train departs before the next arrival:

* Free up a station
* Decrease `stations`



### 6ï¸âƒ£ Track Maximum

```cpp
result = max(result, stations);
```

This is the **peak station usage**, which is the answer.



### 7ï¸âƒ£ Return Result

```cpp
return result;
```



## ðŸ§ª Dry Run Example

### Input

```cpp
arr = [900, 945, 955, 1100, 1500, 1800]
dep = [920, 1200, 1130, 1150, 1900, 2000]
```

Already sorted.



### Simulation

| Event  | Time | Stations | Max |
| --- | --- | -- | --- |
| Arrive | 900  | 1        | 1   |
| Depart | 920  | 0        | 1   |
| Arrive | 945  | 1        | 1   |
| Arrive | 955  | 2        | 2   |
| Arrive | 1100 | 3        | 3   |
| Depart | 1130 | 2        | 3   |
| Depart | 1150 | 1        | 3   |
| Depart | 1200 | 0        | 3   |
| Arrive | 1500 | 1        | 3   |
| Arrive | 1800 | 2        | 3   |

âœ” Answer = **3**



## â±ï¸ Time & Space Complexity

| Metric | Value                          |
| --- | --- |
| Time   | **O(n log n)** (sorting)       |
| Space  | **O(1)** extra (in-place sort) |



## ðŸ§  Why Greedy Works

* We only care about **events in time order**.
* Sorting lets us simulate real-time behavior.
* Counting active trains gives us peak load.
* Peak load = minimum number of stations.

This greedy logic ensures **no waiting** and **minimum stations**.



## ðŸ™‹ FAQs

### â“ Why use `arr[i] <= dep[j]` instead of `<`?

This means:

* If a train arrives at the exact time another departs, we **still need a new station**.

If your problem allows reuse at the same time, change condition to:

```cpp
if (arr[i] < dep[j])
```



### â“ Can arrivals and departures be unsorted?

Yes â€” thatâ€™s why we sort them first.



### â“ Is this same as minimum platforms?

Yes. Stations, platforms â€” same logic.



### â“ Alternative approach?

Yes â€” using a **min-heap** of departure times (`O(n log n)`), but two pointers are simpler and faster.



## âœ¨ Cleaner Alternative (Event-Based)

```cpp
int minPlatforms(vector<int>& arr, vector<int>& dep) {
    sort(arr.begin(), arr.end());
    sort(dep.begin(), dep.end());

    int platforms = 0, maxPlatforms = 0;
    int i = 0, j = 0;

    while (i < arr.size()) {
        if (arr[i] <= dep[j]) {
            platforms++;
            i++;
        } else {
            platforms--;
            j++;
        }
        maxPlatforms = max(maxPlatforms, platforms);
    }

    return maxPlatforms;
}
```

Same logic, slightly different initialization.

