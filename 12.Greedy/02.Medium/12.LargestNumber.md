

# ğŸ”¢ Largest Number [#179](https://leetcode.com/problems/largest-number/)



## ğŸ“Œ Problem Statement

You are given an array of **non-negative integers** `nums`.

ğŸ¯ **Goal:**
Arrange them such that they form the **largest possible number** when concatenated, and return it as a **string**.



### Examples

```text
Input:  [10, 2]
Output: "210"
```

```text
Input:  [3, 30, 34, 5, 9]
Output: "9534330"
```



## ğŸ§  Intuition

This problem looks like sortingâ€¦ but not in the usual way.

The key insight:

> For two numbers `a` and `b`,
> decide which order gives a **larger concatenated result**:
>
> * `a + b`
> * `b + a`

Whichever is larger determines the order.

This local greedy decision guarantees a globally optimal arrangement.



## ğŸªœ Brute Force (Why Not)

* Generate all permutations of the array.
* Convert each permutation into a number.
* Return the maximum.

â›” Time complexity: `O(n!)` â€” completely infeasible.



## ğŸš€ Optimal Greedy Approach

### Strategy

1. Convert all integers to strings.
2. Sort them using a **custom comparator**:

   * `a` comes before `b` if `a + b > b + a`
3. Concatenate the sorted strings.
4. Handle edge case where result starts with `"0"`.



## ğŸ§© Code Walkthrough

Our implementation ğŸ‘‡

```cpp
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        vector<string> array;
        for (int num : nums) {
            array.push_back(to_string(num));
        }

        sort(array.begin(), array.end(), [](const string &a, const string &b) {
            return (b + a) < (a + b);
        });

        if (array[0] == "0") {
            return "0";
        }
        string largest;
        for (const string &num : array) {
            largest += num;
        }

        return largest;
    }
};
```

Letâ€™s unpack this step by step ğŸ‘‡



### 1ï¸âƒ£ Convert Integers to Strings

```cpp
vector<string> array;
for (int num : nums) {
    array.push_back(to_string(num));
}
```

Why?

* We need to **concatenate** numbers.
* Integer comparison alone doesnâ€™t work for cases like `3` and `30`.



### 2ï¸âƒ£ Custom Sorting Logic (Core Idea)

```cpp
sort(array.begin(), array.end(), [](const string &a, const string &b) {
    return (b + a) < (a + b);
});
```

This comparator means:

* Place `a` before `b` **if**

  ```
  a + b > b + a
  ```

Example:

```text
a = "3", b = "30"
a + b = "330"
b + a = "303"
â†’ "330" > "303"
â†’ "3" comes before "30"
```

This greedy rule is the heart of the solution.



### 3ï¸âƒ£ Handle All-Zero Edge Case

```cpp
if (array[0] == "0") {
    return "0";
}
```

Why?

If the largest element is `"0"`, then all elements are `"0"`.

Example:

```text
[0, 0, 0] â†’ "000" âŒ
```

Correct output:

```text
"0" âœ…
```



### 4ï¸âƒ£ Build Final Answer

```cpp
string largest;
for (const string &num : array) {
    largest += num;
}
```

Concatenate everything into the final result.



## ğŸ§ª Dry Run Example

### Example 1

```cpp
nums = [10, 2]
```

Converted:

```text
["10", "2"]
```

Comparison:

```text
"210" > "102"
```

Sorted:

```text
["2", "10"]
```

Result:

```text
"210"
```

âœ” Correct



### Example 2

```cpp
nums = [3, 30, 34, 5, 9]
```

After sorting (by comparator):

```text
["9", "5", "34", "3", "30"]
```

Concatenation:

```text
"9534330"
```

âœ” Correct



### Example 3 (Edge Case)

```cpp
nums = [0, 0, 0]
```

Sorted:

```text
["0", "0", "0"]
```

Return `"0"` (not `"000"`).



## â±ï¸ Time & Space Complexity

### Time Complexity

* Converting to string: `O(n)`
* Sorting: `O(n log n)`

  * Each comparison costs up to `O(k)` where `k` is max digit length

Overall:

```
O(n log n * k)
```



### Space Complexity

* String storage: `O(n * k)`
* Output string: `O(n * k)`



## ğŸ§  Why Greedy Works (Proof Intuition)

The comparator enforces:

* For any adjacent pair `(a, b)`, the order chosen gives the **maximum local contribution**.
* Any deviation would reduce the final number.

This is a classic **pairwise swap argument** used in greedy correctness proofs.



## ğŸ™‹ FAQs

### â“ Why not sort numerically?

Because:

```text
30 > 3  âŒ
but
"330" > "303" âœ…
```

Numeric comparison fails for concatenation problems.



### â“ Why return string, not integer?

The result may exceed 64-bit integer limits.



### â“ Is this stable sort dependent?

No. Comparator fully defines ordering.



### â“ Can this fail for large inputs?

No â€” this is the accepted optimal solution.

