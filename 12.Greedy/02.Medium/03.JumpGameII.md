# ðŸ¦˜ Jump Game II [#45](https://leetcode.com/problems/jump-game-ii/description/)

## ðŸ“Œ Problem Statement

You are given an array `nums` where:

* `nums[i]` represents the **maximum jump length** from index `i`.

You start at index `0`.

ðŸŽ¯ **Goal:**
Return the **minimum number of jumps** needed to reach the **last index**.

You are guaranteed that the last index is reachable.


### Examples

```text
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: 0 â†’ 1 â†’ 4
```

```text
Input: nums = [2,3,0,1,4]
Output: 2
```


## ðŸ§  Intuition

This is not about *whether* you can reach the end (Jump Game I), but about **how fast** you can get there.

Key idea:

> Treat each jump as expanding a **reachable range**.

Think in terms of **levels** (like BFS):

* Level 0: index `0`
* Level 1: all indices reachable in 1 jump
* Level 2: all indices reachable in 2 jumps
* â€¦

Each jump lets you move to the **farthest index possible** from the current range.


## ðŸªœ Brute Force (Why We Donâ€™t Use It)

### Recursive / DP approach

* From each index, try all possible jumps.
* Take the minimum jumps among all possibilities.

### Complexity

* DP time: `O(nÂ²)`
* Space: `O(n)`

Works, but greedy gives **O(n)** time and is cleaner.


## ðŸš€ Optimal Greedy Approach

### Core Strategy

Maintain a **sliding window** `[l, r]`:

* `[l, r]` represents the range of indices reachable with the current number of jumps.
* From this range, compute the **farthest** index reachable with **one more jump**.
* Move the window to the next range.
* Increment jump count.

This is essentially BFS on array indices, but implemented greedily.


## ðŸ§© Code Walkthrough

Your implementation:

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        int l = 0, r = 0, jumps = 0;

        while (r < n - 1) {
            int farthest = r;

            for (int i = l; i <= r; ++i) {
                long long reach = (long long)i + nums[i];
                farthest = max(farthest, (int)min(reach, (long long)n - 1));
            }

            l = r + 1;
            r = farthest;
            jumps++;
        }

        return jumps;
    }
};
```

Letâ€™s break it down step by step ðŸ‘‡


### 1ï¸âƒ£ Initialization

```cpp
int l = 0, r = 0, jumps = 0;
```

* `[l, r]` = indices reachable using `jumps` jumps
* Initially:

  * `l = r = 0` (only index 0 is reachable)
  * `jumps = 0`


### 2ï¸âƒ£ Loop Condition

```cpp
while (r < n - 1)
```

* Continue until the **last index** is inside the reachable range.


### 3ï¸âƒ£ Compute Farthest Reach in Next Jump

```cpp
int farthest = r;

for (int i = l; i <= r; ++i) {
    long long reach = (long long)i + nums[i];
    farthest = max(farthest, (int)min(reach, (long long)n - 1));
}
```

* For all indices in the current range `[l, r]`:

  * Calculate how far you can jump from each.
  * Track the maximum reachable index (`farthest`).

This tells us how far we can reach with **one more jump**.


### 4ï¸âƒ£ Move to Next Level

```cpp
l = r + 1;
r = farthest;
jumps++;
```

* Update the window to the next range:

  * New range = indices reachable in `jumps + 1`
* Increment jump count.

This mimics BFS level expansion.


### 5ï¸âƒ£ Return Answer

```cpp
return jumps;
```

Once the last index is within reach, return the total jumps used.


## ðŸ§ª Dry Run Example

### Example

```cpp
nums = [2,3,1,1,4]
```

| Jump | Range `[l, r]` | Reachable Indices | New `r` |
| ---- | -------------- | ----------------- | ------- |
| 0    | [0,0]          | from 0 â†’ 2        | 2       |
| 1    | [1,2]          | max(1+3, 2+1) = 4 | 4       |
| end  | r â‰¥ n-1        | stop              |         |

Answer: **2 jumps** âœ…


### Another Example

```cpp
nums = [2,3,0,1,4]
```

| Jump | Range   | Farthest          |
| ---- | ------- | ----------------- |
| 0    | [0,0]   | 2                 |
| 1    | [1,2]   | max(1+3, 2+0) = 4 |
| end  | reached |                   |

Answer: **2**


## â±ï¸ Time & Space Complexity

| Metric | Value    |
| ------ | -------- |
| Time   | **O(n)** |
| Space  | **O(1)** |

Each index is processed **at most once** across all ranges.


## ðŸ§  Why This Greedy Works

* At each jump, you **delay committing** to a specific index.
* Instead, you explore **all options in the current range**.
* You only commit when the jump is inevitable.

This ensures:

* Minimum number of jumps.
* No wasted steps.

This is greedy + BFS intuition combined.


## âœ¨ Cleaner Greedy Variant (Common Interview Version)

Same logic, fewer variables:

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int jumps = 0, curEnd = 0, curFarthest = 0;

        for (int i = 0; i < nums.size() - 1; ++i) {
            curFarthest = max(curFarthest, i + nums[i]);

            if (i == curEnd) {
                jumps++;
                curEnd = curFarthest;
            }
        }

        return jumps;
    }
};
```

### Mapping to your version

| Your Code       | Cleaner Version     |
| --------------- | ------------------- |
| `l, r`          | current level range |
| `farthest`      | `curFarthest`       |
| level increment | `jumps++`           |

Both are equally correct.


## ðŸ™‹ FAQs

### â“ Why not greedily jump to the farthest index immediately?

Because a later index in the same range may give a **better next reach**.

We wait until weâ€™ve evaluated all options in the current jump window.


### â“ Is the end always reachable?

Yes, per problem constraints.

If it wasnâ€™t, youâ€™d need an additional check like Jump Game I.


### â“ Is this BFS?

Conceptually yes â€” but implemented greedily in `O(n)` without a queue.


### â“ Why use `long long` in reach?

Safety against overflow for large `i + nums[i]`.


