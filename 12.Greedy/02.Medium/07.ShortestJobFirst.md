# ‚ö° Shortest Job First

## üìå Problem statement

Given an array of job durations (positive integers), schedule the jobs to minimize **average waiting time**.
Return the **average waiting time** (mean of wait times for all jobs).

* A job‚Äôs **waiting time** = time it waits in the queue before starting execution.
* For a non-preemptive SJF schedule (we run each job to completion once started), the optimal strategy to minimize average waiting time is:

  > Execute jobs in **ascending order of duration**.


## üß† Intuition

If short jobs go first, later jobs wait less overall.
Putting a long job early makes many small jobs wait a long time ‚Äî which increases average waiting time. SJF avoids that by always running the shortest remaining job next.

This is the same intuition behind Huffman-ish greedy scheduling: small-first minimizes cumulative waiting.


## ‚úÖ Brute-force approach (inefficient)

* Try every permutation of jobs.
* Compute average waiting for each permutation.
* Pick minimum.

Time complexity: `O(n! * n)` ‚Äî infeasible for `n > 10`.


## üöÄ Optimal approach (greedy SJF)

1. Sort job durations in ascending order.
2. Simulate running jobs in this order.
3. Track:

   * `totTime` = completion time (cumulative sum of durations processed so far)
   * `waitSum` = sum of waiting times:

     * For job `i`, waiting time = time before it starts = sum of durations of jobs before it = `totTime` before adding `arr[i]`
4. Average waiting time = `waitSum / n`.

This is exactly what the provided code attempts ‚Äî with a few small but important fixes needed.



## ‚úÖ CPP Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

// Returns average waiting time (double) for non-preemptive SJF schedule
double shortestJobAverageWaitingTime(const vector<int> &jobs) {
    int n = jobs.size();
    if (n == 0) return 0.0;

    vector<int> arr = jobs;          // work on a copy
    sort(arr.begin(), arr.end());    // SJF: shortest first

    long long elapsed = 0;           // time elapsed / completion time so far
    long long waitSum = 0;           // sum of waiting times (use long long to be safe)

    for (int i = 0; i < n; ++i) {
        // Job i waits the time elapsed so far before it starts
        waitSum += elapsed;
        elapsed += arr[i];           // run job i
    }

    return static_cast<double>(waitSum) / n;
}

int main() {
    vector<int> jobs = {3, 1, 4, 2, 5};

    cout.setf(std::ios::fixed);     // print with fixed precision
    cout << setprecision(6);        // 6 decimal places
    cout << shortestJobAverageWaitingTime(jobs) << endl;

    // More tests
    cout << shortestJobAverageWaitingTime({}) << endl;               // 0.0 (no jobs)
    cout << shortestJobAverageWaitingTime({10}) << endl;            // 0.0 (only one job, no waiting)
    cout << shortestJobAverageWaitingTime({1,1,1,1}) << endl;       // 0.000000
    cout << shortestJobAverageWaitingTime({10, 1, 1}) << endl;      // shorter jobs first -> small avg

    return 0;
}
```

### Example (for `jobs = {3,1,4,2,5}`)

Sorted order: `{1,2,3,4,5}`
Waiting times:

* job 1 (1): waits `0`
* job 2 (2): waits `1`
* job 3 (3): waits `1+2 = 3`
* job 4 (4): waits `1+2+3 = 6`
* job 5 (5): waits `1+2+3+4 = 10`
  Sum = `0 + 1 + 3 + 6 + 10 = 20`
  Average = `20 / 5 = 4.0`

So output: `4.000000`


## ‚è± Complexity

* Sorting: `O(n log n)`
* Summation loop: `O(n)`
* **Total time:** `O(n log n)`
* **Space:** `O(n)` if we copy jobs, `O(1)` extra otherwise (in-place sort).


## üß† Variations & Notes

* **Minimize turnaround time vs waiting time**

  * Waiting time = time before a job starts.
  * Turnaround time = waiting time + job duration (time from arrival to completion).
  * SJF also minimizes average turnaround time (for non-preemptive case) under same assumptions.

* **Preemptive variant: Shortest Remaining Time First (SRTF)**

  * If jobs can arrive over time and preemption is allowed, use SRTF (always run job with smallest remaining time).
  * Implementation often uses a min-heap keyed by remaining time and simulates time progression.

* **Assumptions**

  * All jobs are available at time `0` (no arrival times). If arrival times exist, the problem becomes scheduling with release times and SJF is not trivially just sorting.
  * Non-preemptive: once a job starts it runs to completion.

* **Stability/ties**

  * If two jobs have equal duration, order between them doesn't affect total waiting time. If priorities exist, tie-break accordingly.


## üß™ Test cases

1. `[]` ‚Üí `0.0`
2. `[5]` ‚Üí `0.0` (single job)
3. `[1,2,3]` ‚Üí schedule `{1,2,3}` ‚Üí waits `0,1,3` ‚Üí avg `4/3 ‚âà 1.333333`
4. `[3,1,4,2,5]` ‚Üí avg `4.0` (worked example above)
5. `[10,1,1]` ‚Üí schedule `{1,1,10}` ‚Üí waits `0,1,2` ‚Üí sum `3` ‚Üí avg `1.0`


## ‚ö†Ô∏è Practical considerations

* For real CPU scheduling, jobs can arrive dynamically; SJF (non-preemptive) can cause starvation for long jobs if short jobs keep arriving.
* For production or simulation, consider integer overflow if job durations are huge; we use `long long` for sums to be safe.
* If you need strict reproducibility, sort using stable sort if you rely on order among equal-length jobs.
