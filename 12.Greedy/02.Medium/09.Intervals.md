# ðŸ§© Insert Interval - [LC](https://leetcode.com/problems/insert-interval/description/)


## ðŸ“Œ Problem Statement

You are given:

* A list of **non-overlapping intervals** `intervals`
* Intervals are already **sorted by start time**
* A new interval `newInterval`

Each interval is of the form:

```
[start, end]
```

ðŸŽ¯ **Goal:**
Insert `newInterval` into `intervals` such that:

* The resulting list remains **sorted**
* All **overlapping intervals are merged**



### Example

```text
Input:
intervals = [[1,3],[6,9]]
newInterval = [2,5]

Output:
[[1,5],[6,9]]
```



## ðŸ§  Intuition

Since intervals are:

* Already sorted
* Non-overlapping

We can process them **linearly**.

Think in three phases:

1. **Left part**
   Intervals that end **before** `newInterval` starts
2. **Overlapping part**
   Intervals that overlap with `newInterval`
3. **Right part**
   Intervals that start **after** `newInterval` ends

We only need to merge in the **middle phase**.



## ðŸªœ Brute Force (Why Not)

* Add `newInterval` to the list
* Sort all intervals
* Merge overlapping intervals

â›” Time complexity: `O(n log n)`
But since intervals are already sorted, we can do better.



## ðŸš€ Optimal Greedy Approach (Your Code)

### Strategy

1. Add all intervals that end **before** `newInterval` starts
2. Merge all overlapping intervals into `newInterval`
3. Add remaining intervals

Single pass, no extra sorting.



## ðŸ§© Code Walkthrough

Your solution ðŸ‘‡

```cpp
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        int n = intervals.size();
        vector<vector<int>> res;

        int i = 0;
        while (i < n && intervals[i][1] < newInterval[0]) {
            res.push_back(intervals[i]);
            i++;
        }

        while (i < n && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = min(newInterval[0], intervals[i][0]);
            newInterval[1] = max(newInterval[1], intervals[i][1]);
            i++;
        }

        res.push_back(newInterval);
        while (i < n) {
            res.push_back(intervals[i]);
            i++;
        }

        return res;
    }
};
```

Letâ€™s break it down step by step ðŸ‘‡



## ðŸ”¹ Phase 1: Non-Overlapping Left Intervals

```cpp
while (i < n && intervals[i][1] < newInterval[0]) {
    res.push_back(intervals[i]);
    i++;
}
```

These intervals:

* End before `newInterval` starts
* Can be safely added as-is

Example:

```text
[1,2] ends before [5,7] starts
```



## ðŸ”¹ Phase 2: Merge Overlapping Intervals

```cpp
while (i < n && intervals[i][0] <= newInterval[1]) {
    newInterval[0] = min(newInterval[0], intervals[i][0]);
    newInterval[1] = max(newInterval[1], intervals[i][1]);
    i++;
}
```

If an interval overlaps:

* Extend `newInterval` to cover it
* Keep expanding until no overlap remains

This collapses **all overlapping intervals into one**.



## ðŸ”¹ Phase 3: Add Merged Interval

```cpp
res.push_back(newInterval);
```

Now the merged interval is complete.



## ðŸ”¹ Phase 4: Remaining Right Intervals

```cpp
while (i < n) {
    res.push_back(intervals[i]);
    i++;
}
```

Intervals that start after `newInterval` ends are added untouched.



## ðŸ§ª Dry Run Example

### Example

```cpp
intervals = [[1,3],[6,9]]
newInterval = [2,5]
```



### Step-by-step

**Phase 1**

* `[1,3]` overlaps â†’ skip

**Phase 2**

* Merge `[1,3]` â†’ newInterval becomes `[1,5]`

**Phase 3**

* Add `[1,5]`

**Phase 4**

* Add `[6,9]`

Result:

```text
[[1,5],[6,9]]
```

âœ” Correct



### Another Example

```cpp
intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]]
newInterval = [4,8]
```

Merged result:

```text
[[1,2],[3,10],[12,16]]
```



## â±ï¸ Time & Space Complexity

| Metric | Value                   |
| -- | -- |
| Time   | **O(n)**                |
| Space  | **O(n)** (output array) |

No extra sorting. One pass.



## ðŸ§  Why Greedy Works

* Intervals are already sorted
* Overlaps are local and contiguous
* Merging overlapping intervals greedily produces a globally optimal solution

This is a canonical **interval merging pattern**.



## ðŸ™‹ FAQs

### â“ What if intervals are not sorted?

Sort them first by start time.



### â“ What if `intervals` is empty?

Then just return `[newInterval]`.



### â“ Why check `intervals[i][0] <= newInterval[1]`?

This ensures **overlapping or touching intervals** are merged.



### â“ Can touching intervals be merged?

Yes, as per problem definition. If not, change condition to `<`.



## âœ¨ Cleaner Alternative (Optional)

```cpp
vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
    vector<vector<int>> res;
    int i = 0, n = intervals.size();

    while (i < n && intervals[i][1] < newInterval[0])
        res.push_back(intervals[i++]);

    while (i < n && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = min(newInterval[0], intervals[i][0]);
        newInterval[1] = max(newInterval[1], intervals[i][1]);
        i++;
    }

    res.push_back(newInterval);

    while (i < n)
        res.push_back(intervals[i++]);

    return res;
}
```

Same logic, slightly compact.



