# ğŸ¬ Candy Distribution [#135](https://leetcode.com/problems/candy/description/)



## ğŸ“Œ Problem Statement

You are given an array `ratings` where:

* `ratings[i]` is the rating of the `i-th` child.

ğŸ“Œ **Rules:**

1. Every child must get **at least 1 candy**.
2. A child with a **higher rating than a neighbor** must get **more candies** than that neighbor.

ğŸ¯ **Goal:**
Return the **minimum number of candies** needed to satisfy all children.



### Example

```text
Input:  ratings = [1, 2, 2]
Output: 4
Explanation:
candies = [1, 2, 1]
```



## ğŸ§  Intuition

At first glance, this looks like a simple left-right comparison problem.
But the difficulty comes when ratings **increase then decrease** (mountains), like:

```text
[1, 3, 5, 4, 2]
```

This creates:

* an **uphill** (increasing slope),
* followed by a **downhill** (decreasing slope).

The greedy trick is to:

* Count how long the uphill goes (**peak**),
* Count how long the downhill goes (**valley**),
* Carefully adjust candies so the peak child isnâ€™t overcounted.



## ğŸªœ Brute Force / DP Approach (Common but Heavier)

A common solution is:

1. Left-to-right pass.
2. Right-to-left pass.
3. Take max of both.

This works in `O(n)` time and `O(n)` space.

But your solution is **more elegant**:

* `O(n)` time
* `O(1)` extra space



## ğŸš€ Optimal Greedy Approach (Single Pass)

### Core Idea

* Give **1 candy to everyone initially**.
* Traverse the array and identify:

  * **Increasing sequences** â†’ uphill â†’ `peak`
  * **Decreasing sequences** â†’ downhill â†’ `valley`
* Add candies according to arithmetic progression.
* Subtract the smaller of `peak` and `valley` to avoid **double counting the peak child**.



## ğŸ§© Code Walkthrough

Your implementation:

```cpp
int numCandies(vector<int> &ratings) {
    int n = ratings.size(), candy = n, i = 1;
```

* Start by giving **1 candy to each child** â†’ `candy = n`
* Start comparing from index `1`



### 1ï¸âƒ£ Skip Equal Ratings

```cpp
if (ratings[i] == ratings[i - 1]) {
    i++;
    continue;
}
```

If ratings are equal:

* No extra candy needed.
* Move forward.



### 2ï¸âƒ£ Handle Increasing Slope (Peak)

```cpp
int peak = 0;
while (i < n && ratings[i] > ratings[i - 1]) {
    peak++;
    i++;
    candy += peak;
}
```

For a sequence like:

```text
1 â†’ 2 â†’ 3 â†’ 4
```

Candies added:

```text
+1, +2, +3
```

This ensures:

* Higher rating â†’ more candies.



### 3ï¸âƒ£ Handle Decreasing Slope (Valley)

```cpp
int valley = 0;
while (i < n && ratings[i] < ratings[i - 1]) {
    valley++;
    i++;
    candy += valley;
}
```

For a sequence like:

```text
4 â†’ 3 â†’ 2 â†’ 1
```

Candies added:

```text
+1, +2, +3
```



### 4ï¸âƒ£ Fix Peak Double Counting

```cpp
candy -= min(peak, valley);
```

Why?

In a mountain:

```text
1 2 3 2 1
```

The peak (`3`) is counted:

* once during increasing
* once during decreasing

So we subtract the smaller slope to correct it.



### 5ï¸âƒ£ Final Answer

```cpp
return candy;
```

This gives the **minimum** candies needed.



## ğŸ§ª Dry Run Examples



### Example 1

```cpp
ratings = [1, 2, 2]
```

Step-by-step:

* Initial candies = 3
* 1 â†’ 2 (increase): peak = 1 â†’ +1 candy
* 2 â†’ 2 (equal): skip

Total candies = `3 + 1 = 4`

âœ” Output: **4**



### Example 2 (Mountain)

```cpp
ratings = [1, 3, 5, 4, 2]
```

* Initial candies = 5
* Increasing: `1 â†’ 3 â†’ 5`

  * peak = 2 â†’ +1 +2 = +3
* Decreasing: `5 â†’ 4 â†’ 2`

  * valley = 2 â†’ +1 +2 = +3
* Subtract overlap: `min(2,2) = 2`

Total:

```
5 + 3 + 3 - 2 = 9
```

Candies distribution:

```text
[1, 2, 3, 2, 1]
```

âœ” Correct



### Example 3 (Strictly Decreasing)

```cpp
ratings = [5, 4, 3, 2, 1]
```

* Initial = 5
* valley = 4 â†’ +1 +2 +3 +4 = 10

Total = `5 + 10 = 15`

Candies:

```text
[5, 4, 3, 2, 1]
```



## â±ï¸ Time & Space Complexity

| Metric | Value    |
| --- | -- |
| Time   | **O(n)** |
| Space  | **O(1)** |

Single pass. Constant space. Very optimal.



## ğŸ§  Why This Greedy Works

* Any increasing slope must assign increasing candies.
* Any decreasing slope must assign decreasing candies.
* The peak must satisfy **both sides**.
* Correcting overlap ensures minimal candies.

This greedy logic enforces constraints **locally**, yet guarantees global optimality.



## ğŸ™‹ FAQs

### â“ Why not just do two passes?

You can â€” thatâ€™s the standard solution.
This approach is just more space-efficient and elegant.



### â“ Why subtract `min(peak, valley)`?

Because the peak child gets counted twice â€” once from left, once from right.



### â“ What if there are multiple equal ratings?

Equal ratings donâ€™t impose extra constraints â€” skip them safely.



### â“ Is this harder than it looks?

Yes ğŸ˜„
Thatâ€™s why itâ€™s a favorite interview problem.

