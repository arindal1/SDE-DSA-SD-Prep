# 🚨 Detecting Duplicates in an Array

---

## 📋 Problem Statement

Given an integer array **`arr`** of size **`n`**, determine whether it contains any **duplicate** elements. Print **“Yes”** if a duplicate exists, otherwise **“No”**.

---

## 🐢 Brute‑Force Approach (O(n²) Time)

1. **Compare** every pair `arr[i]` and `arr[j]` for `0 ≤ i < j < n`.
2. **If** any pair matches, **return** **true**.
3. **Otherwise**, after all comparisons, **return** **false**.

```cpp
bool hasDuplicatesBrute(const vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if (arr[i] == arr[j]) 
                return true;
        }
    }
    return false;
}
```

> **Drawback:**
>
> * Quadratic time → too slow for large **n** (e.g., n ≥ 10⁵).

---

## ⚖️ Sorting‑Based Approach (O(n log n) Time)

1. **Sort** `arr`.
2. **Scan** once to check adjacent pairs: if `arr[i] == arr[i+1]`, **duplicate** found.
3. **Return** accordingly.

```cpp
bool hasDuplicatesSort(vector<int> arr) {
    sort(arr.begin(), arr.end());    // O(n log n)
    for (int i = 1; i < arr.size(); ++i) {
        if (arr[i] == arr[i-1])
            return true;
    }
    return false;
}
```

> **Pros:**
>
> * Simpler than brute.
>   **Cons:**
> * **Modifies** the array (unless you copy it).
> * **O(n log n)** time.

---

## ⚡ Hashing Approach (O(n) Average Time)

### **Key Idea**

Use an **`unordered_set`** (hash table) to track seen values:

1. **Initialize** an empty `unordered_set<int> seen;`.
2. **For each** `x` in `arr`:

   * **If** `x` is already in `seen`, **return** **true**.
   * **Else**, insert `x` into `seen`.
3. **Return** **false** after the loop.

This is **O(n)** expected time and **O(n)** extra space.

---

## 📝 Hashing Pseudocode

```text
FUNCTION hasDuplicatesHash(arr):
    seen ← empty unordered_set

    FOR each x IN arr:
        IF x IN seen:
            RETURN true
        seen.insert(x)

    RETURN false
```

---

## 💾 C++ Code (Revised)

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns true if 'arr' contains any duplicates.
 */
bool hasDuplicates(const vector<int>& arr) {
    unordered_set<int> seen;
    seen.reserve(arr.size());
    for (int x : arr) {
        if (!seen.insert(x).second) {
            // insert returns (iterator, wasInserted)
            return true;
        }
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    cout << (hasDuplicates(arr) ? "Yes" : "No") << "\n";
    return 0;
}
```

> **Changes & Enhancements:**
>
> * Pass `arr` as **`const vector<int>&`** to avoid copying.
> * Use `unordered_set::reserve` to preallocate and avoid rehashes.
> * Rely on `insert`’s return value to detect existing keys.

---

## 📈 Complexity Analysis

| Approach          | Time Complexity      | Space Complexity |
| ----------------- | -------------------- | ---------------- |
| Brute‑Force       | O(n²)                | O(1)             |
| Sorting‑Based     | O(n log n)           | O(1) (in-place)  |
| Hashing (optimal) | **O(n)** *amortized* | **O(n)**         |

---

## ✨ Notes & Facts

* **Unordered vs. Ordered:**

  * `unordered_set` gives **O(1)** average insert/lookup.
  * `set` gives **O(log n)** but maintains sorted order.

* **Edge Cases:**

  * **Empty** array → no duplicates → **“No”**.
  * **Single‑element** → **“No”**.

* **Load Factor & Rehashing:**

  * Reserving capacity reduces expensive rehash operations.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Why not use a boolean array for small integer ranges?**

> If you know all `arr[i]` are in a bounded range (e.g., `0…10⁶`), a `vector<bool>` can work in O(1) per check with O(maxValue) space.

---

**Q2: Can this detect duplicates of multiple values?**

> Yes—immediately returns on the **first** duplicate found.

---

**Q3: What if we need to list the duplicate values?**

> Maintain a separate `vector<int> dups;` and on each failed insert, push `x` into `dups` (checking to avoid listing the same duplicate multiple times).

---

**Q4: How to handle floating‑point or custom types?**

> Use `unordered_set<double>` or supply a custom hash/functor for user‑defined types.

---

