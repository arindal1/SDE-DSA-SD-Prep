## **Count Frequencies of Elements in an Array**

## 🧾 Problem Statement

Given an array of integers, compute and print the **frequency** of each distinct element.

---

## 📦 Original Code

```cpp
#include <bits/stdc++.h>
using namespace std;

void ElFreq(vector<int> arr) {
    unordered_map<int, int> mpp;
    for (int i : arr)
        mpp[i]++;
    for (auto i : mpp)
        cout << i.first << " - " << i.second << endl;
}

int main() {
    vector<int> arr = {2, 3, 1, 1, 2, 4};
    ElFreq(arr);
    return 0;
}
```

---

## 🧠 Key Concepts

* **Hash Table (`unordered_map`)**

  * *Average* **O(1)** insertion and lookup.
  * Maps each element → its count.
* **Iteration**

  * First pass: **tally** counts.
  * Second pass: **print** key–value pairs.

---

## 🔎 Detailed Explanation

1. **Function Signature**

   ```cpp
   void ElFreq(const vector<int>& arr)
   ```

   * **Recommended Change:**
     Pass by **`const` reference** to avoid copying the vector.

2. **Counting Frequencies**

   ```cpp
   unordered_map<int, int> freq;
   for (int x : arr) {
       freq[x]++;
   }
   ```

   * Each read `x` increments `freq[x]` by 1.
   * If `x` is new, default-initialized to 0, then incremented → 1.

3. **Output**

   ```cpp
   for (auto& p : freq) {
       cout << p.first << " -> " << p.second << "\n";
   }
   ```

   * **Note:** `unordered_map` does **not** guarantee any ordering of keys.
   * If you need **sorted** output, collect keys and sort them before printing.

---

## 🔁 Algorithm

```text
FUNCTION ElFreq(arr):
    freqMap ← empty hash map

    // Count
    FOR each element x in arr:
        freqMap[x] ← freqMap[x] + 1

    // Print
    FOR each (key, count) in freqMap:
        PRINT key, "-", count
```

---

## 📈 Complexity Analysis

| Metric              | Value                         |
| ------------------- | ----------------------------- |
| 🕒 Time Complexity  | O(n)                          |
|                     | – n insert/lookup operations  |
| 🧠 Space Complexity | O(k)                          |
|                     | – k = number of distinct keys |

---

## ✨ Enhancements & Edge Cases

1. **Pass by Reference**

   ```cpp
   void ElFreq(const vector<int>& arr);
   ```

   avoids an **O(n)** copy of the input.

2. **Sorted Output**

   ```cpp
   vector<int> keys;
   keys.reserve(freq.size());
   for (auto& p : freq) keys.push_back(p.first);
   sort(keys.begin(), keys.end());
   for (int k : keys)
       cout << k << " -> " << freq[k] << "\n";
   ```

3. **Support for Large Types**

   * If elements might not fit in `int`, use `unordered_map<long long, int>`.

4. **Empty Array**

   * If `arr` is empty, the function prints nothing.

---

## 💾 Revised Code

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;

void ElFreq(const vector<int>& arr) {
    unordered_map<int,int> freq;
    for (int x : arr) {
        freq[x]++;
    }

    // Optional: print in sorted order
    vector<int> keys;
    keys.reserve(freq.size());
    for (auto& p : freq) 
        keys.push_back(p.first);
    sort(keys.begin(), keys.end());

    for (int k : keys) {
        cout << k << " -> " << freq[k] << "\n";
    }
}

int main() {
    vector<int> arr = {2, 3, 1, 1, 2, 4};
    ElFreq(arr);
    return 0;
}
```

> **Sample Output:**
>
> ```
> 1 -> 2
> 2 -> 2
> 3 -> 1
> 4 -> 1
> ```

---
