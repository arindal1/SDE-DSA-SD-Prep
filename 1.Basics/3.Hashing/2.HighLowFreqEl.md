## **Find Elements with Highest and Lowest Frequencies**

## üìã Problem Statement

Given an array of integers, identify:

1. The element that occurs **most** frequently.
2. The element that occurs **least** frequently.

If multiple elements tie for highest or lowest frequency, this implementation picks the **first** encountered.

---

## üîé Example

```
Input:  [1, 2, 3, 4, 5, 5, 7, 8]
Frequencies: {1:1, 2:1, 3:1, 4:1, 5:2, 7:1, 8:1}

Highest frequency element: 5    (frequency = 2)
Lowest frequency element: 1     (frequency = 1; same as 2,3,4,7,8, but 1 encountered first)
```

---

## üí° Approach

1. **Count Frequencies**

   * Use an **unordered\_map** to tally how many times each value appears.
2. **Scan for Extremes**

   * Track **`maxFreq`** (initialized to 0) and **`minFreq`** (initialized to a large value).
   * Walk through the map once:

     * If a count > `maxFreq`, update `maxFreq` and record its key.
     * If a count < `minFreq`, update `minFreq` and record its key.

*Why unordered\_map?*

* Average **O(1)** for insert & lookup‚Äîoverall linear time in array size.

---

## üîÅ Algorithm

```text
FUNCTION HighLowFreq(arr):
    IF arr is empty:
        PRINT "Array is empty"
        RETURN

    // 1) Build frequency map
    freq ‚Üê empty hash map<int,int>
    FOR each x IN arr:
        freq[x] ‚Üê freq[x] + 1

    // 2) Initialize extremes
    maxFreq ‚Üê 0
    minFreq ‚Üê ‚àû
    highElem ‚Üê undefined
    lowElem  ‚Üê undefined

    // 3) Find highest & lowest
    FOR each (elem, count) IN freq:
        IF count > maxFreq:
            maxFreq ‚Üê count
            highElem ‚Üê elem
        IF count < minFreq:
            minFreq ‚Üê count
            lowElem ‚Üê elem

    // 4) Output results
    PRINT "Highest frequency element:", highElem
    PRINT "Lowest frequency element:",  lowElem
```

---

## üíæ Revised C++ Code

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <limits>
using namespace std;

void HighLowFreq(const vector<int>& arr) {
    if (arr.empty()) {
        cout << "Array is empty.\n";
        return;
    }

    // 1) Count frequencies
    unordered_map<int,int> freq;
    freq.reserve(arr.size());
    for (int x : arr) {
        ++freq[x];
    }

    // 2) Initialize tracking variables
    int maxFreq = 0;
    int minFreq = numeric_limits<int>::max();
    int highElem = arr[0];
    int lowElem  = arr[0];

    // 3) Find highest and lowest frequency elements
    for (auto& [elem, count] : freq) {
        if (count > maxFreq) {
            maxFreq  = count;
            highElem = elem;
        }
        if (count < minFreq) {
            minFreq = count;
            lowElem = elem;
        }
    }

    // 4) Print results
    cout << "Highest frequency element: " << highElem
         << " (freq=" << maxFreq << ")\n";
    cout << "Lowest  frequency element: " << lowElem
         << " (freq=" << minFreq << ")\n";
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 5, 7, 8};
    HighLowFreq(arr);
    return 0;
}
```

---

## üìà Complexity Analysis

* **Time Complexity:**

  * **O(n)** to build the frequency map (n = array size).
  * **O(k)** to scan the map (k = number of distinct elements, ‚â§ n).
  * **Overall:** **O(n)**.

* **Space Complexity:**

  * **O(k)** for the hash map.
  * Additional constant space for a few variables.

---

## ‚ú® Highlights & Notes

* **Pass by `const` reference** avoids copying the array (`vector<int>&` ‚Üí `const vector<int>&`).
* **`numeric_limits<int>::max()`** is safer than `INT_MAX` in `<limits>`.
* **Reservation** (`freq.reserve(arr.size())`) can improve performance by reducing rehashes when the distinct count is large.
* **Tie-breaking:**

  * This code chooses the first-seen element for both highest and lowest.
  * To collect *all* elements with max/min frequencies, do a second pass collecting keys whose counts equal `maxFreq` or `minFreq`.
* **Edge Cases:**

  * Empty array handled explicitly.
  * Single-element array ‚Üí that element is both highest and lowest.

---

