# üìò Printing the Fibonacci Series up to *n* Using Recursion

## üßæ Problem Statement

> **Goal:**
> Print the first **n** terms of the Fibonacci sequence using a recursive approach.
>
> The Fibonacci sequence is defined by:
>
> $$
> F(0) = 0,\quad F(1) = 1,\quad 
> F(k) = F(k-1) + F(k-2)\quad\text{for }k \ge 2.
> $$

---

## üîé Examples

| Input (`n`) | Output           | Explanation                               |
| :---------: | :--------------- | :---------------------------------------- |
|     `1`     | `0`              | Only the first term, 0.                   |
|     `2`     | `0 1`            | First two terms, 0 and 1.                 |
|     `5`     | `0 1 1 2 3`      | First five terms of the Fibonacci series. |
|     `0`     | (prints nothing) | No terms to print.                        |

---

## üí° Approach

1. **Recursive Fibonacci Function (`fib`)**

   * **Base cases:**

     $$
       F(0) = 0,\quad F(1) = 1
     $$
   * **Recursive case:**

     $$
       F(k) = F(k-1) + F(k-2)
     $$

2. **Recursive Print Function (`printFib`)**

   * Prints **first** term(s) by **recursing** on `n-1` and then printing the $n$th term computed via `fib(n-1)`.
   * **Base cases:**

     * `n == 0` ‚Üí nothing to print
     * `n == 1` ‚Üí print `0`
     * `n == 2` ‚Üí print `0 1`

---

## üîÅ Algorithm

```text
FUNCTION fib(k):
    IF k == 0: RETURN 0
    IF k == 1: RETURN 1
    RETURN fib(k-1) + fib(k-2)

FUNCTION printFib(n):
    IF n <= 0:
        RETURN
    IF n == 1:
        PRINT 0
        RETURN
    IF n == 2:
        PRINT "0 1"
        RETURN

    // Print first (n-1) terms
    printFib(n-1)
    // Now print the nth term (index n-1)
    PRINT fib(n-1)
```

---

## üìù C++ Code Snippet

```cpp
#include <iostream>
using namespace std;

// Recursive Fibonacci computation
int fib(int k) {
    if (k == 0) return 0;
    if (k == 1) return 1;
    return fib(k - 1) + fib(k - 2);
}

// Recursive function to print first n Fibonacci terms
void printFib(int n) {
    if (n <= 0) {
        return;  // No terms to print
    }
    if (n == 1) {
        cout << 0;
        return;
    }
    if (n == 2) {
        cout << 0 << " " << 1;
        return;
    }

    // Print the first (n-1) terms
    printFib(n - 1);
    // Then print the nth term (which is fib(n-1))
    cout << " " << fib(n - 1);
}

int main() {
    int n;
    cin >> n;
    printFib(n);
    cout << endl;
    return 0;
}
```

---

## üßÆ Dry Run Example

For `n = 5`:

1. `printFib(5)`

   * calls `printFib(4)` ‚Üí ‚Ä¶
2. `printFib(4)`

   * calls `printFib(3)`
3. `printFib(3)`

   * calls `printFib(2)` ‚Üí prints `0 1`
   * then prints `fib(2) = 1` ‚Üí output so far: `0 1 1`
4. Returning to `printFib(4)`

   * prints `fib(3) = 2` ‚Üí `0 1 1 2`
5. Returning to `printFib(5)`

   * prints `fib(4) = 3` ‚Üí `0 1 1 2 3`

---

## üìà Complexity Analysis

| Metric              | Value                             |
| ------------------- | --------------------------------- |
| üïí Time Complexity  | **O(n ¬∑ 2‚Åø)** (exponential)       |
| üß† Space Complexity | **O(n)** (due to recursion depth) |

* Each call to `fib(k)` recursively invokes two smaller fib calls ‚Üí exponential blow-up.
* Printing requires **n** calls to `printFib`, each of which calls `fib`.

---

## üìé Notes & Enhancements

* **Inefficiency Warning:**

  * This naive recursive `fib` recomputes many values.
  * For moderate `n` (e.g., > 40), runtime becomes impractical.

* **Memoization / Dynamic Programming:**

  * **Top-down (memoized recursion)** or **bottom-up** transforms the time to **O(n)**.
  * Example: store computed `fib(k)` in an array or map.

* **Iterative Alternative:**

  ```cpp
  void printFibIter(int n) {
      int a = 0, b = 1;
      for (int i = 0; i < n; ++i) {
          cout << a << (i+1 < n ? " " : "");
          int next = a + b;
          a = b; b = next;
      }
      cout << endl;
  }
  ```

* **Tail Recursion (Accumulator):**

  * A helper function can carry two previous values to achieve **O(n)** time and **O(n)** stack:

    ```cpp
    void printFibTail(int n, int a = 0, int b = 1) {
        if (n <= 0) return;
        cout << a << (n > 1 ? " " : "");
        printFibTail(n - 1, b, a + b);
    }
    ```

* **Edge Cases:**

  * `n <= 0`: prints nothing.
  * Very large `n`: prefer iterative or DP methods to avoid stack overflow and time blow-up.

---
