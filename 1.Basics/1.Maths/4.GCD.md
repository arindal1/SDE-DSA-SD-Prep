## **Find GCD of Two Numbers**

## ğŸ“‹ Problem Statement

Given two integers **Nâ‚** and **Nâ‚‚**, compute their **Greatest Common Divisor (GCD)**â€”the largest positive integer that divides both without leaving a remainder.

---

## ğŸ” Examples

|  Nâ‚  |  Nâ‚‚  | GCD | Explanation                                                                                            |   |     |
| :--: | :--: | :-: | :----------------------------------------------------------------------------------------------------- | - | --- |
|  `9` | `12` | `3` | Factors of 9: 1, 3, 9;<br>Factors of 12: 1, 2, 3, 4, 6, 12;<br>Common: 1, 3 â†’ **3** is greatest.       |   |     |
| `20` | `15` | `5` | Factors of 20: 1, 2, 4, 5, 10, 20;<br>Factors of 15: 1, 3, 5, 15;<br>Common: 1, 5 â†’ **5** is greatest. |   |     |
|  `0` |  `7` | `7` | By convention, \`gcd(0, b) =                                                                           | b | \`. |
| `â€“8` | `12` | `4` | We take absolute values: `gcd(8, 12) = 4`.                                                             |   |     |

---

## ğŸ’¡ Approach

> **Euclidean Algorithm (Optimized)**
> Leverages the fact that
>
> $$
> \gcd(a, b) = \gcd(b,\; a \bmod b)
> $$
>
> and that $\gcd(a,0)=|a|$.

1. **Ensure non-negativity**: work with $|a|$ and $|b|$.
2. **Iterate** until one number becomes 0:

   * Replace the larger by its remainder when divided by the smaller.
3. **Result**: the non-zero number is the GCD.

---

## ğŸ“ Algorithm

```text
FUNCTION findGCD(a, b):
    a â† abs(a)
    b â† abs(b)

    WHILE b â‰  0:
        temp â† b
        b â† a mod b
        a â† temp

    RETURN a
```

---

## ğŸ’¾ C++ Code Snippet

```cpp
#include <iostream>
#include <cstdlib>     // for std::abs
using namespace std;

// Iterative Euclidean algorithm
int findGCD(int a, int b) {
    a = abs(a);
    b = abs(b);

    while (b != 0) {
        int rem = a % b;
        a = b;
        b = rem;
    }
    return a;
}

int main() {
    int n1, n2;
    cin >> n1 >> n2;

    int gcd = findGCD(n1, n2);
    cout << "GCD of " << n1 << " and " << n2 << " is: " << gcd << endl;
    return 0;
}
```

> **Example Run:**
>
> ```
> Input:  20 15  
> Output: GCD of 20 and 15 is: 5
> ```

---

## ğŸ“ˆ Complexity Analysis

* **Time Complexity:**

  * $O(\log \min(a, b))$.
  * Each modulus operation reduces the pair significantly (in the worst case by the golden-ratio factor).
* **Space Complexity:**

  * $O(1)$.
  * Only a constant number of variables (`a`, `b`, `rem`, `temp`).

---

## âœ¨ Notes & Variations

* **Recursive Version:**

  ```cpp
  int findGCD(int a, int b) {
      return b == 0 ? abs(a) : findGCD(b, a % b);
  }
  ```
* **Built-in (C++17):**

  ```cpp
  #include <numeric>
  int g = std::gcd(n1, n2);
  ```
* **Edge Cases:**

  * One or both inputs zero.
  * Negative inputs (handle via `abs`).
  * Very large inputs (fits within 32-bit? consider 64-bit types).

---

