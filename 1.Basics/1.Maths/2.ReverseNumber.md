## **Reverse Digits of a Number**

## 📋 Problem Statement

Given an integer `N`, return its digits reversed.

> **Note:**
> Trailing zeros in `N` do not appear in the reversed result.
> e.g., `reverse(10400) → 401` (not `00401`)

---

## 🔎 Examples

|  Input  | Output  | Explanation                           |
| :-----: | :------ | :------------------------------------ |
| `12345` | `54321` | The reverse of 12345 is **54321**.    |
|  `7789` | `9877`  | The reverse of 7789 is **9877**.      |
| `10400` | `401`   | Leading zeros are dropped → **401**.  |
|  `-120` | `-21`   | Preserve the sign of negative inputs. |

---

## 💡 Approach

> **Key Idea:**
> Extract one digit at a time from the end of `N` and append it to a running “reversed” number.

1. Initialize `revNum = 0`.
2. While `|N| > 0`:

   * `ld = N % 10`  → the last digit
   * `revNum = revNum * 10 + ld`  → append it
   * `N = N / 10`  → remove the last digit
3. Restore the sign if the original `N` was negative.

---

## 📝 Algorithm

```text
FUNCTION reverseNumber(N):
    sign ← (N < 0) ? -1 : 1
    N ← abs(N)
    revNum ← 0

    WHILE N > 0:
        ld ← N % 10
        revNum ← revNum * 10 + ld
        N ← N / 10

    RETURN sign * revNum
```

---

## 💾 C++ Code Snippet

```cpp
#include <iostream>
#include <cmath>
using namespace std;

long long reverseNumber(long long n) {
    int sign = (n < 0) ? -1 : 1;
    n = llabs(n);

    long long revNum = 0;
    while (n > 0) {
        int lastDigit = n % 10;
        revNum = revNum * 10 + lastDigit;
        n /= 10;
    }
    return sign * revNum;
}

int main() {
    long long N;
    cin >> N;

    cout << reverseNumber(N) << endl;
    return 0;
}
```

> **Example Run:**
>
> ```
> Input:  7789  
> Output: 9877
> 
> Input:  -120
> Output: -21
> ```

---

## 📈 Complexity Analysis

* **Time Complexity:**

  * $O(d)$, where $d$ is the number of digits in `N`.
  * Each loop iteration “peels off” one digit → about $\lfloor \log_{10}|N| \rfloor + 1$ iterations.

* **Space Complexity:**

  * $O(1)$, uses only a fixed number of extra variables (`revNum`, `sign`, `lastDigit`).

---

## ✨ Edge Cases & Notes

* **Zero Input:**

  * `reverseNumber(0) → 0`.
* **Trailing Zeros:**

  * Automatically discarded, since integer division drops them.
* **Negative Numbers:**

  * We capture the sign separately and reapply after reversing.
* **Data Type:**

  * Use a 64-bit type (`long long`) if `N` may exceed `2^{31}-1`.
* **Overflow Considerations:**

  * For extremely large inputs, reversing might overflow—consider using strings or big‐integer libraries if needed.
