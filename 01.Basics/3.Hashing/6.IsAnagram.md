## **Check if Two Strings Are Anagrams**

## üìã Problem Statement

Given two strings **`a`** and **`b`**, determine whether they are **anagrams** of each other‚Äîi.e., whether one can be rearranged to form the other. Return **‚ÄúYes‚Äù** if they are anagrams, otherwise **‚ÄúNo‚Äù**.

> *Assumption:* strings contain only **lowercase** English letters.

---

## üîé Examples

| `a`         | `b`         | Output | Explanation                             |
| ----------- | ----------- | ------ | --------------------------------------- |
| `"listen"`  | `"silent"`  | Yes    | Rearrangement matches exactly.          |
| `"anagram"` | `"nagaram"` | Yes    | All letters count match.                |
| `"rat"`     | `"car"`     | No     | Letter counts differ (`t` vs. `c`).     |
| `"aabbcc"`  | `"abcabc"`  | Yes    | Counts of `a`, `b`, `c` all equal.      |
| `"a"`       | `"aa"`      | No     | Different lengths ‚Üí cannot be anagrams. |

---

## üê¢ Brute‚ÄëForce Approach: Sort & Compare

1. **Sort** both strings (O(n log n) time).
2. **Compare** the sorted results. If identical, they‚Äôre anagrams.

```cpp
bool isAnagramSort(string a, string b) {
    if (a.size() != b.size()) return false;
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    return a == b;
}
```

* **Time Complexity:** O(n log n)
* **Space Complexity:** O(n) (for sorting)
* **Drawback:** Higher time; modifies or copies input.

---

## ‚ö° Optimal Approach: Frequency Counting

### **Key Idea**

Track how many times each character appears in each string, then verify all counts match. Since we assume **only `'a'‚Äì'z'`**, we can use a fixed-size array of 26 counters.

1. **Early exit** if lengths differ.
2. **Initialize** `int freq[26] = {0}`.
3. **Single pass** over both strings:

   * `freq[a[i] - 'a']++`
   * `freq[b[i] - 'a']--`
4. **Check** that every `freq[c] == 0`.

```text
FUNCTION isAnagram(a, b):
    IF |a| ‚â† |b|: RETURN false
    freq[0‚Ä¶25] ‚Üê all zeros
    FOR i FROM 0 TO |a|-1:
        freq[a[i] ‚Äì 'a']++
        freq[b[i] ‚Äì 'a']--
    FOR c FROM 0 TO 25:
        IF freq[c] ‚â† 0:
            RETURN false
    RETURN true
```

* **Time Complexity:** O(n)
* **Space Complexity:** O(1) (26 counters)
* **Does not modify** inputs.

---

## üì¶ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns true if strings a and b are anagrams (contain
 * the same lowercase letters with the same frequencies).
 */
bool isAnagram(const string &a, const string &b) {
    if (a.size() != b.size())
        return false;

    int freq[26] = {0};
    int n = a.size();
    for (int i = 0; i < n; i++) {
        freq[a[i] - 'a']++;
        freq[b[i] - 'a']--;
    }
    for (int c = 0; c < 26; c++) {
        if (freq[c] != 0)
            return false;
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s1, s2;
    cin >> s1 >> s2;
    cout << (isAnagram(s1, s2) ? "Yes\n" : "No\n");
    return 0;
}
```

---

## üìà Complexity Analysis

| Approach                      | Time Complexity | Space Complexity |
| ----------------------------- | --------------- | ---------------- |
| **Sort & Compare**            | O(n log n)      | O(n)             |
| **Frequency Counting (opt.)** | **O(n)**        | **O(1)**         |

* *n* = length of the strings.

---

## ‚ú® Notes & Extensions

* **Case‚ÄëInsensitive / Unicode:**

  * To handle uppercase or broader character sets, convert to one case (`tolower`) and use an **`unordered_map<char,int>`** instead of a fixed array.
* **Streaming Data:**

  * You can build counts on the fly as data arrives, exiting early on any negative count.
* **Large Alphabets:**

  * For Unicode or large alphabets, use a hash map with O(n) expected time, O(n) space.

---

## ‚ùì Frequently Asked Questions (FAQs)

**Q1: What if strings contain spaces or punctuation?**

> Preprocess by **removing non‚Äëletters** and normalizing case before counting.

---

**Q2: Can I detect anagrams in O(1) space?**

> Only for fixed small alphabets. With unbounded characters, at least O(n) space is required.

---

**Q3: How to list all anagram groups in a list of words?**

> Use a map from **sorted word** ‚Üí list of originals, grouping by key.

---
