## **Check if a Number Is Prime**

## ğŸ“‹ Problem Statement

Given an integer **N**, determine whether it is **prime**.

> A **prime number** has **exactly two** positive divisors: 1 and itself.

---

## ğŸ” Examples

| Input | Output    | Explanation                                               |
| :---: | :-------- | :-------------------------------------------------------- |
|  `2`  | **True**  | Divisors of 2: {1, 2} â†’ count = 2 â†’ prime.                |
|  `10` | **False** | Divisors of 10: {1, 2, 5, 10} â†’ count = 4 â†’ not prime.    |
|  `1`  | **False** | Divisors of 1: {1} â†’ count = 1 â†’ not prime by definition. |
|  `17` | **True**  | Divisors of 17: {1, 17} â†’ count = 2 â†’ prime.              |
|  `0`  | **False** | 0 has infinitely many divisors â†’ not prime.               |
|  `â€“7` | **False** | Negative numbers are not prime in the usual definition.   |

---

## ğŸ’¡ Approach

> **Key Insight:**
> A composite number must have at least one factor **â‰¤ âˆšN** (other than 1).
> Therefore, to test primality **efficiently**, check divisibility **only** up to $\lfloor\sqrt{N}\rfloor$.

1. **Handle edge cases**:

   * If $N â‰¤ 1$, return **false**.
   * If $N = 2$, return **true**.
2. **Iterate** $i$ from **2** to $\lfloor\sqrt{N}\rfloor$:

   * If $N \bmod i = 0$, **immediately** return **false**.
3. If no divisor found, return **true**.

This runs in **O(âˆšN)** time and **O(1)** space.

---

## ğŸ“ Algorithm

```text
FUNCTION isPrime(N):
    IF N â‰¤ 1:
        RETURN false
    IF N = 2:
        RETURN true     // 2 is the smallest prime

    limit â† floor(sqrt(N))
    FOR i FROM 2 TO limit:
        IF (N mod i) = 0:
            RETURN false

    RETURN true
```

---

## ğŸ’¾ C++ Code Snippet

```cpp
#include <iostream>
#include <cmath>
using namespace std;

// Returns true if 'n' is prime
bool isPrime(int n) {
    if (n <= 1) 
        return false;
    if (n == 2) 
        return true;
    if (n % 2 == 0) 
        return false;               // eliminate even numbers early

    int limit = static_cast<int>(sqrt(n));
    for (int i = 3; i <= limit; i += 2) {
        if (n % i == 0)
            return false;
    }
    return true;
}

int main() {
    int N;
    cin >> N;

    if (isPrime(N))
        cout << N << " is a prime number." << endl;
    else
        cout << N << " is not a prime number." << endl;

    return 0;
}
```

> **Sample Runs:**
>
> ```
> Input:  2   
> Output: 2 is a prime number.
>
> Input:  10
> Output: 10 is not a prime number.
> ```

---

## ğŸ“ˆ Complexity Analysis

* **Time Complexity:**

  * $O(\sqrt{N}/2)$ â‰ƒ $O(\sqrt{N})$

    * We test only odd divisors after checking 2.
* **Space Complexity:**

  * $O(1)$ â€” only a fixed number of variables.

---

## âœ¨ Notes & Variations

* **Early Even Check:**

  * Testing `n % 2 == 0` lets us skip half the loop (all even `i`).
* **1 and 0:**

  * By definition, neither 0 nor 1 are prime.
* **Negative Inputs:**

  * Commonly classified as **not prime**â€”we treat any `n â‰¤ 1` as non-prime.
* **Larger Ranges:**

  * For 64-bit `n`, use `long long` and `sqrtl`.
* **Sieve of Eratosthenes:**

  * For testing many numbers or generating all primes up to `M`, consider the sieve (O(M log log M) total time).
