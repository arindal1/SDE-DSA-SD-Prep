## **Check if a Number Is a Palindrome**

## 📋 Problem Statement

Given an integer **N**, return **true** if it is a palindrome; otherwise, return **false**.

> **Definition:**
> A palindrome reads the same **backward** and **forward**.

---

## 🔎 Examples

|  Input | Output             | Explanation                                                            |
| :----: | :----------------- | :--------------------------------------------------------------------- |
| `4554` | **Palindrome**     | Reverse of 4554 is 4554 → reads the same.                              |
| `7789` | **Not Palindrome** | Reverse of 7789 is 9877 → differs from original.                       |
| `-121` | **Not Palindrome** | Depending on definition, negative sign `-` does not mirror at the end. |
|   `0`  | **Palindrome**     | A single digit always reads the same both ways.                        |

---

## 💡 Approach

> **Key Idea:**
> Reverse the digits of **N** and compare with the original. If they match, **N** is a palindrome.

1. **Duplicate** the original number (`dup`) to preserve it for comparison.
2. **Reverse** the digits of **N** using the same digit-extraction technique:

   * Extract last digit
   * Append to `revNum`
   * Remove last digit from **N**
3. **Compare** `revNum` with `dup`.

---

## 📝 Algorithm

```text
FUNCTION isPalindrome(N):
    // Step 1: Handle negative inputs (optional)
    IF N < 0:
        RETURN false

    // Step 2: Store original
    dup ← N
    revNum ← 0

    // Step 3: Build reversed number
    WHILE N > 0:
        ld ← N % 10
        revNum ← revNum * 10 + ld
        N ← N / 10

    // Step 4: Compare
    RETURN (dup == revNum)
```

---

## 💾 C++ Code Snippet

```cpp
#include <iostream>
#include <cmath>
using namespace std;

// Returns true if 'n' is a palindrome
bool isPalindrome(int n) {
    // Negative numbers are not palindromes by this definition
    if (n < 0) return false;

    int dup = n;
    int revNum = 0;

    while (n > 0) {
        int lastDigit = n % 10;
        revNum = revNum * 10 + lastDigit;
        n /= 10;
    }

    return (dup == revNum);
}

int main() {
    int number;
    cin >> number;

    if (isPalindrome(number))
        cout << number << " is a palindrome." << endl;
    else
        cout << number << " is not a palindrome." << endl;

    return 0;
}
```

> **Sample I/O:**
>
> ```
> Input:  4554  
> Output: 4554 is a palindrome.
>
> Input:  7789
> Output: 7789 is not a palindrome.
>
> Input: -121
> Output: -121 is not a palindrome.
> ```


---

## 📈 Complexity Analysis

* **Time Complexity:**

  * $O(d)$, where $d$ is the number of digits in **N**
  * Each iteration strips one digit → about $\lfloor \log_{10}N\rfloor + 1$ steps

* **Space Complexity:**

  * $O(1)$
  * Only constant extra variables (`dup`, `revNum`, `lastDigit`)

---

## ✨ Edge Cases & Notes

* **Negative Numbers:**

  * We treat all negative inputs as *not* palindromes.
  * If you wish to allow `-121 → 121-`, adjust logic accordingly.
* **Single Digit:**

  * Every single-digit integer (0–9) is trivially a palindrome.
* **Zero:**

  * `0` reversed is `0`.
* **Overflow Concerns:**

  * If **N** can exceed 32-bit, use `long long` (or larger) for `revNum`.
* **Zero-Trailing Inputs:**

  * e.g., `1001` → reversed `1001` → still a palindrome.
  * e.g., `1200` → reversed `21` → **not** a palindrome.

---
