## **Print All Divisors of a Number**

## üìã Problem Statement

Given an integer **N**, return **all positive divisors** of **N**‚Äîthose integers that divide **N** without a remainder.

---

## üîé Examples

| Input | Output                           | Explanation                              |
| :---: | :------------------------------- | :--------------------------------------- |
|  `36` | `[1, 2, 3, 4, 6, 9, 12, 18, 36]` | Divisors of 36.                          |
|  `12` | `[1, 2, 3, 4, 6, 12]`            | Divisors of 12.                          |
|  `1`  | `[1]`                            | 1 is only divisible by itself.           |
|  `17` | `[1, 17]`                        | 17 is prime, so only 1 and 17 divide it. |

---

## üí° Approach

> **Key Insight:**
> If **i** divides **N**, then $\tfrac{N}{i}$ is also a divisor.
> All divisors come in **pairs** $(i,\,N/i)$, and one member of each pair is $\le \sqrt{N}$.

1. **Iterate** **i** from 1 up to $\lfloor \sqrt{N}\rfloor$.
2. **Check** `if (N % i == 0)`:

   * **Push** `i`.
   * **If** `i != N/i`, **push** the counterpart `N/i`.
3. (Optional) **Sort** the resulting list for ascending order.

This runs in **O(‚àöN)** time and uses **O(k)** space, where $k \le 2\sqrt{N}$.

---

## üìù Algorithm

```text
FUNCTION findDivisors(N):
    divisors ‚Üê empty list
    limit ‚Üê floor(sqrt(N))

    FOR i FROM 1 TO limit:
        IF N mod i == 0:
            ADD i to divisors
            IF i ‚â† (N/i):
                ADD (N/i) to divisors

    SORT divisors in ascending order
    RETURN divisors
```

---

## üíæ C++ Code Snippet

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

vector<int> findDivisors(int n) {
    vector<int> divisors;
    int limit = static_cast<int>(sqrt(n));

    for (int i = 1; i <= limit; ++i) {
        if (n % i == 0) {
            divisors.push_back(i);
            if (i != n / i) {
                divisors.push_back(n / i);
            }
        }
    }

    // Sort for ascending order
    sort(divisors.begin(), divisors.end());
    return divisors;
}

int main() {
    int N;
    cin >> N;

    vector<int> divs = findDivisors(N);
    cout << "Divisors of " << N << " are: ";
    for (int d : divs) {
        cout << d << " ";
    }
    cout << endl;
    return 0;
}
```

> **Sample Run:**
>
> ```
> Input:  12  
> Output: Divisors of 12 are: 1 2 3 4 6 12 
> ```

---

## üìà Complexity Analysis

* **Time Complexity:**

  * $O(\sqrt{N}\cdot \log{\sqrt{N}})$

    * $O(\sqrt{N})$ to collect pairs
    * $O(\sqrt{N}\log\sqrt{N})$ if you include the final sort
* **Space Complexity:**

  * $O(k)$, where $k$ is the number of divisors (at most $2\sqrt{N}$)

---

## ‚ú® Notes & Variations

* **Brute-Force Alternative:**

  * Loop `i` from 1 to **N**, checking `N % i == 0`. This is **O(N)**‚Äîuseful for small **N** only.
* **Unsorted Output:**

  * If order doesn‚Äôt matter, you can skip the final `sort()`, reducing to **O(‚àöN)** time and **O(k)** space.
* **Edge Cases:**

  * **N = 0**: every positive integer divides 0‚Äîundefined ‚Äúall divisors.‚Äù Usually, skip or handle separately.
  * **N = 1**: returns `[1]`.
  * **Negative N**: if you want negative divisors too, process absolute value and then append negatives.

> *Efficient divisor enumeration is crucial in factorization, totient computations, and many number-theoretic algorithms.*
