## **Check if a Number Is an Armstrong Number**

## 📋 Problem Statement

Given an integer **N**, return **true** if it is an **Armstrong number**, otherwise return **false**.

> **Definition:**
> An Armstrong (or narcissistic) number is one that equals the sum of its own digits each raised to the power of the number of digits.
>
> $$
> N = \sum_{i=0}^{d-1} (\text{digit}_i)^d
> $$
>
> where $d$ is the total count of digits.

---

## 🔎 Examples

|  Input |   Output  | Explanation                                              |
| :----: | :-------: | :------------------------------------------------------- |
|  `153` |  **True** | $1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153$                   |
|  `371` |  **True** | $3^3 + 7^3 + 1^3 = 27 + 343 + 1 = 371$                   |
| `9474` |  **True** | $9^4 + 4^4 + 7^4 + 4^4 = 6561 + 256 + 2401 + 256 = 9474$ |
|  `123` | **False** | $1^3 + 2^3 + 3^3 = 1 + 8 + 27 = 36 \neq 123$             |
|   `0`  |  **True** | A single-digit 0 satisfies $0^1 = 0$.                    |

---

## 💡 Approach

> **Key Idea:**
>
> 1. Determine the number of digits $d$ in **N**.
> 2. Extract each digit, raise it to the power $d$, and accumulate.
> 3. Compare the accumulated sum with the original **N**.

1. **Count digits**:

   ```cpp
   int d = to_string(N).length();
   // — or — 
   int d = floor(log10(N)) + 1; 
   ```
2. **Sum powers**:

   ```cpp
   int sum = 0, temp = N;
   while (temp > 0) {
       int digit = temp % 10;
       sum += pow(digit, d);
       temp /= 10;
   }
   ```
3. **Check equality**:

   ```cpp
   return sum == N;
   ```

---

## 📝 Algorithm

```text
FUNCTION isArmstrong(N):
    IF N < 0:
        RETURN false        // Negative numbers are not Armstrong by definition

    d ← number of digits in N
    sum ← 0
    temp ← N

    WHILE temp > 0:
        digit ← temp % 10
        sum ← sum + (digit ^ d)
        temp ← temp / 10

    RETURN (sum == N)
```

---

## 💾 C++ Code Snippet

```cpp
#include <iostream>
#include <cmath>
using namespace std;

bool isArmstrong(int num) {
    if (num < 0) return false;              // Handle negative input

    int d = to_string(num).length();        // Number of digits
    int sum = 0, temp = num;

    while (temp > 0) {
        int digit = temp % 10;
        sum += static_cast<int>(pow(digit, d));
        temp /= 10;
    }

    return (sum == num);
}

int main() {
    int N;
    cin >> N;

    if (isArmstrong(N))
        cout << N << " is an Armstrong number." << endl;
    else
        cout << N << " is not an Armstrong number." << endl;

    return 0;
}
```

> **Sample Run:**
>
> ```
> Input:  153  
> Output: 153 is an Armstrong number.
> 
> Input:  123
> Output: 123 is not an Armstrong number.
> ```

---

## 📈 Complexity Analysis

* **Time Complexity:**

  * $O(d)$, where $d$ is the number of digits in **N**.
  * Each loop iteration processes one digit and computes a power in constant time (assuming `pow` is $O(1)$).

* **Space Complexity:**

  * $O(1)$ — only a fixed number of variables (`d`, `sum`, `temp`, `digit`) are used.

---

## ✨ Notes & Edge Cases

* **Zero Handling:**

  * `0` is valid: $0^1 = 0$.
* **Negative Inputs:**

  * Treated as **not** Armstrong numbers.
* **Precision:**

  * `pow(int, int)` returns a `double`. Cast carefully to `int`—for large exponents this may introduce rounding.
* **Alternative Digit Count:**

  * Using `int d = floor(log10(num)) + 1;` avoids string conversion but fails when `num = 0`.
* **Larger Ranges:**

  * For very large **N**, beware of integer overflow in `pow` or in the sum accumulation. Consider using 64-bit types (`long long`) or big-integer libraries if needed.

