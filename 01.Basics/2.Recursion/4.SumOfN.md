# ðŸ“˜ Computing the Sum of First *n* Numbers Using Recursion

## ðŸ§¾ Problem Statement

> **Goal:**
> Write a recursive function that returns the sum of the first **n** positive integers:
>
> $$
> 1 + 2 + 3 + \dots + n
> $$

---

## ðŸ“¦ Code

```cpp
#include <iostream>
using namespace std;

// Recursive function to compute 1 + 2 + ... + n
int sumFirstN(int n) {
    if (n <= 0) {
        return 0;          // Base case: sum of zero or negative is 0
    }
    // Recursive step: n + sum of all numbers before it
    return n + sumFirstN(n - 1);
}

int main() {
    int n = 5;
    int result = sumFirstN(n);
    cout << "Sum of first " << n << " numbers is: " << result << endl;
    return 0;
}
```

---

## ðŸ§  Key Concepts

### âœ… Recursion

* **Definition:** A function that calls **itself**, solving smaller subproblems until a **base case** is reached.
* **Components:**

  1. **Base Case:** Terminates recursion (here, when `n â‰¤ 0`).
  2. **Recursive Case:** Breaks the problem into a smaller instance (`n - 1`).

### âœ… Mathematical Insight

$$
\sum_{k=1}^{n} k = n + \sum_{k=1}^{n-1} k
$$

---

## ðŸ§® Dry Run Example

Letâ€™s trace `sumFirstN(3)`:

| Call           | Returns            | Explanation                  |
| -------------- | ------------------ | ---------------------------- |
| `sumFirstN(3)` | `3 + sumFirstN(2)` | needs sum of first 2 numbers |
| `sumFirstN(2)` | `2 + sumFirstN(1)` | needs sum of first 1 number  |
| `sumFirstN(1)` | `1 + sumFirstN(0)` | needs sum of first 0 numbers |
| `sumFirstN(0)` | `0`                | base case reached            |

Unwinding:

* `sumFirstN(1)` â†’ `1 + 0` = **1**
* `sumFirstN(2)` â†’ `2 + 1` = **3**
* `sumFirstN(3)` â†’ `3 + 3` = **6**

Thus, **sumFirstN(3) = 6**.

---

## ðŸ” Algorithm

```text
FUNCTION sumFirstN(n):
    IF n â‰¤ 0:
        RETURN 0           // Base case
    ELSE:
        RETURN n + sumFirstN(n - 1)
```

---

## ðŸ“Œ Step-by-Step Approach

1. **Function Entry:** Receive integer `n`.
2. **Base Case Check:**

   ```cpp
   if (n <= 0) return 0;
   ```

   * Ensures recursion terminates and handles non-positive inputs gracefully.
3. **Recursive Call + Work:**

   ```cpp
   return n + sumFirstN(n - 1);
   ```

   * Adds current `n` to the sum of all preceding numbers.
4. **Result Propagation:** The final returned value bubbles up through the call stack.

---

## ðŸ’» Sample Output

For `n = 5`, the program prints:

```
Sum of first 5 numbers is: 15
```

---

## ðŸ“ˆ Complexity Analysis

| Metric              | Value                 |
| ------------------- | --------------------- |
| ðŸ•’ Time Complexity  | **O(n)**              |
| ðŸ§  Space Complexity | **O(n)** (call stack) |

* Each call reduces `n` by 1 until zero â†’ **n** calls total.
* The call stack depth is **n + 1** at peak.

---

## ðŸ“Ž Notes & Enhancements

* **Input Validation:**

  * If reading from the user, ensure `n` is non-negative or handle invalid cases.
* **Tail Recursion:**

  * This function is *not* tail-recursive since the addition happens **after** the recursive call returns.
  * To convert to tail recursion, you could use an accumulator parameter:

    ```cpp
    int sumAcc(int n, int acc = 0) {
        if (n <= 0) return acc;
        return sumAcc(n - 1, acc + n);
    }
    ```
* **Iterative Alternative:**

  ```cpp
  int sum = 0;
  for (int i = 1; i <= n; ++i) sum += i;
  ```
* **Mathematical Formula:**

  $$
  \sum_{k=1}^{n} k = \frac{n(n+1)}{2}
  $$

  * Gives **O(1)** computation without loops or recursion:

    ```cpp
    int sum = n * (n + 1) / 2;
    ```

---
