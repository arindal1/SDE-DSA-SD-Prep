# 📘 Computing the Factorial of **n** Using Recursion

## 🧾 Problem Statement

> **Goal:**
> Write a recursive function that computes the **factorial** of a non-negative integer **n**, defined as:
>
> $$
> n! = 
> \begin{cases}
> 1, & n = 0\\
> n \times (n - 1)!, & n > 0
> \end{cases}
> $$
>
> And then **print** the result.

---

## 📦 Code

```cpp
#include <iostream>
using namespace std;

// Recursive function to compute n!
long long factorial(int n) {
    // Base case:
    // 0! and 1! both equal 1
    if (n <= 1) {
        return 1LL;
    }
    // Recursive step:
    // n! = n * (n - 1)!
    return n * factorial(n - 1);
}

int main() {
    int n;
    cin >> n;

    if (n < 0) {
        cout << "Error: factorial undefined for negative n." << endl;
    } else {
        long long result = factorial(n);
        cout << n << "! = " << result << endl;
    }
    return 0;
}
```

---

## 🧠 Key Concepts

### ✅ **Recursion**

* A function calls **itself** to solve a **smaller** instance of the same problem.
* **Components**:

  1. **Base Case** to stop recursion.
  2. **Recursive Case** that moves toward the base case.

### ✅ **Base Case**

```cpp
if (n <= 1) return 1;
```

* Defines **0! = 1** and **1! = 1**.
* Prevents infinite recursion.

### ✅ **Recursive Case**

```cpp
return n * factorial(n - 1);
```

* Computes **n!** by multiplying **n** with **(n − 1)!**.

---

## 🧮 Dry Run Example

Let’s trace `factorial(4)`:

| Call           | Returns            |
| -------------- | ------------------ |
| `factorial(4)` | `4 * factorial(3)` |
| `factorial(3)` | `3 * factorial(2)` |
| `factorial(2)` | `2 * factorial(1)` |
| `factorial(1)` | `1`  *(base case)* |

Unwinding:

* `factorial(2)` → `2 * 1 = 2`
* `factorial(3)` → `3 * 2 = 6`
* `factorial(4)` → `4 * 6 = 24`

Thus, **4! = 24**.

---

## 🔁 Algorithm

```text
FUNCTION factorial(n):
    IF n ≤ 1:
        RETURN 1           // Base case: 0! = 1, 1! = 1
    ELSE:
        RETURN n * factorial(n - 1)
```

---

## 📌 Step-by-Step Approach

1. **Read Input**

   * Accept integer `n` from the user.

2. **Input Validation**

   * If `n < 0`, print an error (factorial is undefined for negatives).

3. **Compute Factorial**

   * Call `factorial(n)`:

     * **Base Case:** If `n` is 0 or 1, return 1.
     * **Recursive Case:** Multiply `n` by `factorial(n - 1)`.

4. **Print Result**

   * Output the computed `n!`.

---

## 📈 Complexity Analysis

| Metric              | Value                        |
| ------------------- | ---------------------------- |
| 🕒 Time Complexity  | **O(n)**                     |
| 🧠 Space Complexity | **O(n)** (due to call stack) |

* There are **n** recursive calls until reaching the base case.
* Call-stack depth is **n + 1** at most.

---

## 📎 Notes & Enhancements

* **Data Type:**

  * We use `long long` to handle factorials up to about **20!** without overflow.
  * For larger `n`, consider **arbitrary-precision** (e.g., C++ big-integer libraries).

* **Tail Recursion:**

  * This implementation is **not** tail-recursive: multiplication occurs **after** the recursive call returns.
  * You can convert it to a **tail-recursive** form by using an **accumulator** parameter:

    ```cpp
    long long factHelper(int n, long long acc) {
        if (n <= 1) return acc;
        return factHelper(n - 1, acc * n);
    }
    long long factorial(int n) {
        return factHelper(n, 1LL);
    }
    ```
  * Some compilers may optimize tail calls to iterations.

* **Iterative Alternative:**

  ```cpp
  long long factorialIter(int n) {
      long long res = 1;
      for (int i = 2; i <= n; ++i) {
          res *= i;
      }
      return res;
  }
  ```

  * Uses **O(1)** space but still **O(n)** time.

---
