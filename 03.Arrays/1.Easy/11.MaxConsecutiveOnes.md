# 🔢 Longest Run of Consecutive 1’s in a Binary Array

---

## 📋 Problem Statement

Given a binary array **`arr`** of size **`n`** (elements are either 0 or 1), find the length of the **longest** contiguous sequence of **1’s**.

---

## 🐢 Brute‑Force Approach (O(n²) Time)

1. For each **start** index `i` from `0` to `n−1`:

   * Initialize a counter `cnt = 0`.
   * For each **end** index `j` from `i` to `n−1`:

     * If `arr[j] == 1`, increment `cnt`; otherwise break.
     * Track the maximum `cnt` over all `i`.
2. Return the maximum.

```cpp
int longestOnesBrute(const vector<int>& arr) {
    int n = arr.size(), best = 0;
    for (int i = 0; i < n; ++i) {
        int cnt = 0;
        for (int j = i; j < n; ++j) {
            if (arr[j] == 1)
                best = max(best, ++cnt);
            else
                break;
        }
    }
    return best;
}
```

> 🔴 **Drawback:** Quadratic time can be too slow for large `n`.

---

## ⚡ Optimal Single‑Pass Approach (O(n) Time)

### **Key Idea**

Maintain two variables:

* `ctr` = current length of the ongoing run of 1’s.
* `maxi` = maximum run length seen so far.

Traverse once:

1. **If** `arr[i] == 1`:

   * Increment `ctr`.
   * Update `maxi = max(maxi, ctr)`.
2. **Else** (element is 0):

   * Reset `ctr = 0`.

At the end, `maxi` holds the answer.

---

## 📝 Algorithm

```text
FUNCTION longestConsecutiveOnes(arr, n):
    maxi ← 0
    ctr  ← 0

    FOR i FROM 0 TO n−1:
        IF arr[i] == 1:
            ctr ← ctr + 1
            maxi ← max(maxi, ctr)
        ELSE:
            ctr ← 0

    RETURN maxi
```

---

## 💾 C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the length of the longest contiguous run of 1's in arr.
 */
int longestConsecutiveOnes(const vector<int>& arr) {
    int maxi = 0, ctr = 0;
    for (int x : arr) {
        if (x == 1) {
            ctr++;
            maxi = max(maxi, ctr);
        } else {
            ctr = 0;
        }
    }
    return maxi;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    cout << longestConsecutiveOnes(arr) << "\n";
    return 0;
}
```

---

## 📈 Complexity Analysis

| Approach           | Time Complexity | Space Complexity |
| ------------------ | --------------- | ---------------- |
| Brute‑Force        | O(n²)           | O(1)             |
| Single‑Pass (Opt.) | **O(n)**        | **O(1)**         |

---

## ✨ Notes & Facts

* **Zero Reset:** Each zero forces the current run counter `ctr` to zero.
* **Edge Cases:**

  * **All 1’s** → answer = `n`.
  * **All 0’s** → answer = `0`.
  * **Empty array** (`n = 0`) → answer = `0`.
* **Generalization:**

  * You can adapt this to find longest run of any target value or in non-binary arrays.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: How to get the indices of that longest run?**

> Track `end_index` when you update `maxi`, then `start_index = end_index − maxi + 1`.

---

**Q2: Can this be done recursively?**

> Yes, but recursion adds **O(n)** call-stack overhead; iterative is simpler.

---

**Q3: What if you wanted the longest run of zeros instead?**

> Change the comparison to `if (x == 0)` and reset on `1`.

---
