# 🔄 Left Rotate an Array by One Position

---

## 📋 Problem Statement

Given an integer array **`arr`** of size **`n`**, **left rotate** it by **one** position and print the resulting array.

> A **left rotation** shifts each element to its **left** neighbor; the first element wraps around to the end.

---

## 🚀 Brute‑Force Approach (Multiple Shifts)

If you needed to rotate by **`k`** positions, you could repeat the “rotate by one” step **`k`** times:

```cpp
// O(k·n) time, O(1) space
void rotateBrute(int arr[], int n, int k) {
    k %= n;  // in case k ≥ n
    while (k--) {
        int first = arr[0];
        for (int i = 0; i < n-1; ++i)
            arr[i] = arr[i+1];
        arr[n-1] = first;
    }
}
```

> 🔴 **Drawback:**
>
> * If `k` is large (e.g., \~n), this becomes **O(n²)**.

---

## ⚡ Optimal Single‑Pass Approach for **k = 1**

Since **`k = 1`** here, we can do the rotation in **one pass**:

1. **Store** the first element in a temporary variable.
2. **Shift** every element `arr[i+1]` into `arr[i]` for `i = 0…n-2`.
3. **Place** the stored first element into `arr[n-1]`.
4. **Print** the array.

This runs in **O(n)** time and **O(1)** extra space.

---

## 📝 Pseudocode

```text
FUNCTION leftRotateByOne(arr, n):
    IF n == 0: RETURN

    temp ← arr[0]
    FOR i FROM 0 TO n−2:
        arr[i] ← arr[i+1]
    arr[n−1] ← temp

    PRINT arr[0…n−1]
```

---

## 💾 C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Left rotates the array arr of size n by one position in-place,
 * then prints the rotated array.
 */
void leftRotateByOne(int arr[], int n) {
    if (n <= 1) {
        // Nothing to do for empty or single-element arrays
        for (int i = 0; i < n; ++i)
            cout << arr[i] << " ";
        return;
    }

    // Step 1: Save the first element
    int temp = arr[0];

    // Step 2: Shift elements left by one
    for (int i = 0; i < n - 1; ++i) {
        arr[i] = arr[i + 1];
    }

    // Step 3: Place saved element at the end
    arr[n - 1] = temp;

    // Step 4: Print the rotated array
    for (int i = 0; i < n; ++i) {
        cout << arr[i] << (i + 1 < n ? ' ' : '\n');
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n = 5;
    int arr[] = {1, 2, 3, 4, 5};

    leftRotateByOne(arr, n);
    return 0;
}
```

---

## 📈 Complexity Analysis

| Metric               | Value |
| -------------------- | ----- |
| **Time Complexity**  | O(n)  |
| **Space Complexity** | O(1)  |

* Exactly **n − 1** assignments in the shift loop.
* Only a constant number of extra variables (`temp`, loop counters).

---

## ✨ Notes & Facts

* **In-Place:** No extra array needed—works directly on the input.
* **Edge Cases:**

  * **`n = 0`** (empty array): prints nothing.
  * **`n = 1`**: array remains the same.
* **Generalizing to `k` Rotations:**

  * For **arbitrary** `k`, an optimal technique is to reverse segments:

    1. Reverse the first `k` elements.
    2. Reverse the remaining `n - k` elements.
    3. Reverse the entire array.
  * That method runs in **O(n)** time and **O(1)** space.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Why check `n <= 1`?**

> Arrays with 0 or 1 elements are trivially unchanged by any rotation.

---

**Q2: Can we rotate right by one instead?**

> Yes—store the last element, shift everything right, and place the stored element at index 0.

---

**Q3: How to rotate by `k` without repeated shifts?**

> Use the **three‑reverse trick** (see Notes above), or compute **new indices** directly.

---

**Q4: Does this preserve order?**

> Yes—the relative order of all other elements is maintained, only the first moves to last.

---
