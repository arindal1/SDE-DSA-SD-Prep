# 💧 Container With Most Water


## 📄 Problem Statement

You are given an array `height` of **n** non-negative integers where each represents a vertical line of width 1 on the x-axis. Find two lines, which together with the x-axis form a container, such that the container holds the **most water**. Return the maximum amount of water it can store.

* **Input:**

  * An integer `n`, the number of lines.
  * An array `height` of length `n`, where `height[i]` is the line’s height.
* **Output:**

  * A single integer: the maximum water area.

---

## 💡 Intuition

* The **area** between two lines at indices `i` and `j` is:

  $$
    \text{area} = \min(\text{height}[i], \text{height}[j]) \times (j - i)
  $$
* To maximize area, you want **large width** and **tall boundary**.
* A **two-pointer** approach scans from both ends:

  1. Start with `left = 0`, `right = n-1`.
  2. Compute area, update `max_area`.
  3. **Move** the pointer at the **shorter** line inward—because moving the taller line cannot increase the minimum height, but moving the shorter line *might* find a taller one.

This yields an **O(n)** solution without extra space.

---

## 🐢 Brute‑Force Approach

Try all pairs `(i, j)`:

```cpp
int maxAreaBrute(const vector<int>& h) {
    int n = h.size(), ans = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            int area = min(h[i], h[j]) * (j - i);
            ans = max(ans, area);
        }
    }
    return ans;
}
```

* **Time Complexity:** *O(n²)*
* **Space Complexity:** *O(1)*

> ❌ Too slow for large `n` (up to 10⁵).

---

## 🚀 Optimal Two‑Pointer Approach

```cpp
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int max_area = 0;

    while (left < right) {
        int h = min(height[left], height[right]);
        int w = right - left;
        max_area = max(max_area, h * w);

        // Move the shorter line inward
        if (height[left] < height[right]) 
            ++left;
        else 
            --right;
    }
    return max_area;
}
```

### Why It Works

* Starting from the widest container, any movement of the **taller** line can only reduce the minimum height or width.
* By moving the **shorter** line, you *might* find a taller boundary that compensates for the reduced width.

---

## ✏️ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int max_area = 0;

    while (left < right) {
        int h = min(height[left], height[right]);
        int w = right - left;
        max_area = max(max_area, h * w);

        if (height[left] < height[right])
            ++left;
        else
            --right;
    }
    return max_area;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> height(n);
    for (int i = 0; i < n; i++) {
        cin >> height[i];
    }

    cout << maxArea(height) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase            | Time Complexity | Space Complexity |
| ---------------- | --------------- | ---------------- |
| Two-pointer scan | *O(n)*          | *O(1)*           |
| **Overall**      | **O(n)**        | **O(1)**         |

---

## ✅ Test Cases

| `height`              | Output | Explanation                                                  |
| --------------------- | ------ | ------------------------------------------------------------ |
| `[1,8,6,2,5,4,8,3,7]` | `49`   | Between lines at `i=1` (h=8) and `j=8` (h=7), area = 7×7=49. |
| `[1,1]`               | `1`    | Only one container: area = min(1,1)×(1−0)=1.                 |
| `[4,3,2,1,4]`         | `16`   | Lines at ends: min(4,4)×4=16.                                |
| `[1,2,1]`             | `2`    | Best between `i=0` and `j=2`: min(1,1)×2=2.                  |

---

## 🎯 Tips & Tricks

* 🖋️ **Greedy two-pointer** is a common pattern for pairwise optimizations on sorted or monotonic structures.
* 🔢 Always consider **width** vs **height** trade-offs—moving the pointer at the smaller height is key.
* 🛡️ Edge-case: if all heights equal, the maximum is between the first and last.

---

## 🔄 Variations

1. **Maximal Rectangle in Histogram** (more complex, stack-based).
2. **Trapping Rain Water** (two-pointer with water accumulation).
3. **Largest Island** in a grid (DFS/BFS rather than two-pointer).

---

## ❓ FAQs

> **Q1. Why not move both pointers?** <br>
> Moving both reduces width by 2 each step and offers no benefit—only the shorter line matters.

> **Q2. Can this fail on negative heights?** <br>
> Heights are non-negative by definition. Negative values would break the “area” interpretation.

> **Q3. What if input size `n` is 0 or 1?** <br>
> Return `0` (no container possible). You can add a guard:
>
> ```cpp
> if (n < 2) return 0;
> ```

> **Q4. Is there a divide‑and‑conquer way?** <br>
> Yes, but it typically runs in *O(n log n)* and is overkill compared to this linear solution.

---

