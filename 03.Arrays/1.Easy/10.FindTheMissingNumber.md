# â“ Finding the Missing Number (1â€¦n) Using XOR

---

## ğŸ“‹ Problem Statement

You have an array **`arr`** containing **`n-1`** distinct integers from the range **1** to **n**, with exactly **one** number missing. Write a function to **find** that missing number **in O(n)** time and **O(1)** extra space.

---

## ğŸ¢ Bruteâ€‘Force Approaches

### 1. Sum Formula

* Compute the expected sum of 1â€¦n:

  $$
    S = \frac{n(n+1)}{2}
  $$
* Subtract the sum of array elements:

  $$
    \text{missing} = S - \sum arr[i]
  $$
* **Time:** O(n)
* **Space:** O(1)
* **Caveat:** Risk of **integer overflow** for large n.

### 2. Boolean Marker Array

* Create a boolean `seen[1â€¦n]` initialized to `false`.
* Mark `seen[arr[i]] = true` for each element.
* Scan `seen` to find the index still `false`.
* **Time:** O(n)
* **Space:** O(n) extra.

---

## âš¡ Optimal XOR Approach

### **Key Insight**

* XOR of a number with itself is 0: `x ^ x = 0`.
* XOR with 0 leaves the other operand unchanged: `x ^ 0 = x`.
* XOR is **associative** and **commutative**.

If you XOR all numbers from **1** to **n** and then XOR all elements in the array, every number that appears in both lists will cancel out, leaving only the **missing** number.

---

## ğŸ“ Algorithm

```text
FUNCTION findMissing(arr, n):
    xorFull â† 0
    xorArr  â† 0

    // XOR 1 through n
    FOR i FROM 1 TO n:
        xorFull â† xorFull XOR i

    // XOR all elements in arr[0..n-2]
    FOR each x in arr:
        xorArr â† xorArr XOR x

    // missing number is the XOR of these two results
    RETURN xorFull XOR xorArr
```

---

## ğŸ’¾ Corrected C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Assumes arr contains n-1 distinct integers from 1 to n,
 * with exactly one missing. Returns the missing integer.
 */
int findMissing(const vector<int>& arr, int n) {
    int xorFull = 0;  // XOR of 1..n
    int xorArr  = 0;  // XOR of all elements in arr

    // 1) XOR all numbers from 1 to n
    for (int i = 1; i <= n; i++) {
        xorFull ^= i;
    }

    // 2) XOR all values actually present
    for (int x : arr) {
        xorArr ^= x;
    }

    // 3) The missing number remains
    return xorFull ^ xorArr;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    // Read n = upper bound of range (1..n), arr size should be n-1
    cin >> n;
    vector<int> arr(n - 1);
    for (int i = 0; i < n - 1; i++) {
        cin >> arr[i];
    }

    cout << findMissing(arr, n) << "\n";
    return 0;
}
```

> **Note:**
>
> * We read **n**, then exactly **n-1** elements into `arr`.
> * This matches â€œone missing numberâ€ scenario.

---

## ğŸ“ˆ Complexity Analysis

| Metric               | Value    |
| -------------------- | -------- |
| **Time Complexity**  | **O(n)** |
| **Space Complexity** | **O(1)** |

* Single pass to build `xorFull` and single pass over `arr`.
* Only two integer accumulators.

---

## âœ¨ Notes & Facts

* **No Overflow Risk:** Unlike the sum formula, XOR wonâ€™t overflow for standard 32â€‘bit or 64â€‘bit integers in this use case.
* **Generalizes** to other â€œone missingâ€ problemsâ€”e.g., missing element in 0â€¦n.
* **Variant:** If **two** numbers are missing or one duplicate and one missing, youâ€™ll need more complex bitwise partitioning.

---

## â“ Frequently Asked Questions (FAQs)

**Q1: What if the array contained the numbers 0â€¦n instead?**

> XOR from **0** to **n** instead of **1** to **n**, and read **n** elements.

---

**Q2: Can we detect two missing numbers with XOR?**

> Not directly. Youâ€™d first find the XOR of the two missing values, then partition numbers by a set bitâ€”more complex.

---

**Q3: What if the array isnâ€™t of size n-1?**

> Ensure input meets the precondition; otherwise the method yields incorrect results.

---

