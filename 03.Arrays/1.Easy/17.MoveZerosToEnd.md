# 🚚 Move Zeroes to End

## 📄 Problem Statement

Given an integer array `nums`, move all `0`'s to the **end** of the array while maintaining the **relative order** of the non-zero elements.

* **Do this in-place** without making a copy of the array.
* **Minimize the total number of operations.**

---

## 💡 Intuition

To solve this efficiently:

* We want to **move all non-zero elements forward**, keeping their original order.
* Every time we find a non-zero, we can **bring it to the front** at the earliest available index (`i`).
* If `i` is different from current index `j`, we **swap** them.
* At the end, all the `0`s will have been shifted to the right.

This is a classic **two-pointer** problem.

---

## 🐢 Brute‑Force Approach

1. Create a temporary vector and store all non-zero elements.
2. Fill the rest of the vector with 0s.
3. Copy it back to the original array.

```cpp
void moveZeroesBrute(vector<int>& nums) {
    vector<int> temp;
    for (int x : nums)
        if (x != 0)
            temp.push_back(x);
    while (temp.size() < nums.size())
        temp.push_back(0);
    nums = temp;
}
```

* ❌ Uses extra space → violates **in-place** constraint.

---

## 🚀 Optimal Two‑Pointer In‑Place Approach

```cpp
void moveZeroes(vector<int>& nums) {
    int i = 0, n = nums.size();
    for (int j = 0; j < n; j++) {
        if (nums[j] != 0) {
            swap(nums[i], nums[j]);
            i++;
        }
    }
}
```

### Explanation:

* `i`: tracks the position to place the next non-zero.
* `j`: iterates through the array.
* When `nums[j] != 0`, we bring it to position `i`, then increment `i`.

> 📌 If `i == j`, the element is already in the right place, so the swap is cheap.

---

## ✅ Test Cases

| Input          | Output         | Explanation            |
| -------------- | -------------- | ---------------------- |
| `[0,1,0,3,12]` | `[1,3,12,0,0]` | Move non-zeros forward |
| `[0,0,1]`      | `[1,0,0]`      | Only one non-zero      |
| `[1,2,3]`      | `[1,2,3]`      | Already optimized      |
| `[0,0,0]`      | `[0,0,0]`      | Only zeroes            |
| `[]`           | `[]`           | Empty array            |

---

## ✏️ Full Code with `main()` (User Input)

```cpp
#include <bits/stdc++.h>
using namespace std;

void moveZeroes(vector<int>& nums) {
    int i = 0, n = nums.size();
    for (int j = 0; j < n; j++) {
        if (nums[j] != 0) {
            swap(nums[i], nums[j]);
            i++;
        }
    }
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> nums(n);

    for (int i = 0; i < n; i++)
        cin >> nums[i];

    Solution sol;
    sol.moveZeroes(nums);

    for (int x : nums)
        cout << x << " ";
    cout << "\n";

    return 0;
}
```

---

## 📊 Complexity Analysis

| Operation         | Time Complexity | Space Complexity  |
| ----------------- | --------------- | ----------------- |
| Loop through nums | *O(n)*          | *O(1)* (in-place) |
| **Overall**       | **O(n)**        | **O(1)**          |

---

## 🎯 Tips & Tricks

* 🧠 Use **two pointers** when you need to reorganize while preserving order.
* 💡 The idea is **pushing useful elements forward**, not removing zeroes explicitly.
* 🔁 When `i == j`, no swap is needed, but the code still works correctly and fast.

---

## 🔄 Variations

1. **Move all zeros to the front** instead of the back.
2. **Move all even numbers to the end** (change the condition to `nums[j] % 2 != 0`).
3. **Return count of non-zero elements** while moving zeroes.

---

## ❓ FAQs

> **Q1. Why use `swap` even when `i == j`?** <br>
> It's safe and ensures logic remains simple. Some compilers optimize the redundant swap anyway.

> **Q2. Can we overwrite zeroes manually after the first pass?** <br>
> Yes, but that would require two loops and complicate logic unnecessarily.

> **Q3. Does this preserve the order of non-zero elements?** <br>
> ✅ Yes! That's the main reason for using the two-pointer approach in this way.

---

