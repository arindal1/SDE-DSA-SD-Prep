# ➕ Plus One

---

## 📄 Problem Statement

Given a non-empty array of digits representing a non-negative integer, **increment** the integer by **one** and return the resulting array of digits.

* Each element in the array contains a single digit (`0`–`9`).
* The digits are stored such that the most significant digit is at the head of the list.
* **You may assume** the integer does not contain leading zeros, except the number 0 itself.

---

## 💡 Intuition

* We’re simulating **addition** of 1 to a multi-digit number stored in an array.
* Starting from the **least significant** digit (end of the array), add the **carry** (initially 1).
* If the sum stays below 10, store it and **stop**—no further carry.
* If it reaches 10, store 0 and **propagate** carry = 1 to the next digit on the left.
* If after processing all digits a carry remains, **prepend** a 1 (e.g., 999 → 1000).

---

## 🐢 Brute‑Force Approach

Convert the digit array to a **string** or **big integer**, add 1 using library support, then convert back to digits:

```cpp
vector<int> plusOneBrute(vector<int>& digits) {
    int n = digits.size();

    for (int i = n-1; i >= 0; i++) {
        if (digits[i] != 9) {
            digits[i] += 1;
            break;
        } else if (digits[i] == 9 && i != 0) {
            digits[i] = 0;
        } else {
            digits[i] = 0;
            digits.insert(nums.begin(), 1);
        }
    }

    return ans;
}
```

* **Time Complexity:** *O(n)*
* **Space Complexity:** *O(1)*

‼️ **Mid‑loop insert** (which itself is O(n) when it happens), you do at most one assign/resize at the end.

---

## 🚀 Optimal In‑Place Approach

1. **Initialize** `carry = 1`.
2. **Traverse** from index `n−1` down to `0` **while** `carry` is non-zero:

   * Compute `sum = digits[i] + carry`.
   * Set `digits[i] = sum % 10`.
   * Update `carry = sum / 10`.
3. **After** loop, if `carry` remains (`1`), **prepend** `1` to the array:

   ```cpp
   digits.assign(n+1, 0);
   digits[0] = 1;
   ```
4. **Return** `digits`.

*No extra buffers*, just modifying the input vector (plus one resize if needed).

---

## ✏️ Full Corrected & Enhanced Code

> **Enhancements / Notes:**
>
> * Uses in-place updates for O(1) extra space.
> * Handles edge-cases: all 9’s, single-digit, zero.

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Adds one to the integer represented by digits[].
 * Returns the new digits vector.
 */
vector<int> plusOne(vector<int>& digits) {
    int n = digits.size();
    int carry = 1;  // initial +1

    // Add carry from least significant digit backwards
    for (int i = n - 1; i >= 0 && carry; --i) {
        int sum = digits[i] + carry;
        digits[i] = sum % 10;
        carry = sum / 10;
    }

    // If carry still remains, need an extra digit at front
    if (carry) {
        digits.assign(n + 1, 0);
        digits[0] = 1;
    }

    return digits;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    vector<int> ans = plusOne(arr);
    for (int d : ans) {
        cout << d << " ";
    }
    cout << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                           | Time Complexity | Space Complexity |
| ------------------------------- | --------------- | ---------------- |
| Single backward pass            | *O(n)*          | *O(1)*           |
| Possible vector resize & assign | *O(n)*          | *O(n)* (new)     |
| **Overall**                     | **O(n)**        | **O(n)** (worst) |

> 🎯 In typical case (no carry at end), extra space is **O(1)**.

---

## ✅ Test Cases

| Input       | Output    | Explanation                    |
| ----------- | --------- | ------------------------------ |
| `[1,2,3]`   | `1 2 4`   | Simple +1                      |
| `[4,3,2,1]` | `4 3 2 2` | Carry resets after first digit |
| `[9]`       | `1 0`     | Single 9 → wrap to 10          |
| `[9,9,9]`   | `1 0 0 0` | All 9’s → new leading digit    |
| `[0]`       | `1`       | 0 → 1                          |
| `[1,9,9]`   | `2 0 0`   | Multi-digit carry propagate    |

---

## 🎯 Tips & Tricks

* 🔄 **In‑place** updates avoid extra memory.
* 🛡️ **Carry logic**: always use `sum = digit + carry`, then separate new digit and carry.
* ✨ **Vector resize**: `assign(n+1, 0)` creates new size and zero-fills—nice shortcut.

---

## 🔄 Variations

1. **Arbitrary Base**

   * Generalize to base-`k` digits by replacing `%10` and `/10` with `%k` and `/k`.
2. **Add K**

   * Instead of +1, add any integer `K` by initializing `carry = K` and doing same loop.
3. **Linked‑List Representation**

   * Apply same logic on a singly‑linked list—requires pointer manipulations and potential new head.

---

## ❓ FAQs

> **Q1. Why `assign(n+1, 0)` instead of `insert`?** <br>
> `assign` conveniently resizes and zero‑initializes in one step, then we set the leading `1`.

> **Q2. What about very large arrays?** <br>
> Time is linear. Memory spike only if original number is all 9’s.

> **Q3. Can this handle negative numbers?** <br>
> Problem assumes non-negative integer representation only.

> **Q4. Why loop stops when `carry` is zero?** <br>
> No further changes needed once carry = 0, saving unnecessary iterations.

---

