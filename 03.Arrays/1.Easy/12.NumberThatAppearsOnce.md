# ğŸ•µï¸â€â™‚ï¸ Find the Element That Appears Only Once (All Others Twice)

---

## ğŸ“‹ Problem Statement

Given an integer array **`nums`** of size **`n`**, where **every element** appears **exactly twice** except for **one** element that appears **once**, find and return that **single** element.

---

## ğŸ¢ Bruteâ€‘Force Approaches

### 1ï¸âƒ£ Hashâ€Map Frequency Count

1. Traverse the array, build a `unordered_map<int,int> freq`.
2. Second pass: return the key whose `freq[key] == 1`.

```cpp
// O(n) time, O(n) extra space
int findSingleHash(const vector<int>& nums) {
    unordered_map<int,int> freq;
    for(int x: nums) freq[x]++;
    for(auto& p: freq) {
        if(p.second == 1) return p.first;
    }
    return -1; // should never happen given problem constraints
}
```

### 2ï¸âƒ£ Sorting

1. Sort the array in O(n log n).
2. Scan adjacent pairs; the single element will not match its neighbor.

```cpp
// O(n log n) time, O(1) or O(n) depending on in-place sort
int findSingleSort(vector<int> nums) {
    sort(nums.begin(), nums.end());
    int n = nums.size();
    for (int i = 0; i < n-1; i+=2) {
        if (nums[i] != nums[i+1]) 
            return nums[i];
    }
    return nums[n-1]; // last element if all pairs matched earlier
}
```

> **Drawbacks:** Both use extra space or higher time than optimal.

---

## âš¡ Optimal XOR Approach (O(n) Time, O(1) Space)

### **Key Insight**

* XOR properties:

  ```
  x ^ x = 0  
  x ^ 0 = x  
  ^ is commutative and associative
  ```
* XOR'ing **all** array elements cancels out every number appearing twice, leaving the **unique** one.

```text
FUNCTION findSingle(nums):
    result â† 0
    FOR each x IN nums:
        result â† result XOR x
    RETURN result
```

---

## ğŸ“¦ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the element that appears only once in 'nums',
 * where every other element appears exactly twice.
 */
int AppearsOnce(const vector<int>& nums) {
    int x = 0;
    for (int v : nums) {
        x ^= v;
    }
    return x;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    cout << AppearsOnce(nums) << "\n";
    return 0;
}
```

---

## ğŸ“ˆ Complexity Analysis

| Approach           | Time Complexity | Space Complexity |
| ------------------ | --------------- | ---------------- |
| Hashâ€‘Map Frequency | O(n)            | O(n)             |
| Sorting            | O(n log n)      | O(1)/O(n)        |
| **XOR (Optimal)**  | **O(n)**        | **O(1)**         |

---

## âœ¨ Notes & Facts

* **Single Pass:** XOR method requires only one traversal.
* **No Extra Memory:** Uses a single integer accumulator.
* **Guaranteed Uniqueness:** Works only when **exactly one** element is unpaired and all others appear **exactly twice**.
* **Generalization:**

  * If every element appears `k` times except one, more advanced bitâ€counting methods are needed.

---

## â“ Frequently Asked Questions (FAQs)

**Q1: What if more than one element appears once?**

> The XOR trick only finds **one** unique if all others are paired. For multiple uniques, use sorting or a frequency map.

---

**Q2: Can this handle negative numbers?**

> Yesâ€”XOR works on the bit representation, sign bit included.

---

**Q3: What if one appears once, another appears three times, others twice?**

> XOR failsâ€”use bitwise counting per bit position to handle arbitrary counts.

---
