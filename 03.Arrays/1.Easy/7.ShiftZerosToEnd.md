# ‚û°Ô∏è Move All Zeros to the End of the Array (Stable, In‚ÄëPlace)

---

## üìã Problem Statement

Given an integer array **`arr`** of size **`n`**, **move all zeros** to the **end** while preserving the **relative order** of non‚Äëzero elements, **in-place**. Return (or print) the modified array.

---

## üîé Examples

| Input              | Output             | Explanation                                   |
| ------------------ | ------------------ | --------------------------------------------- |
| `[0, 1, 0, 3, 12]` | `[1, 3, 12, 0, 0]` | Non‚Äëzeros stay in order; zeros shifted right. |
| `[1, 2, 3]`        | `[1, 2, 3]`        | No zeros ‚Üí unchanged.                         |
| `[0, 0, 0, 5]`     | `[5, 0, 0, 0]`     | All zeros to end.                             |
| `[]`               | `[]`               | Empty array ‚Üí unchanged.                      |

---

## üê¢ Brute‚ÄëForce Approach

1. **Allocate** a new array `result` of size `n`.
2. **Copy** all non‚Äëzero elements from `arr` into `result` (in order).
3. **Fill** the remaining positions in `result` with zeros.
4. **Copy back** to `arr`, or simply return `result`.

```cpp
// O(n) time, O(n) extra space
vector<int> moveZerosBrute(const vector<int>& arr) {
    int n = arr.size();
    vector<int> result(n);
    int idx = 0;
    // 1) copy non-zeros
    for (int x : arr) {
        if (x != 0) result[idx++] = x;
    }
    // 2) fill rest with zeros
    while (idx < n) {
        result[idx++] = 0;
    }
    return result;
}
```

> **Drawbacks:**
>
> * Uses **O(n)** extra space.
> * Does not modify in-place.

---

## ‚ö° Optimal Two‚ÄëPointer (In‚ÄëPlace, Stable)

### **Key Idea**

Use two pointers:

* **`j`** tracks the **next position** to place a non-zero.
* **`i`** scans through the array.

**Steps:**

1. Initialize `j = 0`.
2. For each `i` from `0` to `n‚àí1`:

   * If `arr[i] != 0`, **swap** `arr[i]` with `arr[j]`, then **increment** `j`.
3. After this pass, all non‚Äëzeros are in `arr[0‚Ä¶j‚àí1]` in order, and positions `j‚Ä¶n‚àí1` are zeros.

This maintains stability (relative order) and runs in **O(n)** time, **O(1)** extra space.

---

## üìù Pseudocode

```text
FUNCTION moveZeros(arr, n):
    j ‚Üê 0

    FOR i FROM 0 TO n‚àí1:
        IF arr[i] ‚â† 0:
            swap(arr[i], arr[j])
            j ‚Üê j + 1

    // positions j‚Ä¶n‚àí1 are implicitly zeros
```

---

## üíæ Revised C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Moves all zeros in 'arr' of size 'n' to the end, in-place.
 * Maintains the order of non-zero elements.
 */
void moveZeros(vector<int>& arr) {
    int n = arr.size(), j = 0;
    // j = next position to place a non-zero
    for (int i = 0; i < n; i++) {
        if (arr[i] != 0) {
            swap(arr[i], arr[j]);
            j++;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    moveZeros(arr);

    for (int x : arr) {
        cout << x << " ";
    }
    cout << "\n";
    return 0;
}
```

---

## üìà Complexity Analysis

| Metric               | Value    |
| -------------------- | -------- |
| **Time Complexity**  | **O(n)** |
| **Space Complexity** | **O(1)** |

* **Single pass** over the array (`i` runs 0‚Ä¶n‚àí1).
* Only two integer pointers (`i`, `j`) and in-place swaps.

---

## ‚ú® Notes & Facts

* This method **preserves** the **relative order** of non-zero elements.
* After the loop, all indices ‚â• `j` must be zeros, because each non-zero has been swapped forward.
* If the array is very large, this approach is memory‚Äëefficient since it uses **no extra structures**.

---

## ‚ùì Frequently Asked Questions

**Q1: Why initialize `j = 0` instead of searching for the first zero?**

> This variant is simpler. Every time you find a non-zero, you move it to the earliest vacancy (`j`), automatically pushing zeros right.

---

**Q2: Is stability guaranteed?**

> **Yes.** Swapping each non-zero with `arr[j]` only moves zeros back; the relative order of non-zeros remains unchanged.

---

**Q3: What if the order of zeros among themselves matters?**

> Zeros are indistinguishable, so their internal order is irrelevant.

---

**Q4: How to move all **ones** to the end instead?**

> Simply change the condition to `if (arr[i] != 1)` in the same algorithm.

---
