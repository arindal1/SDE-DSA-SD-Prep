## **Find the Largest and Second Largest Elements in an Array**

## 📋 Problem Statement

Given an integer array **`arr`** of size **`n`**, print its **second largest** and **largest** elements.

---

## 🔎 Examples

| Input                   | Output         | Explanation                                                |
| ----------------------- | -------------- | ---------------------------------------------------------- |
| `arr = [2, 5, 1, 5, 3]` | `3 – 5`        | Largest = 5; Second largest = 3 (the next distinct value). |
| `arr = [7]`             | `– –` or error | Only one element → no second largest.                      |
| `arr = [4, 4, 4]`       | `– –`          | All equal → no distinct second largest.                    |

---

## 🐢 Brute-Force Approach

1. **Sort** the array in **descending** order.
2. **Walk** the sorted array until you find the **first value** strictly less than the maximum.
3. That value is the second largest.

```cpp
// O(n log n) due to sort
void bruteForce(vector<int>& arr) {
    sort(arr.begin(), arr.end(), greater<int>());
    int maxVal = arr[0];
    for (int x : arr) {
        if (x < maxVal) {
            cout << x << " - " << maxVal;
            return;
        }
    }
    // no second largest found
    cout << "No second largest\n";
}
```

> **Drawbacks:**
>
> * **Time:** O(n log n)
> * **Space:** May modify the input.
> * **Inefficient** if all you need is two values.

---

## ⚡ Optimal Single-Pass Approach

### **Key Idea**

Scan the array **once**, maintaining two variables:

* `largest`
* `second_largest`

At each element `x`:

1. If `x > largest`:

   * `second_largest = largest`
   * `largest = x`
2. Else if (`x < largest` AND `x > second_largest`):

   * `second_largest = x`

This yields an **O(n)** time, **O(1)** space solution.

---

## 📝 Algorithm

```text
FUNCTION findTwoLargest(arr, n):
    IF n < 2:
        ERROR "Need at least two elements"

    largest ← max(arr[0], arr[1])
    second_largest ← min(arr[0], arr[1])

    FOR i FROM 2 TO n–1:
        x ← arr[i]
        IF x > largest:
            second_largest ← largest
            largest ← x
        ELSE IF (x < largest) AND (x > second_largest):
            second_largest ← x

    IF second_largest == initial_minimum_value:
        ERROR "No distinct second largest"
    RETURN (second_largest, largest)
```

---

## 💾 Revised C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Prints second largest and largest in arr of size n.
// If not available, prints an error message.
void printTwoLargest(const vector<int>& arr) {
    int n = arr.size();
    if (n < 2) {
        cout << "Error: need at least two elements\n";
        return;
    }

    int largest   = max(arr[0], arr[1]);
    int second_largest = min(arr[0], arr[1]);

    for (int i = 2; i < n; i++) {
        int x = arr[i];
        if (x > largest) {
            second_largest = largest;
            largest = x;
        } else if (x < largest && x > second_largest) {
            second_largest = x;
        }
    }

    if (largest == second_largest) {
        cout << "Error: no distinct second largest\n";
    } else {
        cout << second_largest << " – " << largest << "\n";
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    printTwoLargest(arr);
    return 0;
}
```

---

## 📈 Complexity Analysis

| Approach            | Time Complexity | Space Complexity |
| ------------------- | --------------- | ---------------- |
| **Sorting (brute)** | O(n log n)      | O(1) / in-place  |
| **Linear scan**     | **O(n)**        | **O(1)**         |

---

## ✨ Notes & Facts

* **Initialization:** Start by comparing the first two elements to seed both `largest` and `second_largest`.
* **Distinctness:** The check `x < largest` ensures that we only update the second largest when encountering a **strictly smaller** value.
* **Edge Cases:**

  * **All elements equal** → no distinct second largest.
  * **Negative values** → code handles correctly since comparisons are value-based.

---

## ❓ Frequently Asked Questions

**Q1: What if the array has duplicates of the maximum?**

> Duplicates of the maximum do **not** count as second largest. We require the next **distinct** value.

---

**Q2: Can we extend this to k-th largest?**

> Yes, you can maintain a **min-heap** of size `k` in O(n log k) time.

---

**Q3: Why is sorting not ideal?**

> Sorting costs O(n log n) versus the single-scan O(n). For large `n`, the difference is significant.

---
