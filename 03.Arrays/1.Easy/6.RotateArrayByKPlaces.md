# 🔄 Rotate an Array by **k** Positions (Left Rotation via Reversal)

---

## 📋 Problem Statement

Given an integer array **`arr`** of size **`n`** and an integer **`k`**, **rotate** the array to the **left** by **`k`** positions **in-place**, then print the resulting array.

> A **left rotation** by `k` moves each element from index `i` to `(i−k+n) % n`.

---

## 🚀 Brute‑Force Approach (Repeated Single Rotations)

Perform the “rotate by one” step **`k`** times:

```cpp
// O(k·n) time, O(1) space
void rotateBrute(int arr[], int n, int k) {
    k %= n;
    while (k--) {
        int first = arr[0];
        for (int i = 0; i < n - 1; ++i)
            arr[i] = arr[i + 1];
        arr[n - 1] = first;
    }
}
```

> 🔴 **Drawback:**
>
> * If `k` is large (e.g., \~n), this becomes **O(n²)**.

---

## ⚡ Optimal Reversal‑Based Approach

### **Key Insight**

A left rotation by **`k`** can be achieved by three **in-place** reversals:

1. **Reverse** the first **`k`** elements.
2. **Reverse** the remaining **`n−k`** elements.
3. **Reverse** the **entire** array.

After these operations, elements that were at positions `0…k−1` end up at `n−k…n−1`, and the rest shift left.

---

## 📝 Algorithm

```text
FUNCTION rotateLeft(arr, n, k):
    // 1. Normalize k
    k ← k mod n
    IF k == 0:
        RETURN

    // 2. Reverse subarrays
    reverse(arr[0 … k−1])
    reverse(arr[k … n−1])
    reverse(arr[0 … n−1])
```

---

## 💾 C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Rotates the vector arr of size n to the left by k positions in-place.
 */
void RotateArray(vector<int>& arr, int n, int k) {
    k %= n;                    // Normalize k
    if (k == 0) return;        // No rotation needed

    // Step 1: Reverse the first k elements
    reverse(arr.begin(), arr.begin() + k);

    // Step 2: Reverse the remaining n-k elements
    reverse(arr.begin() + k, arr.end());

    // Step 3: Reverse the entire array
    reverse(arr.begin(), arr.end());
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    cin >> n >> k;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    RotateArray(arr, n, k);

    for (int x : arr) {
        cout << x << " ";
    }
    cout << "\n";
    return 0;
}
```

---

## 📈 Complexity Analysis

| Metric               | Value    |
| -------------------- | -------- |
| **Time Complexity**  | **O(n)** |
| **Space Complexity** | **O(1)** |

* Each of the three `reverse` calls runs in **O(n)** total across the entire array (sum of their lengths = n).
* Only constant extra space is used.

---

## ✨ Notes & Facts

* **In-Place:** No additional arrays or vectors needed.
* **Handles Large k:** Normalizing `k %= n` ensures correct behavior even if `k > n`.
* **Direction Flexibility:**

  * For **right rotation** by `k`, reverse the **entire** array first, then reverse the first `k` and last `n−k` segments.
* **STL Utility:** `std::rotate(arr.begin(), arr.begin() + k, arr.end())` achieves the same in linear time.

---

## ❓ Frequently Asked Questions

**Q1: Why three reversals?**

> Reversing segments and then the whole array effectively shifts the order without per-element moves.

---

**Q2: Can we do this with extra buffer?**

> Yes—copy the first `k` elements to a temp array, shift the rest left, then append the temp. That also runs in O(n) time but uses O(k) space.

---

**Q3: How to rotate by **right** instead of left?**

> Right rotation by `k` is equivalent to left rotation by `n−k`. Or use the reversal steps in this order:
>
> 1. `reverse(arr.begin(), arr.end());`
> 2. `reverse(arr.begin(), arr.begin() + k);`
> 3. `reverse(arr.begin() + k, arr.end());`

---
