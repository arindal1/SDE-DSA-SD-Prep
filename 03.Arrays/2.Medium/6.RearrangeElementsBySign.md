

# ‚ÜîÔ∏è Rearrange Array Alternating Positive and Negative Numbers

---

## üìã Problem Statement

Given an array **`arr`** of size **`n`** containing an **equal number** of positive and negative integers (or with a difference of at most one), **rearrange** the array so that **positive** and **negative** numbers appear **alternately**, starting with a positive at index 0. Return the rearranged array.

> **Note:** You may assume `n` is even for simplicity, or that there is one extra positive when `n` is odd‚Äîjust begin and end with a positive.

---

## üîé Example

```text
Input:  [ -1,  2, -3,  4, -5,  6 ]
Output: [  2, -1,  4, -3,  6, -5 ]

Input:  [ 5, -2, 3, -1, -7, 4 ]
Output: [  5, -2,  3, -1,  4, -7 ]
```

---

## üê¢ Brute-Force Approach (Filter & Merge)

1. **Partition** into two lists: `positives` and `negatives` by scanning once (O(n)).
2. **Merge** them by alternating picks from each:

   * Initialize an empty `result`.
   * While both lists non-empty, `result.push_back(positives[i++])`, then `result.push_back(negatives[j++])`.
   * Append any leftover elements.

```cpp
vector<int> rearrangeBrute(const vector<int>& arr) {
    vector<int> pos, neg;
    for (int x : arr) {
        if (x >= 0) pos.push_back(x);
        else        neg.push_back(x);
    }
    vector<int> res;
    int i = 0, j = 0, n = arr.size();
    while (i < pos.size() && j < neg.size()) {
        res.push_back(pos[i++]);
        res.push_back(neg[j++]);
    }
    // Append leftovers (if any)
    while (i < pos.size()) res.push_back(pos[i++]);
    while (j < neg.size()) res.push_back(neg[j++]);
    return res;
}
```

* **Time:** O(n)
* **Space:** O(n) extra

---

## ‚ö° Optimal Two-Pointer Fill (O(n) Time, O(n) Space)

### **Key Idea**

Use two indices into the **result** array:

* **`pos = 0`** ‚Üí next even index for a positive.
* **`neg = 1`** ‚Üí next odd index for a negative.

Scan the original `arr` once:

```text
FOR each x IN arr:
    IF x ‚â• 0:
        result[pos] = x
        pos += 2
    ELSE:
        result[neg] = x
        neg += 2
```

This places positives at indices 0,2,4‚Ä¶ and negatives at 1,3,5‚Ä¶ guaranteeing alternation.

---

## üìù Algorithm Pseudocode

```text
FUNCTION rearrange(arr, n):
    pos ‚Üê 0
    neg ‚Üê 1
    result ‚Üê new array of length n

    FOR i FROM 0 TO n‚àí1:
        IF arr[i] ‚â• 0:
            result[pos] = arr[i]
            pos += 2
        ELSE:
            result[neg] = arr[i]
            neg += 2

    RETURN result
```

---

## üíæ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Rearranges arr so that positives and negatives alternate,
 * starting with a positive at index 0. Uses O(n) time and space.
 */
vector<int> Rearrange(const vector<int>& arr, int n) {
    int pos = 0, neg = 1;
    vector<int> res(n);
    for (int x : arr) {
        if (x >= 0) {
            res[pos] = x;
            pos += 2;
        } else {
            res[neg] = x;
            neg += 2;
        }
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    vector<int> result = Rearrange(arr, n);
    for (int x : result) {
        cout << x << " ";
    }
    cout << "\n";
    return 0;
}
```

---

## üìà Complexity Analysis

| Metric               | Value    |
| -------------------- | -------- |
| **Time Complexity**  | **O(n)** |
| **Space Complexity** | **O(n)** |

* Single pass over `arr`.
* Extra `result` array of size `n`.

---

## ‚ú® Notes & Variations

* **Stability:** This does **not** preserve the original relative order among positives or negatives.
* **In-Place Variant:**

  * More complex in-place algorithms exist (e.g., using rotations) but typically cost **O(n¬≤)** or additional bookkeeping.
* **Unequal Counts:**

  * If positives outnumber negatives by more than one, after alternation append the remaining positives at the end (or vice versa).
* **Zero as Positive:** Treated as non-negative here; adjust per requirements.

---

## ‚ùì Frequently Asked Questions

**Q1: Why start `pos` at 0 and `neg` at 1?**

> To ensure **positives** land on **even** indices (0-based) and **negatives** on **odd** indices.

---

**Q2: What if the first element must be negative?**

> Initialize `pos = 1`, `neg = 0`, and proceed similarly.

---

**Q3: How to handle odd `n`?**

> Only one extra slot remains‚Äîif there are more positives, they fill that slot automatically.

---
