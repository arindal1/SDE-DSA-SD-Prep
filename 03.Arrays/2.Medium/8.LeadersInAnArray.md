# 🕵🏼‍♂️ **Find Leaders in an Array**

## 📋 Problem Statement

A **leader** in an array is an element that is **strictly greater** than all the elements to its **right**. Given an array **`arr`** of size **`n`**, return a list of all leaders in **left‑to‑right** order.

---

## 🔎 Examples

| Input                  | Leaders      | Explanation                                             |
| ---------------------- | ------------ | ------------------------------------------------------- |
| `[16, 17, 4, 3, 5, 2]` | `[17, 5, 2]` | 17>all right; 5>2; 2 is last element                    |
| `[1, 2, 3, 4, 0]`      | `[4, 0]`     | 4>0; 0 is last                                          |
| `[7, 4, 5, 7, 3]`      | `[7, 7, 3]`  | The first 7 and second 7 both lead their right segments |

---

## 🐢 Brute‑Force Approach (O(n²) Time)

1. For each index `i` from `0` to `n−1`:
2. Check **all** elements to its right `(j = i+1 … n−1)`.
3. If **none** are ≥ `arr[i]`, it’s a **leader**—append to result.

```cpp
vector<int> findLeadersBrute(const vector<int>& arr) {
    int n = arr.size();
    vector<int> leaders;
    for (int i = 0; i < n; ++i) {
        bool is_leader = true;
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] >= arr[i]) {
                is_leader = false;
                break;
            }
        }
        if (is_leader) leaders.push_back(arr[i]);
    }
    return leaders;
}
```

* **Time Complexity:** O(n²)
* **Space Complexity:** O(n) for output

---

## ⚡ Optimal Single‑Pass from Right (O(n) Time)

### **Key Idea**

Scan the array **from right to left**, keeping track of the **maximum** seen so far (`max_right`):

1. Initialize `max_right = -∞` and an empty `leaders_rev` list.
2. For `i` from `n−1` down to `0`:

   * If `arr[i] > max_right`:

     * **Record** `arr[i]` as a leader (append to `leaders_rev`).
     * Update `max_right = arr[i]`.
3. Reverse `leaders_rev` to restore **left‑to‑right** order.

This visits each element **once** and uses constant extra space aside from the result.

---

## 📝 Pseudocode

```text
FUNCTION findLeaders(arr, n):
    max_right ← -∞
    leaders_rev ← empty list

    FOR i FROM n−1 DOWNTO 0:
        IF arr[i] > max_right:
            leaders_rev.append(arr[i])
            max_right ← arr[i]

    RETURN reverse(leaders_rev)
```

---

## 💾 Revised C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns all leaders in 'arr' in left-to-right order.
 */
vector<int> Leaders(const vector<int>& arr) {
    int n = arr.size();
    int max_right = INT_MIN;
    vector<int> leaders_rev;
    leaders_rev.reserve(n);

    // 1) Scan from right to left
    for (int i = n - 1; i >= 0; --i) {
        if (arr[i] > max_right) {
            leaders_rev.push_back(arr[i]);
            max_right = arr[i];
        }
    }

    // 2) Reverse to get left-to-right order
    reverse(leaders_rev.begin(), leaders_rev.end());
    return leaders_rev;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    auto res = Leaders(arr);
    for (int x : res) {
        cout << x << " ";
    }
    cout << "\n";
    return 0;
}
```

---

## 📈 Complexity Analysis

| Metric               | Value             |
| -------------------- | ----------------- |
| **Time Complexity**  | **O(n)**          |
| **Space Complexity** | **O(n)** (output) |

* Single pass over the array, plus one pass to reverse the minimal result list.

---

## ✨ Notes & Facts

* **Last element** is always a leader (nothing to its right).
* We use `INT_MIN` to handle arrays of negatives.
* **Reserving** capacity for `leaders_rev` avoids multiple reallocations.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Can we do it strictly in-place without extra vector?**

> You need some space to collect leaders; you could print them on the fly by first scanning and storing indexes, but overall O(n) output is required.

---

**Q2: What if equal elements count?**

> By definition here, a leader must be **strictly greater** than all to its right. To allow **`≥`**, change the comparison.

---

**Q3: How to handle streaming input?**

> Not possible—finding leaders requires knowing future (right‑side) values.

---
