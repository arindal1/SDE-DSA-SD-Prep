# ğŸŒˆ Dutch National Flag / Sort Colors

---

## ğŸ“‹ Problem Statement

Given an array **`arr`** of size **`n`**, where each element is **0**, **1**, or **2**, sort the array **in-place** so that all 0â€™s come first, then all 1â€™s, then all 2â€™s. This is also known as the **Dutch National Flag** problem.

---

## ğŸ¢ Brute-Force Counting Approach (Two Passes)

1. **Count** the number of 0â€™s, 1â€™s, and 2â€™s in one pass.
2. **Overwrite** the array in a second pass: fill with that many 0â€™s, then 1â€™s, then 2â€™s.

```cpp
void sortColorsCount(vector<int>& arr) {
    int n = arr.size();
    int count0 = 0, count1 = 0, count2 = 0;
    for (int x : arr) {
        if (x == 0) count0++;
        else if (x == 1) count1++;
        else count2++;
    }
    int idx = 0;
    while (count0--) arr[idx++] = 0;
    while (count1--) arr[idx++] = 1;
    while (count2--) arr[idx++] = 2;
}
```

* **Time Complexity:** O(n)
* **Space Complexity:** O(1)
* **Drawback:** Two passes and overwrites every element; doesnâ€™t preserve â€œin-place one-passâ€ spirit.

---

## âš¡ Optimal One-Pass (Dutch National Flag)

### **Key Idea**

Maintain three pointers:

* `low`   â†’ boundary for 0â€™s region (everything left of `low` is 0).
* `mid`   â†’ current element under examination.
* `high`  â†’ boundary for 2â€™s region (everything right of `high` is 2).

Invariant during processing:

```
[0 â€¦ low-1]   = all 0â€™s
[low â€¦ mid-1] = all 1â€™s
[mid â€¦ high]  = unknown
[high+1 â€¦ n-1]= all 2â€™s
```

Algorithm:

1. Initialize `low = 0`, `mid = 0`, `high = nâˆ’1`.
2. While `mid â‰¤ high`:

   * **If** `arr[mid] == 0`:

     * `swap(arr[low], arr[mid])`
     * `low++`, `mid++`
   * **Else if** `arr[mid] == 1`:

     * `mid++`
   * **Else** (`arr[mid] == 2`):

     * `swap(arr[mid], arr[high])`
     * `high--`
3. At termination, all 0â€™s, 1â€™s, and 2â€™s are partitioned correctly.

---

## ğŸ“ Algorithm Pseudocode

```text
FUNCTION sortColors(arr, n):
    low â† 0
    mid â† 0
    high â† n âˆ’ 1

    WHILE mid â‰¤ high:
        IF arr[mid] == 0:
            swap(arr[low], arr[mid])
            low â† low + 1
            mid â† mid + 1
        ELSE IF arr[mid] == 1:
            mid â† mid + 1
        ELSE:  // arr[mid] == 2
            swap(arr[mid], arr[high])
            high â† high âˆ’ 1
```

---

## ğŸ’¾ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Sorts array 'arr' containing only 0,1,2 in-place.
 */
void SortColors(vector<int>& arr) {
    int n = arr.size();
    int low = 0, mid = 0, high = n - 1;

    while (mid <= high) {
        if (arr[mid] == 0) {
            swap(arr[low], arr[mid]);
            low++; mid++;
        } else if (arr[mid] == 1) {
            mid++;
        } else {
            swap(arr[mid], arr[high]);
            high--;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    SortColors(arr);

    for (int x : arr) {
        cout << x << " ";
    }
    cout << "\n";
    return 0;
}
```

---

## ğŸ“ˆ Complexity Analysis

| Approach                   | Time Complexity | Space Complexity |
| -------------------------- | --------------- | ---------------- |
| Counting (two-pass)        | O(n)            | O(1)             |
| Dutch National Flag (opt.) | **O(n)**        | **O(1)**         |

* **One pass** over the array, each element is swapped at most once.

---

## âœ¨ Notes & Facts

* **In-Place & One-Pass:** Achieves sorting without extra arrays or multiple scans.
* **Stable?** Not stable for equal elements, but stability isnâ€™t required when sorting colors.
* **Generalization:** The Dutch National Flag technique extends to three-way partitioning problems by pivot.

---

## â“ Frequently Asked Questions (FAQs)

**Q1: Why does the swap in the `2` case not increment `mid`?**

> Because the element swapped from `high` into `mid` is unprocessedâ€”it might be 0, 1, or 2â€”so we re-examine `arr[mid]`.

---

**Q2: Can this handle other three-category sorting tasks?**

> Yesâ€”for any problem where you partition into three regions based on a â€œcolorâ€ or category.

---

**Q3: What if the input isnâ€™t guaranteed to have only 0,1,2?**

> You would first validate or filter; the algorithm assumes only three distinct values.

---
