# üè∞ Count Unguarded Cells [#2257](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/description/)

## Problem Statement

Given:

* `m, n` ‚Äî grid dimensions.
* `guards` ‚Äî vector of `[row, col]` positions of guards.
* `walls` ‚Äî vector of `[row, col]` positions of walls.

Rules:

* A guard can *see* along a row and column in both directions (up, right, down, left).
* The view continues until it encounters a wall **or** another guard (that blocks the view).
* Cells containing guards or walls are not counted as unguarded.
* Return the number of grid cells that are neither walls nor guards nor visible by any guard.


### Intuition

* Imagine each guard shining four straight beams (UP, RIGHT, DOWN, LEFT). Each beam marks cells as "watched" until it hits an obstacle (wall or guard).
* Maintain a grid status:

  * `0` = unmarked / currently unguarded
  * `1` = watched / guarded (seen by at least one guard)
  * `2` = obstacle (guard or wall)
* After marking all rays from all guards, count zeros.

This is a direct simulation, simple and robust.

---

### Brute Force

A na√Øve brute force might:

* For each cell check whether any guard sees it by scanning along row/column to find a guard without encountering a wall first.
  That would be very expensive ‚Äî `O(m * n * (m + n))` worst-case ‚Äî too slow when grid is large.


### Optimal Approach

* Place guards and walls on a grid (`O(mn)` memory).
* For each guard, from the guard position, extend in the 4 directions cell by cell until hitting a guard or a wall. Mark cells as watched.
* Counting unguarded cells is then a single pass.

**Time complexity**: `O(g * (m + n) + m*n)` where `g` = number of guards.
Reason: each guard's ray in each direction traverses at most `m` or `n` cells. Sum across guards gives `O(g*(m+n))`. Plus grid initialization and final counting `O(mn)`.

**Space complexity**: `O(mn)` for the grid.

This is optimal in practice for typical constraints and is easy to implement.



### Clean CPP Code

```cpp
int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
    vector<vector<int>> prison(m, vector<int>(n, 0));
        
    for (auto& g : guards) {
        prison[g[0]][g[1]] = 2;
    }
    for (auto& w : walls) {
        prison[w[0]][w[1]] = 2;
    }

    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, 1, 0, -1};

    for (auto& g : guards) {
       int gr = g[0], gc = g[1];
        for (int d = 0; d < 4; ++d) {
            int r = gr + dr[d], c = gc + dc[d];
            while (r >= 0 && r < m && c >= 0 && c < n && prison[r][c] < 2) {
                prison[r][c] = 1;
                r += dr[d];
                c += dc[d];
            }
        }
    }
    int cnt = 0;
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (prison[i][j] == 0)
                cnt++;
        }
    }
    return cnt;
}
```

### Complexity Analysis

* **Time**: `O(m*n + g*(m + n))`

  * Build grid and initial marking: `O(m*n)` (grid creation) + `O(g + w)` for placing guards/walls (g = #guards, w = #walls).
  * Each guard casts up to 4 rays, each ray traverses up to `m` or `n` cells, so `O(g*(m+n))`.
  * Final counting: `O(m*n)`.
  * Summed, dominated by `O(m*n + g*(m+n))`.

* **Space**: `O(m*n)` for the grid.

---


### Test cases (with explanation)

1. **Tiny grid, no guards/walls**

   * Input: `m=2, n=2, guards=[], walls=[]`
   * Every cell is unguarded ‚Üí Output: `4`.

2. **Single guard in center**

   * `m=3,n=3`, `guards=[[1,1]]`, `walls=[]`
   * Guard watches all four cardinal directions until edges: watched cells are `(0,1), (1,2), (2,1), (1,0)`. Guard's own cell is obstacle. All cells either guard or watched ‚Üí Output: `0`.

3. **Wall blocks sight**

   * `m=3,n=3`, `guards=[[1,1]]`, `walls=[[0,1]]`
   * Up direction immediately blocked; other directions open. Count accordingly.

4. **Multiple guards with overlapping fields**

   * Overlapping watched cells should still be counted once as watched.

5. **Edge guard**

   * Guard on border ‚Äî rays in outside directions should be ignored due to boundary checks.

6. **Invalid coordinates (defensive)**

   * Non-sane coordinates in input are skipped in code; usually constraints guarantee valid inputs.


### Tips & Tricks

* Use **constants** or `enum` to name cell states: `EMPTY`, `WATCHED`, `OBSTACLE`. This improves readability and reduces errors.
* If you want separate identification of guards vs walls (for debugging), use different values (e.g., `GUARD = 2`, `WALL = 3`), but be sure to stop rays on either one. E.g., `if (prison[r][c] == GUARD || prison[r][c] == WALL) break;`.
* If grid is very large but number of guards is small, the current approach is still effective: rays only traverse until obstacle or boundary.
* If many guards exist and you worry about double-walking many cells, you could deduplicate or early-stop when scanning a row/col already fully watched ‚Äî but added complexity usually not worth it.


### Variations & Extensions

* **Diagonal vision**: Extend direction vectors to 8 directions.
* **Limited-range guards**: Add a max distance limit for each guard's rays.
* **Weighted obstacles**: Some obstacles might reduce but not fully block view ‚Äî then you would modify stop condition.
* **Multiple guard types**: Different guard types with different viewing patterns (e.g., knights, rooks). Model similarly with direction sets.


### FAQs

**Q: Why do we set guard/wall cells to `2`?**
> A: So we can easily detect obstacles (value `>= 2`) when extending rays. This prevents ray passing through guards or walls.

**Q: Why `prison[r][c] < 2` in the while?**
> A: That condition means ‚Äúcurrent cell is *not* an obstacle‚Äù (it could be `0` empty or `1` already watched). We only mark/watch such cells. If the cell is `>= 2` (guard/wall), we stop.

**Q: Could marking guards with a different number break the algorithm?**
> A: Only if you change the stopping condition accordingly. If you use `GUARD = 2, WALL = 3`, then while condition should stop when encountering either value (`while (...) && prison[r][c] != GUARD && prison[r][c] != WALL`) or use `prison[r][c] < 2` if both obstacles are `>= 2`.

**Q: Is this the fastest possible way?**
> A: For this problem constraints and semantics, this approach is simple and efficient. There are other ways (row/column sweeps), but they are essentially equivalent complexity-wise and sometimes more code-heavy.
