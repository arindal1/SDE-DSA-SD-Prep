# üîÑ Next Permutation

---

## üìã Problem Statement

Given a sequence of integers **`arr`** of length **`n`**, transform it **in-place** to its **next lexicographical permutation**. If the sequence is the **highest** permutation, rearrange it to the **lowest** (sorted ascending) and return.

> **Example:** <br>
> Input: `[1,2,3]` ‚Üí Next: `[1,3,2]` <br>
> Input: `[3,2,1]` ‚Üí Next: `[1,2,3]` (wrapped around) <br>
> Input: `[1,1,5]` ‚Üí Next: `[1,5,1]` <br>

---

## üê¢ Brute-Force Approach (O(n¬∑n!))

1. **Generate** all permutations of the array (e.g., via `next_permutation` in a loop).
2. **Collect** them in a list, **sort** lexicographically.
3. **Locate** the current permutation, return the **next** (or first if at end).

> **Drawbacks:**
>
> * Factorial time and space‚Äîimpractical except for very small n.

---

## ‚ö° Optimal In-Place Algorithm (O(n) Time, O(1) Space)

### **Key Insight**

To obtain the next permutation lexicographically:

1. **Find** the **rightmost** index `i` such that `arr[i] < arr[i+1]`.

   * Call it the **pivot** index.
   * If none exists, the sequence is in **descending** order ‚Üí it‚Äôs the **last** permutation.

2. **If** pivot found at `i`:

   * **Find** the **rightmost** index `j > i` such that `arr[j] > arr[i]`.
   * **Swap** `arr[i]` and `arr[j]`.

3. **Reverse** the **suffix** from `i+1` to `n‚àí1` to transform it from descending to ascending ‚Üí the **smallest** arrangement for that suffix.

This yields the **next** lexicographical sequence in **O(n)** time, in-place.

---

## üìù Algorithm Pseudocode

```text
FUNCTION nextPermutation(arr, n):
    // 1) Find pivot
    ind ‚Üê -1
    FOR i FROM n‚àí2 DOWNTO 0:
        IF arr[i] < arr[i+1]:
            ind ‚Üê i
            BREAK

    // 2) If no pivot, reverse entire array
    IF ind == -1:
        reverse(arr[0‚Ä¶n‚àí1])
        RETURN

    // 3) Find successor to pivot
    FOR j FROM n‚àí1 DOWNTO ind+1:
        IF arr[j] > arr[ind]:
            swap(arr[j], arr[ind])
            BREAK

    // 4) Reverse suffix
    reverse(arr[ind+1‚Ä¶n‚àí1])
```

---

## üíæ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Transforms arr into its next lexicographical permutation in-place.
 * If arr is the highest permutation, rearranges to the lowest.
 */
vector<int> NextPermutation(vector<int>& arr, int n) {
    int ind = -1;
    // 1) Find pivot
    for (int i = n - 2; i >= 0; --i) {
        if (arr[i] < arr[i + 1]) {
            ind = i;
            break;
        }
    }
    // 2) If no pivot, reverse entire array
    if (ind == -1) {
        reverse(arr.begin(), arr.end());
        return arr;
    }
    // 3) Find rightmost successor to pivot
    for (int j = n - 1; j > ind; --j) {
        if (arr[j] > arr[ind]) {
            swap(arr[j], arr[ind]);
            break;
        }
    }
    // 4) Reverse the suffix
    reverse(arr.begin() + ind + 1, arr.end());
    return arr;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];

    NextPermutation(arr, n);
    for (int x : arr)
        cout << x << " ";
    cout << "\n";
    return 0;
}
```

---

## üìà Complexity Analysis

| Metric               | Value         |
| -------------------- | ------------- |
| **Time Complexity**  | O(n)          |
| **Space Complexity** | O(1) in-place |

* **One pass** to find the pivot, **one** to find successor, and **one** to reverse suffix‚Äîtotal linear.

---

## ‚ú® Notes & Facts

* **Lexicographical Order:** Treat sequences as words compared element-by-element.
* **Edge Case:** A strictly descending sequence has **no pivot** ‚Üí wrap to ascending.
* **In-Place:** Operates directly on `arr` without extra storage.
* **Applications:**

  * Generating permutations in lexicographic order.
  * Next/previous permutation tasks in combinatorial algorithms.

---

## ‚ùì Frequently Asked Questions (FAQs)

**Q1: Why reverse the suffix instead of sorting?**

> Because the suffix is guaranteed to be in **descending** order, reversing yields **ascending** in O(length) time‚Äîsorting would take O(n log n).

---

**Q2: Can this find the **previous** permutation?**

> Mirror the process: find the rightmost index where `arr[i] > arr[i+1]`, swap with the largest smaller on the right, then reverse suffix.

---

**Q3: What if there are duplicate elements?**

> The algorithm still works, finding the next distinct lexicographical arrangement.

---
