# 🔗 Longest Consecutive Sequence

---

## 📋 Problem Statement

Given an **unsorted** array of integers **`arr`** of size **`n`**, find the length of the **longest sequence** of **consecutive** integers present in the array. A consecutive sequence is a run of numbers like `[x, x+1, x+2, …]` in any order.

> **Example:**
>
> * Input: `[100, 4, 200, 1, 3, 2]`
> * Consecutive sequences are `[1,2,3,4]` (length 4), `[100]` (1), `[200]` (1).
> * **Output:** `4`

---

## 🐢 Brute‑Force Approaches

### 1️⃣ Sorting + Scan (O(n log n))

1. **Sort** the array.
2. **Scan** the sorted list, tracking runs of consecutive values:

   * Increment a `current_len` when `arr[i] == arr[i-1]` → same element (skip),
   * When `arr[i] == arr[i-1] + 1` → extend the run,
   * Else → reset run.
3. **Track** the maximum run length.

```cpp
int longestConsecutiveSort(vector<int> arr) {
    if (arr.empty()) return 0;
    sort(arr.begin(), arr.end());  // O(n log n)
    int best = 1, curr = 1;
    for (int i = 1; i < arr.size(); ++i) {
        if (arr[i] == arr[i-1]) {
            continue;             // skip duplicates
        } else if (arr[i] == arr[i-1] + 1) {
            curr++;
        } else {
            best = max(best, curr);
            curr = 1;
        }
    }
    return max(best, curr);
}
```

* **Time Complexity:** O(n log n)
* **Space Complexity:** O(1) or O(n) if you copy before sorting.
* **Drawback:** Sorting is heavier than necessary.

---

## ⚡ Optimal Hash‐Set Approach (O(n) Average Time)

### **Key Idea**

Use an **`unordered_set`** for O(1) average lookups, and only **start** counting a sequence at its **leftmost** element:

1. **Insert** all elements into `st`.
2. **Iterate** over each element `x` in `st`:

   * **If** `(x−1)` is **not** in `st`, then `x` is the **start** of a new sequence.
   * **Count** upward: while `(x+1), (x+2), …` exist in `st`, increment a **counter**.
   * **Update** `longest = max(longest, counter)`.

This ensures each number is visited at most **twice**: once in insertion, once in counting.

---

## 📝 Algorithm Pseudocode

```text
FUNCTION longestConsecutive(arr, n):
    IF n == 0: RETURN 0

    st ← empty unordered_set
    FOR x IN arr:
        st.insert(x)

    longest ← 1
    FOR each num IN st:
        IF (num − 1) NOT IN st:    // candidate sequence start
            curr = 1
            next = num + 1
            WHILE next IN st:
                curr += 1
                next += 1
            longest = max(longest, curr)

    RETURN longest
```

---

## 💾 Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the length of the longest run of consecutive integers in arr.
 * Uses an unordered_set to achieve O(n) average time.
 */
int LongestSequence(const vector<int>& arr) {
    int n = arr.size();
    if (n == 0) return 0;

    unordered_set<int> st;
    st.reserve(n);
    for (int x : arr) {
        st.insert(x);
    }

    int longest = 1;
    for (int num : st) {
        // Only start counting if num is the beginning of a sequence
        if (st.find(num - 1) == st.end()) {
            int curr = 1;
            int next = num + 1;
            while (st.find(next) != st.end()) {
                curr++;
                next++;
            }
            longest = max(longest, curr);
        }
    }
    return longest;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    cout << LongestSequence(arr) << "\n";
    return 0;
}
```

---

## 📈 Complexity Analysis

| Approach           | Time Complexity      | Space Complexity |
| ------------------ | -------------------- | ---------------- |
| Sorting + Scan     | O(n log n)           | O(1)/O(n)        |
| Hash‑Set (Optimal) | **O(n)** *amortized* | **O(n)**         |

* Each element is inserted once and checked at most once in the while‐loop.

---

## ✨ Notes & Facts

* **Handles duplicates:** Duplicates are ignored by the set.
* **Negative values:** Fully supported since hash‐set stores arbitrary ints.
* **Edge Cases:**

  * **Empty array** → returns `0`.
  * **All elements same** → returns `1`.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Why check `num−1` before counting?**

> To ensure we only scan **each** consecutive run **once**, starting at its smallest element—preventing O(n²) behavior.

---

**Q2: Can this be done in-place without extra space?**

> Not in O(n) time; you need at least O(n) auxiliary info to track membership.

---

**Q3: How to adapt if numbers are extremely large?**

> Use a hash‐set of 64‐bit integers; memory may grow but lookup remains O(1) average.

---
