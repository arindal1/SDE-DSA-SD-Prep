# ğŸ”„ Rotate a Square Matrix by 90Â° Clockwise

---

## ğŸ“‹ Problem Statement

Given an **n Ã— n** matrix, rotate it **in-place** by **90 degrees** clockwise.

---

## ğŸ” Example

```
Input:
[
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
Output:
[
  [7, 4, 1],
  [8, 5, 2],
  [9, 6, 3]
]
```

---

## ğŸ¢ Bruteâ€‘Force Approach (Using Extra Matrix)

1. **Allocate** a new `nÃ—n` matrix `B`.
2. For each `(i, j)` in `A`, write

   ```
   B[j][nâˆ’1âˆ’i] = A[i][j];
   ```
3. **Copy** `B` back into `A`.

```cpp
void rotateBrute(vector<vector<int>>& A) {
    int n = A.size();
    vector<vector<int>> B(n, vector<int>(n));
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            B[j][n-1-i] = A[i][j];
    A = B;  // overwrite original
}
```

* **Time:** O(nÂ²)
* **Space:** O(nÂ²) extra

> âŒ *Drawbacks:* Uses O(nÂ²) extra memory and requires two passes.

---

## âš¡ Optimal Inâ€‘Place Twoâ€‘Step Method (O(nÂ²) Time, O(1) Space)

Rotate **in-place** by composing two simpler operations:

1. **Transpose** the matrix (swap across the main diagonal).
2. **Reverse** each row.

Together these yield a 90Â° clockwise rotation.

---

### âœ¨ Step 1: Transpose

Swap `matrix[i][j]` with `matrix[j][i]` for all `i < j`.
This flips the matrix over its main diagonal.

```cpp
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        swap(matrix[i][j], matrix[j][i]);
    }
}
```

---

### âœ¨ Step 2: Reverse Each Row

For each row `i`, reverse the elements:

```cpp
for (int i = 0; i < n; i++) {
    reverse(matrix[i].begin(), matrix[i].end());
}
```

This mirrors the matrix horizontally, completing the rotation.

---

## ğŸ“ Full Algorithm Pseudocode

```text
FUNCTION rotateMatrix(matrix, n):
    // Step 1: Transpose
    FOR i FROM 0 TO n-1:
        FOR j FROM i+1 TO n-1:
            swap(matrix[i][j], matrix[j][i])

    // Step 2: Reverse each row
    FOR i FROM 0 TO n-1:
        reverse(matrix[i][0â€¦n-1])
```

---

## ğŸ’¾ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Rotates the given nÃ—n matrix 90Â° clockwise in-place.
 */
void rotateMatrix(vector<vector<int>>& matrix, int n) {
    // 1) Transpose
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }
    // 2) Reverse each row
    for (int i = 0; i < n; i++) {
        reverse(matrix[i].begin(), matrix[i].end());
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<vector<int>> matrix(n, vector<int>(n));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> matrix[i][j];

    rotateMatrix(matrix, n);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << matrix[i][j] << ' ';
        }
        cout << '\n';
    }
    return 0;
}
```

---

## ğŸ“ˆ Complexity Analysis

| Metric               | Value     |
| -------------------- | --------- |
| **Time Complexity**  | **O(nÂ²)** |
| **Space Complexity** | **O(1)**  |

* Two nested loops for transpose plus one pass over each row for reversal.

---

## âœ¨ Notes & Variations

* **Transpose + Reverse Rows** yields clockwise rotation.
* For **counter-clockwise** rotation, you can transpose then **reverse columns** (i.e., reverse each column).
* These operations are **in-place** and **cache-friendly**.

---

## â“ Frequently Asked Questions (FAQs)

**Q1: Why transpose then reverse rows?**

> Transposing swaps axes; reversing rows aligns the new â€œx-axisâ€ so the matrix is rotated 90Â° clockwise.

---

**Q2: Can we rotate by other multiples of 90Â°?**

> Yes â€”

* 180Â°: reverse each row, then reverse the entire matrix vertically.
* 270Â°: perform three 90Â° rotations or transpose + reverse columns.

---

**Q3: Is this stable for non-square matrices?**

> This method **requires** a square matrix. For non-square, use the extra-matrix approach.

---
