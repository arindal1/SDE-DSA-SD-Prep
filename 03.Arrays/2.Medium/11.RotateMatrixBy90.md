# 🔄 Rotate a Square Matrix by 90° Clockwise

---

## 📋 Problem Statement

Given an **n × n** matrix, rotate it **in-place** by **90 degrees** clockwise.

---

## 🔎 Example

```
Input:
[
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
Output:
[
  [7, 4, 1],
  [8, 5, 2],
  [9, 6, 3]
]
```

---

## 🐢 Brute‑Force Approach (Using Extra Matrix)

1. **Allocate** a new `n×n` matrix `B`.
2. For each `(i, j)` in `A`, write

   ```
   B[j][n−1−i] = A[i][j];
   ```
3. **Copy** `B` back into `A`.

```cpp
void rotateBrute(vector<vector<int>>& A) {
    int n = A.size();
    vector<vector<int>> B(n, vector<int>(n));
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            B[j][n-1-i] = A[i][j];
    A = B;  // overwrite original
}
```

* **Time:** O(n²)
* **Space:** O(n²) extra

> ❌ *Drawbacks:* Uses O(n²) extra memory and requires two passes.

---

## ⚡ Optimal In‑Place Two‑Step Method (O(n²) Time, O(1) Space)

Rotate **in-place** by composing two simpler operations:

1. **Transpose** the matrix (swap across the main diagonal).
2. **Reverse** each row.

Together these yield a 90° clockwise rotation.

---

### ✨ Step 1: Transpose

Swap `matrix[i][j]` with `matrix[j][i]` for all `i < j`.
This flips the matrix over its main diagonal.

```cpp
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        swap(matrix[i][j], matrix[j][i]);
    }
}
```

---

### ✨ Step 2: Reverse Each Row

For each row `i`, reverse the elements:

```cpp
for (int i = 0; i < n; i++) {
    reverse(matrix[i].begin(), matrix[i].end());
}
```

This mirrors the matrix horizontally, completing the rotation.

---

## 📝 Full Algorithm Pseudocode

```text
FUNCTION rotateMatrix(matrix, n):
    // Step 1: Transpose
    FOR i FROM 0 TO n-1:
        FOR j FROM i+1 TO n-1:
            swap(matrix[i][j], matrix[j][i])

    // Step 2: Reverse each row
    FOR i FROM 0 TO n-1:
        reverse(matrix[i][0…n-1])
```

---

## 💾 Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Rotates the given n×n matrix 90° clockwise in-place.
 */
void rotateMatrix(vector<vector<int>>& matrix, int n) {
    // 1) Transpose
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }
    // 2) Reverse each row
    for (int i = 0; i < n; i++) {
        reverse(matrix[i].begin(), matrix[i].end());
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<vector<int>> matrix(n, vector<int>(n));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> matrix[i][j];

    rotateMatrix(matrix, n);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << matrix[i][j] << ' ';
        }
        cout << '\n';
    }
    return 0;
}
```

---

## 📈 Complexity Analysis

| Metric               | Value     |
| -------------------- | --------- |
| **Time Complexity**  | **O(n²)** |
| **Space Complexity** | **O(1)**  |

* Two nested loops for transpose plus one pass over each row for reversal.

---

## ✨ Notes & Variations

* **Transpose + Reverse Rows** yields clockwise rotation.
* For **counter-clockwise** rotation, you can transpose then **reverse columns** (i.e., reverse each column).
* These operations are **in-place** and **cache-friendly**.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Why transpose then reverse rows?**

> Transposing swaps axes; reversing rows aligns the new “x-axis” so the matrix is rotated 90° clockwise.

---

**Q2: Can we rotate by other multiples of 90°?**

> Yes —

* 180°: reverse each row, then reverse the entire matrix vertically.
* 270°: perform three 90° rotations or transpose + reverse columns.

---

**Q3: Is this stable for non-square matrices?**

> This method **requires** a square matrix. For non-square, use the extra-matrix approach.

---
