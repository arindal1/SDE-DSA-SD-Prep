# Number of Laser Beams in a Bank üî¶üè¶

## Problem statement üìù

You are given an `m x n` binary matrix `bank`, represented as a vector of strings, where:

* `bank[i][j] == '1'` means there is a security device at row `i`, column `j`.
* `bank[i][j] == '0'` means the cell is empty.

There is a laser beam between two devices if:

1. The devices are on different rows `r1 < r2`.
2. For every intermediate row `i` with `r1 < i < r2`, that row has **zero** devices.

A beam connects every device in row `r1` to every device in the next non-empty row `r2` (the first row after `r1` that contains at least one `1`). The total number of beams is the sum, over all consecutive non-empty rows, of `(#devices in previous row) * (#devices in next non-empty row)`.

Return the **total number of laser beams**.


### Intuition ‚ú®

If you look at the grid row by row, rows that have zero devices are *transparent* ‚Äî they let beams pass but you only form beams between devices on the two nearest non-empty rows. So you can compress each non-empty row into a single integer equal to the number of `'1'`s in that row.

After compression, the total beams = sum over adjacent entries `a[i] * a[i+1]` (adjacent in the list of *non-empty* rows). No beam skips a non-empty row, so only adjacent non-empty rows matter.


### Brute-force approach (conceptual) üê¢

Na√Øve idea:

* For every `1` at `(r1, c1)`, search rows below to find the next non-empty row `r2` and then count every `1` at `(r2, c2)` and add beams.
* That works but repeats scanning many rows/cells; worst-case cost ‚âà `O(m * n * m)` if implemented poorly.

This is unnecessary because you only need counts per row, not exact column positions.



### Optimal approach (one pass) ‚úÖ

1. Scan all rows; for each row compute the count of `'1'`s.
2. Keep only counts > 0 in a vector (`deviceCounts`) in row order.
3. The answer is `sum_{i=1..k-1} deviceCounts[i-1] * deviceCounts[i]`.

This is a single pass over the input (plus one pass over the compressed counts), `O(m * n)` time, `O(k)` extra space where `k` is number of non-empty rows (‚â§ `m`). Use a 64-bit accumulator to avoid overflow in extreme cases.


#### Important detail ‚Äî use wide integer for accumulation ‚ö†Ô∏è

If `n` (columns) and `m` (rows) can be large, products of counts may exceed 32-bit `int`. Use `long long` (C++) for the `totalBeams` and also for intermediate counts if you want to be safe.

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    long long numberOfBeams(vector<string>& bank) {
        vector<long long> deviceCounts;
        deviceCounts.reserve(bank.size());

        // Count devices in each row; store only non-zero counts
        for (const string &row : bank) {
            long long cnt = 0;
            // manual loop is slightly faster than std::count for char-to-char on some compilers
            for (char c : row) if (c == '1') ++cnt;
            if (cnt > 0) deviceCounts.push_back(cnt);
        }

        // Sum products of adjacent non-empty rows
        long long totalBeams = 0;
        for (size_t i = 1; i < deviceCounts.size(); ++i) {
            totalBeams += deviceCounts[i-1] * deviceCounts[i];
        }
        return totalBeams;
    }
};
```

If you prefer a one-pass memory-light variant that doesn't store all counts:

```cpp
long long numberOfBeams(vector<string>& bank) {
    long long prevCount = 0;
    long long total = 0;
    for (const string &row : bank) {
        long long cnt = 0;
        for (char c : row) if (c == '1') ++cnt;
        if (cnt > 0) {
            total += prevCount * cnt;
            prevCount = cnt;
        }
    }
    return total;
}
```

This uses `O(1)` extra space and still `O(m*n)` time.

---

### Complexity analysis üìä

* **Time complexity:** `O(m * n)` where `m` = number of rows, `n` = number of columns ‚Äî you examine each cell once.
* **Space complexity:**

  * With `deviceCounts` vector: `O(k)` extra, where `k` is number of non-empty rows (‚â§ `m`).
  * One-pass variant: `O(1)` extra.


### Worked examples & test cases üß™

1. **Example 1**

   ```
   bank = [
     "011001",
     "000000",
     "010100",
     "001000"
   ]
   ```

   Row counts (non-empty): `3, 2, 1`
   Beams = `3*2 + 2*1 = 6 + 2 = 8`

2. **Example 2 ‚Äî no devices**

   ```
   bank = ["000", "000"]
   ```

   No non-empty rows ‚Üí result `0`.

3. **Example 3 ‚Äî separated by empty rows**

   ```
   bank = [
     "10001",
     "00000",
     "00001",
     "00000",
     "01000"
   ]
   ```

   Non-empty rows counts: `2, 1, 1` ‚Üí beams = `2*1 + 1*1 = 3`.

4. **Single row only**

   ```
   bank = ["1111"]
   ```

   No pair of rows ‚Üí `0`.

5. **Large counts (overflow test)**

   * If `m = 10^5`, `n = 10^5` and many ones, products can be up to `1e10` ‚Äî use `long long`.

---

### Tips & tricks ‚ú®

* *Skip empty rows:* That‚Äôs the key insight ‚Äî beams only form between consecutive non-empty rows.
* *Memory vs simplicity:* If you only need the final total, the `prevCount` one-pass variant is simpler and uses constant space.
* *Micro-optimization:* For very large inputs, manual character loop can be slightly faster than `std::count` depending on compiler and build flags.
* *Use 64-bit:* Always use `long long` for the accumulator in languages like C++ for safety.
* *Edge-case validation:* If input might be malformed (no leading/trailing zeros guaranteed), the algorithm still works ‚Äî it trusts only non-empty rows.


### Variations & related problems üîÅ

* **Count beams but only between rows within distance `d`** ‚Äî modify to consider pairs of non-empty rows with `r2 - r1 <= d`.
* **Beams between any two non-empty rows (not just adjacent non-empty)** ‚Äî then you‚Äôd sum over all pairs of non-empty rows (use prefix sums).
* **Given sparse device coordinates** ‚Äî if the input is already a list of device positions by row, the same adjacent-row multiplication rule applies.
* **Return beam pairs explicitly** ‚Äî if you needed to list pairs of positions, you'd require more work and memory.


### Frequently Asked Questions (FAQ) ‚ùì

**Q: Why multiply counts of adjacent non-empty rows?**
> A: Every device in earlier non-empty row connects to every device in the very next non-empty row (intervening rows have 0 devices), so number of beams between those two rows is `count1 * count2`.

**Q: What if there are multiple empty rows between two non-empty rows?**
> A: That doesn't matter ‚Äî they are skipped. Beam rules only require there be *no devices in the intermediate rows*, which is satisfied. So we still connect the adjacent non-empty rows in the compressed list.

**Q: Could beams ever connect non-consecutive non-empty rows?**
> A: No ‚Äî the existence of any non-empty row between two rows prevents beams from forming across that gap (because the beam must be between a row and the next non-empty row only). So we only consider adjacent non-empty rows.

**Q: Can this overflow 32-bit int?**
> A: Yes ‚Äî product `count1 * count2` can exceed `2^31-1` if row length or counts are large. Use `long long` (or language equivalent 64-bit integer).

**Q: Are device columns (x coordinates) relevant?**
> A: No ‚Äî beam existence ignores column positions; any column pairs form beams if rows satisfy conditions.
