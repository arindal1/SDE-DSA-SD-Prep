# ğŸ” 4Sum â€“ Find All Unique Quadruplets Summing to Target

---

## ğŸ“‹ Problem Statement

Given an integer array **`arr`** of length **`n`** and an integer **`target`**, return all **unique** quadruplets `[a, b, c, d]` such that

$$
a + b + c + d = \text{target}.
$$

No duplicate quadruplets should appear in the result, and the numbers within each quadruplet should be in nonâ€‘decreasing order.

---

## ğŸ” Key Idea: Generalize 3Sum with Twoâ€¯Pointers

1. **Sort** the array â†’ allows skipping duplicates and two-pointer scans.
2. **Fix** the first two elements with nested loops `i` and `j`.

   * Skip duplicates for both.
3. Apply a **two-pointer** search on the subarray to the right of `j`:

   * Initialize `left = j+1`, `right = nâˆ’1`.
   * Compute `sum = arr[i] + arr[j] + arr[left] + arr[right]`.
   * If `sum < target`, **increment** `left`.
   * If `sum > target`, **decrement** `right`.
   * If `sum == target`, record quadruplet, advance `left`/`right` **past duplicates**.

This yields **O(nÂ³)** time: two fixed loops plus a two-pointer scan of O(n).

---

## ğŸ“ˆ Complexity Analysis

| Metric               | Value                    |
| -------------------- | ------------------------ |
| **Time Complexity**  | O(nÂ³)                    |
| **Space Complexity** | O(1) extra (plus output) |

* Sorting: O(nâ€¯logâ€¯n)
* Triple loop + two-pointer: O(nÂ² Â· n) = O(nÂ³)

---

## ğŸ“ Pseudocode

```text
FUNCTION fourSum(arr, n, target):
    sort(arr)
    ans â† empty list

    FOR i FROM 0 TO nâˆ’4:
        IF i>0 AND arr[i]==arr[iâˆ’1]: CONTINUE  // skip duplicate a
        FOR j FROM i+1 TO nâˆ’3:
            IF j>i+1 AND arr[j]==arr[jâˆ’1]: CONTINUE  // skip duplicate b

            left  â† j+1
            right â† nâˆ’1
            WHILE left < right:
                sum4 â† arr[i] + arr[j] + arr[left] + arr[right]
                IF sum4 < target:
                    left â† left + 1
                ELSE IF sum4 > target:
                    right â† right âˆ’ 1
                ELSE:
                    ans.add([arr[i],arr[j],arr[left],arr[right]])
                    left â† left + 1
                    right â† right âˆ’ 1
                    // skip duplicates for c and d
                    WHILE left<right AND arr[left]==arr[leftâˆ’1]:
                        left â† left + 1
                    WHILE left<right AND arr[right]==arr[right+1]:
                        right â† right âˆ’ 1
    RETURN ans
```

---

## ğŸ’¾ Full C++ Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns all unique quadruplets [a,b,c,d] in arr that sum to target.
 */
vector<vector<int>> fourSum(vector<int>& arr, int n, int target) {
    vector<vector<int>> ans;
    sort(arr.begin(), arr.end());

    for (int i = 0; i < n; i++) {
        if (i > 0 && arr[i] == arr[i-1]) 
            continue;  // skip duplicate a

        for (int j = i + 1; j < n; j++) {
            if (j > i + 1 && arr[j] == arr[j-1]) 
                continue;  // skip duplicate b

            int left  = j + 1;
            int right = n - 1;
            while (left < right) {
                long long sum4 = (long long)arr[i] + arr[j] + arr[left] + arr[right];
                if (sum4 < target) {
                    left++;
                } else if (sum4 > target) {
                    right--;
                } else {
                    ans.push_back({arr[i], arr[j], arr[left], arr[right]});
                    left++;
                    right--;
                    // skip duplicates for c
                    while (left < right && arr[left] == arr[left - 1]) 
                        left++;
                    // skip duplicates for d
                    while (left < right && arr[right] == arr[right + 1]) 
                        right--;
                }
            }
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, target;
    cin >> n >> target;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) 
        cin >> arr[i];

    auto result = fourSum(arr, n, target);
    for (auto& quad : result) {
        for (int x : quad) 
            cout << x << " ";
        cout << "\n";
    }
    return 0;
}
```

---

## ğŸ”‘ Highlights & Tips

* **Sorting** is essential for:

  * Efficient two-pointer scanning
  * Skipping **duplicate** values to ensure unique quadruplets.
* **Use `long long`** when summing four ints to avoid overflow.
* **Duplicate checks**:

  * Before entering each loop level (`i`, `j`) skip if same as previous.
  * After finding a valid quad, advance pointers past equal values.

---

## â“ Frequently Asked Questions

**Q1:** *Can this be generalized to kâ€‘sum?*

> Yesâ€”use recursion: fix the first element, then solve (kâˆ’1)-sum on the remaining array. Time becomes O(n^{kâˆ’1}).

---

**Q2:** *What if `n` is small or `target` is large?*

> For small `n` (â‰¤200), O(nÂ³) is fine. For large `n`, there is no known subâ€‘cubic worstâ€‘case solution without extra constraints.

---

**Q3:** *Why skip duplicates at both ends?*

> To avoid generating the same combination multiple times, thus ensuring **unique** results.

---

