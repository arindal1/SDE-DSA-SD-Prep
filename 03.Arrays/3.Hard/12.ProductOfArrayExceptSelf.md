# ‚ûó Product of Array Except Self

## üìù Problem statement

Given an integer array `nums` of length `n`, produce an array `output` such that:

```
output[i] = product of all nums[j] for all j != i
```

Constraints commonly assumed for this problem (LeetCode-style):

* `2 <= n <= 10^5`
* `-10^9 <= nums[i] <= 10^9`
* You must run in `O(n)` time.
* Do not use division.


## üí° Intuition

Compute for each index `i` the product of:

* all elements *left* of `i` (call this `L[i]`), and
* all elements *right* of `i` (call this `R[i]`).

Then `output[i] = L[i] * R[i]`.

You can compute `L` in a left-to-right pass and compute `R` on-the-fly in a right-to-left pass, storing results directly into the `output` array so you don't need extra arrays for both sides.

This yields `O(n)` time and `O(1)` extra space (the output array doesn't count as extra).



## üê¢ Brute-force approach (why it's slow)

For each `i`, loop through all elements except `i` and multiply them ‚Üí `O(n^2)` time. This is too slow for large `n`.

A division-based approach:

* Compute `total_product = product(nums)`.
* `output[i] = total_product / nums[i]`.
  This is invalid when `nums[i] == 0`, and division might be disallowed.


## üöÄ Optimal Approach (prefix & suffix products)

Two-pass strategy:

1. **Left pass**: build `output` where `output[i]` = product of elements left of `i`

   * Initialize `output[0] = 1`.
   * For `i = 1..n-1`: `output[i] = output[i-1] * nums[i-1]`.
   * Now `output[i]` holds `L[i]`.

2. **Right pass**: maintain `right = 1` (product of elements to the right of current index).

   * Traverse `i` from `n-1` down to `0`:

     * `output[i] *= right` (combines left-product and right-product).
     * `right *= nums[i]` (update the running right product).

No division, single output array, `O(n)` time, `O(1)` extra space.


## üîé Line-by-line Explanation

```cpp
vector<int> productExceptSelf(vector<int>& nums) {
    int n = nums.size();
    vector<int> output(n);
    output[0] = 1;
    for(int i=1; i<n; i++){
        output[i] = output[i-1] * nums[i-1];
    }
    int right = 1;
    for(int i=n-1; i>=0; i--){
        output[i] *= right;
        right *= nums[i];
    }
    return output;
}
```

* `int n = nums.size();` ‚Äî get array length.
* `vector<int> output(n);` ‚Äî prepare output array of same size.
* `output[0] = 1;` ‚Äî product of elements to the left of index `0` is 1 (empty product).
* First loop (`i = 1..n-1`): fill `output[i]` with the product of all elements to the left of `i` by cumulative multiplication.
* `int right = 1;` ‚Äî running product of elements to the right of current index.
* Second loop (`i = n-1 .. 0`): multiply `output[i]` (left-product) by `right` to get final product excluding `nums[i]`. Then update `right` by multiplying `nums[i]` to include this element for the next iteration (moving left).
* Return `output`.

**This is the classic prefix-suffix implementation.**


## üßÆ Worked Example 

`nums = [1, 2, 3, 4]`

**Left pass builds `output` as left products:**

* output\[0] = 1
* output\[1] = output\[0] \* nums\[0] = 1 \* 1 = 1
* output\[2] = output\[1] \* nums\[1] = 1 \* 2 = 2
* output\[3] = output\[2] \* nums\[2] = 2 \* 3 = 6

Now `output = [1, 1, 2, 6]` which are `L[i]`.

**Right pass with `right` initially 1:**

* i = 3: output\[3] \*= right ‚Üí 6 \* 1 = 6; right \*= nums\[3] ‚Üí right = 4
* i = 2: output\[2] \*= right ‚Üí 2 \* 4 = 8; right \*= nums\[2] ‚Üí right = 12
* i = 1: output\[1] \*= right ‚Üí 1 \* 12 = 12; right \*= nums\[1] ‚Üí right = 24
* i = 0: output\[0] \*= right ‚Üí 1 \* 24 = 24; right \*= nums\[0] ‚Üí right = 24

Final `output = [24, 12, 8, 6]` - correct.


### üíª Full C++ code (ready-to-run) 


```cpp
#include <bits/stdc++.h>
using namespace std;

// Primary solution: uses O(1) extra space (excluding output), O(n) time
vector<int> productExceptSelf(const vector<int>& nums) {
    int n = static_cast<int>(nums.size());
    if (n == 0) return {};

    vector<int> output(n);
    output[0] = 1;
    // left products
    for (int i = 1; i < n; ++i) {
        output[i] = output[i-1] * nums[i-1];
    }
    // right products (running)
    long long right = 1; // use long long to reduce risk of overflow while computing right product
    for (int i = n - 1; i >= 0; --i) {
        // multiply current left product by right product
        long long val = static_cast<long long>(output[i]) * right;
        // clamp to int range if necessary (optional)
        if (val > numeric_limits<int>::max()) val = numeric_limits<int>::max();
        if (val < numeric_limits<int>::min()) val = numeric_limits<int>::min();
        output[i] = static_cast<int>(val);

        right *= nums[i];
    }
    return output;
}

// Simple main to demonstrate usage
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    vector<int> arr = {1, 2, 3, 4};
    auto out = productExceptSelf(arr);
    for (int x : out) cout << x << " ";
    cout << "\n";

    // Example: reading from input (uncomment if needed)
    // int n; cin >> n;
    // vector<int> a(n);
    // for (int i = 0; i < n; ++i) cin >> a[i];
    // auto res = productExceptSelf(a);
    // for (int x : res) cout << x << ' ';
    // cout << '\n';
    return 0;
}
```

> **Notes on the sample code:**
>
> * The function preserves the original signature style (returns `vector<int>`).
> * I used `long long right` in the right-pass to reduce risk of intermediate overflow while computing the running right product. I also clamp final values to `int` range, this is optional and depends on what you want the behavior to be when real overflow would occur.


## üìà Complexity Analysis

* **Time complexity:** `O(n)` - two linear passes over the array.
* **Space complexity:** `O(1)` extra space (excluding output). The `output` array is the required result and not counted as extra.


### ‚ö†Ô∏è Edge cases & Pitfalls

* **Zeros in input:**

  * If there's exactly one zero in `nums`, then `output[i]` is `0` for all `i` except at the index of the zero, where the product equals the product of all non-zero elements.
  * If there are two or more zeros, all `output[i]` will be `0`.
  * The given algorithm **handles zeros correctly** without special casing.
* **Overflow:**

  * If elements are large (e.g., `¬±10^9`) and `n` is large, products can overflow 32-bit `int`. You can:

    * Use `long long` for intermediate products and possibly return `vector<long long>` if required.
    * If returning `int` is required, decide whether to clamp, throw, or document undefined behavior.
* **Empty input / n == 1:**

  * For `n == 0` we return empty vector.
  * For `n == 1`, the product except self is typically defined as `[1]` (the empty product). Decide based on problem spec.


## üîÅ Variations & Alternatives

1. **Using division (not allowed here when zeros exist):**

   * Compute `total = product(nums)` and `output[i] = total / nums[i]`.
   * Must handle zeros specially (count zeros). Time `O(n)`, but division approach is usually forbidden by problem statement.

2. **Using two arrays L and R explicitly:**

   * `L[i] = product of nums[0..i-1]`, `R[i] = product of nums[i+1..n-1]`.
   * Then `output[i] = L[i] * R[i]`. This uses `O(n)` extra space besides output.

3. **Return `vector<long long>`** if you expect products to exceed 32-bit range.


## ‚úÖ Tips & Tricks

* The two-pass method is elegant and avoids division pitfalls and zero-handling complexity.
* If you expect overflow, either use 64-bit integers or document the overflow behavior.
* For contest submissions, the minimal memory footprint (just one extra array for output) is typically preferred.


## ‚ùì FAQs

**Q: Does this work with negative numbers?**
> A: Yes ‚Äî negative numbers are supported. Sign is naturally handled by multiplication.

**Q: Is the algorithm stable with zeros?**
> A: Yes. No special-case logic is needed - the prefix/suffix approach handles zeros correctly.

**Q: Why use `right` as `long long`?**
> A: To reduce the chance of overflow when accumulating products on the right side. If `nums` elements are large, even `right` can overflow 32-bit.

**Q: Can I return `vector<long long>` instead?**
> A: Yes ‚Äî if final product values may exceed 32-bit range, prefer `long long`. Change function return type and types used for intermediate calculations accordingly.


## ‚ú® Quick Summary 

* **Approach:** prefix products (left pass) + suffix products (right pass), combining them into `output`.
* **Complexity:** `O(n)` time, `O(1)` extra space (ignoring output).
* **Properties:** Handles zeros correctly, avoids division, minimal extra memory.
* **Watch out for:** integer overflow for large inputs - use larger integer types if needed.

