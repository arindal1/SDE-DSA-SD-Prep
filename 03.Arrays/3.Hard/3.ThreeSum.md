# ğŸ“Œ 3Sum â€“ Find All Unique Triplets Summing to Zero

---

## ğŸ“‹ Problem Statement

Given an integer array **`arr`** of length **`n`**, return all **unique** triplets `[a, b, c]` such that

$$
a + b + c = 0.
$$

No duplicate triplets should appear in the result.

---

## ğŸ” Examples

| Input              | Output                           |
| ------------------ | -------------------------------- |
| `[-1,0,1,2,-1,-4]` | `[[-1,-1,2],[-1,0,1]]`           |
| `[0,1,1]`          | `[]` *â€” no triplet sums to zero* |
| `[0,0,0]`          | `[[0,0,0]]`                      |

---

## ğŸ¢ Bruteâ€‘Force Approach (O(nÂ³) Time)

1. Tripleâ€‘nest loops over indices `i < j < k`.
2. Check if `arr[i] + arr[j] + arr[k] == 0`.
3. Collect the triplet, **sort** it and insert into a `set` to avoid duplicates.
4. Convert the set of vectors back to a list.

```cpp
vector<vector<int>> threeSumBrute(vector<int>& arr) {
    int n = arr.size();
    set<vector<int>> seen;
    for (int i = 0; i < n; ++i)
        for (int j = i+1; j < n; ++j)
            for (int k = j+1; k < n; ++k)
                if (arr[i] + arr[j] + arr[k] == 0) {
                    vector<int> trip = {arr[i], arr[j], arr[k]};
                    sort(trip.begin(), trip.end());
                    seen.insert(trip);
                }
    return vector<vector<int>>(seen.begin(), seen.end());
}
```

* **Time Complexity:** O(nÂ³)
* **Space Complexity:** O(nÂ³) for the set in the worst case
* **Drawback:** Too slow for `n` up to 10â´.

---

## âš¡ Optimal Twoâ€‘Pointer Approach (O(nÂ²) Time)

### **Key Steps**

1. **Sort** the array: O(nâ€¯logâ€¯n).
2. **Fix** the first element at index `i`, iterate `i = 0â€¦nâˆ’3`.

   * **Skip duplicates**: if `i > 0 && arr[i] == arr[i-1]`, continue.
3. **Twoâ€‘pointer** on the subarray `i+1â€¦nâˆ’1` with pointers `left = i+1`, `right = nâˆ’1`:

   * Compute `sum = arr[i] + arr[left] + arr[right]`.
   * If `sum < 0`, **increment** `left`.
   * If `sum > 0`, **decrement** `right`.
   * If `sum == 0`, record `[arr[i], arr[left], arr[right]]`, then advance `left` and `right` **past duplicates**.

This visits each pair `(i, left, right)` at most once, yielding **O(nÂ²)** time and **O(1)** extra space for pointers (excluding output).

---

## ğŸ“ Pseudocode

```text
FUNCTION threeSum(arr, n):
    sort(arr)
    ans â† empty list

    FOR i FROM 0 TO nâˆ’3:
        IF i>0 AND arr[i]==arr[iâˆ’1]:
            CONTINUE   // skip duplicate first elements
        left â† i+1
        right â† nâˆ’1

        WHILE left < right:
            sum â† arr[i] + arr[left] + arr[right]
            IF sum < 0:
                left â† left + 1
            ELSE IF sum > 0:
                right â† right âˆ’ 1
            ELSE:
                ans.append([arr[i], arr[left], arr[right]])
                left â† left + 1
                right â† right âˆ’ 1
                // skip duplicates for second and third elements
                WHILE left<right AND arr[left]==arr[leftâˆ’1]:
                    left â† left + 1
                WHILE left<right AND arr[right]==arr[right+1]:
                    right â† right âˆ’ 1

    RETURN ans
```

---

## ğŸ’¾ Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns all unique triplets [a,b,c] in arr that sum to zero.
 */
vector<vector<int>> threeSum(vector<int>& arr, int n) {
    vector<vector<int>> ans;
    sort(arr.begin(), arr.end());

    for (int i = 0; i < n; i++) {
        // Skip duplicate fixed elements
        if (i > 0 && arr[i] == arr[i-1]) 
            continue;

        int left = i + 1;
        int right = n - 1;
        while (left < right) {
            int sum = arr[i] + arr[left] + arr[right];
            if (sum < 0) {
                left++;
            } else if (sum > 0) {
                right--;
            } else {
                ans.push_back({arr[i], arr[left], arr[right]});
                left++;
                right--;
                // Skip duplicates for left pointer
                while (left < right && arr[left] == arr[left - 1])
                    left++;
                // Skip duplicates for right pointer
                while (left < right && arr[right] == arr[right + 1])
                    right--;
            }
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    vector<vector<int>> res = threeSum(arr, n);
    for (auto& trip : res) {
        cout << trip[0] << " " << trip[1] << " " << trip[2] << "\n";
    }
    return 0;
}
```

---

## ğŸ“ˆ Complexity Analysis

| Metric               | Value                             |
| -------------------- | --------------------------------- |
| **Time Complexity**  | O(nÂ²)                             |
| **Space Complexity** | O(logâ€¯n) (for sort) + O(k) output |

* Sorting costs O(nâ€¯logâ€¯n).
* Twoâ€‘pointer scan per `i` costs O(n).

---

## â“ Frequently Asked Questions (FAQs)

**Q1: Why skip duplicates at each step?**

> To ensure **unique** triplets. After finding a valid triple, we move pointers past all equal values to avoid generating the same combination again.

---

**Q2: What if the array is very large?**

> O(nÂ²) is the best known for 3Sum without extra constraints. For specialized distributions, hashing or integer tricks may help, but worstâ€‘case remains O(nÂ²).

---

**Q3: Can this be generalized to 4Sum, kSum?**

> Yesâ€”use recursion to fix `kâˆ’2` elements and twoâ€‘pointer for the last two, yielding O(n^{kâˆ’1}) time.

---
