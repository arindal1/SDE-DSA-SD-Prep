# ðŸ§© Is Anagram

> **Problem (short)** â€” Given two strings `s` and `t`, determine if `t` is an *anagram* of `s`.
> Two strings are anagrams if they contain the same characters with the same frequencies (order doesn't matter).

This corresponds to LeetCode **242. Valid Anagram**.


### âœ… Quick examples

* `s = "anagram"`, `t = "nagaram"` â†’ **true**
* `s = "rat"`, `t = "car"` â†’ **false**
* `s = ""`, `t = ""` â†’ **true** (empty strings are anagrams)



## Intuition ðŸ’¡

If two strings are anagrams, each character that appears in `s` must appear the same number of times in `t`.
So counting characters is the natural approach:

* Increase the count for each character seen in `s`.
* Decrease the count for each character seen in `t`.
* At the end, if all counts are zero, the strings are anagrams.

The provided code does both the increment and decrement in a **single loop** for efficiency and elegance.



## Step-by-step algorithm (single-pass counting)

1. If sizes differ â†’ return `false`. (Anagrams must have same length.)
2. Create `freq[26]` initialized to `0`.
3. For each index `i`:

   * `freq[s[i] - 'a']++`
   * `freq[t[i] - 'a']--`
4. After the loop, check all entries of `freq` are `0`.

   * If any non-zero â†’ not anagrams.
   * Else â†’ anagrams.

*Why this works:* Each occurrence in `s` is balanced by a corresponding occurrence in `t`. Doing both updates in the same loop avoids traversing strings twice.

---

## ðŸ’» Full Code

```cpp
#include <bits/stdc++.h>
using namespace std;

    // Assumes only lowercase 'a'..'z' in s and t
    bool isAnagram(const string &s, const string &t) {
        if (s.size() != t.size()) return false;
        int freq[26] = {0};

        for (int i = 0; i < (int)s.size(); ++i) {
            freq[s[i] - 'a']++;
            freq[t[i] - 'a']--;
        }
        for (int c = 0; c < 26; ++c)
            if (freq[c] != 0)
                return false;
        return true;
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s, t;
    if (!(cin >> s >> t)) {
        cerr << "Please provide two whitespace-separated strings as input.\n";
        return 1;
    }

    Solution sol;
    cout << (sol.isAnagram(s, t) ? "true\n" : "false\n");
    return 0;
}
```

---

## âž¡ï¸ Alternatives

### 1) *Sorting approach* â€” simple, general

```cpp
bool isAnagram_sort(string s, string t) {
    if (s.size() != t.size()) return false;
    sort(s.begin(), s.end());
    sort(t.begin(), t.end());
    return s == t;
}
```

* **Time:** `O(n log n)`
* **Space:** can be `O(1)` extra if sorts in-place (plus input)

### 2) *Hash map / frequency map* â€” general characters (Unicode/ASCII)

```cpp
bool isAnagram_map(const string &s, const string &t) {
    if (s.size() != t.size()) return false;
    unordered_map<char, int> freq;
    for (size_t i = 0; i < s.size(); ++i) {
        freq[s[i]]++;
        freq[t[i]]--;
    }
    for (auto &p : freq)
        if (p.second != 0) return false;
    return true;
}
```

* **Time:** `O(n)` average
* **Space:** `O(k)` where `k` = distinct characters used

### 3) *Larger fixed array for full ASCII* (if you know input is bytes)

```cpp
bool isAnagram_ascii(const string &s, const string &t) {
    if (s.size() != t.size()) return false;
    array<int, 256> freq{};
    for (size_t i = 0; i < s.size(); ++i) {
        unsigned char a = s[i];
        unsigned char b = t[i];
        freq[a]++;
        freq[b]--;
    }
    for (int v : freq) if (v != 0) return false;
    return true;
}
```

* Good when characters are bytes but still bounded.



## Complexity analysis ðŸ“ˆ

Let `n = s.length()`.

* **Given freq-array solution:**

  * **Time:** `O(n)` â€” single loop of length `n`, plus checking 26 counts.
  * **Space:** `O(1)` â€” fixed 26 ints.

* **Sorting approach:** `O(n log n)` time, `O(1)`â€“`O(n)` extra space depending on sort.

* **Hash map approach:** `O(n)` average time, `O(k)` space (`k` distinct characters).



### âœ… Test cases

1. `s="anagram"`, `t="nagaram"` â†’ `true`
2. `s="rat"`, `t="car"` â†’ `false`
3. `s=""`, `t=""` â†’ `true`
4. `s="a"`, `t="A"` â†’ *false* for lowercase-only solution â€” different case
5. `s="abc"`, `t="ab"` â†’ `false` (different lengths)
6. Large equal strings with same multiset of characters â†’ `true` (performance proven linear)
7. Non-lowercase characters (e.g., punctuation) â€” need robust method

Edge-case check: if input contains characters outside `'a'..'z'` the original code is **unsafe** â€” it will produce out-of-range indexes. Prefer a safe approach then.


## âœ¨ Tips, tricks & best practices 

* If constraints guarantee lowercase letters, the 26-element array is the **fastest** and simplest approach.
* Use the `i`-parallel increment/decrement trick to avoid two loops and shorten code.
* For unknown character sets or Unicode, either:

  * decode to codepoints and use `unordered_map<int,int>` or
  * use sorting (works for any comparable elements).
* Prefer `std::array<int,26>` or `vector<int> freq(26)` in modern C++ for clearer semantics.
* Pay attention to signedness: when indexing larger arrays (0â€“255) cast to `unsigned char` before using as index.


## ðŸ” Variations & related problems 

* **Group Anagrams** (LeetCode 49) â€” group strings by anagram equivalence class.
* **Find All Anagrams in a String** (LeetCode 438) â€” sliding-window variant to find substrings that are anagrams.
* **k-anagrams** â€” check if two strings can be made anagrams with at most `k` character changes.
* **Anagram distance / minimum replacements** â€” compute how many replacements to make strings anagrams.


## â“ FAQs 

**Q: Why do we increment for `s` and decrement for `t` in the same loop?**
> A: This balances counts in one pass â€” at the end all frequencies must be zero if multisets match. It avoids two loops and is cache-friendly.

**Q: Will this code work for uppercase letters?**
> A: *Not as-is.* It assumes lowercase `'a'..'z'`. Convert both strings to lowercase or use a different method if uppercase is possible.

**Q: Is there any faster approach than counting?**
> A: Counting is optimal `O(n)` time and `O(1)` space (for fixed alphabet). Sorting is slower (`O(n log n)`).

**Q: What about Unicode/emojis?**
> A: Treat strings as sequences of codepoints (not bytes). Decode to `vector<int>` of codepoints and use an unordered\_map for counts.

---

