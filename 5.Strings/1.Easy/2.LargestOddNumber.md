# ğŸ”¢ Largest Odd Number in a String

## ğŸ“œ Problem Statement
Given a **string `num`** representing a large non-negative integer, return **the largest-valued odd integer (as a string)** that is a **non-empty substring of `num`** and is a prefix (starts from index 0).  
If no such number exists, return an **empty string**.

---

### ğŸ§© Example

**Input 1:** `num = "35427"`

**Output 1:** `"35427"`

**Explanation:** The number itself is odd, so it's the largest odd prefix.


**Input 2:** `num = "4206"`

**Output 2:** `""`

**Explanation:** No odd digit exists in the string, so the result is empty.


## ğŸ’¡ Intuition
An **odd number** is defined as a number whose **last digit** is odd (`1, 3, 5, 7, 9`).  
This means that **for any prefix to be odd, its last digit must be odd**.  
So:
- If the last digit of `num` is odd â†’ `num` is the answer.
- If the last digit is even â†’ we need to move **leftwards** until we find an odd digit.  
  That index will mark the end of the largest odd prefix.

We don't need to check every possible substring â€” only prefixes ending at odd digits matter.



## ğŸªœ Brute Force Approach
**Idea:**  Check every prefix of the string, see if itâ€™s odd, and keep track of the largest odd prefix.

**Steps:**
1. Start from full length down to 1.
2. Take `num.substr(0, i)` for each `i`.
3. If the last character of this substring is odd, return it.

**Drawbacks:**
- Generates many substrings unnecessarily.
- Time complexity: **O(nÂ²)** due to repeated substring creation.
- Space complexity: **O(n)** for each substring.


## âš¡ Optimal Approach

We can skip creating substrings until the very end.

**Algorithm:**
1. Start from the **rightmost character** of `num`.
2. If itâ€™s odd, return the entire string.
3. Else, keep moving left until an odd digit is found.
4. If found â†’ return substring from `0` to that index.
5. If no odd digit exists â†’ return `""`.

**Why it works:**  
We only need to find **the rightmost odd digit** in the prefix starting at index 0, because any longer prefix ending at an even digit will be even.

---

## ğŸ“ Corrected & Clean Code

```cpp
#include <bits/stdc++.h>
using namespace std;


string largestOddNumber(string num) {
        int n = num.size();
        
        // Traverse from right to left
        for (int i = n - 1; i >= 0; --i) {
            int digit = num[i] - '0';
            if (digit % 2 == 1) {
                return num.substr(0, i + 1);
            }
        }
        
        // No odd digit found
        return "";
}


int main() {
    Solution sol;
    string num;

    cin >> num;

    string result = sol.largestOddNumber(num);
    
    if (result.empty()) {
        cout << " " << endl;
    } else {
        cout << result << endl;
    }

    return 0;
}

````

---

## â± Complexity Analysis

* **Time Complexity:**

  * `O(n)` â†’ Only one pass from right to left.
* **Space Complexity:**

  * `O(1)` extra space (not counting the output string).

---

## ğŸ§ª Test Cases

```cpp
// 1. Last digit is odd â†’ full string returned
Input: "35427"  
Output: "35427"

// 2. Last digit is even, but odd exists in middle
Input: "4209"  
Output: "4209"

// 3. Odd digit in the middle, rest even
Input: "4206"  
Output: ""

// 4. Single digit odd
Input: "7"  
Output: "7"

// 5. Single digit even
Input: "4"  
Output: ""

// 6. Large input (performance test)
Input: "8" repeated 10^6 times + "1"
Output: string of length 10^6 + 1 ending with "1"
```

---

## ğŸ’¡ Tips & Tricks

* **Quick odd check:** `(digit & 1)` is a faster odd-check alternative for integers.
* **Avoid substr in loop:** Only create substring once when answer is known.
* Works for very large numbers because we **never convert to integer**.
* ASCII digit `'0'` to `'9'` â†’ subtract `'0'` to get numeric value.

---

## ğŸ”„ Variations

1. **Smallest Odd Number in String:**
   Scan from left to right until you find an odd digit.
2. **Largest Even Number in String:**
   Similar approach but check `digit % 2 == 0`.
3. **Largest Odd Substring (not just prefix):**
   This becomes more complex â€” need to search for odd digits anywhere.

---

## â“ FAQs

**Q1:** Why not check from left to right?

**A:** We want the **largest** odd prefix. The largest odd prefix ends at the **rightmost odd digit** â€” so scanning from right to left finds it faster.

**Q2:** Why not convert to integer and check parity?

**A:** Numbers can be extremely large (up to `10^5` digits), causing integer overflow. String-based operations avoid this.

**Q3:** Is `(num[i] % 2)` wrong?

**A:** Not wrong for ASCII digits, since `'1' % 2 == 1`, but it relies on ASCII encoding. `(num[i] - '0') % 2` is explicit and safe.

---

## ğŸ“Œ Summary

* Traverse from **right to left**.
* First odd digit found â†’ return prefix ending at it.
* If none â†’ return empty string.
* **O(n)** time, **O(1)** space, works for very large inputs.

