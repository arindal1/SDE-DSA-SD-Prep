# 🔁 **Reverse Words in a String**

Given a string `s`, **reverse the order of the words** in the string.

* A **word** is a maximal substring consisting of non-space characters.
* The returned string should:

  * have **no leading or trailing spaces**,
  * have **exactly one space** between words.

**Example**

```
Input:  "  the sky   is  blue  "
Output: "blue is sky the"
```

---

# 💡 Intuition

We only care about *words* (sequences of non-space characters). Two straightforward ideas:

1. **Collect words** (skip spaces), then output them in reverse order joined by a single space.

   * Simple, clear, linear time.
2. **In-place tricks**:

   * Trim spaces, reverse the whole string, then reverse each word to restore character order.
   * More involved but avoids storing all words separately (still O(n) time, O(1) extra if you allow modifying the input buffer).

The original snippet you provided parses words and *prepends* them into the answer:

```cpp
if (ans != "") ans = temp + " " + ans;
else ans = temp;
```

Prepending strings repeatedly causes repeated reallocations and copies — **worst-case O(n²)**. We should avoid repeated prepending.

---

# 🐢 Brute-Force Approach

Scan characters, build each word, and **prepend** to a string result.

* Correctness: yes.
* Complexity: **O(n²)** worst-case due to repeated string prepends.

Not ideal for long strings.

---

# 🚀 Optimal Approach 


**Goal:** Given a string `s`, reverse the order of words **in place**.


---

## 🧠 Idea / Intuition

We’ll use the classic *reverse trick*:

1. **Trim & normalize spaces in place** — remove leading/trailing spaces and collapse multiple spaces into one.
2. **Reverse the entire trimmed string** — now words are in the order we want, but every word's characters are reversed.
3. **Reverse each word in place** — fixing each word’s characters yields the final answer.

This uses only O(1) extra space (besides storing indices) and runs in linear time.

---

## ✅ Algorithm (high level)

* `trimSpaces(s)`:

  * Two-pointer approach: read pointer `i`, write pointer `j`.
  * Skip leading spaces, copy characters while collapsing multiple spaces.
  * Resize `s` to `j` (new length), then if trailing space left, remove it.
* `reverse(s.begin(), s.end())` — entire string.
* Walk string and whenever you find a word (non-space run), reverse that substring.

---

## ✍️ Full C++ Implementation (in-place)

```cpp
#include <bits/stdc++.h>
using namespace std;

// Remove leading/trailing spaces and reduce multiple spaces to single.
// Operates in-place and resizes the string.
void trimSpaces(string &s) {
    int n = s.size();
    int i = 0; // read pointer
    int j = 0; // write pointer

    // skip leading spaces
    while (i < n && s[i] == ' ') ++i;

    // copy chars, collapsing multiple spaces
    for (; i < n; ++i) {
        if (s[i] == ' ') {
            // if previous written char is a space, skip
            if (j > 0 && s[j - 1] == ' ') continue;
            s[j++] = ' ';
        } else {
            s[j++] = s[i];
        }
    }

    // remove trailing space if any
    if (j > 0 && s[j - 1] == ' ') --j;

    s.resize(j);
}

// Reverse each word in the string (words separated by single space).
void reverseWordsInPlace(string &s) {
    // Step 1: normalize spaces in-place
    trimSpaces(s);
    if (s.empty()) return;

    // Step 2: reverse the whole string
    reverse(s.begin(), s.end());

    // Step 3: reverse each word to restore characters
    int n = s.size();
    int start = 0;
    for (int i = 0; i <= n; ++i) {
        if (i == n || s[i] == ' ') {
            // reverse s[start..i-1]
            reverse(s.begin() + start, s.begin() + i);
            start = i + 1; // skip the space
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    // Read the whole line (may contain leading/trailing spaces)
    getline(cin, s);

    reverseWordsInPlace(s);
    cout << s << "\n";
    return 0;
}
```

---

## 🔍 Why this is *in-place*

* We only mutate the content of the input `string` and resize it; we do not allocate an extra container to hold words.
* Temporary memory used is constant (indices and loop variables). `std::reverse` performs swaps in-place.

---

## ⏱ Complexity

* **Time:** `O(n)` — each character is visited a constant number of times:

  * trimming: `O(n)`,
  * reverse whole: `O(n)`,
  * reverse words: `O(n)`.
* **Space:** `O(1)` extra (not counting the input `string` storage). All operations are in-place.

---

## 🧪 Test Cases

1. `Input: "  the sky   is  blue  "` → `Output: "blue is sky the"`
2. `Input: "hello"` → `Output: "hello"`
3. `Input: "   "` → `Output: ""` (empty string)
4. `Input: "a good   example"` → `Output: "example good a"`
5. `Input: ""` → `Output: ""` (empty line)
6. `Input: "  Bob    Loves  Alice   "` → `Output: "Alice Loves Bob"`

---

## ⚠️ Notes & Tips

* **Use `getline`** to read the whole input line (including leading/trailing spaces).
* This code treats only the ASCII **space `' '`** as a separator. If you want to treat all whitespace (`\t`, `\n`, etc.) as separators, replace checks with `isspace((unsigned char)ch)`.
* **Unicode / UTF-8:** this algorithm operates on bytes in `std::string`. If your input contains multi-byte UTF-8 characters, reversing by bytes will corrupt those characters. For Unicode-aware reversal, you must first decode into codepoints (or work with `wstring` / proper Unicode library).
* `std::reverse` is efficient and in-place.
* We `reserve` nowhere because we're not building a new string; trimming uses the same buffer and `resize` shortens it—no large reallocations.

---

## ✅ Variations / Alternatives

1. **In-place via reverse whole + reverse words + manual trim** (this is the approach above).
2. **Two-pass without reversing whole string:** scan from end to start, write words into front of string (harder to do fully in-place without extra buffer).
3. **Not in-place simple solution:** `istringstream` + vector + join (simple but uses extra memory).
