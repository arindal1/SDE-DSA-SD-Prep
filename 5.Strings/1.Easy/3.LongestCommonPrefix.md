# 🎈 **Longest Common Prefix**

## 📋 Problem Statement

Given an array of strings **`strs`**, find the **longest common prefix** among them. If no common prefix exists, return an empty string `""`.

---

## 🔎 Examples

| Input                                          |   Output   | Explanation                    |
| ---------------------------------------------- | :--------: | ------------------------------ |
| `["flower","flow","flight"]`                   |   `"fl"`   | `"fl"` is common to all three  |
| `["dog","racecar","car"]`                      |    `""`    | No common prefix               |
| `["interspecies","interstellar","interstate"]` | `"inters"` | Common prefix up to `"inters"` |

---

## 🐢 Brute‑Force Approaches

### 1️⃣ Horizontal Scanning

1. **Start** with the first string as the initial prefix.
2. **Compare** this prefix with each subsequent string:

   * While the current string does **not** start with the prefix, **chop off** the last character of the prefix.
   * If the prefix becomes empty, return `""`.
3. **Result** is the final prefix.

```cpp
string longestCommonPrefix_Horizontal(vector<string>& strs) {
    if (strs.empty()) return "";
    string prefix = strs[0];
    for (int i = 1; i < strs.size(); ++i) {
        while (strs[i].find(prefix) != 0) { // prefix not at start
            prefix.pop_back();
            if (prefix.empty()) return "";
        }
    }
    return prefix;
}
```

* **Time Complexity:** O(S)

  * S = sum of all characters in all strings (worst‑case we compare every char).
* **Space Complexity:** O(1) extra.

### 2️⃣ Vertical Scanning

1. **Iterate** character by character along the position `i` from `0…minLen-1`, where `minLen` is length of shortest string.
2. **Compare** character `strs[0][i]` with `strs[j][i]` for all `j`.
3. **Stop** at first mismatch or end; substring up to `i` is the answer.

```cpp
string longestCommonPrefix_Vertical(vector<string>& strs) {
    if (strs.empty()) return "";
    for (int i = 0; i < strs[0].size(); ++i) {
        char c = strs[0][i];
        for (int j = 1; j < strs.size(); ++j) {
            if (i == strs[j].size() || strs[j][i] != c)
                return strs[0].substr(0, i);
        }
    }
    return strs[0];
}
```

* **Time Complexity:** O(S)
* **Space Complexity:** O(1)

---

## ⚡ Optimal “Sort & Compare” Approach (O(n log n + m) Time)

### **Key Idea**

1. **Sort** the array of strings lexicographically.
2. The **common prefix** among *all* strings must be a prefix of both the **smallest** and **largest** strings (first and last after sort).
3. **Compare** those two strings character by character until they diverge.

```cpp
#include <bits/stdc++.h>
using namespace std;

string longestCommonPrefix(vector<string>& strs) {
    if (strs.empty())
        return "";
    sort(strs.begin(), strs.end());

    string first_string = strs.front();
    string last_string  = strs.back();
    string ans = "";
    int i = 0, n = min(first_string.size(), last_string.size());
    while (i < n && first_string[i] == last_string[i]) {
        ans += first_string[i];
        i++;
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    cin.ignore(numeric_limits<streamsize>::max(), '\n'); 

    vector<string> strs(n);
    for (int i = 0; i < n; ++i) {
        getline(cin, strs[i]);
    }

    cout << longestCommonPrefix(strs);
    return 0;
}
```

* **Why it works:**
  Sorting groups similar prefixes together. Any divergence among the set will be reflected between the very first and very last string in sorted order.
* **Time Complexity:**

  * Sorting: O(n log n · m) where *m* is average string length.
  * Comparison: O(m).
* **Space Complexity:** O(1) extra (sorting in-place).

---

## 🧮 Complexity Comparison

| Method              | Time Complexity        | Space Complexity |
| ------------------- | ---------------------- | ---------------- |
| Horizontal Scanning | O(S)                   | O(1)             |
| Vertical Scanning   | O(S)                   | O(1)             |
| **Sort & Compare**  | **O(n log n · m + m)** | **O(1)**         |

* *n* = number of strings, *m* = average string length, *S* = total characters in all strings.

---

## ❓ Frequently Asked Questions

**Q1: What if the input list is empty?**

> Return `""` immediately.

---

**Q2: Which approach is best in practice?**

> For small n, horizontal or vertical scanning are simplest.
> For large n but small m, sorting can be efficient due to low per-compare cost.

---

**Q3: Can we use a Trie?**

> Yes—a Trie can find the common prefix in O(S) time and O(S) space, but with higher constant factors.

---
