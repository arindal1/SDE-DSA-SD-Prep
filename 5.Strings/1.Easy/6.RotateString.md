# üåÄ Rotate String

Given two strings `s` and `goal`, return **true** if `s` can be rotated some number of times so that it equals `goal`. Each rotation moves the first character of `s` to the end. Otherwise return **false**.

Constraints typically:

* `0 <= s.length, goal.length <= 1000` (varies by platform)
* `s` and `goal` consist of lowercase letters (but solution shouldn't rely on that).

> This is LeetCode **796. Rotate String**.


### ‚úÖ Examples

* `s = "abcde"`, `goal = "cdeab"` ‚Üí **true** (`"abcde"` rotated twice becomes `"cdeab"`)
* `s = "abcde"`, `goal = "abced"` ‚Üí **false**
* `s = ""`, `goal = ""` ‚Üí **true** (empty string is trivially equal)



## Intuition üí°

If `s` can be rotated to form `goal`, then `goal` must appear as a substring of `s + s`.
Why? Rotating `s` produces different splits of `s` into `left + right` then concatenating `right + left`. All those rotations are substrings of `s+s` of length `|s|`.

So a simple check:

1. If lengths differ ‚Üí `false`.
2. Check whether `goal` is a substring of `s + s`.

This leads to a clean and efficient solution. For guaranteed linear-time substring search, use KMP; otherwise `std::string::find` is often acceptable.


## üò¨ Brute force (naive)

Try all `n` rotations explicitly:

* For `k` from `0` to `n-1`, rotate `s` by `k` and compare to `goal`.
* Rotation can be done in `O(n)` each time ‚Üí overall `O(n^2)` time and `O(n)` space.

This is fine for small `n`, but can be improved.


## ‚ö° Optimal approaches

### 1) **Concatenate + substring check** (clean, easy)

* Check `s.size() == goal.size()`
* Return `(s + s).find(goal) != npos`

**Time:** Depends on the substring search algorithm used by `find`. Worst-case naive is `O(n^2)`, but in practice `std::string::find` is optimized and performs well.
**Space:** `O(n)` for `s+s`.

### 2) **KMP (Knuth‚ÄìMorris‚ÄìPratt)** ‚Äî guaranteed `O(n)` time

* Build prefix-function (lps) for `goal`.
* Run KMP searching `goal` inside `s+s` without actually allocating `s+s` (or allocate it ‚Äî either is fine).
* This guarantees linear time `O(n)` and `O(n)` extra space for the lps array.

KMP is the best theoretical guarantee and useful when you want predictably linear performance.

---


### A ‚Äî Simple & idiomatic (concatenate + `find`) ‚Äî Recommended for clarity

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    bool rotateString(const string &s, const string &goal) {
        if (s.size() != goal.size()) return false;
        // Concatenate and check substring
        string temp = s + s;
        return temp.find(goal) != string::npos;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s, goal;
    if (!(cin >> s >> goal)) {
        cerr << "Please provide two strings (s and goal) as input.\n";
        return 1;
    }

    Solution sol;
    cout << (sol.rotateString(s, goal) ? "true\n" : "false\n");
    return 0;
}
```

**Notes:**

* Handles empty strings correctly: when both are empty, lengths equal and `""` is found in `"" + ""`.
* Time behavior depends on `string::find`.


### B ‚Äî KMP-based (guaranteed linear time)

```cpp
#include <bits/stdc++.h>
using namespace std;

class KMP {
public:
    // Build LPS (longest proper prefix which is also suffix) array for pattern
    static vector<int> buildLPS(const string &pat) {
        int n = pat.size();
        vector<int> lps(n, 0);
        int len = 0; // length of previous longest prefix suffix
        for (int i = 1; i < n; ++i) {
            while (len > 0 && pat[i] != pat[len]) {
                len = lps[len - 1];
            }
            if (pat[i] == pat[len]) {
                ++len;
                lps[i] = len;
            } else {
                lps[i] = 0;
            }
        }
        return lps;
    }

    // KMP search: checks if pattern exists in text
    static bool contains(const string &text, const string &pattern) {
        if (pattern.empty()) return true;
        vector<int> lps = buildLPS(pattern);
        int i = 0, j = 0;
        int n = text.size(), m = pattern.size();
        while (i < n) {
            if (text[i] == pattern[j]) {
                ++i; ++j;
                if (j == m) return true;
            } else {
                if (j > 0) j = lps[j - 1];
                else ++i;
            }
        }
        return false;
    }
};

class Solution {
public:
    bool rotateString(const string &s, const string &goal) {
        if (s.size() != goal.size()) return false;
        string doubled = s + s; // could also avoid allocation and iterate mod n
        return KMP::contains(doubled, goal);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s, goal;
    if (!(cin >> s >> goal)) {
        cerr << "Please provide two strings (s and goal) as input.\n";
        return 1;
    }

    Solution sol;
    cout << (sol.rotateString(s, goal) ? "true\n" : "false\n");
    return 0;
}
```

**Notes:**

* Guarantees `O(n)` time (where `n = s.length()`).
* Slightly more code but robust worst-case performance.



## ‚åö Complexity Analysis

Let `n = s.length()` (and `goal.length() == n`).

* **Concatenation + `find`**

  * Time: *Practical* average often near `O(n)`, worst-case `O(n^2)` depending on implementation and content.
  * Space: `O(n)` for `s + s`.
* **KMP**

  * Time: `O(n)` (build lps `O(n)` + search `O(n)` over `s+s` which is of length `2n` ‚Üí `O(n)`).
  * Space: `O(n)` for lps and `O(n)` if you create `s+s` (you can avoid the allocation and still run KMP on simulated `s+s`).


### Test cases ‚úÖ

1. Basic rotate

   * Input: `abcde cdeab` ‚Üí `true`
2. Not a rotation

   * Input: `abcde abced` ‚Üí `false`
3. Empty strings

   * Input: `"" ""` ‚Üí `true`
     (In interactive runs this means no input ‚Äî but logically both empty ‚Üí true.)
4. Single character

   * Input: `a a` ‚Üí `true`
   * Input: `a b` ‚Üí `false`
5. Repeated characters

   * Input: `aaaa aa aa` (invalid ‚Äî lengths must match) ‚Äî but example:
     `s="abab", goal="baba"` ‚Üí `true`
6. Different lengths

   * Input: `abc abcd` ‚Üí `false`
7. Worst-case pattern for naive find (repeated patterns)

   * `s = string(n, 'a') + 'b'` and `goal` something similar ‚Äî tests efficiency.


## ‚ú® Tips & tricks

* The `s+s` trick is the standard quick idea. It reads beautifully and is accepted in interviews and contests.
* If you're concerned about worst-case performance on adversarial inputs, use KMP (or another linear substring search algorithm).
* To *avoid extra allocation* for `s+s` in KMP, you can simulate the doubled text by indexing `s[i % n]` during the KMP scan up to `2*n - 1`.
* Use `std::rotate` when you must actually produce rotated strings or want to test every rotation explicitly.
* For small strings, simplicity wins: use the `s+s` + `find` approach.


## üîÅ Variations & related problems 

* **Minimum rotations to match** ‚Äî find the smallest `k` such that rotating `s` by `k` equals `goal`; can be found by searching for `goal` in `s+s` and computing the index.
* **Check rotations between arrays** ‚Äî same idea applies to arrays: check whether `goal` is a contiguous subsequence in `s+s`.
* **Cyclic shift equality modulo index** ‚Äî problems about cyclic equivalence class.
* **Find all rotated matches in large corpus** ‚Äî use suffix automaton/suffix array for many queries.


## ‚ùì FAQs

**Q: Is `s+s` safe for empty strings?**

> A: Yes. When both `s` and `goal` are empty, `s.size() == goal.size()` holds and `""` is considered found in `""` (most substring checks treat empty pattern as found at position 0). Our code returns `true`.

**Q: What if characters are unicode/UTF-8?**

> A: If `s` and `goal` contain multi-byte UTF-8 characters, using `std::string` still works as long as both strings are valid UTF-8 and rotation is defined in *byte* terms. If rotation should be by codepoint, first decode into a vector of codepoints and apply the same logic on that vector.

**Q: Which implementation should I use in interviews?**
> A: Start with the `s+s` + `find` idea and explain its correctness. If the interviewer cares about worst-case complexity or asks for `O(n)` guarantee, propose/implement KMP.

**Q: Can I avoid creating `s+s`?**
> A: Yes, run KMP on a conceptual text of length `2n` where `text[i] = s[i % n]`. That avoids extra memory allocation.

---

## üèÅ Quick summary (TL;DR) 

* **Key idea:** `goal` is a rotation of `s` ‚áî `goal` is a substring of `s + s` *and* lengths match.
* **Simplest code:** `return s.size() == goal.size() && (s + s).find(goal) != string::npos;`
* **For guaranteed linear time:** implement KMP.

---
