# 🔍 Valid Palindrome Checker (Ignoring Non‑Alphanumerics & Case)

---

## 📋 Problem Statement

Given a string **`s`**, determine **whether** it is a **palindrome**, considering **only alphanumeric characters** and **ignoring** cases. Return **`true`** if it is, **`false`** otherwise.

---

## 🔎 Examples

| Input                              | Output | Explanation                                              |
| ---------------------------------- | :----: | :------------------------------------------------------- |
| `"A man, a plan, a canal: Panama"` |  true  | After filtering: `"amanaplanacanalpanama"` → palindrome. |
| `"race a car"`                     |  false | Filtered: `"raceacar"` → not the same backward.          |
| `""`                               |  true  | Empty string is trivially a palindrome.                  |
| `"0P"`                             |  false | Filtered: `"0p"` ≠ `"p0"`.                               |

---

## 🐢 Brute‑Force Approach: Filter & Reverse (O(n) Time, O(n) Space)

1. **Build** a new string `t` by appending only the **lowercased**, **alphanumeric** characters of `s`.
2. **Check** if `t == reverse(t)`.

```cpp
bool isPalindromeBrute(const string& s) {
    string t;
    for (char c : s) {
        if (isalnum(c))
            t.push_back(tolower(c));
    }
    string rev = t;
    reverse(rev.begin(), rev.end());
    return t == rev;
}
```

* **Time:** O(n) to build + O(n) to reverse + O(n) to compare = O(n).
* **Space:** O(n) for the filtered string and its reverse.

---

## ⚡ Optimal Two‑Pointer Approach (O(n) Time, O(1) Extra Space)

### **Key Idea**

Use **two indices**, `left` and `right`, starting at the ends of the string, and **skip** non‑alphanumeric characters **in‑place**:

1. **Initialize**

   ```
   left  = 0  
   right = s.size() - 1
   ```
2. **Loop** while `left < right`:

   * **Increment** `left` until `s[left]` is alphanumeric (or `left ≥ right`).
   * **Decrement** `right` until `s[right]` is alphanumeric (or `left ≥ right`).
   * **Compare** `tolower(s[left])` vs. `tolower(s[right])`.

     * If they differ → **return** `false`.
   * **Advance** both pointers: `left++`, `right--`.
3. If loop completes → **return** `true`.

This avoids extra storage beyond a few variables.

---

## 📝 Algorithm Pseudocode

```text
FUNCTION isPalindrome(s):
    left  ← 0
    right ← length(s) - 1

    WHILE left < right:
        WHILE left < right AND NOT isalnum(s[left]):
            left ← left + 1
        WHILE left < right AND NOT isalnum(s[right]):
            right ← right - 1

        IF tolower(s[left]) ≠ tolower(s[right]):
            RETURN false

        left ← left + 1
        right ← right - 1

    RETURN true
```

---

## 💾 Complete C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns true if string s is a palindrome, considering only
 * alphanumeric characters and ignoring cases.
 */
bool isPalindrome(const string &s) {
    int left  = 0;
    int right = (int)s.size() - 1;

    while (left < right) {
        // Move left forward to next alphanumeric
        while (left < right && !isalnum(s[left])) {
            left++;
        }
        // Move right backward to previous alphanumeric
        while (left < right && !isalnum(s[right])) {
            right--;
        }
        // Case-insensitive comparison
        if (tolower(s[left]) != tolower(s[right])) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    // Use getline to allow spaces and punctuation
    getline(cin, s);

    cout << (isPalindrome(s) ? "true\n" : "false\n");
    return 0;
}
```

> **Modification:** Switched to `getline(cin, s)` to handle spaces and full sentences.

---

## 📈 Complexity Analysis

| Metric               | Value      |
| -------------------- | ---------- |
| **Time Complexity**  | O(n)       |
| **Space Complexity** | O(1) extra |

* Each character is visited at most once by either pointer.
* Only a fixed number of pointers and temporaries.

---

## ✨ Notes & Facts

* **Alphanumeric Check:** `isalnum(c)` → letters **and** digits.
* **Case Folding:** Use `tolower(c)` to compare without regard to uppercase/lowercase.
* **Empty String:** Considered a palindrome by convention.
* **Unicode/Multibyte:** For non‑ASCII or full Unicode support, use a proper Unicode library or `std::wstring` with `iswalnum`.

---

## ❓ Frequently Asked Questions (FAQs)

**Q1: Why skip non‑alphanumeric characters?**

> The problem specifies ignoring punctuation, spaces, and symbols—only letters/digits matter.

---

**Q2: Can this handle uppercase letters?**

> Yes—`tolower` converts both `'A'` and `'a'` to `'a'`, etc.

---

**Q3: What if we only want to ignore spaces, not punctuation?**

> Replace `isalnum` with a check for `' '` only:

```cpp
while (left < right && s[left] == ' ') left++;
```

---

**Q4: How to handle very long input lines?**

> `getline` supports arbitrarily long lines up to memory limits; ensure fast I/O if needed.

---

