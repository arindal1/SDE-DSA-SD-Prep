# 🪞 Longest Palindromic Substring

## 📝 Problem Statement

**Given** a string `s`, return the *longest substring* of `s` that is a palindrome.

Examples:

* `"babad"` → `"bab"` or `"aba"`
* `"cbbd"` → `"bb"`

We want an algorithm that is *fast* (optimal: `O(n)`) and reliable for all ASCII-style inputs.


## 💡 Intuition

Naively expanding around every center takes `O(n^2)` in the worst case. **Manacher’s algorithm** avoids redundant comparisons by transforming the string and maintaining a rightmost palindrome boundary with its center — this allows you to reuse previously computed palindrome radii using a *mirror* index. The transformed string uses separators (e.g., `#`) to make **odd and even** length palindromes uniform — then you compute the radius at each position in one pass.

Key ideas:

* Transform `s` to `t` so that all palindromes in `t` are odd-length.
* Keep track of the current rightmost palindrome (`center`, `right`).
* Use the *mirror* of index `i` about `center` to set a minimum starting radius.
* Expand around `i` only beyond that known minimum.
* Update `center`/`right` as you find larger palindromes.


## 🐢 Brute force (for comparison)

* Check every substring `s[i..j]` for palindrome — `O(n^3)` (naive).
* Improve by expanding around center for each possible center (including between chars) — `O(n^2)` time, `O(1)` space.

These are simple but too slow for very long strings.


## 🚀 Manacher’s algorithm — Optimal approach

**Transform**: build `t = "^#s[0]#s[1]#...#s[n-1]#$"`.

* `^` and `$` are sentinels to avoid bounds checks.
* `#` ensures even-length palindromes become centered at characters.

**Array `p`**: `p[i]` = radius (number of characters to one side) of palindrome centered at `t[i]` (excluding `t[i]`).

**Maintain** `center` and `right`:

* `center` = index of center of rightmost palindrome seen so far.
* `right` = right boundary (index) of that palindrome.

For each `i`:

1. `mirror = 2*center - i`.
2. If `i < right`, set `p[i] = min(right - i, p[mirror])` (reuse symmetry).
3. Try to expand palindrome at `i` while characters match.
4. If `i + p[i] > right`, update `center = i`, `right = i + p[i]`.

At the end:

* `maxLen = max p[i]` and `centerIndex` where it occurs.
* Map back to original string: `start = (centerIndex - maxLen) / 2` and length `maxLen`.

The division by `2` maps indices from `t` to `s` because each original character corresponds to two characters in `t` (`#` + char).


### ✅ Correctness Sketch 

* The transformed string converts both even/odd palindromes to odd-length palindromes so a single radius concept works.
* The mirror trick gives a **lower bound** for `p[i]` because palindrome around `center` guarantees matching characters on both sides.
* The expansion step extends beyond that bound only when new matches exist.
* Each character in `t` is compared at most a constant number of times overall (amortized), giving linear time.


## 📊 Complexity Analysis

* **Time:** `O(n)` where `n = s.length()`. (The transformed string is `O(2n+3)`, and the algorithm runs linear in that.)
* **Space:** `O(n)` for the transformed string `t` and array `p`.


## Full Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Manacher's algorithm: returns the longest palindromic substring of s
string longestPalindrome(const string &s) {
    if (s.empty()) return "";

    // Build transformed string t with separators and sentinels:
    // e.g. s = "aba" -> t = "^#a#b#a#$"
    string t;
    t.reserve(2 * s.size() + 3);
    t.push_back('^');            // left sentinel
    for (char c : s) {
        t.push_back('#');
        t.push_back(c);
    }
    t.push_back('#');
    t.push_back('$');            // right sentinel

    int n = static_cast<int>(t.size());
    vector<int> p(n, 0);         // p[i] = radius around center i (in t)
    int center = 0, right = 0;

    for (int i = 1; i < n - 1; ++i) {
        int mirror = 2 * center - i;

        if (i < right)
            p[i] = min(right - i, p[mirror]);

        // attempt to expand palindrome centered at i
        while (t[i + 1 + p[i]] == t[i - 1 - p[i]])
            p[i]++;

        // update center/right
        if (i + p[i] > right) {
            center = i;
            right = i + p[i];
        }
    }

    // find max
    int maxLen = 0;
    int centerIndex = 0;
    for (int i = 1; i < n - 1; ++i) {
        if (p[i] > maxLen) {
            maxLen = p[i];
            centerIndex = i;
        }
    }

    int start = (centerIndex - maxLen) / 2; // map back to original s
    return s.substr(start, maxLen);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cout << "Enter lines (each line will be processed; EOF to stop):\n";
    string line;
    while (getline(cin, line)) {
        string ans;
        try {
            ans = longestPalindrome(line);
        } catch (...) {
            ans = "";
        }
        cout << "Input: \"" << line << "\"\n";
        cout << "Longest palindrome: \"" << ans << "\"\n\n";
    }
    return 0;
}
```


## 🔎 Detailed example / Step-by-step

Take `s = "abacdfgdcaba"` (has palindromes like `"aba"`).

* Transform: `t = ^ # a # b # a # c # d # f # g # d # c # a # b # a # $`
* Run the loop, compute `p` values (each `p[i]` tells how many characters match on *one side* in `t`).
* Suppose the largest radius occurs at transformed center corresponding to original `"aba"`, then `maxLen = 3`, `centerIndex` maps to start = (centerIndex - 3)/2 → the substring `"aba"`.

For `s = "babad"` you can get either `"bab"` or `"aba"` (both length 3) — Manacher will find one of them.



### ✅ Test cases

* `""` → `""`
* `"a"` → `"a"`
* `"aa"` → `"aa"`
* `"aba"` → `"aba"`
* `"abba"` → `"abba"` (even-length)
* `"babad"` → `"bab"` or `"aba"`
* `"cbbd"` → `"bb"`
* `"forgeeksskeegfor"` → `"geeksskeeg"`
* Very long string (repeated char) — algorithm remains `O(n)`.


## ✨ Tips & Tricks

* **Use sentinels** (`^`, `$`) to avoid bounds checks inside the expanding loop.
* **Reserve capacity** for `t` (`reserve(2*n+3)`) to avoid repeated reallocations when building `t`.
* If you only need the **length** of the longest palindrome, you can return `maxLen` directly and skip computing start/substring.
* For **Unicode** / multi-byte encodings: convert the string to a vector of Unicode code-points first — Manacher expects fixed-length characters.
* When debugging, print `t` and `p` to visualize radii for each transformed index.


## 🔁 Variations & Extensions

* **Count all palindromic substrings**: sum `p[i] / 2` (or appropriate formula) across `i`.
* **Return start index and length** rather than substring (useful for memory-sparing solutions).
* **Longest palindromic subsequence** is a *different* problem — needs DP.
* **Two-pointer expansion** approach (center expansion) is simpler to implement but `O(n^2)` worst-case.
* **Suffix automata / Palindromic Tree (Eertree)** can be used to enumerate distinct palindromic substrings efficiently.

## ❗ Common Pitfalls

* Forgetting to add separators leads to separate handling for even-length palindromes.
* Not using sentinels — you must carefully check bounds when expanding.
* Using `string(1, c)` inside concatenation repeatedly can be slower; prefer explicit `push_back` sequences or `reserve`.
* For large `s`, repeated concatenation without reserve causes many reallocations.


## ℹ️ FAQs

**Q: Why transform with `#`?**
> *A:* So every palindrome (even or odd) in original maps to an odd-length palindrome in transformed string, allowing a single uniform radius calculation.

**Q: Is Manacher’s algorithm always better than expand-around-center?**
> *A:* Asymptotically, yes (`O(n)` vs `O(n^2)`). For small strings the simpler method might be fine, but for long strings or worst-case inputs (e.g., all same characters) Manacher is much faster.

**Q: Can Manacher handle unicode?**
> *A:* Yes if you first convert the UTF-8 string into a sequence of code points (so each element is a logical character), then run the algorithm on that sequence.

**Q: Does this return *all* equally-long palindromes?**
> *A:* No — it returns one longest palindrome. You can modify code to collect all centers with `p[i] == maxLen` and map them back.

---

### ✨ Short Summary 

* Manacher’s algorithm transforms the string, uses a mirror trick and a running right-boundary to compute palindrome radii in **linear time**.
* Implementation is compact and robust (use sentinels + separators).
* Time complexity `O(n)`, space `O(n)`.
* Great for problems where input length may be large or worst-case patterns exist.

