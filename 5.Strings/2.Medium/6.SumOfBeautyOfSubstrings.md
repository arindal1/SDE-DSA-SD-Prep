# üåü Sum of Beauty of All Substrings


## üìù Problem Statement 

Given a lowercase alphabet string `s`, for every substring `s[i..j]` compute:

* `mx = maximum frequency of any character in substring`
* `mn = minimum frequency among characters that occur at least once in substring`

Beauty of substring = `mx - mn`.

Return the **sum of beauties** of all substrings of `s`.

Example:

* `s = "aabcb"`
  Substrings and beauties ‚Üí sum = `5` (see detailed example later).



## üí° Intuition

We need to examine every substring and measure how ‚Äúimbalanced‚Äù character frequencies are. A simple approach is:

* Fix a left index `i`.
* Expand right index `j = i..n-1`, maintain character frequencies for substring `s[i..j]`.
* After each extension, compute `mx` and `mn` from the frequency array and add `mx - mn` to the answer.

Because there are `O(n^2)` substrings and the alphabet size is fixed (26), scanning 26 letters for `mx` and `mn` inside the inner loop is perfectly reasonable and yields `O(n^2 * 26)` time ‚Äî effectively `O(n^2)` for practical constraints.



## üîç Brute-force vs Practical Optimal

* **Naive brute-force**: For each pair `(i, j)` form substring and count frequencies from scratch ‚Äî `O(n^3)` time if counting every substring naively.
* **Practical optimal (used here)**: For each start `i`, incrementally update frequency array while expanding `j`. After each increment, compute `mx` and `mn` by scanning 26 entries. Time: `O(n^2 * 26) = O(n^2)`.

There are more advanced theoretical techniques (contribution counting, frequency-of-frequency tracking, suffix structures) but they either complicate implementation or don't asymptotically beat `O(n^2)` by a meaningful constant for typical constraints (e.g., `n ‚â§ 5000` or less). For lowercase English letters, the `O(n^2 * 26)` approach is simple, clear, and fast enough.

---

## ‚úÖ Algorithm (step-by-step)

1. Let `n = s.size()`, `ans = 0`.
2. For each left index `i` from `0` to `n-1`:

   * Initialize `freq[26] = {0}`.
   * For each right index `j` from `i` to `n-1`:

     * Increment `freq[s[j] - 'a']`.
     * Compute `mx = max(freq[k])` over `k = 0..25` (only positive values considered).
     * Compute `mn = min(freq[k])` over `k = 0..25` but ignoring `0` entries (use `INT_MAX` initial and skip zeros).
     * Add `(mx - mn)` to `ans`.
3. Return `ans`.

Notes:

* `mn` must ignore characters with zero frequency ‚Äî otherwise, the minimum would always be `0` and the beauty would just be `mx`, which is incorrect.
* Use `long long` for the accumulator `ans` to be safe for large sums.


## üßæ Full C++ Code (ready-to-run)


```cpp
#include <bits/stdc++.h>
using namespace std;

/*
  Compute the sum of beauty for all substrings of s.
  Beauty(substring) = max_freq - min_freq (min taken among chars with freq > 0).
*/
int beautySum(string s) {
    int n = static_cast<int>(s.size());
    long long ans = 0;       // use long long internally for safety
    
    for (int i = 0; i < n; ++i) {
        array<int, 26> freq = {0};
        for (int j = i; j < n; ++j) {
            ++freq[s[j] - 'a'];

            int mx = 0;
            int mn = INT_MAX;
            for (int k = 0; k < 26; ++k) {
                int f = freq[k];
                if (f > 0) {
                    mx = max(mx, f);
                    mn = min(mn, f);
                }
            }
            if (mn != INT_MAX) ans += (mx - mn);
        }
    }

    // Clamp to int range before returning (beauty sum is non-negative)
    if (ans > INT_MAX) return INT_MAX;
    return static_cast<int>(ans);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    if (!(cin >> s)) return 0;
    cout << beautySum(s) << '\n';
    return 0;
}
```



## üîé Worked Example (step-by-step)

s = `"aabcb"` (n=5)

We enumerate substrings and their beauties (only non-zero beauties shown here for brevity):

* `"a"` ‚Üí mx=1,mn=1 ‚Üí beauty=0
* `"aa"` ‚Üí mx=2,mn=2 ‚Üí beauty=0
* `"aab"` ‚Üí freq {a:2,b:1} ‚Üí mx=2,mn=1 ‚Üí beauty=1
* `"aabc"` ‚Üí freq {a:2,b:1,c:1} ‚Üí mx=2,mn=1 ‚Üí beauty=1
* `"aabcb"` ‚Üí freq {a:2,b:2,c:1} ‚Üí mx=2,mn=1 ‚Üí beauty=1
* `"ab"` ‚Üí beauty=0
* `"abc"` ‚Üí mx=1,mn=1 ‚Üí 0
* `"abcb"` ‚Üí freq {a:0,b:2,c:1} ‚Üí mx=2,mn=1 ‚Üí beauty=1
* `"b"` ‚Üí 0
* `"bc"` ‚Üí 0
* `"bcb"` ‚Üí freq {b:2,c:1} ‚Üí beauty=1
* `"c"` ‚Üí 0
* `"cb"` ‚Üí 0
* `"b"` ‚Üí 0

Sum of beauties = `1 + 1 + 1 + 1 + 1 = 5`.

(LeetCode example result: `5`.)



## üìä Complexity Analysis

* **Time complexity:** For each `i` (n choices) we run `j = i..n-1` (‚âà n/2 on average) and for each substring we scan 26 letters to compute `mx` and `mn`. So complexity is `O(26 * n^2) = O(n^2)` (constant 26).
* **Space complexity:** `O(1)` extra space aside from input ‚Äî freq array size is constant (26).

This is practical for typical constraints (e.g., `n ‚â§ 500` or even a few thousands).


## ‚öôÔ∏è Micro-optimizations & Alternatives

1. **Incremental `mx` update:**
   When you increment `freq[c]`, you can set `mx = max(mx, freq[c])` directly, avoiding scanning for `mx`. But `mn` still requires scanning 26 entries to find the smallest non-zero frequency.

2. **Frequency-of-frequency approach:**
   Maintain an array `countOfFreq[k]` to track how many letters currently have frequency `k`. Then `mx` can be tracked as the largest `k` with `countOfFreq[k] > 0`, and `mn` as the smallest `k>0` with `countOfFreq[k] > 0`. This can reduce constant factors but adds complexity; overall still `O(n^2)` in practice.

3. **Advanced contribution techniques:**
   There are theoretical approaches that count how often each pair of characters contributes to the difference, but they are more complex and typically unnecessary with only 26 letters.

In most competitive programming / interview settings, the incremental-frequency approach shown is the simplest and fastest to implement reliably.



### üß™ Test Cases 

| Input        | Output    | Explanation                                  |
| ------------ | --------- | -------------------------------------------- |
| `aabcb`      | `5`       | Example explained above                      |
| `a`          | `0`       | Only substring has beauty 0                  |
| `aa`         | `0`       | All substrings balanced                      |
| `ab`         | `0`       | Both single chars (0) and "ab" has mx=1,mn=1 |
| `abb`        | `1`       | substrings `"abb"` and `"bb"` contribute     |
| `abcabc`     | (compute) | Use program to check                         |
| `""` (empty) | `0`       | No substrings                                |


## ‚ú® Tips & Tricks

* Because alphabet is small (26), scanning it per substring is OK ‚Äî keep code simple and readable.
* Use `array<int,26>` instead of `vector<int>` for slightly better performance and stack allocation.
* Use `long long` for the sum to avoid overflow if `n` is moderately large.
* If inputs might contain uppercase or invalid characters, sanitize the input first.


## üîÅ Variations & Extensions

* **Different alphabets:** If alphabet size `K` is large (e.g., Unicode), scanning entire alphabet per substring becomes expensive; consider mapping only seen characters or using other data structures.
* **Count substrings with beauty > 0**: modify to increment a counter when `mx - mn > 0`.
* **Max beauty among substrings**: track maximum `(mx - mn)` seen instead of sum.
* **Return list of beauties** for all substrings (memory heavy but possible).



## ‚ùì Frequently Asked Questions (FAQs)

**Q: Is the algorithm optimal?**
> A: For small fixed alphabets like English lowercase letters, `O(n^2)` (with a small constant 26) is considered optimal/practical for typical constraints. Exact theoretical improvements are complex and rarely worth it here.

**Q: Why skip zeros when computing `mn`?**
> A: `mn` must be the minimum frequency among characters that actually appear in the substring. If you include zeros, `mn` would always be 0 and beauty reduces to `mx`, which is incorrect.

**Q: Should I worry about overflow?**
> A: Use `long long` for the answer to be safe: sum over `O(n^2)` substrings of possibly `O(n)` values could exceed 32-bit limits for larger `n`.

**Q: Can this handle uppercase letters or non-letter chars?**
> A: The provided implementation assumes `a..z`. For other inputs, validate and map characters appropriately.

