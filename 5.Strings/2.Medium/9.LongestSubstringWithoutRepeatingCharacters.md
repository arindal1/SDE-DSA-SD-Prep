# 🧭 Length of Longest Substring Without Repeating Characters

## 📝 Problem Statement 

Given a string `s`, find the length of the longest substring that contains no repeated characters.

Examples:

* `s = "abcabcbb"` → longest substring `"abc"` → return `3`.
* `s = "bbbbb"` → longest substring `"b"` → return `1`.
* `s = "pwwkew"` → longest substring `"wke"` → return `3`.


## 💡 Intuition 

We want the longest contiguous window (substring) where all characters are unique. This suggests a **sliding window**: expand the window to include new characters until a duplicate appears, then move the left boundary forward just enough to remove the duplicate. Maintain the maximum window length seen.

To make moving the left boundary efficient, we store **where each character was last seen** and jump the left boundary forward to `lastIndex[char] + 1` when we encounter a duplicate inside the current window.

This yields a single pass over the string: *linear time*.


## 🐢 Brute force (for comparison) 

* For every start index `i`, for every end index `j >= i`, check if substring `s[i..j]` has all unique characters (using a set).
* Time complexity: `O(n^3)` naive, or `O(n^2)` if you use incremental set updates per `i` — still too slow for large `n`.



## 🚀 Optimal approach (sliding window with last-seen indices) 

**Key idea:**
Use two pointers: `left` and `right` forming a window `[left, right]`. Maintain `lastIndex[c]` = index where char `c` was last seen (initialized to `-1`). As you move `right` forward:

* If `lastIndex[c] >= left` (meaning `c` is inside current window), move `left` to `lastIndex[c] + 1` to exclude the previous occurrence.
* Update `lastIndex[c] = right`.
* Update `maxLength = max(maxLength, right - left + 1)`.

This guarantees each character is processed once, and `left` only moves forward — overall `O(n)` time.



```cpp
int lengthOfLongestSubstring(string s) {
    vector<int> lastIndex(128, -1); // ASCII chars
    int maxLength = 0;
    int left = 0;

    for (int right = 0; right < s.size(); right++) {
        char c = s[right];
        
        // If char was seen, move left pointer
        if (lastIndex[c] >= left) {
            left = lastIndex[c] + 1;
        }

        lastIndex[c] = right;
        maxLength = max(maxLength, right - left + 1);
    }

    return maxLength;
}
```

### Line-by-line Notes

* `vector<int> lastIndex(128, -1);`
  *Stores last seen index for ASCII characters.* `-1` means "not seen yet".
* `int left = 0;`
  *Left boundary (inclusive) of current window.*
* Loop `right` from `0` to `s.size()-1`: `right` is the right boundary (inclusive).
* `char c = s[right];`
  Be careful: on some systems `char` is signed, so using it directly as an index may be negative for non-ASCII bytes. Better to cast: `unsigned char uc = s[right];` and index `lastIndex[uc]`.
* `if (lastIndex[c] >= left) left = lastIndex[c] + 1;`
  If the character was seen inside current window, move `left` to one past its last index — this eliminates duplicates while preserving maximal window.
* `lastIndex[c] = right;` update last seen position.
* `maxLength = max(maxLength, right - left + 1);` record best answer.

### Suggested robustness tweaks

* Use `vector<int> lastIndex(256, -1)` or cast `char` to `unsigned char` to support full byte values safely.
* Use `int n = static_cast<int>(s.size())` to avoid signed/unsigned comparisons.
* Consider `size_t` if you prefer unsigned indices for sizes/loops.
* If you need to support Unicode characters (UTF-8), first convert to code points or use `unordered_map<int,int>`.


## 🧾 Full Code, ready-to-run C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int lengthOfLongestSubstring(const string &s) {
    int n = static_cast<int>(s.size());
    vector<int> lastIndex(256, -1); // support full unsigned char range
    int maxLength = 0;
    int left = 0;

    for (int right = 0; right < n; ++right) {
        unsigned char uc = static_cast<unsigned char>(s[right]);
        if (lastIndex[uc] >= left) {
            left = lastIndex[uc] + 1;
        }
        lastIndex[uc] = right;
        maxLength = max(maxLength, right - left + 1);
    }
    return maxLength;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Quick manual tests
    vector<string> tests = {
        "abcabcbb", // 3
        "bbbbb",    // 1
        "pwwkew",   // 3
        "",         // 0
        " ",        // 1 (single space)
        "dvdf",     // 3 ("vdf")
        "anviaj"    // 5 ("nviaj")
    };

    for (auto &t : tests) {
        cout << '"' << t << "\" -> " << lengthOfLongestSubstring(t) << '\n';
    }

    // Example: read one line from stdin and output result
    // string s;
    // if (getline(cin, s) && !s.empty()) cout << lengthOfLongestSubstring(s) << '\n';

    return 0;
}
```


## 🔎 Example Walkthrough

Take `s = "abba"`:

* `right = 0`, `c = 'a'`: lastIndex\['a'] = -1 < left(0) → lastIndex\['a'] = 0 → maxLen = 1
* `right = 1`, `c = 'b'`: lastIndex\['b'] = -1 → lastIndex\['b'] = 1 → maxLen = 2 (window "ab")
* `right = 2`, `c = 'b'`: lastIndex\['b'] = 1 >= left(0) → move left = 1+1 = 2 → lastIndex\['b'] = 2 → maxLen = 2 (window "b")
* `right = 3`, `c = 'a'`: lastIndex\['a'] = 0 < left(2) → no move → lastIndex\['a'] = 3 → maxLen = max(2, 3 - 2 + 1 = 2) → still 2
  Result: `2` (either "ab" or "ba").


## 📈 Complexity Analysis 

* **Time complexity:** `O(n)`, where `n = s.length()`. Each character is processed once; left pointer only moves forward.
* **Space complexity:** `O(1)` — fixed-size array (`256` or `128`) regardless of input length. If using `unordered_map` for Unicode, then `O(min(n, alphabet_size))`.



### ✅ Test cases

| Input        | Output | Notes            |
| ------------ | ------ | ---------------- |
| `""`         | `0`    | empty string     |
| `"abcabcbb"` | `3`    | `"abc"`          |
| `"bbbbb"`    | `1`    | `"b"`            |
| `"pwwkew"`   | `3`    | `"wke"`          |
| `" "`        | `1`    | single space     |
| `"abba"`     | `2`    | `"ab"` or `"ba"` |
| `"dvdf"`     | `3`    | `"vdf"`          |
| `"anviaj"`   | `5`    | `"nviaj"`        |



## 🛠️ Tips & Best practices 

* **Cast `char` to `unsigned char`** (or use `vector<int> lastIndex(256, -1)`) to avoid negative indexing on platforms with signed `char`. Example: `unsigned char uc = s[right]; lastIndex[uc]`.
* **Prefer `int n = (int)s.size()`** for safe comparisons with other `int` indices.
* If you must **return the substring** (not just length), store the `start` index alongside `maxLength` and return `s.substr(start, maxLength)`.
* For **Unicode**, convert the UTF-8 string into code points (e.g., `vector<int>` of code points) and apply the same algorithm using `unordered_map<int,int>` for last indices.
* In performance-sensitive contexts, pre-allocating `lastIndex` and avoiding maps reduces constant factors.


## 🔁 Variations & Extensions 

* **Return substring** instead of length: track `bestStart` and `maxLength`.
* **Count number of distinct longest substrings**: keep a list of windows that match `maxLength`.
* **K-distinct characters**: modify to find the longest substring containing at most `k` distinct characters (use frequency map + sliding window).
* **Longest substring with no character repeating more than m times**: adapt with frequency counters.


## ❗ Common Pitfalls 

* Using `char` as an index without casting (negative indices possible).
* Forgetting to update `left` correctly — must set `left = lastIndex[uc] + 1`.
* Using `set` or checking uniqueness inefficiently inside inner loops, leading to `O(n^2)` time.
* Confusing substring vs subsequence: this problem is **substring** (contiguous).


## ❓ FAQs 

**Q: Why initialize `lastIndex` to `-1`?**
> A: `-1` means the character hasn't been seen. When `lastIndex[uc] < left`, the character is not inside the current window.

**Q: Why do we compare `lastIndex[c] >= left`?**
> A: If last seen index is before `left`, it's not in the current window and does not cause a duplicate. If it’s `>= left`, it’s inside the window and we must move `left` past that previous occurrence.

**Q: Can we use `unordered_map` instead of array?**
> A: Yes — useful for large alphabets or Unicode code points. But arrays (`128`/`256`) are faster for ASCII/byte inputs.

**Q: Will the algorithm still be linear?**
> A: Yes. Using `unordered_map` still yields amortized `O(n)` time, but with larger constants.


## ✨ Quick Summary 

* The sliding-window + last-seen-index method finds the longest substring without repeating characters in **O(n)** time and **O(1)** additional space (for fixed alphabet).
* Use `lastIndex` to jump the `left` pointer forward in O(1) when duplicates appear.
* Be careful with `char` signedness; prefer `unsigned char` or a 256-sized table.

