# 🏛️ Maximum Nesting Depth of Parentheses 

> **Problem Statement** — Given a valid parentheses string `s` (which may include numbers, operators, or other characters), return the **maximum nesting depth** of parentheses.

This matches **LeetCode 1614. Maximum Nesting Depth of the Parentheses**.


### ✅ Examples

* **Example 1**

  ```
  s = "(1+(2*3)+((8)/4))+1"
  Output: 3
  ```

  * Max depth occurs at `"((8)/4)"` — depth = 3.

* **Example 2**

  ```
  s = "(1)+((2))+(((3)))"
  Output: 3
  ```

  * Nested three times.

* **Example 3**

  ```
  s = "1+(2*3)/(2-1)"
  Output: 1
  ```

  * Only one layer of parentheses.

* **Example 4**

  ```
  s = "1"
  Output: 0
  ```

  * No parentheses, so depth is 0.



## 💡 Intuition 

* Whenever you see an `'('`, you're going **one level deeper** into nesting.
* Whenever you see a `')'`, you're **coming back out** of nesting.
* Keep track of the **current depth** (`ctr`), and update the **max depth** (`maxi`) whenever `ctr` increases.



### Step-by-step logic :

1. **Initialize counters**

   * `ctr = 0` → current nesting depth.
   * `maxi = 0` → maximum depth found so far.

2. **Scan the string**

   * If `ch == '('`:

     * Increase `ctr` by 1.
     * Update `maxi = max(maxi, ctr)`.
   * If `ch == ')'`:

     * Decrease `ctr` by 1.

3. **Return `maxi`** after loop ends.


## Code (simple O(n) scan)

```cpp
int maxDepth(string s) {
    int maxi = 0, ctr = 0;
    for (char ch : s) {
        if (ch == '(')
            maxi = max(maxi, ++ctr);
        else if (ch == ')')
            ctr--;
    }
    return maxi;
}
```


## Example Dry-run

### Input:

```
s = "(1+(2*3)+((8)/4))+1"
```

| Char | Action              | ctr | maxi |
| ---- | ------------------- | --- | ---- |
| (    | ++ctr → 1, maxi=1   | 1   | 1    |
| 1    | -                   | 1   | 1    |
| +    | -                   | 1   | 1    |
| (    | ++ctr → 2, maxi=2   | 2   | 2    |
| 2    | -                   | 2   | 2    |
| \*   | -                   | 2   | 2    |
| 3    | -                   | 2   | 2    |
| )    | ctr-- → 1           | 1   | 2    |
| +    | -                   | 1   | 2    |
| (    | ++ctr → 2, maxi=2   | 2   | 2    |
| (    | ++ctr → 3, maxi=3 ✅ | 3   | 3    |
| 8    | -                   | 3   | 3    |
| )    | ctr-- → 2           | 2   | 3    |
| /    | -                   | 2   | 3    |
| 4    | -                   | 2   | 3    |
| )    | ctr-- → 1           | 1   | 3    |
| )    | ctr-- → 0           | 0   | 3    |
| +1   | -                   | 0   | 3    |

Output: **3**


## ⌚ Complexity Analysis

* **Time:** `O(n)` — single pass through string.
* **Space:** `O(1)` — only two integer variables.



## 🪂 Edge Cases

1. **Empty string**

   ```
   "" → 0
   ```

2. **No parentheses**

   ```
   "123+456" → 0
   ```

3. **All nested**

   ```
   "(((())))" → 4
   ```

4. **Balanced but varying depth**

   ```
   "(())()" → 2
   ```

---

## Full Runnable Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int maxDepth(const string &s) {
    int maxi = 0, ctr = 0;
    for (char ch : s) {
        if (ch == '(')
            maxi = max(maxi, ++ctr);
        else if (ch == ')')
            ctr--;
    }
    return maxi;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    getline(cin, s); // read entire line with spaces
    cout << maxDepth(s) << "\n";
}
```

---

## Related Problems 🔁

* **Valid Parentheses** (LeetCode 20) — check balance rather than depth.
* **Minimum Add to Make Parentheses Valid** (LeetCode 921).
* **Score of Parentheses** (LeetCode 856).
* **Longest Valid Parentheses** (LeetCode 32).

