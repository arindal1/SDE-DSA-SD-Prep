# Graph Representation in C++ - Adjacency Matrix, Adjacency List & Weighted Graphs üß†üìò

# 1. Quick problem statement & why representations matter

**Problem statement (short):**
Given nodes and edges, choose a data structure to store the graph so algorithms (BFS, DFS, Dijkstra, MST, etc.) can run efficiently. Different representations change the runtime, memory usage, and simplicity of implementation.

**Why it matters:**

* Some algorithms iterate neighbors fast - adjacency list is great.
* Some require O(1) edge-existence checks - adjacency matrix helps.
* Weighted graphs need to store weights per edge.
  Picking the right representation is one of the easiest levers to speed your graph code.



# 2. Overview of common representations üåâ

1. **Adjacency Matrix** - 2D matrix `mat[u][v]` indicates edge (or weight).
2. **Adjacency List** - vector of neighbors `adj[u] = {v1, v2, ...}`.
3. **Edge List** - list of edges `(u, v)` or `(u, v, w)` - useful for Kruskal and offline processing.

Short rule-of-thumb:

* Use **adj list** for sparse graphs (E ‚âà V or E ‚â™ V¬≤).
* Use **adj matrix** for dense graphs (E ‚âà V¬≤) or when you need O(1) edge queries.
* Use **edge list** when sorting edges or off-line algorithms.



# 3. Adjacency Matrix - explanation, pros/cons, code üßæ

## What it is

An `n √ó n` 2D array where `mat[u][v]` is either `1` (edge exists) / `0` (no edge) for unweighted graphs, or `weight` (or `INF`) for weighted graphs.

## Use-cases

* Dense graphs (many edges).
* When you need **O(1)** `hasEdge(u, v)` checks.
* Simple implementations (education / small problems).

## Memory & Complexity

* Memory: **O(n¬≤)**.
* Iterate all neighbors of `u`: O(n) (even if only a few neighbors - costly).
* Edge existence: O(1).
* Good when `n ‚â§ ~2‚Äì4k` depending on memory/time constraints.

![image](https://cdn.programiz.com/sites/tutorial2program/files/adjacency-matrix_1.png)

## C++ examples

**Unweighted, bool matrix**

```cpp
int n = 5;
vector<vector<bool>> mat(n, vector<bool>(n, false));
mat[u][v] = true;     // directed u -> v
mat[v][u] = true;     // undirected
bool exists = mat[a][b];
```

**Weighted (use large sentinel for no-edge)**

```cpp
const long long INF = 1e18;
vector<vector<long long>> mat(n, vector<long long>(n, INF));
mat[u][v] = weight;   // if u->v exists
mat[i][i] = 0;        // distance to self
```

### For the given graph below, let us construct an adjacency matrix -

![image](https://www.tutorialspoint.com/data_structures_algorithms/images/Adjacency_Matrix.jpg)

The adjacency matrix :-

![image](https://www.tutorialspoint.com/data_structures_algorithms/images/adjacency_matrix_representation.jpg)

## Pitfalls

* Memory blow-up for large `n`.
* Iterating neighbors requires scanning all `n` columns - expensive if graph is sparse.



# 4. Adjacency List - explanation, pros/cons, code üåø

## What it is

A vector (size `n`) where each entry stores the neighbors of that vertex. For weighted graphs the neighbor is usually a pair `(v, weight)`.

## Use-cases

* Most practical algorithms on sparse graphs.
* When iterating *actual* neighbors needs to be fast (O(degree(u))).
* Memory-efficient for sparse graphs.

## Memory & Complexity

* Memory: **O(n + m)** (n vertices + m edges).
* Iterate neighbors of `u`: O(deg(u)).
* Adding an edge: amortized O(1).

![image](https://cdn.programiz.com/sites/tutorial2program/files/adjacency-list.png)

## C++ examples

**Unweighted**

```cpp
int n = 5;
vector<vector<int>> adj(n);
adj[u].push_back(v);    // directed
adj[v].push_back(u);    // undirected
```

**Weighted**

```cpp
vector<vector<pair<int,int>>> adj(n);
// pair: {neighbor, weight}
adj[u].push_back({v, w});
adj[v].push_back({u, w}); // undirected weighted
```

### For the given graph below, let us construct an adjacency list -

![image](https://www.tutorialspoint.com/data_structures_algorithms/images/Adjacency_Matrix.jpg)

The adjacency list :-

![image](https://www.tutorialspoint.com/data_structures_algorithms/images/adjacency_list.jpg)


## Extra patterns

* Use `vector<int>` for vertex-only graphs.
* Use `vector<pair<int,int>>` or `vector<pair<int,long long>>` for weighted.
* For dense graphs but still want list features, adjacency list still works but memory advantage disappears.

## Pitfalls

* `hasEdge(u, v)` is O(deg(u)) - slower than matrix if many checks are needed.
* When using `vector`, keep in mind reallocation cost (usually fine). Use `reserve()` when you know degrees roughly.



# 5. Edge List - short note üîó

**Structure:** `vector<tuple<int,int>>` or `vector<tuple<int,int,int>>` for weights.
**Use-case:** Kruskal‚Äôs MST, offline processing, simple storage, sorting edges by weight.
**Complexity:** O(m) memory. No fast neighbor iteration (you scan all edges).



# 6. Weighted graphs - how to store & access weights ü™ô

* **Adjacency-list weighted:** `vector<vector<pair<int,w>>>` - best for Dijkstra/Prim/graph algorithms.
* **Adjacency-matrix weighted:** store `weight` or `INF` in `mat[u][v]`.
* **Edge list weighted:** `vector<tuple<u, v, w>>` - used in Bellman-Ford and Kruskal.

**Important detail:** For integer weights consider using `long long` if sums/weights may exceed `int`. Use `const long long INF = 9e18;` rather than `INT_MAX` to avoid overflow on `dist + w`.

![image](https://www.tutorialspoint.com/data_structures_algorithms/images/minimum_spanning_tree.jpg)

```
In the above graph, we have shown a spanning tree though it's not the minimum spanning tree. The cost of this spanning tree is (5+7+3+3+5+8+3+4)=38.
```


# 7. Typical operations & cost table üìä

| Operation              | Adjacency List | Adjacency Matrix |               Edge List |
| - | -: | -: | -: |
| Memory                 |       O(n + m) |        **O(n¬≤)** |                    O(m) |
| Iterate neighbors of u |      O(deg(u)) |             O(n) | O(m) (need to scan all) |
| Check `hasEdge(u,v)`   |      O(deg(u)) |         **O(1)** |                    O(m) |
| Add edge               |           O(1) |             O(1) |                    O(1) |
| Remove edge            |      O(deg(u)) |             O(1) |                    O(m) |

*Bold = fastest for that operation.*



# 8. Conversion helpers (matrix ‚áÑ list) - code snippets üîÅ

**Matrix ‚Üí List**

```cpp
vector<vector<int>> mat_to_list(const vector<vector<int>>& mat) {
    int n = mat.size();
    vector<vector<int>> adj(n);
    for (int u = 0; u < n; ++u) {
        for (int v = 0; v < n; ++v) {
            if (mat[u][v]) adj[u].push_back(v);
        }
    }
    return adj;
}
```

**List ‚Üí Matrix**

```cpp
vector<vector<int>> list_to_mat(const vector<vector<int>>& adj) {
    int n = adj.size();
    vector<vector<int>> mat(n, vector<int>(n, 0));
    for (int u = 0; u < n; ++u) {
        for (int v : adj[u]) mat[u][v] = 1;
    }
    return mat;
}
```

For weighted conversions use `long long` and `INF` appropriately.



# 9. Test cases - verify correctness ‚úÖ

**A. Small undirected unweighted**

* n = 4, edges: (0,1), (1,2), (2,3)
* Adj list: `adj[1]` should contain `{0,2}`
* Adj matrix: `mat[0][1] == 1`, `mat[3][0] == 0`

**B. Weighted undirected**

* n = 3, edges: (0,1,5), (1,2,2)
* Dijkstra from 0: dist[2] = 7

**C. Dense graph edge check**

* n = 1000, random dense edges - `hasEdge(u,v)` queries should be O(1) using matrix (but memory is heavy).

**D. Kruskal edge list**

* edges: (0,1,1), (1,2,2), (0,2,3) ‚Üí sorted by weight ‚Üí ensure MST picks 1 and 2 weights.



# 10. Full single-file C++ reference (demonstration) üß©

This file demonstrates:

* adjacency matrix (unweighted + weighted),
* adjacency list (unweighted + weighted),
* edge list,
* simple operations and small demos.

```cpp
// graph_representations.cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (ll)9e18;

//  Adjacency Matrix (unweighted) 
vector<vector<bool>> make_adj_matrix_unweighted(int n) {
    return vector<vector<bool>>(n, vector<bool>(n, false));
}
void add_edge_mat_unweighted(vector<vector<bool>>& mat, int u, int v, bool undirected = true) {
    mat[u][v] = true;
    if (undirected) mat[v][u] = true;
}

//  Adjacency Matrix (weighted) 
vector<vector<ll>> make_adj_matrix_weighted(int n) {
    vector<vector<ll>> mat(n, vector<ll>(n, INF));
    for (int i = 0; i < n; ++i) mat[i][i] = 0;
    return mat;
}
void add_edge_mat_weighted(vector<vector<ll>>& mat, int u, int v, ll w, bool undirected = true) {
    mat[u][v] = w;
    if (undirected) mat[v][u] = w;
}

//  Adjacency List (unweighted) 
vector<vector<int>> make_adj_list_unweighted(int n) {
    return vector<vector<int>>(n);
}
void add_edge_list_unweighted(vector<vector<int>>& adj, int u, int v, bool undirected = true) {
    adj[u].push_back(v);
    if (undirected) adj[v].push_back(u);
}

//  Adjacency List (weighted) 
vector<vector<pair<int,ll>>> make_adj_list_weighted(int n) {
    return vector<vector<pair<int,ll>>>(n);
}
void add_edge_list_weighted(vector<vector<pair<int,ll>>>& adj, int u, int v, ll w, bool undirected = true) {
    adj[u].push_back({v,w});
    if (undirected) adj[v].push_back({u,w});
}

//  Edge List (weighted) 
using Edge = tuple<int,int,ll>;
vector<Edge> make_edge_list() { return vector<Edge>(); }
void add_edge_edge_list(vector<Edge>& edges, int u, int v, ll w) {
    edges.emplace_back(u,v,w);
}

//  Simple demos 
void demo_matrix_vs_list() {
    int n = 4;
    auto mat = make_adj_matrix_unweighted(n);
    add_edge_mat_unweighted(mat, 0, 1);
    add_edge_mat_unweighted(mat, 1, 2);

    auto adj = make_adj_list_unweighted(n);
    add_edge_list_unweighted(adj, 0, 1);
    add_edge_list_unweighted(adj, 1, 2);

    cout << "Matrix neighbors of 1: ";
    for (int v = 0; v < n; ++v) if (mat[1][v]) cout << v << ' ';
    cout << '\n';

    cout << "List neighbors of 1: ";
    for (int v : adj[1]) cout << v << ' ';
    cout << '\n';
}

void demo_weighted_structures() {
    int n = 3;
    auto matW = make_adj_matrix_weighted(n);
    add_edge_mat_weighted(matW, 0, 1, 5);
    add_edge_mat_weighted(matW, 1, 2, 2);

    auto adjW = make_adj_list_weighted(n);
    add_edge_list_weighted(adjW, 0, 1, 5);
    add_edge_list_weighted(adjW, 1, 2, 2);

    cout << "Matrix weight 0->1: " << (matW[0][1] == INF ? -1 : matW[0][1]) << '\n';
    cout << "List weight 0->1: ";
    for (auto [v,w] : adjW[0]) if (v == 1) cout << w << '\n';
}

//  Dijkstra using adjacency list (for correctness test) 
vector<ll> dijkstra_list(int src, const vector<vector<pair<int,ll>>>& adj) {
    int n = adj.size();
    vector<ll> dist(n, INF);
    using pli = pair<ll,int>;
    priority_queue<pli, vector<pli>, greater<pli>> pq;
    dist[src] = 0; pq.push({0, src});
    while (!pq.empty()) {
        auto [d,u] = pq.top(); pq.pop();
        if (d != dist[u]) continue;
        for (auto [v,w] : adj[u]) {
            if (dist[v] > d + w) {
                dist[v] = d + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << "=== Graph representation demos ===\n\n";
    demo_matrix_vs_list();
    cout << '\n';
    demo_weighted_structures();
    cout << '\n';

    // Dijkstra test using adjacency list (weighted)
    vector<vector<pair<int,ll>>> adj = make_adj_list_weighted(3);
    add_edge_list_weighted(adj, 0, 1, 5);
    add_edge_list_weighted(adj, 1, 2, 2);
    auto dist = dijkstra_list(0, adj);
    cout << "Dijkstra dist 0->2: " << (dist[2] >= INF ? -1 : dist[2]) << " (expect 7)\n";
    return 0;
}
```



# 11. Complexity analysis recap üîç

* **Adjacency matrix:** memory O(n¬≤), neighbor iteration O(n), edge check O(1).
* **Adjacency list:** memory O(n + m), neighbor iteration O(deg(u)), edge check O(deg(u)).
* **Edge list:** memory O(m), good for global operations (sort by weight) but poor for neighbor queries.

When `m` (edges) ‚â™ `n¬≤`, adjacency list almost always wins in memory and iteration efficiency.



# 12. Tips, tricks & common pitfalls üõ†Ô∏è

* If you need fast `hasEdge(u,v)` and graph is small-ish, matrix is perfect. For large `n` prefer list.
* For weighted graphs, avoid `int` if weights accumulate or are large - prefer `long long`.
* When using matrix for weighted graphs, initialize `mat[u][v] = INF` for ‚Äúno edge‚Äù.
* If you build an adjacency list from edge inputs, prefer `adj.reserve()` per node if you know approximate degrees to avoid reallocations.
* For undirected graphs, always add both directions (`u->v` and `v->u`) - and watch double-counting when iterating edges.
* When doing many `hasEdge` checks on a sparse graph, consider unordered_set of neighbor pairs or adjacency hashmaps: `vector<unordered_set<int>> adjset;` gives near O(1) `hasEdge` with O(deg(u)) iteration still possible.



# 13. Variations & extensions ‚ú®

* **Adjacency bitset / boolean matrix with `vector<bitset<N>>`** - memory- and cache-friendly for small N (useful for bitset DP / fast intersection ops).
* **Compressed sparse row (CSR)** - memory-compact representation used in heavy-duty graph libraries and numerical methods.
* **Adjacency hashmap (`vector<unordered_map<int,w>>`)** - when you need O(1) checks *and* weights per neighbor, but beware overhead.
* **Dynamic graphs** - representations that support fast insert/delete of edges often mix list + hash maps.



# 14. FAQs - short & helpful ‚ùì

**Q: Which to memorize for interviews?**
A: *Adjacency list*. It's the most used and versatile. Know matrix basics too.

**Q: When to use matrix in contests?**
A: Small `n` or when you need fast edge-existence or algorithms that rely on O(1) lookup.

**Q: Weighted adjacency list vs edge list for Dijkstra?**
A: Use **adjacency list** for Dijkstra. Edge list is for Bellman-Ford or Kruskal.

**Q: How to store directed vs undirected?**
A: For adjacency list/matrix, add only `u->v` for directed; add both `u->v` and `v->u` for undirected.

**Q: What about memory limits?**
A: If `n = 10^5`, matrix is impossible (`10^10` entries). Lists (O(n+m)) are the only practical option.



# 15. Final short checklist (before you code) ‚úÖ

* Is the graph **dense** or **sparse**? ‚Üí matrix vs list.
* Do you need **fast edge checks**? ‚Üí matrix / hash-set.
* Are edges **weighted**? ‚Üí use `pair` values in list or matrix of weights.
* Could recursion depth be a problem? ‚Üí use iterative traversals.
* Will sums overflow `int`? ‚Üí use `long long` and big `INF`.

