# ğŸŒ² Depth First Search (DFS) in Graphs [GfG [link](https://www.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1)]

> â€œBFS spreads like ripples. DFS goes all in.â€
> DFS is that friend who enters a maze and refuses to turn back until they hit a wall ğŸ§­



## ğŸ§¾ Problem Statement

Given:

* `V` vertices numbered `0 to V-1`
* An undirected or directed graph represented using adjacency list

Perform **Depth First Search (DFS)** traversal starting from a source node and:

* Visit all reachable vertices
* Optionally solve problems like cycle detection, connected components, topological sort, etc.



## ğŸ§  What is DFS?

DFS explores a graph **as deep as possible** before backtracking.

Instead of exploring neighbors level-by-level (like BFS), DFS:

1. Goes to a neighbor
2. Then neighborâ€™s neighbor
3. Continues until dead-end
4. Backtracks

It uses:

* ğŸ” Recursion (implicit stack)
* OR explicit stack



### ğŸ“˜ Example

Graph:

```
0 - 1 - 2
|   |
3   4
```

Adjacency List:

```
0: 1,3
1: 0,2,4
2: 1
3: 0
4: 1
```

### DFS from 0 (recursive)

Traversal order could be:

```
0 â†’ 1 â†’ 2 â†’ 4 â†’ 3
```

Note: DFS order depends on adjacency order.



## ğŸ¢ Brute Force Idea

Try exploring all possible paths manually.

âŒ Redundant
âŒ Revisits nodes
âŒ Exponential explosion

DFS avoids revisiting using a visited array.



## âš¡ Optimal DFS Approach



### ğŸ” Algorithm (Recursive DFS)

```
DFS(node):
    mark node visited
    process node

    for each neighbor:
        if not visited:
            DFS(neighbor)
```



### ğŸ’» C++ Implementation (Recursive DFS)

```cpp
#include <bits/stdc++.h>
using namespace std;

void dfs(int node, vector<vector<int>>& adj, vector<bool>& visited, vector<int>& result) {
    visited[node] = true;
    result.push_back(node);

    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, adj, visited, result);
        }
    }
}

vector<int> dfsTraversal(int V, vector<vector<int>>& adj, int start) {
    vector<bool> visited(V, false);
    vector<int> result;
    dfs(start, adj, visited, result);
    return result;
}
```



## ğŸ“Š Complexity

* **Time:** O(V + E)
* **Space:** O(V)

  * visited array
  * recursion stack (worst case depth = V)



## ğŸ§  DFS Using Stack (Iterative Version)

Sometimes recursion stack can overflow (for large graphs ~10âµ nodes).

Hereâ€™s iterative version:

```cpp
vector<int> dfsIterative(int V, vector<vector<int>>& adj, int start) {
    vector<bool> visited(V, false);
    vector<int> result;
    stack<int> st;

    st.push(start);

    while (!st.empty()) {
        int node = st.top();
        st.pop();

        if (!visited[node]) {
            visited[node] = true;
            result.push_back(node);

            // Push neighbors in reverse for correct order
            for (int i = adj[node].size() - 1; i >= 0; i--) {
                int neighbor = adj[node][i];
                if (!visited[neighbor]) {
                    st.push(neighbor);
                }
            }
        }
    }

    return result;
}
```



## ğŸ§ª Test Cases

### Case 1

```
V = 5
Edges = [[0,1],[0,2],[1,3],[1,4]]
Start = 0
```

Possible DFS output:

```
0 1 3 4 2
```



### Case 2 (Disconnected Graph)

```
V = 6
Edges = [[0,1],[1,2],[3,4]]
```

DFS from 0:

```
0 1 2
```

To cover entire graph:

```cpp
void dfsAll(int V, vector<vector<int>>& adj) {
    vector<bool> visited(V, false);

    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            dfs(i, adj, visited);
        }
    }
}
```



# ğŸ¯ Applications of DFS

DFS is extremely powerful. Used in:

* Connected components
* Cycle detection
* Topological sort
* Finding bridges & articulation points
* Strongly Connected Components (Kosaraju)
* Backtracking problems
* Maze solving
* Detecting bipartite graph

DFS is like the Swiss Army knife of graph algorithms ğŸ”§



# ğŸ”¥ DFS for Cycle Detection (Undirected)

```cpp
bool dfsCycle(int node, int parent, vector<vector<int>>& adj, vector<bool>& visited) {
    visited[node] = true;

    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            if (dfsCycle(neighbor, node, adj, visited))
                return true;
        }
        else if (neighbor != parent) {
            return true;
        }
    }
    return false;
}
```



# ğŸ”¥ DFS for Cycle Detection (Directed Graph)

Use 3-color method:

```cpp
bool dfsDirected(int node, vector<vector<int>>& adj, vector<int>& color) {
    color[node] = 1; // visiting

    for (int neighbor : adj[node]) {
        if (color[neighbor] == 1)
            return true;
        if (color[neighbor] == 0 && dfsDirected(neighbor, adj, color))
            return true;
    }

    color[node] = 2; // visited
    return false;
}
```



# ğŸ“Œ DFS vs BFS

| Feature       | DFS                | BFS                |
| - | - | - |
| Structure     | Stack / Recursion  | Queue              |
| Traversal     | Depth-first        | Level-first        |
| Shortest Path | âŒ No               | âœ… Yes (unweighted) |
| Memory        | Lower              | Higher             |
| Good for      | Components, cycles | Shortest path      |



# âš ï¸ Common Mistakes

* âŒ Forgetting visited array
* âŒ Infinite recursion in cyclic graphs
* âŒ Stack overflow for large graphs
* âŒ Mixing parent logic in undirected cycle detection



# ğŸ’¡ Pro Tips

* Mark visited immediately when entering DFS.
* For competitive programming â†’ use iterative version if V can be large.
* DFS order depends on adjacency list ordering.
* Always pass parent in undirected cycle detection.
* Use `vector<int>` color array for directed graphs.



# ğŸŒ Real-World Analogy

* Exploring a cave system ğŸ•³ï¸
* Backtracking in Sudoku
* Finding connected land masses in maps
* Git commit graph traversal



# ğŸ§© Advanced Variations

* DFS on Grid (Number of Islands)
* Tarjanâ€™s Algorithm (SCC)
* Bridges & Articulation Points
* Eulerian Path
* Topological Sort (DFS-based)



# â“ FAQs

**Q: When to prefer DFS over BFS?**
When depth exploration matters or for structural analysis like cycles, bridges, SCC.

**Q: Why does DFS use recursion naturally?**
Because recursion internally uses a stack - exactly what DFS needs.

**Q: Can DFS detect shortest path?**
Not reliably in unweighted graphs. Use BFS.

**Q: What is recursion stack space?**
Worst-case depth equals number of vertices in a chain.



# ğŸ Final Takeaway

DFS is fundamental.

If BFS is about distance,
DFS is about structure.

Mastering DFS unlocks:

* Connected components
* Cycle detection
* Topological sorting
* SCC
* Backtracking
* Advanced graph theory
