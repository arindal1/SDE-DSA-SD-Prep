# ğŸŒŠ Breadth First Search (BFS) in Graphs [GfG [link](https://www.geeksforgeeks.org/problems/bfs-traversal-of-graph/1)]

> â€œDFS dives deep. BFS spreads wide.â€
> Think of BFS like WiFi spreading signal from a router ğŸ“¡ - it reaches all nearby nodes first before going farther.



# ğŸ§¾ Problem Statement

Given a graph with:

* `V` vertices numbered `0 to V-1`
* Adjacency list representation

Perform **Breadth First Search (BFS)** starting from a source vertex and:

* Traverse all reachable vertices
* Optionally compute shortest distance (in unweighted graph)



# ğŸ§  What is BFS?

BFS explores nodes **level by level**.

From a source node:

1. Visit it
2. Visit all its neighbors
3. Then neighbors of neighbors
4. Continue until all reachable nodes are visited

It uses a **Queue (FIFO)**.



# ğŸ¯ Where BFS is Used

* Shortest path in **unweighted graph**
* Checking connectivity
* Finding connected components
* Bipartite graph check
* Level-order traversal
* Multi-source shortest path

If DFS is a tunnel explorer â›ï¸, BFS is a wave ğŸŒŠ.



# ğŸŸ¢ Core Idea (Intuition)

We:

1. Start from a source node
2. Push it into queue
3. Mark as visited
4. While queue not empty:

   * Pop front
   * Visit its neighbors
   * Push unvisited neighbors into queue



# ğŸ“˜ Example

Graph:

```
0 - 1 - 2
|   |
3   4
```

Adjacency List:

```
0: 1,3
1: 0,2,4
2: 1
3: 0
4: 1
```

### BFS from node 0

Traversal order:

```
0 â†’ 1 â†’ 3 â†’ 2 â†’ 4
```

Levels:

```
Level 0: 0
Level 1: 1, 3
Level 2: 2, 4
```



# ğŸ¢ Brute Force Approach

Try to manually explore all possible paths using recursion.

âŒ Redundant
âŒ May revisit nodes
âŒ Not level-based

We need something systematic.



# âš¡ Optimal Approach - BFS with Queue



# ğŸ” Algorithm

```
Create visited array
Create queue

Push source node into queue
Mark source visited

While queue not empty:
    node = queue.front()
    pop it

    For each neighbor:
        If not visited:
            Mark visited
            Push into queue
```



# ğŸ’» C++ Implementation (Basic BFS Traversal)

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> bfsTraversal(int V, vector<vector<int>>& adj, int start) {
    vector<bool> visited(V, false);
    vector<int> result;
    queue<int> q;

    visited[start] = true;
    q.push(start);

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);

        for (int neighbor : adj[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }

    return result;
}
```



# ğŸ“Š Time & Space Complexity

* **Time:** O(V + E)
* **Space:** O(V)

Why?

* Every node is pushed once
* Every edge is checked once



# ğŸ§  BFS for Shortest Path (Unweighted Graph)

One of BFSâ€™s biggest powers.

If graph is unweighted:

ğŸ‘‰ The first time we visit a node = shortest distance from source.



## ğŸ’» C++ Code (Shortest Distance)

```cpp
vector<int> shortestPath(int V, vector<vector<int>>& adj, int src) {
    vector<int> dist(V, -1);
    queue<int> q;

    dist[src] = 0;
    q.push(src);

    while (!q.empty()) {
        int node = q.front();
        q.pop();

        for (int neighbor : adj[node]) {
            if (dist[neighbor] == -1) {
                dist[neighbor] = dist[node] + 1;
                q.push(neighbor);
            }
        }
    }

    return dist;
}
```



# ğŸ§ª Test Cases

### Case 1

```
V = 5
Edges: [[0,1],[0,2],[1,3],[2,4]]
Start = 0
```

Output Traversal:

```
0 1 2 3 4
```

Distances:

```
0 â†’ 0
1 â†’ 1
2 â†’ 1
3 â†’ 2
4 â†’ 2
```



### Case 2 (Disconnected Graph)

```
V = 6
Edges: [[0,1],[1,2],[3,4]]
```

Running BFS from 0:

```
0 1 2
```

Nodes 3,4,5 remain unreachable.



# ğŸŒ BFS for Disconnected Graph

To traverse entire graph:

```cpp
void bfsAll(int V, vector<vector<int>>& adj) {
    vector<bool> visited(V, false);

    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            queue<int> q;
            q.push(i);
            visited[i] = true;

            while (!q.empty()) {
                int node = q.front();
                q.pop();
                cout << node << " ";

                for (int neighbor : adj[node]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }
    }
}
```



# ğŸ”¥ Advanced BFS Variations

### ğŸ”¹ Multi-Source BFS

Push multiple starting nodes into queue initially.

Used in:

* Rotting Oranges
* Fire spread problems
* Distance from multiple sources



### ğŸ”¹ 0-1 BFS

When weights are only 0 or 1 â†’ use deque instead of priority queue.



### ğŸ”¹ BFS on Grid

Treat each cell as node with 4 or 8 directions.



# âš ï¸ Common Mistakes

* âŒ Forgetting to mark visited before pushing
* âŒ Using DFS when shortest path required
* âŒ Not handling disconnected graphs
* âŒ Using recursion (BFS must use queue)



# ğŸ§© BFS vs DFS Quick Comparison

| Feature         | BFS                | DFS               |
| - | - | -- |
| Data Structure  | Queue              | Stack / Recursion |
| Shortest Path   | âœ… Yes (unweighted) | âŒ No              |
| Memory          | Higher             | Lower             |
| Traversal Style | Level-wise         | Depth-wise        |



# ğŸ’¡ Pro Tips

* Always mark visited **when pushing**, not when popping.
* For shortest path â†’ use distance array instead of visited.
* If graph size large (10âµ nodes) â†’ BFS is safe.
* For weighted graphs â†’ use Dijkstra instead.



# ğŸ¯ Real World Analogy

* Finding shortest route in metro system ğŸš‡
* Web crawler visiting pages level by level ğŸŒ
* Social network degrees of separation ğŸ‘¥
* Virus spreading simulation ğŸ¦ 



# â“ FAQs

**Q: Why does BFS guarantee shortest path?**
Because it explores nodes in increasing distance order.

**Q: Can BFS be recursive?**
Not really practical. It fundamentally uses a queue.

**Q: What if graph is weighted?**
Use Dijkstra.

**Q: What if weights are only 0 or 1?**
Use 0-1 BFS with deque.



# ğŸ Final Takeaway

BFS is one of the most powerful and elegant graph techniques.

If graphs were a toolkit:

* DFS = exploration tool
* BFS = distance calculator
* Dijkstra = weighted BFS
* Union-Find = connectivity checker

