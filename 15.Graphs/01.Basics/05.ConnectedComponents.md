# ðŸŒ Connected Components in an Undirected Graph (C++)

> â€œA graph is just a bunch of cities. Connected components tell us how many separate countries exist.â€ ðŸ—ºï¸



## ðŸ§¾ Problem Statement

Given an **undirected graph** with:

* `V` vertices numbered `0` to `V-1`
* `E` edges represented as `[ai, bi]`

Two vertices belong to the same component if there exists a **path** between them.

ðŸ‘‰ **Goal:** Find the number of **connected components** in the graph.



## ðŸ§  Understanding Connected Components

A **connected component** is:

* A subgraph where **every vertex is reachable from every other vertex**
* No vertex in the subgraph connects to a vertex outside it

Think of it like islands ðŸŒ´. If you can travel between cities without crossing water, they belong to the same island.



## ðŸ” Examples

### Example 1

**Input**

```
V = 4
edges = [[0,1],[1,2]]
```

**Graph**

```
0 - 1 - 2     3
```

**Output**

```
2
```

âœ” Component 1: {0,1,2}
âœ” Component 2: {3}



### Example 2

**Input**

```
V = 7
edges = [[0,1],[1,2],[2,3],[4,5]]
```

**Graph**

```
0 - 1 - 2 - 3     4 - 5     6
```

**Output**

```
3
```

âœ” {0,1,2,3}
âœ” {4,5}
âœ” {6}



# ðŸ’¡ Intuition

If we:

1. Start from a node
2. Visit all nodes reachable from it
3. Mark them visited

Then that entire set forms **one connected component**.

Repeat this process for every unvisited node.

Each time we start from a new unvisited node â†’ **new component found** ðŸŽ¯



# ðŸ¢ Brute Force Approach

For every pair `(u, v)`:

* Check if there's a path between them
* Group them manually

âŒ Extremely inefficient
âŒ Checking reachability repeatedly is expensive

Time complexity would blow up.

We need something smarter.



# âš¡ Optimal Approach

We use:

* **DFS (Depth First Search)** OR
* **BFS (Breadth First Search)** OR
* **Disjoint Set Union (Union-Find)**

All give:

> â± **Time Complexity:** O(V + E)
> ðŸ’¾ **Space Complexity:** O(V)

Letâ€™s break them down.



# ðŸ”µ Approach 1: DFS (Most Intuitive)

### ðŸ”¹ Idea

* Maintain a `visited` array
* Loop through all vertices
* If not visited:

  * Run DFS
  * Increment component count



## ðŸ”Ž Algorithm

```
count = 0
for each vertex i:
    if not visited[i]:
        DFS(i)
        count++
return count
```



## ðŸ’» C++ Code (DFS)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    void dfs(int node, vector<vector<int>>& adj, vector<bool>& visited) {
        visited[node] = true;
        for (int neighbor : adj[node]) {
            if (!visited[neighbor]) {
                dfs(neighbor, adj, visited);
            }
        }
    }

    int countComponents(int V, vector<vector<int>>& edges) {
        vector<vector<int>> adj(V);
        
        // Build adjacency list
        for (auto &edge : edges) {
            int u = edge[0];
            int v = edge[1];
            adj[u].push_back(v);
            adj[v].push_back(u);
        }

        vector<bool> visited(V, false);
        int count = 0;

        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                dfs(i, adj, visited);
                count++;
            }
        }

        return count;
    }
};
```



# ðŸŸ¢ Approach 2: BFS

Same logic - different traversal style.



## ðŸ’» C++ Code (BFS)

```cpp
int countComponents(int V, vector<vector<int>>& edges) {
    vector<vector<int>> adj(V);

    for (auto &edge : edges) {
        adj[edge[0]].push_back(edge[1]);
        adj[edge[1]].push_back(edge[0]);
    }

    vector<bool> visited(V, false);
    int count = 0;

    for (int i = 0; i < V; i++) {
        if (!visited[i]) {
            queue<int> q;
            q.push(i);
            visited[i] = true;

            while (!q.empty()) {
                int node = q.front(); q.pop();
                for (int neighbor : adj[node]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }

            count++;
        }
    }

    return count;
}
```



# ðŸŸ£ Approach 3: Disjoint Set (Union-Find)

Very powerful when:

* Edges are processed dynamically
* Many connectivity queries exist



## ðŸ’» C++ Code (Union-Find)

```cpp
class DSU {
public:
    vector<int> parent, rank;

    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }

    void unite(int x, int y) {
        int px = find(x);
        int py = find(y);

        if (px == py) return;

        if (rank[px] < rank[py])
            parent[px] = py;
        else if (rank[px] > rank[py])
            parent[py] = px;
        else {
            parent[py] = px;
            rank[px]++;
        }
    }
};

int countComponents(int V, vector<vector<int>>& edges) {
    DSU dsu(V);

    for (auto &edge : edges) {
        dsu.unite(edge[0], edge[1]);
    }

    unordered_set<int> components;

    for (int i = 0; i < V; i++) {
        components.insert(dsu.find(i));
    }

    return components.size();
}
```



# ðŸ“Š Complexity Analysis

| Approach   | Time     | Space |
| - | -- | -- |
| DFS        | O(V + E) | O(V)  |
| BFS        | O(V + E) | O(V)  |
| Union-Find | O(V + E) | O(V)  |

Union-Find operations are nearly constant time due to **path compression + union by rank**.



# ðŸ§ª Edge Cases to Test

1. `V = 1`, `edges = []` â†’ Output = 1
2. `V = 5`, `edges = []` â†’ Output = 5
3. Fully connected graph â†’ Output = 1
4. Linear chain â†’ Output = 1
5. Multiple isolated nodes â†’ count them individually



# ðŸ§  Why This Works

Every time we start traversal from an unvisited node, we're discovering a new â€œislandâ€ in the graph.

Thatâ€™s the entire idea. Simple. Elegant. Powerful.



# ðŸ”¥ Tips & Tricks

* Always build adjacency list first.
* For large graphs (10âµ nodes), avoid recursive DFS â†’ use iterative DFS or BFS.
* Union-Find is great when edges are given first and many connectivity queries follow.
* If graph is directed â†’ this problem changes (Strongly Connected Components).



# ðŸ§© Variations

* Count number of **provinces** (LeetCode variant).
* Find largest connected component.
* Return all connected components.
* Count connected components in a grid (2D graph problem).
* Dynamic graph connectivity.



# â“ FAQs

**Q: Why do we increment count only when node is unvisited?**
Because it means we discovered a brand new component.

**Q: What if graph is directed?**
Then this solution counts weakly connected components. For strongly connected components use Kosaraju or Tarjan.

**Q: Is Union-Find faster than DFS?**
Same complexity, but DSU shines in dynamic connectivity problems.

**Q: What if V is very large?**
Use adjacency list. Matrix will cause memory explosion.



# ðŸŽ¯ Final Takeaway

Connected Components is one of the **most fundamental graph problems**.

If you master this, youâ€™re halfway to understanding:

* Cycle detection
* MST
* Network connectivity
* Graph traversal patterns
* Grid-based graph problems

Itâ€™s like learning pushups before lifting weights ðŸ’ª
