# ğŸ¨ 733. Flood Fill â€” BFS on Grid [[Leetcode](https://leetcode.com/problems/flood-fill/description/)]

> If youâ€™ve ever used the paint bucket tool in MS Paintâ€¦ congratulations, you already understand this problem ğŸ˜„
> Flood Fill is just **graph traversal on a 2D grid**.



## ğŸ§¾ Problem Statement

You are given:

* A 2D grid `image`
* A starting pixel `(sr, sc)`
* A new `color`

ğŸ‘‰ Replace the color of the starting pixel and all **4-directionally connected pixels** with the same original color.

Return the modified image.



## ğŸ§  Key Insight

This is:

> Connected Components in a Grid

More specifically:

* Each cell = node
* Adjacent cells (up/down/left/right) = edges
* We need to traverse all connected cells having same initial color

This is classic:

* âœ… BFS
* âœ… DFS



## ğŸ” Intuition

1. Store the initial color of `(sr, sc)`
2. If new color is same â†’ return image immediately
3. Traverse all connected cells with same color
4. Change their color

This is literally **BFS/DFS region expansion**



### ğŸ“˜ Example

Input:

```
image = 
[
 [1,1,1],
 [1,1,0],
 [1,0,1]
]

sr = 1, sc = 1
color = 2
```

Original region (color 1):

```
1 1 1
1 1 0
1 0 1
```

Output:

```
2 2 2
2 2 0
2 0 1
```



## ğŸ§© Understanding Your Code

Letâ€™s break it down.



### ğŸŸ¢ Step 1: Get Dimensions

```cpp
int n = image.size();
int m = image[0].size();
```



### ğŸŸ¢ Step 2: Store Initial Color

```cpp
int initColor = image[sr][sc];
```

We only replace pixels matching this color.



### ğŸŸ¢ Step 3: Early Exit Optimization

```cpp
if (initColor == color)
    return image;
```

Important!

If new color is same as old â†’ no need to process.

Prevents infinite loop.



### ğŸŸ¢ Step 4: BFS Setup

```cpp
queue<pair<int,int>> q;
q.push({sr, sc});
image[sr][sc] = color;
```

* Push starting pixel
* Immediately recolor (acts as visited marker)



### ğŸŸ¢ Step 5: Direction Vectors

```cpp
int dx[4] = {0,0,1,-1};
int dy[4] = {1,-1,0,0};
```

Right, Left, Down, Up.



### ğŸŸ¢ Step 6: BFS Traversal

```cpp
while (!q.empty()) {
    auto [x,y] = q.front();
    q.pop();
```

Pop current pixel.



#### ğŸ”„ Visit Neighbors

```cpp
if (nx >= 0 && nx < n && ny >= 0 && ny < m && image[nx][ny] == initColor) {
    image[nx][ny] = color;
    q.push({nx,ny});
}
```

Conditions:

* Within bounds
* Same original color
* Not already recolored

We use recoloring as visited marking â€” very clean trick.



## ğŸ“Š Complexity Analysis

Let grid size = `n Ã— m`

* **Time:** O(n Ã— m)
* **Space:** O(n Ã— m) (queue worst case)

Each cell visited at most once.



## ğŸ§ª Edge Cases

| Case                    | Result                 |
| -- | - |
| 1x1 grid                | Change single pixel    |
| New color same as old   | No change              |
| Starting pixel isolated | Only one pixel changes |
| Entire grid same color  | Whole grid changes     |



## ğŸ§  Why BFS Works Here

Flood fill is basically:

> Find all connected cells with same value.

Which is exactly what BFS/DFS does in graphs.



## ğŸ”¥ DFS Version (Recursive Alternative)

Just for completeness:

```cpp
class Solution {
public:
    void dfs(vector<vector<int>>& image, int x, int y, int initColor, int newColor) {
        int n = image.size();
        int m = image[0].size();

        if (x < 0 || y < 0 || x >= n || y >= m)
            return;

        if (image[x][y] != initColor)
            return;

        image[x][y] = newColor;

        dfs(image, x+1, y, initColor, newColor);
        dfs(image, x-1, y, initColor, newColor);
        dfs(image, x, y+1, initColor, newColor);
        dfs(image, x, y-1, initColor, newColor);
    }

    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        int initColor = image[sr][sc];
        if (initColor != color)
            dfs(image, sr, sc, initColor, color);
        return image;
    }
};
```

âš ï¸ Risk: Stack overflow if grid large.



## ğŸŒ Real-World Analogy

* Paint bucket tool ğŸ¨
* Filling area in image processing
* Region detection in computer vision
* Finding islands in a map ğŸï¸



## ğŸ’¡ Patterns to Recognize

Flood Fill is a template for:

* Number of Islands
* Surrounded Regions
* Area of Island
* Connected components in matrix
* Rotting Oranges (with timing added)



## ğŸ§© BFS vs DFS in Flood Fill

| Feature                | BFS             | DFS             |
| - | - | - |
| Memory                 | Queue           | Recursion stack |
| Risk of stack overflow | âŒ No            | âš ï¸ Yes          |
| Implementation         | Slightly longer | Shorter         |
| Performance            | Same            | Same            |



## âš ï¸ Common Mistakes

* âŒ Forgetting to check `initColor == color`
* âŒ Not marking visited
* âŒ Going out of bounds
* âŒ Using diagonal directions accidentally



## ğŸ§  Key Takeaways

Flood Fill teaches:

* Grid â†’ Graph conversion
* Direction arrays
* BFS/DFS traversal pattern
* Visited marking via modification

This pattern appears everywhere in coding interviews.

Once mastered, grid problems become predictable.



## ğŸ¯ Final Thought

Flood Fill is one of the purest examples of graph traversal applied to a grid.

It looks like a painting problemâ€¦

â€¦but itâ€™s secretly graph theory.


