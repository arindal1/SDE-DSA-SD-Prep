# ğŸŠ 994. Rotting Oranges - Multi-Source BFS [[Leetcode](https://leetcode.com/problems/rotting-oranges/)]

> This problem is basically **BFS on a grid**, but with multiple starting points.
> Think zombie outbreak ğŸ§Ÿ - all rotten oranges infect their neighbors at the same time.



## ğŸ§¾ Problem Statement

You are given a grid where:

* `0` â†’ Empty cell
* `1` â†’ Fresh orange ğŸŠ
* `2` â†’ Rotten orange ğŸ¤¢

Every minute:

* Any fresh orange adjacent (4 directions) to a rotten one becomes rotten.

ğŸ‘‰ Return the **minimum time** required to rot all oranges.
ğŸ‘‰ If impossible, return `-1`.



## ğŸ§  Key Insight

This is a **Multi-Source BFS problem**.

Why?

Because:

* All initially rotten oranges spread infection simultaneously.
* Infection spreads level by level.
* Each BFS layer = 1 minute.

This is literally BFS timing simulation â³



## ğŸ” Intuition

1. Push **all rotten oranges** into queue initially.
2. Count total non-empty oranges.
3. Run BFS level by level:

   * Rot neighbors
   * Increase time after each level
4. If all oranges rot â†’ return time.
5. Otherwise â†’ return -1.

![image](https://lh6.googleusercontent.com/h510WBOshEcF40YoVuWMLaC-sJsnK6O7hOeyDz3n17IoJatMzR-h9Jfb-MGFtq7oavCzMd5td8Q2dqy982OfEJ5IuPOj-x7-GehyVIS-xKrjzG5xyO4VgP5c_4-vyC1LOp56czHfFNs_LUgW-Qz9Vag)

![image](https://lh6.googleusercontent.com/8gHh0pcJrXFxATSzxprGVn_gIMlTJd1gI567mqouqQYv9bPNpjXHfiJgZj4TH3J0XnZkCljkTEH1omRo2qHMdnJ3dClVe9rsPyEUHcq9QIq1F3vvB9HxhOdIHKOIUbkLMYPxjYl3Q709g3BhAfzZo5U)



## ğŸ§© Understanding the Given Code

Letâ€™s walk through your solution carefully.



### ğŸŸ¢ Step 1: Edge Case

```cpp
if (grid.empty())
    return -1;
```

If grid is empty â†’ no oranges â†’ return -1.



### ğŸŸ¢ Step 2: Initialization

```cpp
int n = grid.size();
int m = grid[0].size();
queue<pair<int, int>> q;
int totOranges = 0, rottenOranges = 0, time = 0;
```

* `totOranges` â†’ counts fresh + rotten (non-zero cells)
* `rottenOranges` â†’ how many we process during BFS
* `time` â†’ minutes elapsed



### ğŸŸ¢ Step 3: Push All Rotten Oranges (Multi-Source Setup)

```cpp
if (grid[i][j] == 2) {
    q.push({i, j});
}
```

All rotten oranges are pushed into queue at start.

This is key - infection spreads simultaneously.



### ğŸŸ¢ Step 4: Direction Vectors

```cpp
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
```

Used to move:

* Right
* Left
* Down
* Up



### ğŸŸ¢ Step 5: BFS Simulation

```cpp
while (!q.empty()) {
    int k = q.size();
    rottenOranges += k;
```

`k` = number of oranges rotting this minute.

We process them first before spreading further.



#### ğŸ”„ Inner Loop - Infect Neighbors

```cpp
while (k--) {
    int x = q.front().first;
    int y = q.front().second;
    q.pop();

    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i];
        int ny = y + dy[i];

        if (nx < 0 || ny < 0 || nx >= n || ny >= m || grid[nx][ny] != 1)
            continue;

        grid[nx][ny] = 2;
        q.push({nx, ny});
    }
}
```

Important points:

* Skip invalid cells
* Only rot fresh oranges (`grid[nx][ny] == 1`)
* Mark as rotten immediately
* Push into queue



#### â³ Increment Time

```cpp
if (!q.empty())
    time++;
```

Time increases only if infection spreads further.

Brilliant small detail.



### ğŸŸ¢ Final Check

```cpp
return totOranges == rottenOranges ? time : -1;
```

If some oranges were unreachable â†’ return -1.



## ğŸ“Š Complexity Analysis

Let `n Ã— m` be grid size.

* **Time:** O(n Ã— m)
* **Space:** O(n Ã— m) (queue worst case)

Each cell visited at most once.



## ğŸ§ª Example Walkthrough

Input:

```
2 1 1
1 1 0
0 1 1
```

Minute 0:

```
2 1 1
1 1 0
0 1 1
```

Minute 1:

```
2 2 1
2 1 0
0 1 1
```

Minute 2:

```
2 2 2
2 2 0
0 1 1
```

Minute 3:

```
2 2 2
2 2 0
0 2 1
```

Minute 4:

```
2 2 2
2 2 0
0 2 2
```

Output = **4**



## âš ï¸ Important Edge Cases

| Case                          | Output                           |
| -- | -- |
| All fresh, no rotten          | -1                               |
| All rotten initially          | 0                                |
| No oranges                    | 0 or -1 depending interpretation |
| Fresh isolated by empty cells | -1                               |



## ğŸ”¥ Cleaner Version (Slight Improvement)

We can avoid counting `totOranges` and `rottenOranges` by counting fresh oranges only.

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        queue<pair<int,int>> q;
        int fresh = 0, time = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 2)
                    q.push({i,j});
                if (grid[i][j] == 1)
                    fresh++;
            }
        }

        int dx[4] = {0,0,1,-1};
        int dy[4] = {1,-1,0,0};

        while (!q.empty() && fresh > 0) {
            int size = q.size();
            time++;

            while (size--) {
                auto [x,y] = q.front();
                q.pop();

                for (int i = 0; i < 4; i++) {
                    int nx = x + dx[i];
                    int ny = y + dy[i];

                    if (nx>=0 && ny>=0 && nx<n && ny<m && grid[nx][ny]==1) {
                        grid[nx][ny] = 2;
                        q.push({nx,ny});
                        fresh--;
                    }
                }
            }
        }

        return fresh == 0 ? time : -1;
    }
};
```

Cleaner logic. Slightly more intuitive.



## ğŸ§  Why This Works

BFS processes nodes in waves.

Each wave = 1 minute.

Since all rotten oranges start in queue, infection spreads simultaneously.

This is exactly what BFS guarantees.



## ğŸŒ Real-World Analogies

* Virus spreading simulation ğŸ¦ 
* Fire spreading in forest ğŸ”¥
* Rumor spreading in network ğŸ‘¥
* Flood filling in image processing ğŸ¨



## ğŸ’¡ Key Patterns to Remember

This is the classic:

> Multi-Source BFS + Level Order Traversal

Once you recognize it, you'll see similar problems everywhere:

* Walls and Gates
* Fire Spread
* Distance from nearest source
* Rotten oranges variant
* 01 Matrix problem



## â“ FAQs

**Q: Why use BFS and not DFS?**
Because we need minimum time â†’ shortest layer expansion â†’ BFS.

**Q: Why push all rotten oranges first?**
Because infection spreads simultaneously from all of them.

**Q: What if diagonal infection allowed?**
Change direction vectors to 8 directions.

**Q: Why increment time only if queue not empty?**
Because last layer shouldn't add extra minute.



## ğŸ¯ Final Takeaway

This problem is not about oranges.

Itâ€™s about recognizing:

* Grid â†’ Graph
* Infection â†’ BFS expansion
* Time â†’ BFS level
* Multiple sources â†’ Push all initial nodes

