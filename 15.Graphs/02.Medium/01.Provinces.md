# ðŸ™ï¸ 547. Number of Provinces (LeetCode â€“ [Medium](https://leetcode.com/problems/number-of-provinces/description/))

> If cities are nodes and roads are edges, this problem is just **Connected Components in disguise** ðŸŽ­



## ðŸ§¾ Problem Statement

You are given:

* `n` cities
* An `n x n` adjacency matrix `isConnected`

Where:

* `isConnected[i][j] = 1` â†’ City `i` and `j` are directly connected
* `isConnected[i][j] = 0` â†’ No direct connection

A **province** is a group of cities that are directly or indirectly connected.

ðŸ‘‰ Return the total number of provinces.



## ðŸ§  Key Observation

This is simply:

> Count the number of **connected components** in an undirected graph.

But the graph is given as an **adjacency matrix**, not an edge list.



## ðŸ“˜ Example

### Input

```
isConnected =
[
 [1,1,0],
 [1,1,0],
 [0,0,1]
]
```

### Graph Representation

```
0 - 1      2
```

* Cities {0,1} are connected
* City {2} is isolated

### Output

```
2
```



# ðŸ’¡ Intuition

If we:

1. Pick an unvisited city
2. Visit all cities connected to it (DFS/BFS)
3. Mark them visited
4. Increment province count

Repeat for all cities.

Each new DFS/BFS start = new province ðŸš€



# ðŸ¢ Brute Force Approach

For every city pair:

* Try to manually find indirect connections

âŒ Too complicated
âŒ Repeated traversal
âŒ Inefficient

We need graph traversal.



# âš¡ Optimal Approaches

We can solve using:

* âœ… DFS
* âœ… BFS
* âœ… Union-Find (DSU)

All run in:

> â± Time: O(nÂ²)
> ðŸ’¾ Space: O(n)

Why O(nÂ²)? Because we scan the entire matrix.



# ðŸ”µ Approach 1: DFS (Most Common)



## ðŸ”Ž Algorithm

```
visited array of size n
count = 0

for each city i:
    if not visited:
        DFS(i)
        count++

return count
```



## ðŸ’» C++ Code (DFS)

```cpp
class Solution {
public:
    void dfs(int city, vector<vector<int>>& isConnected, vector<bool>& visited) {
        visited[city] = true;

        for (int j = 0; j < isConnected.size(); j++) {
            if (isConnected[city][j] == 1 && !visited[j]) {
                dfs(j, isConnected, visited);
            }
        }
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        vector<bool> visited(n, false);
        int provinces = 0;

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i, isConnected, visited);
                provinces++;
            }
        }

        return provinces;
    }
};
```

### If input was a Adjacency List instead of a Matrix:

```cpp
class Solution {
public:
    void dfs(int city, vector<vector<int>>& adj, vector<bool>& visited) {
        visited[city] = true;

        for (int neighbor : adj[city]) {
            if (!visited[neighbor]) {
                dfs(neighbor, adj, visited);
            }
        }
    }

    int findCircleNum(vector<vector<int>>& adj) {
        int n = adj.size();
        vector<bool> visited(n, false);
        int provinces = 0;

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(i, adj, visited);
                provinces++;
            }
        }

        return provinces;
    }
};
```



# ðŸŸ¢ Approach 2: BFS

Same logic - different traversal.



## ðŸ’» C++ Code (BFS)

```cpp
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        vector<bool> visited(n, false);
        int provinces = 0;

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                queue<int> q;
                q.push(i);
                visited[i] = true;

                while (!q.empty()) {
                    int city = q.front();
                    q.pop();

                    for (int j = 0; j < n; j++) {
                        if (isConnected[city][j] == 1 && !visited[j]) {
                            visited[j] = true;
                            q.push(j);
                        }
                    }
                }

                provinces++;
            }
        }

        return provinces;
    }
};
```



# ðŸŸ£ Approach 3: Union-Find (DSU)

More elegant for connectivity problems.



## ðŸ’» C++ Code (Union-Find)

```cpp
class DSU {
public:
    vector<int> parent, rank;

    DSU(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }

    void unite(int x, int y) {
        int px = find(x);
        int py = find(y);

        if (px == py) return;

        if (rank[px] < rank[py])
            parent[px] = py;
        else if (rank[px] > rank[py])
            parent[py] = px;
        else {
            parent[py] = px;
            rank[px]++;
        }
    }
};

class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        DSU dsu(n);

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    dsu.unite(i, j);
                }
            }
        }

        unordered_set<int> provinces;
        for (int i = 0; i < n; i++) {
            provinces.insert(dsu.find(i));
        }

        return provinces.size();
    }
};
```



# ðŸ“Š Complexity Analysis

Since matrix is `n x n`:

* **Time:** O(nÂ²)
* **Space:** O(n)

Even DFS/BFS must scan entire row for each node.



# ðŸ§ª Edge Cases

| Input                   | Output |
| -- | -: |
| `[[1]]`                 | 1      |
| Fully connected matrix  | 1      |
| Identity matrix only    | n      |
| No indirect connections | n      |



# âš ï¸ Common Mistakes

* âŒ Forgetting that matrix represents undirected graph
* âŒ Not marking visited early
* âŒ Counting multiple times
* âŒ Using adjacency list unnecessarily



# ðŸ§© Why This Problem is Important

This is a classic pattern:

* LeetCode 547 â†’ Provinces
* Graph connected components
* Number of islands (grid version)
* Network connectivity problems

Once you see it, youâ€™ll recognize it instantly.



# ðŸŒ Real-World Analogy

* Friend groups in a social network ðŸ‘¥
* Airline networks between cities âœˆï¸
* LAN network clusters ðŸ’»
* Political regions with trade routes ðŸ—ºï¸



# ðŸ§  DFS vs BFS vs DSU - Which to Use?

| Approach | When to Prefer                                |
| -- | - |
| DFS      | Most intuitive                                |
| BFS      | Same complexity, iterative                    |
| DSU      | Dynamic connectivity or many union operations |


