# ğŸŒ³ Search in a Binary Search Tree (BST) [Leetcode #[700](https://leetcode.com/problems/search-in-a-binary-search-tree/)]
 
> *â€œItâ€™s like Google Maps for trees. You donâ€™t explore every street, only the ones that make sense.â€* ğŸ—ºï¸ğŸ˜„

This problem is one of the **most fundamental BST problems** and appears in almost every DSA syllabus and interview list.

Weâ€™ll break it down **gently but deeply**: intuition, brute force, optimal solution, code, complexity, pitfalls, variations, FAQs, and some fun analogies.



## ğŸ“Œ Problem Statement

You are given the **root of a Binary Search Tree (BST)** and an integer `val`.

Return the **subtree rooted at the node whose value equals `val`**.
If such a node does not exist, return `nullptr`.

### Example

BST:

```
        4
       / \
      2   7
     / \
    1   3
```

Search `val = 2`

Output:

```
      2
     / \
    1   3
```



## ğŸ§  Key Property of a BST

A Binary Search Tree follows:

* All values in **left subtree** `< node.val`
* All values in **right subtree** `> node.val`

This single rule is the **superpower** that lets us search in **logarithmic time**.



## ğŸ’¡ Intuition (The Human Version)

Imagine you're searching for a word in a **dictionary** ğŸ“–:

* If your word is alphabetically smaller â†’ go left
* If larger â†’ go right
* If equal â†’ boom, found it ğŸ¯

You **never scan the whole dictionary**.
You only look where it *makes sense*.

BST works the exact same way.



## ğŸŒ Brute Force Approach

Ignore the BST property and just treat it as a normal binary tree.

### Idea

Do a full DFS or BFS and check every node.

### Pseudocode

```
search(node):
    if node == null: return null
    if node.val == val: return node
    search left
    search right
```

### Time Complexity

* **O(n)** in all cases

### Why this is bad?

Youâ€™re wasting the BSTâ€™s biggest advantage.
Itâ€™s like using linear search on a sorted array ğŸ¤¦â€â™‚ï¸.



## âš¡ Optimal Approach (Using BST Property)

This is what your code does.

### Algorithm

Start from root:

1. If root is null â†’ return null
2. If root.val == val â†’ return root
3. If val < root.val â†’ go left
4. Else â†’ go right
5. Repeat until found or null



## ğŸ§ª  Code (Iterative & Optimal)

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != nullptr && root->val != val) {
            root = val < root->val ? root->left : root->right;
        }
        return root;
    }
};
```



## ğŸ” Line-by-Line Explanation

```cpp
while (root != nullptr && root->val != val)
```

Keep moving until:

* We fall off the tree (not found)
* Or we find the value



```cpp
root = val < root->val ? root->left : root->right;
```

This is a **ternary operator**:

Equivalent to:

```cpp
if (val < root->val)
    root = root->left;
else
    root = root->right;
```

We **discard half the tree every step**
Just like binary search ğŸ˜Œ



```cpp
return root;
```

If found â†’ returns node
If not â†’ returns nullptr

Clean. Elegant. Interview-approved âœ¨




## ğŸ” Recursive Version (Alternative)

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (!root || root->val == val)
            return root;
        
        if (val < root->val)
            return searchBST(root->left, val);
        else
            return searchBST(root->right, val);
    }
};
```

Same logic, different style.



## ğŸ§ª Test Cases

### Case 1

BST: `[4,2,7,1,3]`, val = 2
Output: Node with value 2

### Case 2

BST: `[4,2,7,1,3]`, val = 5
Output: `nullptr`

### Case 3

BST: `[1]`, val = 1
Output: Node 1

### Case 4 (Empty Tree)

BST: `[]`, val = 10
Output: `nullptr`



## â±ï¸ Complexity Analysis

| Case         | Time         |
| - | - |
| Balanced BST | **O(log n)** |
| Skewed BST   | **O(n)**     |

### Space

* Iterative: **O(1)**
* Recursive: **O(h)** stack



## ğŸ¯ Why This is Better Than DFS?

Because BST gives **direction**.

DFS:

> "Iâ€™ll search everywhere just in case."

BST search:

> "I know exactly where to look." ğŸ˜



## ğŸ§  Common Mistakes

### 1. Forgetting BST property

Using DFS instead of smart traversal.

### 2. Not returning subtree

Returning just `true/false` instead of the node.

### 3. Infinite loop

Forgetting to update `root`.

### 4. Using recursion blindly

Causing stack overflow on skewed trees.



## ğŸ› ï¸ Variations You Should Know

### 1. Search with Parent

Return both node and parent pointer.

### 2. Kth Smallest

Use inorder traversal.

### 3. Floor / Ceil

Find closest value â‰¤ or â‰¥ target.

### 4. Search Range

Print all values between L and R.



## ğŸ¤” FAQs

### Q1: What if BST has duplicates?

Depends on definition:

* Some allow duplicates on left.
* Some store a `count`.

This code assumes **no duplicates**.



### Q2: Why not always use recursion?

Iterative is:

* Faster
* No stack overflow
* More memory efficient



### Q3: Is this same as binary search?

Conceptually yes.
But instead of array indices, we move through **pointers**.



### Q4: What if tree is not balanced?

Worst case becomes **O(n)**
Like searching in a linked list ğŸ¥²

Solution: Use AVL / Red-Black Trees.


## ğŸ TL;DR

* This code is **perfect and optimal**
* Uses BST property to achieve **O(log n)**
* Iterative = clean and efficient
* One of the most important BST patterns ever

If you remember only one line from this topic:

```cpp
root = val < root->val ? root->left : root->right;
```

That line alone is **half of all BST problems**. ğŸ’¯
