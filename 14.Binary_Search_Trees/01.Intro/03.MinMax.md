# üå≥ Find Minimum & Maximum in a Binary Search Tree (BST)

> *‚ÄúFinding min/max in a BST is like finding the youngest and oldest person in a family tree. You just follow the extremes.‚Äù* üòÑ

This is one of the **simplest yet most powerful** BST problems.
If you truly understand this, you‚Äôve unlocked the mental model for **successor, predecessor, delete, floor, ceil, range queries** and more.



# üìå Problem Statement

You are given the **root of a Binary Search Tree (BST)**.

Your task is to:

* Find the **minimum value** in the BST.
* Find the **maximum value** in the BST.



## Example

BST:

```
        8
       / \
      3   10
     / \    \
    1   6    14
```

* Minimum = **1**
* Maximum = **14**



# üß† Key BST Property (The Superpower)

In a BST:

* The **leftmost node** is the **minimum**
* The **rightmost node** is the **maximum**

This is not a coincidence.
It‚Äôs literally **guaranteed by definition**.



# üí° Intuition (Human-Friendly)

Think of BST as a **sorted structure in disguise**.

If you want:

* Smallest ‚Üí keep going **left**
* Largest ‚Üí keep going **right**

That‚Äôs it. No recursion. No searching. No drama. üòå



# üêå Brute Force Approach

Ignore BST property. Just traverse everything.

### Idea

Do DFS and track min/max.

### Pseudocode

```
min = +‚àû
max = -‚àû
traverse all nodes:
    min = min(min, node.val)
    max = max(max, node.val)
```

### Time Complexity

* **O(n)**

### Why this is bad?

You‚Äôre treating a **Ferrari like a bicycle** üö≤.



# ‚ö° Optimal Approach (Using BST Property)

### For Minimum

Go left until you can‚Äôt.

### For Maximum

Go right until you can‚Äôt.



## Iterative Algorithm

### Find Minimum

```
while node.left exists:
    node = node.left
return node.val
```

### Find Maximum

```
while node.right exists:
    node = node.right
return node.val
```



# ‚úÖ Optimal C++ Code (Iterative)

```cpp
class Solution {
public:
    int findMin(TreeNode* root) {
        if (!root) return -1; // or throw error
        
        while (root->left != nullptr) {
            root = root->left;
        }
        return root->val;
    }

    int findMax(TreeNode* root) {
        if (!root) return -1; // or throw error
        
        while (root->right != nullptr) {
            root = root->right;
        }
        return root->val;
    }
};
```



# üîç Line-by-Line Explanation

```cpp
while (root->left != nullptr)
```

Keep walking left until you hit the wall.

That wall = smallest value in tree.

Same logic for right.



# üîÅ Recursive Version (Alternative)

```cpp
int findMin(TreeNode* root) {
    if (root->left == nullptr)
        return root->val;
    return findMin(root->left);
}

int findMax(TreeNode* root) {
    if (root->right == nullptr)
        return root->val;
    return findMax(root->right);
}
```

Elegant, but iterative is usually preferred in interviews.



# üß™ Test Cases

### Case 1

BST: `[5,3,7,2,4,6,8]`

Min = 2
Max = 8



### Case 2

BST: `[10]`

Min = 10
Max = 10



### Case 3

BST: `[10,9,8,7]` (left-skewed)

Min = 7
Max = 10



### Case 4 (Edge)

BST: `[]`

Min = undefined
Max = undefined

(Should handle gracefully.)



# ‚è±Ô∏è Complexity Analysis

| Operation | Time     |
| - | -- |
| Find Min  | **O(h)** |
| Find Max  | **O(h)** |

Where `h` = height of tree.

### Best Case (Balanced)

* **O(log n)**

### Worst Case (Skewed)

* **O(n)**

### Space

* Iterative: **O(1)**
* Recursive: **O(h)** stack



# üéØ Why This is Important?

Because this logic is reused in:

| Problem       | Uses Min/Max                  |
| - | -- |
| Delete node   | Inorder successor/predecessor |
| Floor / Ceil  | Extreme tracking              |
| Range queries | Boundaries                    |
| Validate BST  | Bound checks                  |
| Kth smallest  | Inorder logic                 |

This problem is a **gateway drug** to advanced BST mastery üòè



# üß† Common Mistakes

### 1. Using DFS for no reason

O(n) instead of O(log n).

### 2. Forgetting empty tree case

Accessing `root->left` when `root == nullptr`.

### 3. Overthinking it

This is one of those rare DSA problems that is **actually simple**.



# üõ†Ô∏è Variations

### 1. Floor & Ceil

Floor(x): largest value ‚â§ x
Ceil(x): smallest value ‚â• x

These are basically **dynamic min/max searches**.



### 2. Inorder Successor

Minimum in **right subtree**.

Used in delete operation.



### 3. Augmented BST

Store subtree min/max at every node for faster queries.

Used in segment trees and interval trees.



# ü§î FAQs

### Q1: Why leftmost is minimum?

Because all smaller values must be in left subtree. Recursively.



### Q2: What if BST has duplicates?

Depends on rule:

* If duplicates go left ‚Üí min still leftmost
* If go right ‚Üí min still leftmost unique



### Q3: Can this be done in O(1)?

Only if tree stores min/max as fields.

Otherwise **O(h)** is optimal.



### Q4: Why not just store array and sort?

Because BST supports:

* Dynamic inserts
* Deletes
* Range queries

All in log time.


# üèÅ TL;DR

| Task  | How                |
| -- |  |
| Min   | Go left till null  |
| Max   | Go right till null |
| Time  | O(h)               |
| Space | O(1)               |
| Key   | BST property       |

