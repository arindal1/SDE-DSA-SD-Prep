# ğŸŒ³ 98. Validate Binary Search Tree (BST) [Leetcode #[98](https://leetcode.com/problems/validate-binary-search-tree/description/)]

> *â€œNot every binary tree that looks sorted is actually a BST.â€* ğŸ˜
> This problem separates **surface-level understanding** from **deep structural understanding**.

If you truly understand this one, you wonâ€™t ever confuse:

* Local ordering âŒ
* Global ordering âœ…

Letâ€™s break it down beautifully.



# ğŸ“Œ Problem Statement

Given the `root` of a binary tree, determine whether it is a **valid Binary Search Tree (BST)**.

### BST Definition Reminder

For every node:

* All values in the left subtree must be **strictly less**
* All values in the right subtree must be **strictly greater**
* This must hold **recursively for every node**



## ğŸ§ª Example 1

```
    2
   / \
  1   3
```

âœ… Valid BST



## ğŸ§ª Example 2

```
    5
   / \
  1   4
     / \
    3   6
```

âŒ Not a BST

Why?
Because `3` is in the right subtree of `5`, but `3 < 5`.

This violates the **global rule**.



# ğŸ§  Core Insight (The Big Idea)

Most people check:

```cpp
node->left->val < node->val
node->right->val > node->val
```

That is WRONG âŒ

Because BST validity is **not just about parent-child**.
Itâ€™s about **global boundaries**.

Each node must lie within a **valid range**.



# ğŸ’¡ Our Approach (Correct & Optimal)

We use a **range-based validation**.

This is the cleanest and most interview-approved solution.



## âœ… Our Code

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return validate(root, LONG_MIN, LONG_MAX);
    }

    bool validate(TreeNode* node, long minVal, long maxVal) {
        if (!node) return true;

        if (node->val <= minVal || node->val >= maxVal)
            return false;

        return validate(node->left, minVal, node->val) && 
               validate(node->right, node->val, maxVal);
    }
};
```



# ğŸ” Line-by-Line Explanation

### Step 1

```cpp
validate(root, LONG_MIN, LONG_MAX);
```

Initially, root can be anything within full integer range.



### Step 2

```cpp
if (!node) return true;
```

An empty subtree is always valid.



### Step 3 (Critical Check)

```cpp
if (node->val <= minVal || node->val >= maxVal)
    return false;
```

This ensures:

* Node value lies strictly inside allowed range.

Notice:

* Strict `<`
* Strict `>`

Duplicates are NOT allowed in standard BST definition.



### Step 4 (Recursive Boundaries)

```cpp
validate(node->left, minVal, node->val)
```

Left subtree must be:

```
(minVal, node->val)
```



```cpp
validate(node->right, node->val, maxVal)
```

Right subtree must be:

```
(node->val, maxVal)
```

This enforces **global correctness**.



# ğŸ§  Why LONG_MIN and LONG_MAX?

If we used:

```cpp
INT_MIN, INT_MAX
```

We might fail on edge cases:

```
root->val = INT_MIN
```

So using `long` avoids overflow issues.

Smart move ğŸ‘Œ



# ğŸŒ Brute Force Approach (Incorrect Way Many Try)

Check only:

```cpp
if (left < root && right > root)
```

Fails on deep violations.

Time: O(n)
But logically wrong.



# âš¡ Alternative Correct Approach

Use **inorder traversal**.

Because inorder of BST must be **strictly increasing**.

```cpp
long prev = LONG_MIN;

bool inorder(TreeNode* root) {
    if (!root) return true;

    if (!inorder(root->left)) return false;

    if (root->val <= prev) return false;
    prev = root->val;

    return inorder(root->right);
}
```

Also valid.



# â±ï¸ Complexity Analysis

| Metric | Value                |
| - | -- |
| Time   | O(n)                 |
| Space  | O(h) recursion stack |

`h` = height of tree

Balanced â†’ O(log n)
Skewed â†’ O(n)



# ğŸ§ª Test Cases

### Case 1

```
[2,1,3]
```

âœ” True



### Case 2

```
[5,1,4,null,null,3,6]
```

âŒ False



### Case 3

```
[1,1]
```

âŒ False (duplicates not allowed)



### Case 4

```
[]
```

âœ” True




# ğŸ¯ Why This Problem Is Important

This tests whether you understand:

* Recursion depth
* Global constraints
* BST definition
* Bound propagation

Itâ€™s not about coding.
Itâ€™s about understanding.



# ğŸ› ï¸ Variations

1. Allow duplicates (modify inequality rules)
2. Validate BST iteratively
3. Check if tree is balanced + BST
4. Count violations instead of boolean



# ğŸ¤” FAQs

### Q1: Why not just check left < root and right > root?

Because deeper nodes might violate global bounds.



### Q2: Why strict inequality?

Standard BST disallows duplicates.



### Q3: Can this be done iteratively?

Yes, using stack and tracking bounds.



### Q4: Which method is better?

Range-based is more intuitive and robust.



# ğŸ¬ Pop Culture Reference

Validating a BST is like:

> Checking if everyone in Hogwarts stayed in their assigned house ğŸ°
> If a Slytherin sneaks into Gryffindorâ€™s subtree,
> the system collapses ğŸ˜„



# ğŸ TL;DR

| Concept       | Rule            |
| - | - |
| Use range     | (min, max)      |
| Left subtree  | (min, root.val) |
| Right subtree | (root.val, max) |
| Use long      | avoid overflow  |
| Time          | O(n)            |
| Space         | O(h)            |

