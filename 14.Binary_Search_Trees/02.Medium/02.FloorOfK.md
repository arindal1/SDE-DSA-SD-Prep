# üå≥ Find Floor in a Binary Search Tree (BST) [GfG [link](https://www.geeksforgeeks.org/problems/floor-in-bst/1)]

> *‚ÄúFinding the floor in a BST is like asking: what‚Äôs the **best value I can get without crossing the limit?**‚Äù* üòå

This problem is the **mirror twin of Ceil** and is extremely important for:

* range queries
* scheduling systems
* recommendation engines
* database indexing
* and of course‚Ä¶ interviews üòè

If you understand **Ceil + Floor**, you‚Äôve basically mastered **ordered searching in BSTs**.



# üìå Problem Statement

You are given the **root of a Binary Search Tree (BST)** and an integer `x`.

Your task is to **find the floor of `x` in the BST**.

### Definition of Floor

The **floor of `x`** is:

> the **largest value in the BST that is less than or equal to `x`**

If no such value exists, return **-1**.



## Example

BST:

```
        10
       /  \
      5    15
     / \     \
    2   7     20
```

| x  | Floor |
| -- | -- |
| 6  | 5     |
| 7  | 7     |
| 1  | -1    |
| 17 | 15    |



# üß† Key BST Insight

Because BST is sorted:

* If `x < node.val` ‚Üí floor must be in **left subtree**
* If `x > node.val` ‚Üí node could be a **candidate**, but maybe a **better one exists on the right**

So we walk the tree **strategically**, not randomly.



# üí° Intuition (Real Life Analogy)

Imagine you‚Äôre shopping with a budget of ‚Çπ1000 üí∏.

You ask:

> ‚ÄúWhat‚Äôs the **most expensive item I can buy without exceeding ‚Çπ1000**?‚Äù

You don‚Äôt want:

* something more expensive ‚ùå
* something too cheap if better exists ‚ùå

You want the **best possible valid option**.
That‚Äôs exactly what **floor** means.



# üêå Brute Force Approach

Ignore BST property.

### Idea

* Traverse all nodes
* Keep track of max value ‚â§ x

### Pseudocode

```
floor = -1
for every node:
    if node.val <= x:
        floor = max(floor, node.val)
```

### Time Complexity

* **O(n)**

### Why it‚Äôs bad?

You‚Äôre ignoring the tree‚Äôs superpower ü•≤



# ‚ö° Optimal Approach (Using BST Property)

This is your given code.
And yes, it is **already optimal and clean**.



## ‚úÖ CPP Code

```cpp
class Solution {
  public:
    int floor(Node* root, int x) {
        if (!root)
            return -1;

        int floor = -1;
        while (root) {
            if (root->data == x) {
                floor = root->data;
                return floor;
            }
    
            if (x < root->data) {
                root = root->left;
            } else {
                floor = root->data;
                root = root->right;
            }
        }
    
        return floor;
    }
};
```



# üîç Line-by-Line Explanation

### Step 1

```cpp
int floor = -1;
```

We assume floor does not exist initially.



### Step 2

```cpp
while (root)
```

Traverse until you fall off the tree.



### Step 3 (Exact match)

```cpp
if (root->data == x)
```

Perfect answer. This is the **best possible floor**.



### Step 4 (x is smaller)

```cpp
if (x < root->data)
    root = root->left;
```

Current node is **too big**.
Discard it and move left.



### Step 5 (x is bigger)

```cpp
else {
    floor = root->data;
    root = root->right;
}
```

This node is a **valid candidate**.
But maybe there‚Äôs a **bigger valid one on the right**.

So:

* store it
* try to improve it



# üß™ Test Cases

### Case 1

BST: `[10,5,15,2,7,20]`, x = 6
Answer = **5**



### Case 2

BST: `[10,5,15,2,7,20]`, x = 7
Answer = **7**



### Case 3

BST: `[10,5,15,2,7,20]`, x = 1
Answer = **-1**



### Case 4

BST: `[10]`, x = 100
Answer = **10**



### Case 5 (Empty)

BST: `[]`, x = 10
Answer = **-1**



# ‚è±Ô∏è Complexity Analysis

| Case         | Time         |
| - | - |
| Balanced BST | **O(log n)** |
| Skewed BST   | **O(n)**     |

### Space

* Iterative: **O(1)**
* Recursive: **O(h)**



# üéØ Why This Problem is Important

Floor logic is used in:

| Feature                 | Usage                  |
| -- | - |
| Scheduling              | nearest available slot |
| Databases               | range queries          |
| Recommendation systems  | closest lower match    |
| Competitive programming | tons of problems       |
| System design           | rate limiting          |

This is **not just a DSA problem**.
This is a **real-world concept**.



# üõ†Ô∏è Mirror Problem: Find Ceil

Ceil = smallest value ‚â• x
Floor = largest value ‚â§ x

They are literally **mirror algorithms**.

| Floor                         | Ceil                          |
| -- | -- |
| go left if x < node           | go right if x > node          |
| store candidate when x > node | store candidate when x < node |



# üß† Common Mistakes

### 1. Not storing candidate

Forgetting `floor = root->data`.

### 2. Using DFS

Turning O(log n) into O(n) for no reason.

### 3. Confusing with closest

Floor is **not nearest**. It‚Äôs **just ‚â§ x**.

### 4. Returning 0 instead of -1

0 might be a valid value.



# ü§î FAQs

### Q1: What if BST has duplicates?

If `x` exists, return that exact value.



### Q2: Can floor ever be greater than x?

Never. That‚Äôs logically impossible.



### Q3: Can this be solved recursively?

Yes, but iterative is simpler and safer.



### Q4: What if all values are greater than x?

Return **-1**.



# üèÅ TL;DR

| Concept     | Logic                     |
| -- | - |
| Floor       | largest ‚â§ x               |
| If x < node | go left                   |
| If x > node | store candidate, go right |
| Time        | O(h)                      |
| Space       | O(1)                      |
| Key idea    | BST ordering              |

 