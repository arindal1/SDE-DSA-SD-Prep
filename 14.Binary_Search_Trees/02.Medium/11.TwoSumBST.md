# ðŸŒ³ Two Sum IV â€“ Input is a BST [Leetcode #[653](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/)]

## ðŸ”¥ Using BST Iterator + Two Pointers (Optimal Approach)

> *â€œWhat if we could treat a BST like a sorted arrayâ€¦ without actually building one?â€* ðŸ˜
> Thatâ€™s exactly what this solution does.

This is one of the most elegant BST problems because it combines:

* BST property
* Stack-based iteration
* Two-pointer technique
* Space optimization

Letâ€™s break it down beautifully and deeply.



# ðŸ“Œ Problem Statement

Given:

* `root` of a **Binary Search Tree**
* integer `k`

Return `true` if there exist **two distinct nodes** such that:

```
node1->val + node2->val == k
```

Otherwise return `false`.



## ðŸ§ª Example

BST:

```
        5
       / \
      3   6
     / \   \
    2   4   7
```

Input:

```
k = 9
```

Output:

```
true
```

Because `2 + 7 = 9`.



# ðŸ§  Core Insight

BST inorder traversal gives:

```
Sorted ascending order
```

So this becomes:

> Two Sum in a sorted array.

But instead of storing all values in an array (which costs O(n) space),
we simulate two pointers directly on the BST.



# ðŸ’¡ Strategy Overview

We use:

* One iterator from smallest â†’ largest
* One iterator from largest â†’ smallest

Then apply:

```
Two pointer technique
```



# ðŸ§© The BSTIterator Class

This is the secret sauce ðŸ§‚

It simulates:

* Normal inorder traversal
* Reverse inorder traversal

Using a stack.



## âœ… Key Components

### ðŸ”¹ Stack

```cpp
stack<TreeNode*> myStack;
```

Simulates recursion.



### ðŸ”¹ Direction Flag

```cpp
bool reverse;
```

If:

* `false` â†’ ascending iterator
* `true` â†’ descending iterator



# ðŸ” How pushAll() Works

```cpp
void pushAll(TreeNode* node) {
    while (node != nullptr) {
        myStack.push(node);
        if (reverse)
            node = node->right;
        else
            node = node->left;
    }
}
```

### If reverse == false:

Push left chain â†’ smallest elements first.

### If reverse == true:

Push right chain â†’ largest elements first.



# ðŸ” How next() Works

```cpp
int next() {
    TreeNode* tmpNode = myStack.top();
    myStack.pop();

    if (!reverse)
        pushAll(tmpNode->right);
    else
        pushAll(tmpNode->left);

    return tmpNode->val;
}
```

It:

1. Pops top element
2. Moves to next valid subtree
3. Maintains sorted traversal



# ðŸš€ Main Logic (Two Pointer Simulation)

```cpp
BSTIterator l(root, false); // smallest â†’ largest
BSTIterator r(root, true);  // largest â†’ smallest
```

Then:

```cpp
int i = l.next();
int j = r.next();
```

Now we simulate:

```
while (i < j)
```

If:

* `i + j == k` â†’ return true
* `i + j < k` â†’ move left iterator forward
* `i + j > k` â†’ move right iterator backward

Classic two-pointer logic.



# ðŸ§  Why This Works

Because BST iterators behave exactly like:

```
Sorted array iterators
```

But without building the array.



# â±ï¸ Complexity Analysis

Let `n` = number of nodes.

### Time Complexity

| Operation      | Complexity     |
| -- | -- |
| Each next()    | Amortized O(1) |
| Entire process | O(n)           |

Worst case we visit each node once.



### Space Complexity

| Component | Space |
| - | -- |
| Stack     | O(h)  |
| Total     | O(h)  |

`h` = height of tree

Balanced â†’ O(log n)
Skewed â†’ O(n)

Better than storing full array (O(n)).



# ðŸŒ Brute Force Approach

1. Do inorder traversal â†’ store in array
2. Use two-pointer on array

Time: O(n)
Space: O(n)

Your approach improves space to O(h).



# ðŸ§ª Example Walkthrough

BST:

```
[2,3,4,5,6,7]
```

k = 9

* i = 2
* j = 7

2 + 7 = 9 âœ”

Immediate success.




# ðŸ› ï¸ Alternative Approaches

### ðŸ”¹ HashSet Method

```cpp
Traverse tree
If (k - node->val) exists â†’ true
Else insert node->val
```

Time: O(n)
Space: O(n)

Simpler but less optimal space.



### ðŸ”¹ Array + Two Pointer

Clear but uses O(n) space.



# ðŸŽ¯ Why This Problem Is Important

Tests:

* BST traversal understanding
* Stack simulation of recursion
* Two pointer technique
* Space optimization thinking

This is a **very strong interview-level solution**.



# ðŸ¤” FAQs

### Q1: Why check `while (i < j)`?

To ensure we donâ€™t use same node twice.



### Q2: What if duplicates exist?

Standard BST usually assumes unique values.



### Q3: Why not use recursion?

Stack-based approach avoids deep recursion issues.



### Q4: Is this optimal?

Yes. Time O(n), space O(h).



# ðŸ TL;DR

| Concept      | Trick                 |
| - | - |
| BST          | Gives sorted order    |
| Iterator     | Simulates inorder     |
| Two pointers | Check sum efficiently |
| Time         | O(n)                  |
| Space        | O(h)                  |
| Core power   | No extra array needed |

