# ğŸŒ³ Lowest Common Ancestor in a Binary Search Tree (BST) [Leetcode #[235](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)]

> *â€œIn a BST, ancestors are not found by exploring everywhereâ€¦
> they reveal themselves through ordering.â€* ğŸ˜Œ

This is one of the most elegant BST problems.
If you understand this deeply, youâ€™ll realize:

ğŸ‘‰ **You donâ€™t need recursion.**
ğŸ‘‰ **You donâ€™t need parent pointers.**
ğŸ‘‰ **You donâ€™t need path storage.**

Just BST property + logic.



# ğŸ“Œ Problem Statement

Given:

* `root` of a **Binary Search Tree**
* two nodes `p` and `q`

Return their **Lowest Common Ancestor (LCA)**.



## ğŸ“– What is LCA?

The **Lowest Common Ancestor** of two nodes `p` and `q` is:

> The lowest node in the tree that has both `p` and `q` as descendants
> (we allow a node to be a descendant of itself)



## ğŸ§ª Example

BST:

```
        6
       / \
      2   8
     / \ / \
    0  4 7  9
      / \
     3   5
```

* LCA(2, 8) = 6
* LCA(2, 4) = 2
* LCA(3, 5) = 4



# ğŸ§  Why BST Makes This Easy

In a **normal binary tree**, youâ€™d:

* Find paths to both nodes
* Compare paths

Time = O(n)

But in a **BST**, values are ordered.

So we use comparison instead of brute traversal.



# ğŸ’¡ Core Insight

At any node `cur`:

### Case 1: Both nodes are smaller

```
p < cur AND q < cur
```

Go left.



### Case 2: Both nodes are larger

```
p > cur AND q > cur
```

Go right.



### Case 3: Split happens

One is smaller and one is larger
OR one equals current

ğŸ‘‰ That node is the **LCA**



# âœ… Our Code (Iterative & Optimal)

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root)
            return root;

        TreeNode* cur = root;

        while (cur) {
            if (p->val < cur->val && q->val < cur->val)
                cur = cur->left;
            else if (p->val > cur->val && q->val > cur->val)
                cur = cur->right;
            else
                return cur;
        }
        return cur;
    }
};
```



# ğŸ” Line-by-Line Explanation

### Step 1

```cpp
TreeNode* cur = root;
```

Start at the root.



### Step 2

```cpp
if (p->val < cur->val && q->val < cur->val)
```

Both nodes lie in left subtree.

So move left.



### Step 3

```cpp
else if (p->val > cur->val && q->val > cur->val)
```

Both lie in right subtree.

Move right.



### Step 4

```cpp
else return cur;
```

This means:

* They split here
  OR
* One equals current

So this is the LCA ğŸ¯



# ğŸ§  Why This Works

Because in BST:

Left subtree contains only smaller values
Right subtree contains only larger values

If one node is on left and the other on right,
the current node is their first common meeting point.



# ğŸŒ Brute Force Approach (For Comparison)

In a normal binary tree:

1. Find path from root â†’ p
2. Find path from root â†’ q
3. Compare paths

Time = O(n)
Space = O(n)

BST reduces it to:

Time = O(h)
Space = O(1)

Thatâ€™s the magic âœ¨



# â±ï¸ Complexity Analysis

| Metric | Value |
| - | -- |
| Time   | O(h)  |
| Space  | O(1)  |

Where `h` = height of tree

Balanced â†’ O(log n)
Skewed â†’ O(n)



# ğŸ” Recursive Version (Cleaner but Uses Stack)

```cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root) return nullptr;

    if (p->val < root->val && q->val < root->val)
        return lowestCommonAncestor(root->left, p, q);

    if (p->val > root->val && q->val > root->val)
        return lowestCommonAncestor(root->right, p, q);

    return root;
}
```

Same logic, different style.



# ğŸ§ª Test Cases

### Case 1

```
root = [6,2,8,0,4,7,9,null,null,3,5]
p = 2, q = 8
```

Output: 6



### Case 2

```
p = 2, q = 4
```

Output: 2



### Case 3

```
p = 3, q = 5
```

Output: 4



### Case 4 (One node is ancestor)

```
p = 6, q = 8
```

Output: 6

Correct because node can be ancestor of itself.




# ğŸ¯ Why This Problem Is Important

It tests:

* BST understanding
* Logical splitting
* Tree traversal efficiency
* Problem simplification

This is a **classic interview favorite**.



# ğŸ› ï¸ Variation: General Binary Tree LCA

If itâ€™s not BST, you must use:

```
if root == p or root == q â†’ return root
search left and right
if both non-null â†’ return root
```

Time = O(n)



# ğŸ¤” FAQs

### Q1: What if p or q doesnâ€™t exist?

LeetCode guarantees they exist.



### Q2: Why return cur when split happens?

Because thatâ€™s the first node where paths diverge.



### Q3: Can LCA be one of the nodes?

Yes. If one node is ancestor of the other.



### Q4: Does this work for duplicate values?

No. BST usually assumes unique values.



# ğŸ TL;DR

| Situation    | Action           |
| - | - |
| Both smaller | Go left          |
| Both larger  | Go right         |
| Split        | Current is LCA   |
| Time         | O(h)             |
| Space        | O(1)             |
| Core idea    | Use BST ordering |

