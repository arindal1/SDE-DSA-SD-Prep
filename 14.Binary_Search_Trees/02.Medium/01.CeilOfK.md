# ðŸŒ³ Find Ceil in a Binary Search Tree (BST) [GfG [link](https://www.geeksforgeeks.org/problems/implementing-ceil-in-bst/1)]

> *â€œFinding the ceil in a BST is like asking: whatâ€™s the **next bigger or equal number** I can get without overshooting?â€* ðŸŽ¯

This is a **classic BST problem** that quietly powers:

* range queries
* floor/ceil systems
* scheduling systems
* autocomplete logic
* database indexes

Once you understand this, youâ€™ve basically unlocked **ordered searching** in trees.



# ðŸ“Œ Problem Statement

You are given the **root of a Binary Search Tree (BST)** and an integer `k`.

Your task is to **find the ceil of `k` in the BST**.

### Definition of Ceil

The **ceil of `k`** is:

> the **smallest value in the BST that is greater than or equal to `k`**.

If no such value exists, return **-1**.



## Example

BST:

```
        8
       / \
      4   12
     / \    \
    2   6    14
```

| k  | Ceil |
| -- | - |
| 5  | 6    |
| 7  | 8    |
| 8  | 8    |
| 15 | -1   |



# ðŸ§  Key Insight (BST Superpower)

Because BST is sorted:

* If `k > node.val` â†’ ceil must be in **right subtree**
* If `k < node.val` â†’ node could be a ceil, but maybe thereâ€™s a **smaller one on left**

So we **walk the tree intelligently**, not blindly.



# ðŸ’¡ Intuition (Real Life Analogy)

Imagine youâ€™re booking a train ðŸš†.

You ask:

> â€œWhatâ€™s the earliest train **at or after 5 PM**?â€

You donâ€™t check all trains.
You just move forward in time and pick the **first valid one**.

Thatâ€™s exactly what ceil does.



# ðŸŒ Brute Force Approach

Ignore BST property. Traverse all nodes.

### Idea

* Do inorder traversal
* Collect all values
* Find smallest â‰¥ k

### Time Complexity

* **O(n)**

### Why itâ€™s bad?

Youâ€™re turning a smart tree into a dumb list ðŸ« 



# âš¡ Optimal Approach (Using BST Property)

This is your given code (which is already optimal and clean).



## âœ… CPP Code

```cpp
int findCeil(Node* root, int k) {
    if (!root)
        return -1;

    int ceil = -1;
    while (root) {
        if (root->val == k) {
            ceil = root->val;
            return ceil;
        }

        if (k > root->val) {
            root = root->right;
        } else {
            ceil = root->val;
            root = root->left;
        }
    }

    return ceil;
}
```



# ðŸ” Line-by-Line Explanation

### Step 1

```cpp
int ceil = -1;
```

We assume ceil doesnâ€™t exist initially.



### Step 2

```cpp
while (root)
```

Walk down the tree until you fall off.



### Step 3 (Exact match)

```cpp
if (root->val == k)
```

Perfect. This is the best possible ceil.



### Step 4 (k is bigger)

```cpp
if (k > root->val)
    root = root->right;
```

Current node is too small. Ignore it completely.



### Step 5 (k is smaller)

```cpp
else {
    ceil = root->val;
    root = root->left;
}
```

This node is a **candidate**.
But maybe thereâ€™s a **smaller valid one on the left**.

So we:

* store it
* try to improve it



# ðŸ§ª Test Cases

### Case 1

BST: `[8,4,12,2,6,14]`, k = 5
Answer = **6**



### Case 2

BST: `[8,4,12,2,6,14]`, k = 8
Answer = **8**



### Case 3

BST: `[8,4,12,2,6,14]`, k = 15
Answer = **-1**



### Case 4

BST: `[5]`, k = 1
Answer = **5**



### Case 5 (Empty)

BST: `[]`, k = 10
Answer = **-1**



# â±ï¸ Complexity Analysis

| Case         | Time         |
| - | - |
| Balanced BST | **O(log n)** |
| Skewed BST   | **O(n)**     |

### Space

* Iterative: **O(1)**
* Recursive: **O(h)**



# ðŸŽ¯ Why This is Powerful

This logic is used in:

* Floor & Ceil queries
* Range searching
* Auto-complete
* Scheduling systems
* Database indexing
* Interview problems ðŸ˜„



# ðŸ› ï¸ Related Variation: Find Floor

Floor = **largest value â‰¤ k**

Just flip directions:

```cpp
int findFloor(Node* root, int k) {
    int floor = -1;
    while (root) {
        if (root->val == k)
            return root->val;

        if (k < root->val)
            root = root->left;
        else {
            floor = root->val;
            root = root->right;
        }
    }
    return floor;
}
```



# ðŸ§  Common Mistakes

### 1. Forgetting to store candidate

You must store `ceil = root->val` before going left.

### 2. Using DFS

Turning O(log n) into O(n) for no reason.

### 3. Returning 0 for empty tree

Wrong in most problems.

### 4. Not understanding what ceil means

Ceil is **not closest**. It is **just â‰¥ k**.



# ðŸ¤” FAQs

### Q1: What if BST has duplicates?

If duplicates exist, and k equals one of them, return that value.



### Q2: Can ceil be smaller than k?

Never. That would be **floor**, not ceil.



### Q3: Can this be done recursively?

Yes, but iterative is cleaner and stack-safe.



### Q4: Is this similar to binary search?

Yes. Itâ€™s literally **binary search on a tree**.


# ðŸ TL;DR

| Concept     | Logic                    |
| -- | - |
| Ceil        | smallest â‰¥ k             |
| If k > node | go right                 |
| If k < node | store candidate, go left |
| Time        | O(h)                     |
| Space       | O(1)                     |
| Core idea   | BST ordering             |

