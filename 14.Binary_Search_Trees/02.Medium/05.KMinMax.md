# ğŸŒ³ Find Kth Smallest & Kth Largest in a BST [Leetcode #[230](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)]

> *â€œIn a BST, order is already built-in.
> You just need to walk it in the right direction.â€* ğŸ˜Œ

This problem cleverly finds **both the kth smallest and kth largest** element using inorder traversal logic.

Letâ€™s break it down beautifully and deeply.



# ğŸ“Œ Problem Statement (Based on Your Code)

Given:

* `root` of a **Binary Search Tree**
* integer `k`

Return:

* `kth smallest`
* `kth largest`

As:

```cpp
vector<int> {kth_smallest, kth_largest}
```



# ğŸ§  Why This Works (Core Insight)

BST property guarantees:

### ğŸ”¹ Inorder Traversal (Left â†’ Root â†’ Right)

Produces elements in **sorted ascending order**

### ğŸ”¹ Reverse Inorder (Right â†’ Root â†’ Left)

Produces elements in **sorted descending order**

Thatâ€™s the entire trick.

No sorting needed.
No extra arrays required.



# ğŸ” Understanding Our Code

## Main Function

```cpp
    vector<int> kthSmallest(TreeNode* root, int k) {
        if (!root || k <= 0)
            return {-1, -1};
        int res1 = -1, res2 = -1;
        int k1 = k, k2 = k;

        kmin(root, k1, res1);
        kmax(root, k2, res2);
        return {res1, res2};
    }
```

We:

* Find kth smallest via `kmin`
* Find kth largest via `kmax`
* Return both

Smart reuse of logic ğŸ‘Œ



# ğŸ§© How kmin Works (Kth Smallest)

```cpp
void kmin(TreeNode* root, int& k, int& res)
```

This is **inorder traversal**.

### Step-by-step

```cpp
kmin(root->left, k, res);
```

Go to smallest elements first.



```cpp
if (--k == 0)
```

Every time we visit a node:

* decrement `k`
* if it reaches 0 â†’ that node is the kth smallest



```cpp
kmin(root->right, k, res);
```

Continue traversal if not found.



# ğŸ§© How kmax Works (Kth Largest)

Same logic, but reversed.

```cpp
kmax(root->right, k, res);
```

Start from largest elements.

Then visit root, then left.



# ğŸ“Š Visual Example

BST:

```
        5
       / \
      3   7
     / \   \
    2   4   8
```

Sorted order:

```
2 3 4 5 7 8
```

If k = 2:

* kth smallest = 3
* kth largest = 7



# ğŸŒ Brute Force Approach

1. Store inorder traversal in array
2. Return:

   * arr[k-1]
   * arr[n-k]

Time: **O(n)**
Space: **O(n)**

Your approach is better because:

* No extra array
* Stops early
* Uses only recursion stack



# âš¡ Time & Space Complexity

| Metric | Value                |
| - | -- |
| Time   | O(h + k) worst O(n)  |
| Space  | O(h) recursion stack |

`h` = height of tree

Balanced â†’ O(log n)



# ğŸ§  Important Details

### Why pass `k` by reference?

```cpp
int& k
```

Because:

* We want to decrement same counter across recursive calls
* Otherwise each call gets its own copy



### Why check `k == 0` early?

To stop recursion once answer is found.

This is an optimization.



## âœ… CPP Code

```cpp
class Solution {
public:
    vector<int> kthSmallest(TreeNode* root, int k) {
        if (!root || k <= 0) return {-1, -1};

        int res1 = -1, res2 = -1;
        int k1 = k, k2 = k;

        kmin(root, k1, res1);
        kmax(root, k2, res2);

        return {res1, res2};
    }

private:
    void kmin(TreeNode* root, int& k, int& res) {
        if (!root || k == 0) return;

        kmin(root->left, k, res);

        if (--k == 0) {
            res = root->val;
            return;
        }

        kmin(root->right, k, res);
    }

    void kmax(TreeNode* root, int& k, int& res) {
        if (!root || k == 0) return;

        kmax(root->right, k, res);

        if (--k == 0) {
            res = root->val;
            return;
        }

        kmax(root->left, k, res);
    }
};
```



# ğŸ› ï¸ Alternative: Iterative Version (Stack-Based)

If interviewer says:
ğŸ‘‰ *â€œNo recursionâ€*

You can use stack for inorder traversal.

Time same.
Space same.

```CPP
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
    stack<TreeNode*> st;
    
    while (true) {
        while (root) {
            st.push(root);
            root = root->left;
        }

        root = st.top();
        st.pop();

        if (--k == 0)
            return root->val;

        root = root->right;
    }
}
};
```


# ğŸ”¥ Interview Insight

This problem tests:

* BST property understanding
* Traversal order
* Recursion control
* Early stopping

Itâ€™s deceptively simple but conceptually powerful.




# ğŸ TL;DR

| Concept      | Trick                 |
| - | - |
| Kth Smallest | Inorder traversal     |
| Kth Largest  | Reverse inorder       |
| Stop early   | When k == 0           |
| Time         | O(h + k)              |
| Space        | O(h)                  |
| Core idea    | BST is already sorted |

