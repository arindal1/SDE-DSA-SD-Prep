# ğŸŒ³ 450. Delete Node in a Binary Search Tree (BST) [Leetcode #[450](https://leetcode.com/problems/delete-node-in-a-bst/)]

> *â€œDeletion in a BST is where things stop being cute and start being interesting.â€* ğŸ˜„
> This problem is the **final boss** of basic BST operations.

If you can confidently solve **delete**, you officially understand BSTs end-to-end. ğŸ†



## ğŸ“Œ Problem Statement

You are given:

* the **root of a Binary Search Tree (BST)**
* an integer `key`

Your task is to **delete the node with value = `key`** (if it exists) and return the **updated root**.

### BST Reminder

For every node:

* Left subtree â†’ values `< node.val`
* Right subtree â†’ values `> node.val`



## ğŸ§ª Examples

### Example 1

```
Input:
root = [5,3,6,2,4,null,7]
key = 3
```

Valid Output:

```
[5,4,6,2,null,null,7]
```

Or:

```
[5,2,6,null,4,null,7]
```

âœ… Multiple answers are valid as long as BST property holds.



### Example 2

```
Input:
root = [5,3,6,2,4,null,7]
key = 0
```

Output:

```
[5,3,6,2,4,null,7]
```



### Example 3

```
Input:
root = []
key = 0
```

Output:

```
[]
```



## ğŸ§  Key Insight (The Heart of the Problem)

Deletion in a BST has **3 distinct cases**:

### ğŸ”¹ Case 1: Node is a Leaf (0 children)

Just delete it. Easy. ğŸª¶



### ğŸ”¹ Case 2: Node has 1 Child

Replace the node with its child.



### ğŸ”¹ Case 3: Node has 2 Children (ğŸ”¥ tricky part)

You must:

* Find the **inorder successor** (smallest in right subtree)
  **OR**
* Find the **inorder predecessor** (largest in left subtree)

Then:

1. Copy its value into the current node
2. Delete that successor/predecessor recursively



## ğŸ’¡ Intuition

Think of deleting a manager from a company org chart ğŸ¢:

* No subordinates â†’ just remove
* One subordinate â†’ promote them
* Two subordinates â†’ find the *next best replacement* and reshuffle

BST deletion works the same way.



## ğŸŒ Brute Force Approach

### Idea

* Convert BST to sorted array
* Remove key
* Rebuild BST

### Complexity

* Time: **O(n)**
* Space: **O(n)**

### Why this is bad?

You destroyed the BST structure and rebuilt it like a barbarian ğŸ˜



## âš¡ Optimal Approach [Recursive]

Use BST property to:

* Search for the node
* Delete in **O(height)** time

Which is:

* **O(log n)** for balanced BST
* **O(n)** for skewed BST



# ğŸ§© Algorithm (Step-by-Step)

```
deleteNode(root, key):
    if root == null:
        return null

    if key < root.val:
        root.left = deleteNode(root.left, key)

    else if key > root.val:
        root.right = deleteNode(root.right, key)

    else:
        // node found
        if root has no left child:
            return root.right
        if root has no right child:
            return root.left

        // node has 2 children
        successor = min(root.right)
        root.val = successor.val
        root.right = deleteNode(root.right, successor.val)

    return root
```



## âœ… Full Working Code

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (!root) return nullptr;

        if (key < root->val) {
            root->left = deleteNode(root->left, key);
        } 
        else if (key > root->val) {
            root->right = deleteNode(root->right, key);
        } 
        else {
            // Node found

            // Case 1 & 2: 0 or 1 child
            if (!root->left)
                return root->right;
            if (!root->right)
                return root->left;

            // Case 3: 2 children
            TreeNode* successor = findMin(root->right);
            root->val = successor->val;
            root->right = deleteNode(root->right, successor->val);
        }

        return root;
    }

private:
    TreeNode* findMin(TreeNode* node) {
        while (node->left)
            node = node->left;
        return node;
    }
};
```



## ğŸ” Line-by-Line Explanation (Important Parts)

### ğŸ”¹ Searching for the node

```cpp
if (key < root->val)
    root->left = deleteNode(root->left, key);
```

BST search logic. Same as search/insert.



### ğŸ”¹ Node found

```cpp
else {
```

Now the fun begins ğŸ˜„



### ğŸ”¹ No left child

```cpp
if (!root->left)
    return root->right;
```

Replace node with its right child.



### ğŸ”¹ No right child

```cpp
if (!root->right)
    return root->left;
```



### ğŸ”¹ Two children (core logic)

```cpp
TreeNode* successor = findMin(root->right);
root->val = successor->val;
root->right = deleteNode(root->right, successor->val);
```

We:

1. Find inorder successor
2. Copy its value
3. Delete duplicate node

BST property stays intact âœ¨



## ğŸ§ª Test Cases

### Case 1

BST: `[5,3,6,2,4,null,7]`, key = 3
Output: `[5,4,6,2,null,null,7]`



### Case 2

BST: `[5,3,6,2,4,null,7]`, key = 0
Output unchanged



### Case 3

BST: `[1]`, key = 1
Output: `[]`



### Case 4

BST: `[10,5,15]`, key = 10
New root becomes successor (15 or 5 depending on approach)



## â±ï¸ Complexity Analysis

| Metric | Value                    |
| - | - |
| Time   | **O(h)**                 |
| Space  | **O(h)** recursion stack |

Where `h` = height of BST


<br>

# ğŸµ Iterative Method


### ğŸ§­ Step-by-Step Strategy (Iterative)

### Step 1: Search for the node

Keep:

* `cur` â†’ current node
* `parent` â†’ parent of current node


### Step 2: If node not found

Return original root.


### Step 3: Handle deletion

Split into cases:

* 0 or 1 child â†’ easy reconnect
* 2 children â†’ replace with inorder successor



### ğŸ”¹ Searching Iteratively

```cpp
while (cur && cur->val != key)
```

Classic BST search, but we **track parent**.


### ğŸ”¹ Two Children Case

```cpp
if (cur->left && cur->right)
```

This is the tricky one.

We:

1. Find inorder successor (leftmost of right subtree)
2. Copy its value
3. Delete successor instead (which has â‰¤1 child)

Why this works:

* Successor is guaranteed to preserve BST ordering


### ğŸ”¹ Reconnecting Pointers

```cpp
if (parent->left == cur)
    parent->left = child;
else
    parent->right = child;
```

This is the **heart of iterative deletion**.

Youâ€™re manually doing what recursion does automatically.


## ğŸ§ª Test Cases

### Case 1

```
BST: [5,3,6,2,4,null,7]
key = 3
```

âœ” Output valid BST


### Case 2

```
BST: [5,3,6,2,4,null,7]
key = 0
```

âœ” Tree unchanged


### Case 3

```
BST: [1]
key = 1
```

âœ” Output: []


### Case 4 (Delete root with two children)

```
BST: [10,5,15,12,18]
key = 10
```

âœ” Root replaced by successor (12)


## â±ï¸ Complexity Analysis

| Metric | Value    |
| ------ | -------- |
| Time   | **O(h)** |
| Space  | **O(1)** |

`h` = height of BST

No recursion stack. No extra memory. ğŸ’ª


```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        TreeNode* parent = nullptr;
        TreeNode* cur = root;

        // Step 1: Find the node to delete
        while (cur && cur->val != key) {
            parent = cur;
            if (key < cur->val)
                cur = cur->left;
            else
                cur = cur->right;
        }

        // Key not found
        if (!cur) return root;

        // Step 2: If node has two children
        if (cur->left && cur->right) {
            TreeNode* succParent = cur;
            TreeNode* succ = cur->right;

            // Find inorder successor
            while (succ->left) {
                succParent = succ;
                succ = succ->left;
            }

            // Copy successor value
            cur->val = succ->val;

            // Now delete successor instead
            parent = succParent;
            cur = succ;
        }

        // Step 3: Node has at most one child
        TreeNode* child = cur->left ? cur->left : cur->right;

        // Deleting root node
        if (!parent) {
            return child;
        }

        // Reconnect parent
        if (parent->left == cur)
            parent->left = child;
        else
            parent->right = child;

        return root;
    }
};
```



## ğŸ¯ Why This Problem is Important

Deletion combines:

* Search
* Min / Max
* Recursion
* Tree restructuring

Itâ€™s a **perfect interview filter problem** ğŸ˜„

If you nail this:

> You *know* BSTs. Period.



## ğŸ› ï¸ Variations You Should Know

### 1. Use Inorder Predecessor

Largest in left subtree instead of successor.

### 2. Iterative Deletion

Harder but stack-safe.

### 3. Self-balancing Trees

AVL / Red-Black handle rotations after delete.



## ğŸ§  Common Mistakes

### âŒ Forgetting to return updated root

Breaks tree links.

### âŒ Deleting node before replacing value

Leads to dangling pointers.

### âŒ Not handling 2-children case properly

Most common interview fail ğŸ˜¬

### âŒ Thinking output is unique

Multiple valid BSTs can exist.



## ğŸ¤” FAQs

### Q1: Why successor instead of predecessor?

Either works. Successor is more commonly used.



### Q2: Can deletion change root?

Yes. Always return updated root.



### Q3: Why delete successor again?

To avoid duplicate values.



### Q4: What if tree is skewed?

Worst case becomes **O(n)**.




## ğŸ TL;DR

| Case         | Action                 |
| - | - |
| Leaf         | delete                 |
| One child    | replace                |
| Two children | replace with successor |
| Time         | O(height)              |
| Space        | O(height)              |
| Key skill    | BST mastery            |

