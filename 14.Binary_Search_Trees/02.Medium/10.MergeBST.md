# ğŸŒ³ Merge Two Binary Search Trees (BSTs) [GFG [Link](https://www.geeksforgeeks.org/problems/merge-two-bst-s/1)]

> *â€œTwo sorted trees walk into a barâ€¦
> we turn them into one perfectly sorted list.â€* ğŸ˜„

This is a clean and classic problem that combines:

* **BST inorder traversal**
* **Two-pointer merge technique**
* A touch of algorithm elegance âœ¨

Your solution is **correct, readable, and optimal for the array-based approach**. Letâ€™s break it down deeply and clearly.



# ğŸ“Œ Problem Statement

Given two **Binary Search Trees**:

* `root1`
* `root2`

Return a **sorted list** containing all elements from both BSTs.



# ğŸ§  Key Insight

Two important facts:

### 1ï¸âƒ£ Inorder Traversal of BST â†’ Sorted Order

```
Left â†’ Root â†’ Right
```

Produces elements in ascending order.



### 2ï¸âƒ£ Merging Two Sorted Arrays

We can use the classic **two-pointer technique**.

This is the same idea as:

* Merge step in Merge Sort
* Merging sorted lists



# ğŸ’¡ Overall Strategy

### Step 1

Convert both BSTs into sorted arrays using inorder traversal.

### Step 2

Merge the two sorted arrays.

### Step 3

Return the merged result.

Clean. Logical. Efficient.



# âœ… Our Code

```cpp
class Solution {
public:
    void inorderTraversal(Node* root, vector<int>& arr) {
        if (!root) return;
        inorderTraversal(root->left, arr);
        arr.push_back(root->data);
        inorderTraversal(root->right, arr);
    }

    vector<int> mergeArrays(vector<int>& arr1, vector<int>& arr2) {
        vector<int> merged;
        int i = 0, j = 0;
        while (i < arr1.size() && j < arr2.size()) {
            if (arr1[i] < arr2[j]) merged.push_back(arr1[i++]);
            else merged.push_back(arr2[j++]);
        }
        while (i < arr1.size()) merged.push_back(arr1[i++]);
        while (j < arr2.size()) merged.push_back(arr2[j++]);
        return merged;
    }

    vector<int> mergeBSTs(Node* root1, Node* root2) {
        vector<int> arr1, arr2;
        inorderTraversal(root1, arr1);
        inorderTraversal(root2, arr2);
        return mergeArrays(arr1, arr2);
    }
};
```



# ğŸ” Step-by-Step Explanation



## ğŸ”¹ Part 1: Inorder Traversal

```cpp
void inorderTraversal(Node* root, vector<int>& arr)
```

This produces:

```
Sorted elements of BST
```

Because BST property ensures:

```
Left < Root < Right
```



## ğŸ”¹ Part 2: Merge Two Sorted Arrays

```cpp
while (i < arr1.size() && j < arr2.size())
```

We compare:

* If `arr1[i] < arr2[j]` â†’ push `arr1[i]`
* Else â†’ push `arr2[j]`

Exactly like merge sort.



## ğŸ”¹ Final Step

Append remaining elements if one array finishes earlier.



# ğŸ§ª Example

BST 1:

```
    2
   / \
  1   4
```

Inorder â†’ `[1,2,4]`

BST 2:

```
    1
   / \
  0   3
```

Inorder â†’ `[0,1,3]`

Merged â†’ `[0,1,1,2,3,4]`



# â±ï¸ Complexity Analysis

Let:

* n = nodes in BST1
* m = nodes in BST2

### Time

| Step              | Complexity   |
| -- | - |
| Inorder traversal | O(n + m)     |
| Merge             | O(n + m)     |
| Total             | **O(n + m)** |



### Space

| Component       | Space      |
| - | - |
| arr1            | O(n)       |
| arr2            | O(m)       |
| merged          | O(n + m)   |
| recursion stack | O(h1 + h2) |

Total: **O(n + m)**



# ğŸ§  Why This Works

You reduce the problem to:

> Merge two sorted arrays.

And BST already gives sorted output via inorder.

This is very clean and intuitive.



# âš ï¸ Optimization Opportunity

Above approach uses extra space for:

* arr1
* arr2
* merged

We can reduce space using **simultaneous inorder traversal with two stacks**.



# ğŸš€ Advanced Optimization (No Extra Arrays)

Instead of storing arrays:

* Use two stacks
* Simultaneously traverse both trees
* Compare top elements

This reduces space to:

```
O(h1 + h2)
```

But code becomes slightly more complex.



# ğŸ› ï¸ Optimized Stack-Based Version (Advanced)

```cpp
vector<int> mergeBSTs(Node* root1, Node* root2) {
    stack<Node*> s1, s2;
    vector<int> result;

    while (root1 || root2 || !s1.empty() || !s2.empty()) {
        while (root1) {
            s1.push(root1);
            root1 = root1->left;
        }
        while (root2) {
            s2.push(root2);
            root2 = root2->left;
        }

        if (s2.empty() || (!s1.empty() && s1.top()->data <= s2.top()->data)) {
            root1 = s1.top(); s1.pop();
            result.push_back(root1->data);
            root1 = root1->right;
        } else {
            root2 = s2.top(); s2.pop();
            result.push_back(root2->data);
            root2 = root2->right;
        }
    }

    return result;
}
```

Time: O(n + m)
Space: O(h1 + h2)

More optimal. More interview-flex-worthy ğŸ˜„




# ğŸ¯ Why This Problem Is Important

This tests:

* BST understanding
* Inorder traversal mastery
* Two-pointer merging
* Space-time tradeoffs

Itâ€™s common in:

* Interview questions
* Competitive programming
* Tree-based data systems



# ğŸ¤” FAQs

### Q1: What if one tree is empty?

Just return inorder of the other.



### Q2: Does this handle duplicates?

Yes. Merge logic allows duplicates.



### Q3: Can we merge into a BST instead of array?

Yes, but that requires building a balanced BST from sorted array.



### Q4: Which solution is better?

* Simpler: array method
* Optimal: stack-based

Depends on interview expectations.



# ğŸ TL;DR

| Concept         | Trick                           |
| - | - |
| BST inorder     | Sorted order                    |
| Merge           | Two-pointer                     |
| Time            | O(n + m)                        |
| Space           | O(n + m)                        |
| Optimized space | O(h1 + h2)                      |
| Core idea       | Reduce to merging sorted arrays |

