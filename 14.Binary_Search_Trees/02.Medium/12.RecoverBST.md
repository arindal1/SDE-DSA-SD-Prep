# ðŸŒ³ 99. Recover Binary Search Tree [Leetcode #[99](https://leetcode.com/problems/recover-binary-search-tree/description/)]

> *â€œTwo nodes messed up the BST.
> Your job? Restore order without rebuilding the world.â€* ðŸ˜Ž

This is one of the **most elegant and interview-famous BST problems**.
It tests whether you *truly* understand:

* Inorder traversal
* BST ordering property
* Detecting structural violations

Letâ€™s break this down cleanly and deeply.



# ðŸ“Œ Problem Statement

Youâ€™re given the `root` of a **Binary Search Tree (BST)**.

Exactly **two nodes were swapped by mistake**.

Your task:

> Restore the tree **without changing its structure**.

âš ï¸ You can only swap values back.



## ðŸ§ª Example

Original BST:

```
    3
   / \
  1   4
     /
    2
```

Inorder:

```
1 3 2 4
```

Notice the violation: `3 > 2`

Correct BST:

```
    2
   / \
  1   4
     /
    3
```



# ðŸ§  Key Insight

Inorder traversal of a BST should be:

```
Strictly increasing
```

If two nodes are swapped, inorder traversal will show:

* Either **one violation**
* Or **two violations**



## ðŸ” Two Possible Cases

### ðŸ”¹ Case 1: Swapped nodes are NOT adjacent

Example:

```
1 5 3 4 2 6
```

Violations:

* 5 > 3
* 4 > 2

We detect:

* first = 5
* last = 2

Swap them.



### ðŸ”¹ Case 2: Swapped nodes are adjacent

Example:

```
1 3 2 4 5
```

Only one violation:

* 3 > 2

We detect:

* first = 3
* middle = 2

Swap them.



## ðŸ’¡ Strategy

We track:

| Variable | Meaning                         |
| -- | - |
| `prev`   | previous node in inorder        |
| `first`  | first wrong node                |
| `middle` | next node after first violation |
| `last`   | second violation node           |



# âœ… Our Code

```cpp
class Solution {
private:
    TreeNode* first = nullptr;
    TreeNode* middle = nullptr;
    TreeNode* last = nullptr;
    TreeNode* prev = nullptr;

public:
    void recoverTree(TreeNode* root) {
        inorder(root);

        if (first && last)
            swap(first->val, last->val);
        else if (first && middle)
            swap(first->val, middle->val);
    }

    void inorder(TreeNode* root) {
        if (!root) return;

        inorder(root->left);

        if (prev && root->val < prev->val) {
            if (!first) {
                first = prev;
                middle = root;
            } else {
                last = root;
            }
        }

        prev = root;
        inorder(root->right);
    }
};
```

# ðŸ” Step-by-Step Explanation



## ðŸ”¹ Step 1: Initialize tracking pointers

```cpp
first = middle = last = nullptr;
prev = new TreeNode(INT_MIN);
```

`prev` keeps track of previous inorder node.



## ðŸ”¹ Step 2: Perform inorder traversal

```cpp
inorder(root);
```

We detect violations during traversal.



## ðŸ”¹ Step 3: Detect Violation

```cpp
if (root->val < prev->val)
```

If current value is smaller than previous â†’ violation.



### First Violation

```cpp
first = prev;
middle = root;
```



### Second Violation

```cpp
last = root;
```



## ðŸ”¹ Step 4: Fix Tree

After traversal:

### If two violations:

```cpp
swap(first->val, last->val);
```

### If one violation:

```cpp
swap(first->val, middle->val);
```

Tree restored ðŸŽ‰


# â±ï¸ Complexity Analysis

| Metric | Value                |
| - | -- |
| Time   | O(n)                 |
| Space  | O(h) recursion stack |

Balanced â†’ O(log n)
Skewed â†’ O(n)



# ðŸš€ Bonus: Can We Do It in O(1) Space?

Yes. Using **Morris Traversal** (threaded binary tree).


Interview gold â­


To recover a BST in **O(1) space**, you need to avoid recursion (which uses O(h) stack space).
The correct approach is **Morris Inorder Traversal**, which performs inorder traversal without stack or recursion by temporarily modifying the tree.


```cpp
class Solution {
public:
    void recoverTree(TreeNode* root) {
        TreeNode *first = nullptr, *second = nullptr;
        TreeNode *prev = nullptr;
        TreeNode *curr = root;

        while (curr) {
            if (!curr->left) {
                // Visit node
                if (prev && curr->val < prev->val) {
                    if (!first) first = prev;
                    second = curr;
                }
                prev = curr;
                curr = curr->right;
            } 
            else {
                // Find inorder predecessor
                TreeNode* pred = curr->left;
                while (pred->right && pred->right != curr)
                    pred = pred->right;

                if (!pred->right) {
                    // Create temporary link
                    pred->right = curr;
                    curr = curr->left;
                } 
                else {
                    // Remove temporary link
                    pred->right = nullptr;

                    // Visit node
                    if (prev && curr->val < prev->val) {
                        if (!first) first = prev;
                        second = curr;
                    }

                    prev = curr;
                    curr = curr->right;
                }
            }
        }

        if (first && second)
            swap(first->val, second->val);
    }
};
```



### Why This Is O(1) Space

* No recursion
* No explicit stack
* Only a few pointers are used
* Tree structure is restored after traversal



### Time & Space Complexity

* **Time:** O(n)
* **Space:** O(1)


# ðŸŽ¯ Why This Problem Is Important

It tests:

* Deep understanding of inorder traversal
* Pattern recognition in sorted arrays
* Edge case handling
* Pointer tracking

This is a **high-quality interview question**.



# ðŸ¤” FAQs

### Q1: Why inorder traversal?

Because BST inorder gives sorted order.



### Q2: Why only two nodes?

Problem guarantees exactly two nodes swapped.



### Q3: What if more nodes swapped?

This approach assumes exactly two.



### Q4: Why not use vector?

You can, but space becomes O(n).



# ðŸ TL;DR

| Concept          | Trick                       |
| - | - |
| BST inorder      | Should be sorted            |
| Detect violation | root->val < prev->val       |
| Two cases        | Adjacent or non-adjacent    |
| Fix              | Swap correct nodes          |
| Time             | O(n)                       |
| Space            | O(h) / O(1)                        |
| Core power       | Inorder violation detection |

