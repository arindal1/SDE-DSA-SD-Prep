# ğŸŒ³ Construct BST from Preorder Traversal [Leetcode #[1008](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/description/)]

> *â€œPreorder gives you the root first.
> If you understand BST rules, the rest of the tree reveals itself.â€* ğŸ˜Œ

This is one of the **most elegant BST construction problems**.
No sorting.
No splitting arrays manually.
Just smart boundary control.



# ğŸ“Œ Problem Statement

Given the **preorder traversal of a BST**, construct and return the BST.

### Reminder: Preorder Traversal

```
Root â†’ Left â†’ Right
```



## ğŸ§ª Example

Input:

```
preorder = [8,5,1,7,10,12]
```

Constructed BST:

```
        8
       / \
      5   10
     / \     \
    1   7     12
```



# ğŸ§  Core Insight

Two facts:

### 1ï¸âƒ£ Preorder gives root first

The first element is always the root.

### 2ï¸âƒ£ BST property

* Left subtree â†’ values < root
* Right subtree â†’ values > root

So we can build the tree using **value boundaries instead of searching or slicing arrays**.



# ğŸ’¡ The Genius Trick: Upper Bound

Instead of splitting the array manually:

We pass a **bound** that tells us:

> â€œYou can only insert values smaller than this.â€

Thatâ€™s it.

No need to find partition point.
No need to sort.
No need to use extra memory.



# âœ… Our Code

```cpp
class Solution {
public:
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        int i = 0;
        return buildBST(preorder, i, INT_MAX);
    }

    TreeNode* buildBST(vector<int>& arr, int& i, int bound) {
        if (i == arr.size() || arr[i] > bound)
            return nullptr;

        TreeNode* root = new TreeNode(arr[i++]);
        root->left = buildBST(arr, i, root->val);
        root->right = buildBST(arr, i, bound);

        return root;
    }
};
```

This is **optimal and beautiful**.



# ğŸ” Step-by-Step Explanation



## ğŸ”¹ Step 1: Start with entire range

```cpp
return buildBST(preorder, i, INT_MAX);
```

Initially:

* `i = 0`
* bound = infinity

So root can be any value.



## ğŸ”¹ Step 2: Base Condition

```cpp
if (i == arr.size() || arr[i] > bound)
    return nullptr;
```

Stop building when:

* we used all elements
* next value violates BST bound

This enforces correctness.



## ğŸ”¹ Step 3: Create Root

```cpp
TreeNode* root = new TreeNode(arr[i++]);
```

Use current value and move forward.



## ğŸ”¹ Step 4: Build Left Subtree

```cpp
root->left = buildBST(arr, i, root->val);
```

Left subtree must contain values:

```
< root->val
```

So we pass new upper bound = `root->val`.



## ğŸ”¹ Step 5: Build Right Subtree

```cpp
root->right = buildBST(arr, i, bound);
```

Right subtree can go up to previous bound.



# ğŸ“Š How It Works (Dry Run)

Preorder:

```
[8,5,1,7,10,12]
```

### Call stack:

1. root = 8
2. left subtree bound = 8

   * 5 < 8 â†’ valid
   * 1 < 5 â†’ valid
   * 7 > 5 â†’ stop left of 5
   * 7 < 8 â†’ right of 5
3. 10 > 8 â†’ stop left subtree
4. build right subtree

Beautifully controlled by bounds âœ¨



# ğŸ§  Why Pass `i` by Reference?

```cpp
int& i
```

Because:

* We want a **global moving pointer**
* If passed by value, each recursive call would use its own copy

This ensures linear traversal.



# ğŸŒ Brute Force Approach

1. First element = root
2. Find first element greater than root
3. Split array into left and right parts
4. Recursively build

Time = O(nÂ²) worst case

Because for every node, you search for partition.



# âš¡ Optimal Complexity

| Metric | Value                |
| - | -- |
| Time   | O(n)                 |
| Space  | O(h) recursion stack |

Each element processed once.

This is optimal.



# ğŸ¯ Why This Is Powerful

This technique is used in:

* Construct BST from preorder
* Construct BST from postorder
* Validate preorder BST
* Deserialize BST
* Competitive programming tricks

This is a **very advanced recursion pattern**.



# ğŸ› ï¸ Alternative: Using Lower & Upper Bound

Even cleaner conceptual version:

```cpp
TreeNode* build(vector<int>& pre, int& i, int low, int high) {
    if (i >= pre.size() || pre[i] < low || pre[i] > high)
        return nullptr;

    int val = pre[i++];
    TreeNode* root = new TreeNode(val);
    root->left = build(pre, i, low, val);
    root->right = build(pre, i, val, high);
    return root;
}
```

Same idea. Slightly more explicit.



# ğŸ§ª Test Cases

### Case 1

```
[8,5,1,7,10,12]
```

âœ” Valid BST



### Case 2

```
[1,2,3,4,5]
```

Right-skewed tree



### Case 3

```
[5,4,3,2,1]
```

Left-skewed tree



### Case 4

```
[]
```

Returns null



# ğŸ¤” FAQs

### Q1: Why does this work without searching split point?

Because preorder guarantees left subtree comes immediately after root until violation.



### Q2: Can this be done iteratively?

Yes using stack. Slightly more complex.



### Q3: Does this work for duplicates?

Standard BST assumes unique values.



### Q4: What if input is invalid preorder?

This assumes valid BST preorder.



# ğŸ TL;DR

| Concept      | Trick                |
|  | -- |
| Preorder     | Root first           |
| Use bound    | Enforce BST property |
| Move pointer | Once per node        |
| Time         | O(n)                 |
| Space        | O(h)                 |
| Core power   | Boundary recursion   |

