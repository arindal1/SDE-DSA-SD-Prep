# üå≥ 1373. Maximum Sum BST in Binary Tree [Leetcode #[1373](https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/)]

> *‚ÄúNot every subtree is a BST‚Ä¶
> but the ones that are might be hiding the biggest treasure.‚Äù* üí∞üå≥

This is a **next-level BST problem**.
It combines:

* Tree traversal
* BST validation
* Dynamic programming on trees
* Bottom-up reasoning

If you understand this properly, you‚Äôve unlocked **advanced tree DP thinking** üî•



# üìå Problem Statement

Given the `root` of a binary tree (NOT necessarily a BST),

Return:

> The **maximum sum of all keys of any subtree that is also a BST**.

If no BST subtree exists, return `0`.



## üß™ Example

```
        1
       / \
      4   3
     / \   \
    2   4   5
```

Valid BST subtrees:

* `[2]`
* `[4]`
* `[5]`
* `[3,5]`

Maximum sum BST subtree:

```
    3
     \
      5
```

Sum = **8**



# üß† Key Insight

We must evaluate **every subtree** and determine:

1. Is this subtree a BST?
2. If yes, what‚Äôs its sum?
3. Track the maximum sum seen.

This screams:

> Postorder traversal (Bottom-up processing)

Because:

* To know if current node forms BST
* We must know about left and right subtrees first.



# üí° Why Postorder?

We need:

* Left subtree info
* Right subtree info

Before deciding about the current node.

So we process:

```
Left ‚Üí Right ‚Üí Root
```



# üß© The Genius Trick: Return Multiple Values

For each subtree, we need to return:

| Info      | Why                        |
| - | -- |
| min value | To validate parent BST     |
| max value | To validate parent BST     |
| sum       | To compute BST sum         |
| isBST     | To ensure subtree validity |

That‚Äôs why we created:

```cpp
class NodeValue {
public:
    int minNode, maxNode, sum;
    bool isBST;
};
```

This is a classic **Tree DP pattern**.



# ‚úÖ Our Code

```cpp
class NodeValue {
public:
    int minNode, maxNode, sum;
    bool isBST;

    NodeValue(int minN, int maxN, int s, bool bst) 
        : minNode(minN), maxNode(maxN), sum(s), isBST(bst) {}
};

class Solution {
private:
    int maxSum = 0;

    NodeValue helper(TreeNode* root) {
        if (!root) {
            return NodeValue(INT_MAX, INT_MIN, 0, true);
        }

        auto left = helper(root->left);
        auto right = helper(root->right);

        if (left.isBST && right.isBST && 
            root->val > left.maxNode && 
            root->val < right.minNode) {

            int currentSum = root->val + left.sum + right.sum;
            maxSum = max(maxSum, currentSum);
            
            return NodeValue(
                min(root->val, left.minNode), 
                max(root->val, right.maxNode), 
                currentSum, 
                true
            );
        }

        return NodeValue(0, 0, 0, false);
    }

public:
    int maxSumBST(TreeNode* root) {
        maxSum = 0;
        helper(root);
        return maxSum;
    }
};
```

This is **optimal and interview-ready**.



# üîç Step-by-Step Explanation

### üîπ Base Case

```cpp
if (!root)
    return NodeValue(INT_MAX, INT_MIN, 0, true);
```

Why?

For null node:

* It is a valid BST
* min should be very large
* max should be very small
* sum = 0

This ensures comparisons work properly.

Brilliant trick ‚ú®



### üîπ Recursive Calls

```cpp
auto left = helper(root->left);
auto right = helper(root->right);
```

We gather:

* Left subtree info
* Right subtree info



### üîπ BST Check Condition

```cpp
if (left.isBST && right.isBST &&
    root->val > left.maxNode &&
    root->val < right.minNode)
```

This ensures:

* Left subtree valid BST
* Right subtree valid BST
* Current value fits properly between them

Global BST validation üëå



### üîπ If Valid BST

```cpp
int currentSum = root->val + left.sum + right.sum;
```

Update global max.

Return updated:

* minNode
* maxNode
* sum
* isBST = true



### üîπ If Not BST

```cpp
return NodeValue(0, 0, 0, false);
```

Mark subtree invalid.



## üìä Why **INT_MAX** and **INT_MIN**?

For null nodes:

```
minNode = INT_MAX
maxNode = INT_MIN
```

So any real node:

```
root->val > left.maxNode  ‚Üí true
root->val < right.minNode ‚Üí true
```

This makes leaf nodes automatically valid BST.



# ‚è±Ô∏è Complexity Analysis

Let `n` = number of nodes.

| Metric | Value                |
| - | -- |
| Time   | O(n)                 |
| Space  | O(h) recursion stack |

Each node visited once.



# üß† Why This Problem Is Advanced

This combines:

* BST validation
* Subtree aggregation
* Global maximum tracking
* Postorder dynamic programming

This is **Tree DP pattern**, very important for interviews.



# üõ†Ô∏è Edge Cases

### 1Ô∏è‚É£ Entire tree is BST

Return sum of whole tree.

### 2Ô∏è‚É£ No BST larger than single node

Return maximum single node value.

### 3Ô∏è‚É£ Negative values

Your code handles it properly because:

```
maxSum starts at 0
```

If all negative:
Answer remains 0.



# ‚ö†Ô∏è Subtle Interview Discussion

If problem required:

> Return maximum sum even if negative

Then:

```
int maxSum = INT_MIN;
```

Would be needed.



# üèÅ TL;DR

| Concept                | Trick                       |
| - | - |
| Use postorder          | Bottom-up                   |
| Return multiple values | min, max, sum, isBST        |
| Validate BST           | Compare with subtree bounds |
| Track global max       | Update when valid           |
| Time                   | O(n)                        |
| Space                  | O(h)                        |
| Pattern                | Tree DP                     |

