# ðŸŒ³ Largest BST Subtree in a Binary Tree [Leetcode [link](https://leetcode.com/problems/largest-bst-subtree/description/)]

> *â€œThe whole tree may be chaoticâ€¦
> but somewhere inside it, a perfect BST might be hiding.â€* ðŸ”ðŸŒ³

This is a **classic tree DP problem** and very closely related to:

* Maximum Sum BST
* Validate BST
* Diameter of Tree
* Tree-based dynamic programming

If you understand this pattern, youâ€™re operating at **strong tree-interview level** ðŸš€



# ðŸ“Œ Problem Statement

Given the `root` of a binary tree (not necessarily a BST),

Return:

> The **size (number of nodes)** of the largest subtree that is a valid BST.



## ðŸ§ª Example

```
        10
       /  \
      5    15
     / \     \
    1   8     7
```

The largest BST subtree is:

```
      5
     / \
    1   8
```

Size = **3**

The whole tree is NOT a BST because:

```
7 < 15 but lies in right subtree of 10
```



# ðŸ§  Key Insight

We must check every subtree and determine:

1ï¸âƒ£ Is it a BST?
2ï¸âƒ£ If yes â†’ whatâ€™s its size?
3ï¸âƒ£ Track the largest size found.

This requires:

> Postorder traversal (Bottom-up thinking)



# ðŸ’¡ Why Postorder?

To determine whether current node forms a BST,
we must already know:

* Left subtree info
* Right subtree info

So we process:

```
Left â†’ Right â†’ Root
```



# ðŸ§© What Information Do We Return?

For each subtree we need:

| Field   | Why                            |
| - | - |
| minNode | To validate parent             |
| maxNode | To validate parent             |
| maxSize | Size of largest BST in subtree |

This is classic **Tree DP state return pattern**.



# âœ… Our Code

```cpp
class NodeValue {
public:
    int minNode, maxNode, maxSize;

    NodeValue(int minN, int maxN, int size) 
        : minNode(minN), maxNode(maxN), maxSize(size) {}
};

class Solution {
private:
    NodeValue helper(TreeNode* root) {
        if (!root) {
            return NodeValue(INT_MAX, INT_MIN, 0);
        }

        auto left = helper(root->left);
        auto right = helper(root->right);

        if (left.maxNode < root->val && root->val < right.minNode) {
            return NodeValue(
                min(root->val, left.minNode), 
                max(root->val, right.maxNode), 
                left.maxSize + right.maxSize + 1
            );
        }

        return NodeValue(INT_MIN, INT_MAX, max(left.maxSize, right.maxSize));
    }

public:
    int largestBSTSubtree(TreeNode* root) {
        return helper(root).maxSize;
    }
};
```

This is elegant and efficient.



# ðŸ” Step-by-Step Explanation



### ðŸ”¹ Base Case

```cpp
if (!root)
    return NodeValue(INT_MAX, INT_MIN, 0);
```

Why?

* Empty tree is valid BST
* min = very large
* max = very small
* size = 0

This ensures comparisons work naturally.



### ðŸ”¹ Recursively Get Left & Right Info

```cpp
auto left = helper(root->left);
auto right = helper(root->right);
```

Now we know everything about subtrees.



### ðŸ”¹ BST Check Condition

```cpp
if (left.maxNode < root->val && root->val < right.minNode)
```

This ensures:

* All left nodes < root
* All right nodes > root

If true â†’ current subtree is BST.



### ðŸ”¹ If Valid BST

```cpp
return NodeValue(
    min(root->val, left.minNode),
    max(root->val, right.maxNode),
    left.maxSize + right.maxSize + 1
);
```

We:

* Update min and max
* Add sizes
* Return updated BST size



### ðŸ”¹ If NOT BST

```cpp
return NodeValue(INT_MIN, INT_MAX, max(left.maxSize, right.maxSize));
```

Important trick:

We deliberately return:

```
min = INT_MIN
max = INT_MAX
```

This ensures parent will FAIL BST check.

Because:

```
left.maxNode < root->val  â†’ false
root->val < right.minNode â†’ false
```

Smart invalidation trick ðŸ˜Ž



# ðŸ§  Why No isBST Flag?

Unlike maxSumBST, we don't explicitly store `isBST`.

Instead:

* We encode validity using impossible min/max values.

Very clever optimization.



# â±ï¸ Complexity Analysis

Let `n` = number of nodes.

| Metric | Value                |
| - | -- |
| Time   | O(n)                 |
| Space  | O(h) recursion stack |

Each node visited once.

Balanced â†’ O(log n)
Skewed â†’ O(n)



# ðŸ§ª Dry Run Example

```
        10
       /  \
      5    15
     / \     \
    1   8     7
```

Left subtree (5 subtree):

* Valid BST
* Size = 3

Right subtree (15 subtree):

* Not valid BST (7 violates)
* Largest size = 1

Whole tree:

* Not valid BST
* Return max(3,1) = 3

Correct âœ”



# ðŸ› ï¸ Why This Pattern Is Powerful

This is a template for:

* Largest BST
* Maximum sum BST
* Validate subtree conditions
* Tree-based DP

This is a **must-know interview pattern**.




# ðŸŽ¯ Comparison With maxSumBST

| Problem      | Return State          |
| - | - |
| Largest BST  | size                  |
| Max Sum BST  | sum                   |
| Validate BST | boolean               |
| All use      | min + max propagation |

Pattern is same. Only aggregation changes.



# ðŸ¤” FAQs

### Q1: Why INT_MIN / INT_MAX trick works?

Because it forces parent validation to fail.



### Q2: Can we use global variable?

Yes, but returning state is cleaner.



### Q3: What if tree is fully BST?

Returns total node count.



### Q4: What if no BST larger than 1?

Returns 1.



# ðŸ TL;DR

| Concept             | Trick                       |
| - | - |
| Use postorder       | Bottom-up                   |
| Return min/max/size | State propagation           |
| Validate BST        | left.max < root < right.min |
| Invalidate          | Return INT_MIN / INT_MAX    |
| Time                | O(n)                        |
| Space               | O(h)                        |
| Pattern             | Tree DP                     |

