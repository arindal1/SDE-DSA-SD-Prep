# ğŸŒ³ Insert into a Binary Search Tree (BST) [Leetcode #[701](https://leetcode.com/problems/insert-into-a-binary-search-tree/description/)]

> *â€œInserting into a BST is like finding the right parking spot.
> You keep driving left or right until you find an empty space.â€* ğŸš—ğŸ˜„

This is one of the **core operations** of a BST.
If you understand this deeply, you automatically understand:

* Search
* Delete
* Floor / Ceil
* Successor / Predecessor
* Balanced trees (AVL / Red-Black)

Basicallyâ€¦ this is **Level 1 of the BST skill tree** ğŸŒ²ğŸ®



# ğŸ“Œ Problem Statement

You are given the **root of a Binary Search Tree (BST)** and an integer `val`.

Your task is to **insert `val` into the BST** and return the updated root.

### BST Rule Reminder

For every node:

* Left subtree â†’ values **< node.val**
* Right subtree â†’ values **> node.val**
  (or sometimes `>=` depending on convention)



## Example

Initial BST:

```
      4
     / \
    2   7
   / \
  1   3
```

Insert `5`

Result:

```
      4
     / \
    2   7
   / \  /
  1   3 5
```



# ğŸ§  Key Insight

BST is already **sorted by structure**.

So to insert:

* Start at root
* Compare values
* Go left or right
* Stop when you hit a **null**
* Insert there

No rotations.
No reshuffling.
Just follow the rules of the tree ğŸ˜Œ



# ğŸ’¡ Intuition (Human Version)

Imagine a **decision tree game** ğŸ¯:

At each node, the tree asks:

> â€œAre you smaller than me or bigger than me?â€

You answer and move accordingly.

Eventually, you reach a point where:

> â€œThereâ€™s no one here yet.â€
> Congrats, you just found your home ğŸ 



# ğŸŒ Brute Force Approach

Ignore BST property.

### Idea

* Traverse all nodes
* Collect values
* Insert into array
* Sort
* Rebuild BST

### Time Complexity

* **O(n log n)**

### Why this is bad?

You destroyed the whole point of BST ğŸ˜



# âš¡ Optimal Approach (Using BST Property)


### âœ… Code (Iterative)

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (!root)
            return new TreeNode(val);

        TreeNode* cur = root;
        while (true) {
            if (cur->val <= val) {
                if (cur->right != nullptr) {
                    cur = cur->right;
                } else {
                    cur->right = new TreeNode(val);
                    break;
                }
            } else {
                if (cur->left != nullptr) {
                    cur = cur->left;
                } else {
                    cur->left = new TreeNode(val);
                    break;
                }
            }
        }
        return root;
    }
};
```



# ğŸ” Line-by-Line Explanation

### Step 1

```cpp
if (!root)
    return new TreeNode(val);
```

If tree is empty, the new node **becomes the root**.



### Step 2

```cpp
TreeNode* cur = root;
```

We start from the top.



### Step 3 (Main loop)

```cpp
while (true)
```

We keep walking until we insert.



### Step 4 (Go right)

```cpp
if (cur->val <= val)
```

If new value is **greater or equal**, it belongs on the **right side**.



### Step 5 (Right child exists)

```cpp
cur = cur->right;
```

Keep going down.



### Step 6 (Right child empty)

```cpp
cur->right = new TreeNode(val);
break;
```

Found the parking spot ğŸš—
Insert and exit.



### Step 7 (Left side case)

Same logic but mirrored.



### Final

```cpp
return root;
```

Root never changes (unless tree was empty).



# ğŸ§ª Test Cases

### Case 1

BST: `[4,2,7,1,3]`, insert = 5
Output: `[4,2,7,1,3,5]`



### Case 2

BST: `[10]`, insert = 5
Output:

```
   10
  /
 5
```



### Case 3

BST: `[]`, insert = 8
Output: root = 8



### Case 4

BST: `[5,3,8]`, insert = 8
Goes to right of 8 (since `<=` rule)



# â±ï¸ Complexity Analysis

| Case         | Time         |
| - | - |
| Balanced BST | **O(log n)** |
| Skewed BST   | **O(n)**     |

### Space

* Iterative: **O(1)**
* Recursive: **O(h)**



# ğŸ” Recursive Version (Alternative)

Just for learning (interviewers love this too):

```cpp
TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (!root)
        return new TreeNode(val);

    if (val < root->val)
        root->left = insertIntoBST(root->left, val);
    else
        root->right = insertIntoBST(root->right, val);

    return root;
}
```

Cleaner. More elegant. Slightly more stack usage.



# ğŸ¯ Important Design Choice: Duplicates

Our code uses:

```cpp
if (cur->val <= val)
```

So **duplicates go to the right**.

This is a valid convention.

Other options:

* Ignore duplicates
* Store count in node
* Put duplicates on left

Just be **consistent**.



# ğŸ§  Common Mistakes

### 1. Forgetting to return root

Losing the tree reference.

### 2. Infinite loop

Not breaking after insertion.

### 3. Inserting at wrong side

Breaking BST property.

### 4. Overcomplicating

No need for recursion + stack + vectors.



# ğŸ› ï¸ Variations

### 1. Insert with Parent Pointer

Return both node and parent.

### 2. Balanced Insert

Use AVL / Red-Black Tree.

### 3. Insert with Count

Store duplicates in a frequency field.

### 4. Iterative vs Recursive

Both are valid. Iterative is safer.



# ğŸ¤” FAQs

### Q1: Why not rebalance tree?

Normal BST doesnâ€™t rebalance.
Self-balancing trees do.



### Q2: What if tree becomes skewed?

Worst case becomes **O(n)**.
Use AVL or Red-Black tree.



### Q3: Can we insert in O(1)?

No. You must find correct position.



### Q4: Is this similar to search?

Yes. Insert is literally:

> search until null, then attach.



# ğŸ TL;DR

| Concept  | Logic              |
| -- | - |
| Start    | from root          |
| Compare  | val with node      |
| Go left  | if smaller         |
| Go right | if bigger/equal    |
| Stop     | when child is null |
| Insert   | at that spot       |
| Time     | O(h)               |
| Space    | O(1)               |

