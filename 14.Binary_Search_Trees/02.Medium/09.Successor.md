# ğŸŒ³ Inorder Successor in a Binary Search Tree (BST) [GfG [link](https://www.geeksforgeeks.org/problems/predecessor-and-successor/1)]

> *â€œThe inorder successor is simply the next greater element in sorted order.â€*
> Think of it like scrolling to the **next contact alphabetically** in your phone ğŸ“±.

This is a classic BST problem that relies purely on **ordering**, not brute force traversal.



# ğŸ“Œ Problem Statement

Given:

* The `root` of a **Binary Search Tree**
* A node `p` in that tree

Return the **inorder successor** of `p`.

### What is Inorder Successor?

The inorder successor of a node `p` is:

> The node with the **smallest value strictly greater than `p->val`**

If no such node exists, return `nullptr`.



## ğŸ§ª Example

BST:

```
        5
       / \
      3   6
     / \
    2   4
```

* Successor of 3 â†’ 4
* Successor of 4 â†’ 5
* Successor of 6 â†’ nullptr



# ğŸ§  Core Insight

Because BST inorder traversal gives:

```
Sorted ascending order
```

The inorder successor is simply:

ğŸ‘‰ The **next greater value**



# ğŸ’¡ Two Important Cases

## ğŸ”¹ Case 1: Node has a right subtree

Then successor is:

```
Minimum value in right subtree
```

Example:

```
    10
      \
       15
      /
     12
```

Successor of 10 â†’ 12



## ğŸ”¹ Case 2: Node has NO right subtree

Then successor is:

> The lowest ancestor for which this node lies in its left subtree.

This is what your code handles cleverly.



# âœ… Our Code (Iterative)

```cpp
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        TreeNode* successor = nullptr;
        while (root != nullptr) {
            if (p->val >= root->val) {
                root = root->right;
            } else {
                successor = root;
                root = root->left;
            }
        }
        return successor;
    }
};
```



# ğŸ” Line-by-Line Explanation

### Step 1

```cpp
TreeNode* successor = nullptr;
```

Initialize answer as null.



### Step 2

```cpp
while (root != nullptr)
```

Traverse the BST.



### Step 3 (Move Right)

```cpp
if (p->val >= root->val)
    root = root->right;
```

If `p` is greater or equal:

* Successor must be in right subtree
* Ignore current node



### Step 4 (Possible Successor)

```cpp
else {
    successor = root;
    root = root->left;
}
```

If `p->val < root->val`:

* This node is a valid successor candidate
* But maybe thereâ€™s a smaller valid one on the left

So:

* Store candidate
* Go left to try improving it



# ğŸ§  Why This Works

We are essentially doing:

> â€œFind the smallest value greater than p->valâ€

Thatâ€™s exactly what successor means.



# ğŸŒ Brute Force Approach

1. Perform inorder traversal
2. Store elements in array
3. Find next element after `p`

Time: **O(n)**
Space: **O(n)**

Wasteful compared to BST logic.



# âš¡ Time & Space Complexity

| Metric | Value |
| - | -- |
| Time   | O(h)  |
| Space  | O(1)  |

`h` = height of tree

Balanced â†’ O(log n)
Skewed â†’ O(n)



# ğŸ§ª Dry Run Example

BST:

```
        20
       /  \
      10   30
         \
          15
```

Find successor of 15:

1. 20 â†’ 15 < 20 â†’ store 20, go left
2. 10 â†’ 15 > 10 â†’ go right
3. 15 â†’ 15 >= 15 â†’ go right
4. null â†’ stop

Answer = 20

Correct âœ”



# ğŸ› ï¸ Alternative Implementation (Explicit Right Subtree Case)

If interviewer wants clearer logic:

```cpp
TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
    if (p->right) {
        TreeNode* cur = p->right;
        while (cur->left)
            cur = cur->left;
        return cur;
    }

    TreeNode* successor = nullptr;
    while (root) {
        if (p->val < root->val) {
            successor = root;
            root = root->left;
        } else {
            root = root->right;
        }
    }

    return successor;
}
```

More explicit. Same idea.


# ğŸ› ï¸ Alternative Implementation 

```cpp
pair<Node*, Node*> findPreSuc(Node* root, int key) {
    Node* pred = nullptr;
    Node* succ = nullptr;
    Node* node = root;

    while (node) {
        if (key < node->val) {
            succ = node;
            node = node->left;
        } else if (key > node->val) {
            pred = node;
            node = node->right;
        } else {
            // found exact node
            if (node->left) {
                Node* t = node->left;
                while (t->right) t = t->right;
                pred = t;
            }
            if (node->right) {
                Node* t = node->right;
                while (t->left) t = t->left;
                succ = t;
            }
            break;
        }
    }
    return {pred, succ};
}
```




# ğŸ” Mirror Problem: Inorder Predecessor

Just reverse logic:

* If `p->val <= root->val` â†’ go left
* Else â†’ store candidate, go right



# ğŸ¤” FAQs

### Q1: What if `p` has the maximum value?

Return `nullptr`.



### Q2: Does this work if tree is not BST?

No. This relies entirely on BST ordering.



### Q3: What if duplicates exist?

Standard BST problems assume unique values.



### Q4: Why donâ€™t we compare node pointers?

We compare values because BST ordering is based on values.



# ğŸ¯ Why This Problem Is Important

Tests:

* BST traversal logic
* Understanding successor definition
* Efficient searching
* Boundary tracking

This is a **frequent interview problem**.


# ğŸ TL;DR

| Concept      | Logic                    |
| - | - |
| Successor    | Smallest > p             |
| If p >= root | Go right                 |
| If p < root  | Store candidate, go left |
| Time         | O(h)                     |
| Space        | O(1)                     |
| Core trick   | Boundary tracking        |

