# Browser History (Doubly-Linked List) üìöüåê

## Problem statement üìù

Implement a browser history structure that supports:

* `visit(site)`: navigate to `site`. When you visit a new site, all forward history (pages ahead of the current one) must be **deleted**.
* `back(steps)`: move `steps` pages backward if possible, and return the current page's URL after moving.
* `forward(steps)`: move `steps` pages forward if possible, and return the current page's URL after moving.

Operations must preserve the chronological navigation semantics of a real browser.

---

# Intuition ‚ú®

A doubly-linked list models this perfectly:

* Each node stores a URL and has `prev` and `next`.
* `currentPage` points to the page the user is currently viewing.
* `back(steps)` repeatedly moves `currentPage = currentPage->prev` until steps are exhausted or no `prev`.
* `forward(steps)` repeatedly moves `currentPage = currentPage->next`.
* `visit(site)` must *delete all nodes reachable from `currentPage->next`* (the forward chain) and then append a new node as the new `currentPage->next`. This ensures no stale forward nodes remain and memory is freed.

Why delete forward nodes? Because in browsers if you navigate to a new page after going back, the forward history is replaced by the new navigation path.

---

# Brute force vs optimal

* Brute force alternative: keep a vector of visited URLs and an index `pos`; on `visit()` remove elements after `pos` and push the new URL. That is *actually* simpler and also O(1) amortized for `visit` (using `vector::resize`) and O(1) for `back`/`forward` by changing index. This is fine in many cases.

* The doubly-linked list is also optimal: all operations are O(steps) for `back`/`forward` and O(length of forward chain) to delete on `visit`. In average/expected browser modeling both options work; linked list shows pointer manipulation explicitly and is memory-efficient when nodes are large or need object identity.

Which to prefer? If you only need URLs and random access/resizing, the vector approach is simpler. If nodes carry heavy payloads or you want O(1) node deletion without moving memory, prefer linked list.

---

# Full improved, safe, production-ready code ‚úÖ

```cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    string url;
    Node* next;
    Node* prev;

    Node(const string &url1, Node* next1 = nullptr, Node* prev1 = nullptr)
        : url(url1), next(next1), prev(prev1) {}
};

class Browser {
    Node* currentPage;

    // Helper: delete forward list starting at 'start' (inclusive).
    // It will unlink nodes and free memory.
    void deleteForward(Node* start) {
        Node* cur = start;
        while (cur) {
            Node* nx = cur->next;
            delete cur;
            cur = nx;
        }
    }

    // Helper: go to the head (first node) from current
    Node* goToHead() const {
        Node* p = currentPage;
        while (p && p->prev) p = p->prev;
        return p;
    }

public:
    // Construct browser with a home page
    Browser(const string &home) {
        currentPage = new Node(home);
    }

    // Destructor: free whole list
    ~Browser() {
        // Move to head, then delete forward
        Node* head = goToHead();
        deleteForward(head);
    }

    // Visit a site: clear forward history, append new node, move current
    void visit(const string &site) {
        // 1) delete forward history (if any)
        if (currentPage->next != nullptr) {
            deleteForward(currentPage->next);
            currentPage->next = nullptr;
        }

        // 2) append new node and move current
        Node* newNode = new Node(site);
        currentPage->next = newNode;
        newNode->prev = currentPage;
        newNode->next = nullptr;
        currentPage = newNode;
    }

    // Move back up to 'steps' times. Return current URL.
    string back(int steps) {
        while (steps > 0 && currentPage->prev != nullptr) {
            currentPage = currentPage->prev;
            --steps;
        }
        return currentPage->url;
    }

    // Move forward up to 'steps' times. Return current URL.
    string forward(int steps) {
        while (steps > 0 && currentPage->next != nullptr) {
            currentPage = currentPage->next;
            --steps;
        }
        return currentPage->url;
    }

    // Optional: for debugging - print full history from head to tail
    void debugPrint() const {
        Node* head = goToHead();
        Node* p = head;
        bool first = true;
        while (p) {
            if (!first) cout << " <-> ";
            cout << p->url;
            first = false;
            p = p->next;
        }
        cout << "\n";
    }
};

// Example usage
int main() {
    string home = "leetcode.com";
    Browser browser(home);

    browser.visit("google.com");
    browser.visit("facebook.com");
    browser.visit("youtube.com");

    cout << browser.back(1) << endl;      // facebook.com
    cout << browser.back(1) << endl;      // google.com
    cout << browser.forward(1) << endl;   // facebook.com

    browser.visit("linkedin.com");
    cout << browser.forward(2) << endl;   // linkedin.com
    cout << browser.back(2) << endl;      // google.com
    cout << browser.back(7) << endl;      // leetcode.com

    return 0;
}
```

---

# Complexity analysis üìä

Let `n` be the number of nodes currently in the list (history length), and let `f` be the length of the forward chain when calling `visit`.

* `visit(site)`:

  * Deleting the forward chain takes **O(f)** to traverse & delete.
  * Appending new node is **O(1)**.
  * So worst-case `O(n)` (if `f` ‚âà `n`), but amortized across many operations typically small.
* `back(steps)` / `forward(steps)`:

  * Each operation moves at most `steps` pointers: **O(steps)**.
  * If `steps` is bounded by `n`, worst-case **O(n)**.
* **Space:** O(n) for the linked list nodes (each URL stored once).

In practice these are optimal for a pointer-based linked-list design.

---

# Test cases & expected behavior üß™

1. **Simple visit and navigation**

   * Operations: visit g, visit f, visit y, back(1) -> f, back(1) -> g, forward(1) -> f
2. **Visiting after going back clears forward**

   * Start: leet -> g -> f -> y. back(1) to f; visit linkedin -> forward history (y) removed. forward(1) returns linkedin (no forward).
3. **Back/forward beyond ends**

   * back(100) moves to head (leetcode) and returns it. forward(100) moves to tail and returns it.
4. **Edge: multiple sequential visits**

   * Behavior: forward history always cleared.
5. **Memory handling**

   * Repeated visit after back should not leak memory ‚Äî validated by corrected code with destructor.

---

# Tips & tricks ‚ú®

* **Order matters when deleting forward nodes.** Always delete the old `current->next` chain before reassigning `current->next`.
* **Prefer `const string&`** parameters to avoid copies when passing strings.
* **Provide destructor** in classes owning dynamic memory to avoid leaks.
* **Prefer containers (vector) if node identity is not needed.** For pure URL stacks, an index on a `vector<string>` is shorter and easier.
* **Use smart pointers** (e.g., `unique_ptr`) if you want automatic lifetime management ‚Äî but cyclic `next/prev` pointers complicate unique ownership (use `shared_ptr` with weak `prev`).
* **Avoid exposing raw Node pointers** from class internals; keep them private and provide safe public methods.

---

# Variations & extensions üîÅ

1. **Array/Vector-based implementation:** store URLs in `vector<string>` and keep an index `i`. `visit` does `resize(i+1); push_back(url); i = size()-1;`.

   * `back(steps)` ‚Üí `i = max(0, i - steps)`; `forward(steps)` ‚Üí `i = min(size()-1, i + steps)`.
   * Simpler and often preferable.

2. **Limit on history size:** maintain a maximum N entries; when exceeding, delete oldest (head). For a DLL, delete head nodes; for vector, pop front (costly) or use deque.

3. **Persist history to disk:** write nodes/URLs to disk and keep only recent in memory.

4. **Use smart pointers:** `shared_ptr<Node>` for `next` and `weak_ptr<Node>` for `prev` to avoid cycle memory leak problems with shared ownership.

5. **Tabs/Multiple sessions:** maintain multiple `Browser` instances or add tab management with separate histories.

---

# Frequently Asked Questions (FAQs) ‚ùì

**Q: Why use a doubly-linked list instead of a vector?**
A: DLL demonstrates pointer operations and O(1) deletion of nodes without moving memory. Vector (or deque) often gives simpler code if you only need sequential access and an index-based cursor.

**Q: Will deleting forward nodes invalidate anything?**
A: Only nodes in forward chain are removed. After deletion, `currentPage->next` must be set to `nullptr` and the new node appended.

**Q: Is `deleteForward` safe if `start` is `nullptr`?**
A: Yes ‚Äî the function checks `while (cur)` and returns immediately.

**Q: What about concurrency?**
A: This code is not thread-safe. For concurrent access, add locking (mutex) or design a thread-safe wrapper.

**Q: Should I use smart pointers?**
A: In real-world C++ prefer smart pointers to manage memory automatically. However, a bidirectional structure with smart pointers typically uses `shared_ptr` for `next` and `weak_ptr` for `prev` to avoid cycles.

---

# Quick comparison table

| Approach                  |      Simplicity |       Memory overhead | Back/Forward complexity |          Visit complexity | When to use                                 |
| ------------------------- | --------------: | --------------------: | ----------------------: | ------------------------: | ------------------------------------------- |
| `vector<string> + index`  | **Very simple** |                  O(n) |                    O(1) | O(1) amortized (`resize`) | Only URLs needed; simple UI                 |
| Doubly-linked list (this) |          Medium |                  O(n) |                O(steps) |       O(fwdLen) to delete | Need O(1) node deletion, extra node payload |
| Smart pointer DLL         |     Medium-high | O(n) + smart overhead |                    Same |        Same + safe memory | Production C++ with RAII                    |

