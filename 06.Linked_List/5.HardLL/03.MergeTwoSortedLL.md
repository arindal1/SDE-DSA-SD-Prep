# Merge Two Sorted Linked Lists 🧩🔀

## Problem statement 📝

Given the heads of two sorted singly-linked lists `list1` and `list2`, merge them into one sorted list. Return the head of the merged list. You must preserve node values and ordering and you may reuse the input nodes (i.e., no need to allocate new list nodes).

Example:

```
Input: list1 = 1 -> 2 -> 4, list2 = 1 -> 3 -> 4
Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4
```

---

## Intuition ✨

Because both lists are sorted, the smallest node at any step is the smaller of the two current pointers. Repeatedly link the smaller node to the merged list and advance that pointer. Using a dummy node simplifies handling the merged list head and avoids special-casing the first node.

---

## Brute force (not recommended) 🐌

* Copy values from both lists into an array, sort, then build a new linked list.
  Complexity: O((n+m) log(n+m)) time and O(n+m) space.
* This is unnecessary because the inputs are already sorted.

---

## Optimal approach (iterative, in-place) ✅

Steps:

1. Create a *dummy* node `dummy` and a pointer `tail = dummy`.
2. While both `list1` and `list2` are non-null:

   * If `list1->val <= list2->val`: `tail->next = list1; list1 = list1->next;`
   * Else: `tail->next = list2; list2 = list2->next;`
   * Move `tail = tail->next;`
3. After the loop, attach the leftover list: `tail->next = (list1 ? list1 : list2);`
4. Return `dummy->next`.

This is **O(n + m)** time and **O(1)** extra space. It reuses nodes (no new allocations except maybe the dummy).

---

## Full improved & annotated code (iterative, non-leaking) 🧾

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // Use stack-allocated dummy to avoid leaking memory
        ListNode dummy(-1);
        ListNode* tail = &dummy;

        while (list1 != nullptr && list2 != nullptr) {
            if (list1->val <= list2->val) {
                tail->next = list1;
                list1 = list1->next;
            } else {
                tail->next = list2;
                list2 = list2->next;
            }
            tail = tail->next; // advance tail to the node just appended
        }

        // Attach remaining nodes (one of these will be nullptr)
        tail->next = (list1 != nullptr) ? list1 : list2;

        return dummy.next;
    }
};
```

---

## Recursive implementation (short & elegant) 🔁

If recursion is acceptable (stack depth = number of nodes in recursion path), you can write:

```cpp
ListNode* mergeTwoListsRecursive(ListNode* l1, ListNode* l2) {
    if (!l1) return l2;
    if (!l2) return l1;
    if (l1->val <= l2->val) {
        l1->next = mergeTwoListsRecursive(l1->next, l2);
        return l1;
    } else {
        l2->next = mergeTwoListsRecursive(l1, l2->next);
        return l2;
    }
}
```

**Tradeoffs:**

* **Pros:** Short and easy to reason about.
* **Cons:** Uses recursion stack O(n + m) in worst case — may cause stack overflow on very deep lists.

---

## Complexity analysis 📊

* **Time complexity:** **O(n + m)** where `n` and `m` are lengths of `list1` and `list2`. Each node is visited exactly once.
* **Space complexity:** **O(1)** extra space for the iterative method (excluding output). Recursive method uses O(n + m) call stack.

---

## Test cases 🧪

1. **Both empty**

   * `list1 = nullptr`, `list2 = nullptr` → output: `nullptr`.

2. **One empty**

   * `list1 = 1->2`, `list2 = nullptr` → output: `1->2`.

3. **Simple merge**

   * `list1 = 1->3->5`, `list2 = 2->4->6` → `1->2->3->4->5->6`.

4. **Different lengths**

   * `list1 = 1->2->3`, `list2 = 4->5->6->7->8` → merged ascending order.

5. **Duplicates**

   * `list1 = 1->2->4`, `list2 = 1->3->4` → `1->1->2->3->4->4`.

6. **All elements of one smaller**

   * `list1 = 1->2->3`, `list2 = 10->11` → `1->2->3->10->11`.

7. **Very long list**

   * Performance check: merging 1e6 nodes and 1e6 nodes should finish in linear time (practical limits depend on environment).

---

## Tips & tricks ✨

* **Use a dummy node** to simplify handling of the merged list head; it removes the need for special-case logic for the first node.
* **Prefer stack-allocated dummy** to avoid small memory leaks in short-run code or add `delete dummy` if allocated on heap (but deleting dummy is unnecessary if you avoid allocating it on heap).
* **Use `<=` or `<` intentionally**:

  * `<=` yields a stable merge where nodes from `list1` stay before equal-valued nodes from `list2`.
  * `<` would prefer nodes from `list2` on ties.
* **Reusing nodes** is efficient — no new node allocations required.
* **If you must preserve original lists** (not allowed to mutate inputs), you need to clone nodes into a new list (O(n + m) extra memory).

---

## Variations & extensions 🔁

* **Merge k sorted lists**: Use divide-and-conquer (merge pairs) or a min-heap to merge k lists efficiently.

  * Min-heap approach: push head of each list into heap keyed by value; repeatedly pop smallest, attach to result, push its `next`. Complexity: O(N log k) where `N` is total nodes and `k` number of lists.
* **Merge without modifying inputs:** Allocate new nodes for merged list.
* **Merge descending lists**: Reverse one or adapt comparison.
* **Merge lists of objects with comparator**: Use custom comparator on node payloads.

---

## Frequently Asked Questions (FAQs) ❓

**Q: Do I need to allocate new nodes?**
A: No — the standard solution *reuses* existing nodes by changing `next` pointers. Allocating new nodes would increase space complexity.

**Q: Is the merge stable with duplicates?**
A: Yes if you use `<=` when comparing; nodes from `list1` will be placed before equal `list2` nodes.

**Q: Should I free memory for the dummy node created with `new`?**
A: Prefer creating `dummy` on the stack (`ListNode dummy(-1);`) to avoid needing to `delete`. If you `new` it, delete it before returning (but that complicates returning `dummy.next` because `dummy` must still exist — so stack allocation is simpler).

**Q: Is recursive version safe?**
A: For small lists yes. For long lists it risks stack overflow. Use iterative version in production.

**Q: Does this approach work for linked lists with cycles?**
A: No — the lists must be proper singly-linked lists ending in `nullptr`. If inputs may have cycles, detect & handle cycles first.

