# Merge k Sorted Linked Lists üîÄüß†

## Problem statement üìù

Given an array `lists` of `k` singly linked-list heads, each list sorted ascending, merge all lists into one sorted singly linked list and return its head.

Example:

```
Input: lists = [
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```

---

## Intuition ‚ú®

All lists are sorted. At every step we need the smallest available head among the k lists. That suggests a structure that can report and remove the minimum quickly and allow insertion of the next candidate ‚Äî a **min-heap** (priority queue). Put the head of every non-empty list in the heap keyed by node value. Repeatedly:

1. Pop the smallest node `x`.
2. Append `x` to the merged list.
3. If `x->next` exists, push `x->next` into the heap.

This way each node is pushed/popped at most once, and the heap size never exceeds `k`.

---

## Brute force (not recommended) üêå

* Collect all node values into a vector, sort the vector, then recreate a list from the sorted values.

  * Time: `O(N log N)` (worse than heap approach when `k` is small).
  * Space: `O(N)` extra.
* Repeatedly scan heads of all k lists to find minimum each time (linear scan among k lists) ‚Äî O(N * k) worst case.

---

## Optimal approach (min-heap) ‚úÖ

* Use a min-heap keyed by node value (and store the `ListNode*` as payload).
* Initialize heap with the first node of each non-empty list (k pushes).
* While heap not empty:

  * Pop `(val, node)`.
  * Append `node` to result list.
  * If `node->next` exists, push `(node->next->val, node->next)`.
* Return merged list head.

**Time:** `O(N log k)` ‚Äî each of N nodes is pushed and popped once; heap operations cost `O(log k)`.
**Space:** `O(k)` for heap (plus result list nodes reused, not newly allocated).

---

## Full improved & annotated implementation üß©

```cpp
class Solution {
public:
    // Comparator for the min-heap: smaller node value has higher priority.
    struct Cmp {
        bool operator()(const ListNode* a, const ListNode* b) const {
            return a->val > b->val; // min-heap: top is smallest value
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // Edge: no lists or all empty
        if (lists.empty()) return nullptr;

        // Min-heap / priority queue of ListNode* with comparator
        priority_queue<ListNode*, vector<ListNode*>, Cmp> pq;

        // Push heads of non-empty lists
        for (ListNode* node : lists) {
            if (node) pq.push(node);
        }

        // Use a stack-allocated dummy to avoid any heap leak
        ListNode dummy(-1);
        ListNode* tail = &dummy;

        while (!pq.empty()) {
            ListNode* smallest = pq.top();
            pq.pop();

            // Append the smallest node to the merged list
            tail->next = smallest;
            tail = tail->next;

            // If the popped node has a next, push it to the heap
            if (smallest->next) {
                pq.push(smallest->next);
            }
        }

        // Ensure the merged list is properly terminated
        tail->next = nullptr;

        return dummy.next;
    }
};
```
---

## Complexity analysis üìä

* **Time:** `O(N log k)` where:

  * `N` = total number of nodes across all lists.
  * `k` = number of lists.
  * Each node is pushed and popped at most once; each heap operation costs `O(log k)`.
* **Space:** `O(k)` extra for the heap (plus O(1) for dummy pointer). The merged list reuses existing nodes (no additional O(N) allocations).

---

## Test cases & edge cases üß™

1. **Empty input**

   * `lists = []` ‚Üí `nullptr`.

2. **All lists empty**

   * `lists = [nullptr, nullptr]` ‚Üí `nullptr`.

3. **Single list**

   * `lists = [1->2->3]` ‚Üí `1->2->3`.

4. **Multiple small lists**

   * `lists = [1->4, 2->3, 0]` ‚Üí `0->1->2->3->4`.

5. **Duplicates across lists**

   * `lists = [1->3, 1->2]` ‚Üí `1->1->2->3`.

6. **Many lists with varying lengths**

   * Ensure complexity holds (k large and many small lists).

7. **Large k, small total nodes**

   * k could be bigger than N (many empty lists); heap size never exceeds non-empty lists.

8. **Worst case**

   * `k` roughly equals `N` (many single-node lists) ‚Üí heap operations `O(N log N)` which matches `O(N log k)`.

---

## Variations & alternative algorithms üîÅ

* **Divide-and-conquer (pairwise merge)**
  Repeatedly merge pairs of lists (like tournament). Complexity: `O(N log k)` (same asymptotic) but with smaller constants when merging lists in-place efficiently. Good when heap overhead is undesirable.

  * Implementation: repeatedly merge `lists[i]` with `lists[i + step]`, doubling `step` each iteration.
* **Multi-way merge using losers tree / tournament tree**
  Slightly more complex but can give better constants for very large k.
* **Collect and sort**
  Collect node values in a vector and sort ‚Äî simple but uses `O(N)` extra space and `O(N log N)` time.
* **Use `multiset`/`map`**
  Similar to heap but generally slower with higher constants.

---

## Tips & best practices ‚ú®

* **Prefer explicit comparator** for priority queues storing node pointers. Using `pair<int, ListNode*>` works, but comparator behavior for ties can be confusing.
* **Use stack dummy node** to avoid leaking small heap allocation.
* **Set `tail->next = nullptr`** at end ‚Äî defensive programming (prevents accidental dangling linking if input lists had stray pointers).
* **If you must preserve input lists** (not mutate original), clone nodes instead of reusing them. That costs `O(N)` extra memory.
* **If k is small** and lists are large, the heap approach excels. If k is large and lists are tiny, divide-and-conquer can be competitive.

---

## Frequently Asked Questions (FAQs) ‚ùì

**Q: Why a min-heap and not repeated linear scans?**
A: A linear scan among k heads to find the current smallest would cost `O(k)` per extracted node ‚Üí `O(N*k)` total in worst case. Heap gives `O(log k)` per node, much better when `k` is large.

**Q: Is pair<int, ListNode*> + `greater<>` wrong?**
A: It works: `pair` compares `first` (value) then `second` (pointer) to break ties. Tiebreaking by pointer is harmless but nondeterministic and less clear. An explicit comparator that compares `ListNode->val` is clearer.

**Q: Do we need to free input nodes?**
A: No ‚Äî we *reuse* nodes and return merged list. If you allocated new nodes for the merged list, you'd need to free input lists if ownership rules require it. For typical LeetCode problems, reusing nodes is expected.

**Q: Does this method handle cycles in input lists?**
A: No ‚Äî assumed inputs are proper acyclic lists terminating in `nullptr`. If cycles are possible, detect and handle them first.

**Q: Which is better: heap or divide-and-conquer?**
A: Both are `O(N log k)`. Choice depends on constants, memory locality, and implementation preference:

* Heap: simpler, good when k moderately small.
* Divide-and-conquer: fewer heap ops, good when merging cost per pair is cheap.

