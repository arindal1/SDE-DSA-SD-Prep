# Rotate a singly linked list to the right by `k` 🔁🧠

# Problem statement 📝

Given a singly linked list `head` and an integer `k`, rotate the list to the right by `k` places.

Example:

```
Input:  1 -> 2 -> 3 -> 4 -> 5 -> nullptr, k = 2
Output: 4 -> 5 -> 1 -> 2 -> 3 -> nullptr
```

If `k` is greater than the list length, rotation wraps around: rotating by `len + r` is same as rotating by `r`.

---

# Intuition ✨

Rotating right by `k` is equivalent to:

1. Turning the list into a circle by connecting tail → head.
2. Finding the new tail: the node at position `len - (k % len)` (1-based indexing).
3. The node after the new tail becomes the new head.
4. Break the circle by setting `newTail->next = nullptr`.

Turning the list circular makes advancing to the new cut point simple because you can step forward from the original tail.

---

# Brute force (for understanding) 🐢

A brute-force view: perform single-step rotations `k` times, where each rotation removes the last node and inserts it at the front — but that is `O(k * n)` in worst case and unacceptable for large `k`.

---

# Optimal approach (two passes, O(1) extra) ✅

* **Pass 1:** Walk the list to determine `len` and reach the `tail`.
* **Make circular:** `tail->next = head`.
* **Compute effective rotate:** `k = k % len`.

  * If `k == 0` after modulo, the list should remain the same.
* **Find new tail:** walk `len - k` steps from `tail` (or from dummy), or equivalently from `tail` forward `len - k` times because of circularity.
* **Set new head:** `newHead = newTail->next`.
* **Break circle:** `newTail->next = nullptr`.
* **Return `newHead`.**

This is `O(n)` time (two linear traversals at most) and `O(1)` extra space.



---

# Improved & annotated implementation 🧩

> Uses standard LeetCode `ListNode` structure.

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (head == nullptr || head->next == nullptr || k == 0)
            return head;

        // 1) compute length and get the tail
        ListNode* tail = head;
        int len = 1;
        while (tail->next != nullptr) {
            tail = tail->next;
            ++len;
        }

        // 2) make list circular
        tail->next = head;

        // 3) reduce k (effective rotations)
        k = k % len;
        if (k == 0) {
            // break the circle and return original head
            tail->next = nullptr;
            return head;
        }

        // 4) find new tail: move (len - k) steps from current tail
        //    after circular linking, stepping forward len-k times lands on newTail
        int stepsToNewTail = len - k;
        ListNode* newTail = tail;
        while (stepsToNewTail--) {
            newTail = newTail->next;
        }

        // 5) set new head and break the circle
        ListNode* newHead = newTail->next;
        newTail->next = nullptr;

        return newHead;
    }
};
```


# Complexity analysis 📊

* **Time Complexity:** `O(n)` where `n` = number of nodes, because we traverse the list a constant number of times (to compute length and to move to the cutting point).
* **Space Complexity:** `O(1)` extra space (in-place pointer changes only).

---

# Correctness edge-cases & examples (test cases) 🧪

1. **Basic rotation**

   * Input: `1->2->3->4->5`, `k=2` → Output: `4->5->1->2->3`.

2. **k is zero**

   * Input: `1->2->3`, `k=0` → Output: `1->2->3` (unchanged).

3. **k multiple of list length**

   * Input: `1->2->3->4`, `k=4` → Output: `1->2->3->4` (unchanged).
   * Input: `1->2->3->4`, `k=8` → Output: `1->2->3->4`.

4. **k greater than length**

   * Input: `1->2->3`, `k=5` → `k%len = 2` → Output: `2->3->1`.

5. **Single node or empty list**

   * `head=nullptr` or single node → function returns early (no change).

6. **Large k values**

   * Works fine because of `k = k % len`.

7. **Very long list**

   * Still O(n), will perform fine for scale where n fits in memory.

---

# Tips & best practices ✨

* Use `k %= len` — prevents unnecessary rotations and avoids stepping many times.
* Use a **circular trick** (tail→next = head) — it makes locating the new head/tail straightforward.
* Use meaningful variable names (`tail`, `newTail`, `newHead`) — much easier to read and maintain.
* Always handle trivial early returns: empty list, single node, `k == 0`.
* After making circular, **always** break the circle before returning (either in the `k==0` branch, or at the final `newTail->next = nullptr`).
* If you’re writing production code, check for potential overflow if `k` is extremely large and represented by signed 32-bit int — `k % len` is safe but ensure `len` fits comfortably in `int`. Use `long long` if needed.

---

# Variations & related problems 🔁

* **Rotate left by `k`:** Equivalent to rotate right by `len - (k % len)`.
* **In-place value rotate (no pointer change):** Copy node values into array, rotate values, then write back to nodes. Simpler code, but uses `O(n)` extra space.
* **Rotate in groups:** Combine rotation with reversing or other group operations for more complex transformations.
* **Cyclic rotations in circular list:** If list is already circular, you only need to find the cut point and break.

---

# Frequently Asked Questions (FAQs) ❓

**Q: Why make the list circular?**
A: Making it circular simplifies jumping from tail to head and counting steps to the new tail — you can treat it as a ring and step forward a known number of times.

**Q: Why does the code move `len - k` steps?**
A: After circularizing, moving `len - k` steps from the tail places you at the node that will become the new tail. The node after it is the new head.

**Q: What happens if `k` is negative?**
A: Problem statements generally assume `k >= 0`. If negative rotation is desired (rotate left), convert it: rotateLeft by `abs(k)` equals rotateRight by `len - (abs(k) % len)`.

**Q: Is this safe for very large `k`?**
A: Yes — taking `k % len` reduces it to `0..len-1`. Only make sure `len` and `k` types handle their expected ranges.

**Q: Can this be done without turning circular?**
A: Yes — you can locate the new tail by scanning from head to position `len - k - 1` (0-based) and adjust pointers without making the list circular. The circular trick is just concise and easy.

---

# Visual walkthrough (quick) 🔍

Given `1 -> 2 -> 3 -> 4 -> 5`, `k = 2`:

1. Find tail = 5, len = 5. Set `tail->next = head` (circular).
2. `k % len = 2`, `stepsToNewTail = 5 - 2 = 3`.
3. From `tail` (node 5), step 3 times: ->1 ->2 ->3. Now `newTail = 3`.
4. `newHead = newTail->next = 4`.
5. Break circle: `newTail->next = nullptr`.
6. Result: `4 -> 5 -> 1 -> 2 -> 3`.

