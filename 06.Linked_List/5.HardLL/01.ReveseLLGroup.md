# Reverse Nodes in k-Group 🔁🧠

**Short summary:** Given the head of a singly linked list and an integer `k`, reverse the nodes of the list in groups of size `k` and return the modified list. If the number of nodes left is less than `k`, leave them as-is. The algorithm works *in-place* with **O(1)** extra space and **O(n)** time.


---

## Problem statement 📝

Given a singly linked list:

```
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> nullptr
```

and `k = 3`, transform it to:

```
3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8 -> nullptr
```

Reverse every consecutive block of `k` nodes. If final block size < `k`, leave it unchanged.

**Constraints typically assumed:** `k >= 1`. `List` nodes are singly-linked (`next` pointer only).

---

## Intuition ✨

* A natural, optimal solution uses the **iterative in-place** reversal of each k-length chunk.
* Maintain three pointers:

  * `prevTail` — tail of the processed list so far (the node before current chunk).
  * `chunkHead` (called `temp` in your code) — first node of the chunk to reverse.
  * `chunkTail` (found by `findKNode`) — k-th node of the chunk.
* Save `nextChunkHead = chunkTail->next` to reconnect after reversing.
* Break chunk (`chunkTail->next = nullptr`), reverse it, reconnect:

  * `prevTail->next = reversedHead`
  * `reversedTail->next = nextChunkHead`
* Move `prevTail` to `reversedTail`, `chunkHead = nextChunkHead`, and repeat.

This visits each node a constant number of times → **O(n)** time. Only pointer variables used → **O(1)** space.

---

## Brute force vs optimal

* **Brute force**: Reconstructing new list by popping k nodes into an auxiliary structure and re-linking — works but uses extra space.
* **Optimal (used here)**: In-place reversal per k-group using pointer manipulation — O(n) time, O(1) extra space.

---

## Corrected, robust implementation (clean & commented) ✅

> Assumes typical LeetCode `ListNode` definition:

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

**Code:**

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// Find the k-th node from 'start' (inclusive). Return nullptr if fewer than k nodes.
ListNode* findKNode(ListNode* start, int k) {
    ListNode* cur = start;
    int cnt = 1;
    while (cur != nullptr && cnt < k) {
        cur = cur->next;
        ++cnt;
    }
    return cur; // either k-th node or nullptr
}

// Reverse a non-empty list segment whose head is 'head' and whose tail->next == nullptr.
// Returns new head (old tail). Also returns new tail via output parameter (old head).
ListNode* reverseList(ListNode* head, ListNode** outNewTail) {
    ListNode* prev = nullptr;
    ListNode* cur = head;
    while (cur != nullptr) {
        ListNode* nxt = cur->next;
        cur->next = prev;
        prev = cur;
        cur = nxt;
    }
    // prev is new head, head is now tail
    if (outNewTail) *outNewTail = head;
    return prev;
}

ListNode* reverseKGroup(ListNode* head, int k) {
    if (head == nullptr || k <= 1) return head;

    // dummy simplifies head changes
    ListNode dummy(0);
    dummy.next = head;
    ListNode* prevTail = &dummy; // tail of processed part

    ListNode* chunkHead = head;

    while (chunkHead != nullptr) {
        // find k-th node of this chunk
        ListNode* kth = findKNode(chunkHead, k);
        if (kth == nullptr) {
            // fewer than k nodes left -> leave as-is
            break;
        }

        ListNode* nextChunkHead = kth->next;

        // detach chunk, reverse it
        kth->next = nullptr;
        ListNode* newChunkHead = reverseList(chunkHead, &chunkHead /*new tail will be old head*/);
        // After reverseList:
        // newChunkHead == kth (old kth), chunkHead == old head (now tail)

        // connect previous part to reversed chunk head
        prevTail->next = newChunkHead;

        // connect reversed chunk tail to the next chunk
        chunkHead->next = nextChunkHead;

        // move prevTail to tail of reversed chunk
        prevTail = chunkHead;

        // move chunkHead to next chunk's head
        chunkHead = nextChunkHead;
    }

    return dummy.next;
}
```


---

## Example walk-through 🔍

Input: `1 -> 2 -> 3 -> 4 -> 5`, `k = 2`

1. chunkHead = 1, kth = 2, nextChunkHead = 3
2. detach `[1->2]` (kth->next=nullptr) and reverse → `[2->1]`
3. prevTail(dummy) -> next = 2, tail (1) -> next = 3
4. prevTail = 1, chunkHead = 3
5. repeat for `[3,4]` → `[4->3]`, connect 1->4, 3->5
6. final list: `2 -> 1 -> 4 -> 3 -> 5`

---

## Complexity analysis 📊

* **Time:** `O(n)` where `n` is number of nodes. Each node is processed a constant number of times (finding chunks, reversing).
* **Space:** `O(1)` additional space (in-place). Only constant pointers and temporary variables used.

---

## Edge cases & test cases 🧪

1. **Basic**

   * Input: `1->2->3->4->5`, `k=2` → `2->1->4->3->5`.
2. **k = 1**

   * Input: any list, `k=1` → unchanged.
3. **k equals list length**

   * Input: `1->2->3`, `k=3` → `3->2->1`.
4. **k greater than length**

   * Input: `1->2`, `k=3` → unchanged.
5. **Empty list**

   * Input: `head=nullptr`, any `k` → `nullptr`.
6. **Single node**

   * Input: `1`, `k=2` → unchanged.
7. **Large k groups**

   * ensures correct reconnection of tails and next-chunk heads.

---

## Tips & tricks ✨

* Use a **dummy** node to make head management easy (no separate `if` for first chunk).
* Always **save `nextChunkHead` before cutting the chunk** (i.e., before `kth->next = nullptr`).
* After reversing a chunk, remember to **connect the reversed tail to `nextChunkHead`**. Missing this is the most common bug.
* Make `reverseList` return the new head and optionally provide the new tail (or simply treat old head as new tail).
* Check `k <= 1` early — reversing with `k = 1` is a no-op.

---

## Variations & extensions 🔁

* **Recursive approach:** reverse first k nodes recursively then attach. Works but uses recursion stack (O(n/k) depth).
* **Return partial reversed when last chunk shorter than k (LeetCode variant)?** Typically leave last chunk as-is. Another variant asks to drop last incomplete chunk.
* **Reverse every alternate k nodes:** combine `reverseKGroup` with skipping logic.
* **Reverse in groups but preserve node values only:** copy node values into array, reverse values per k-chunk, and reassign. This uses O(n) extra space but simpler pointer handling.

---

## FAQs ❓

**Q: Why break the chunk (`kth->next = nullptr`) before reversing?**
A: Simplifies reversal function: reversing a list segment that ends at `nullptr`. You must restore connection afterwards.

**Q: Can I avoid `reverseList` and reverse in-place inline?**
A: Yes — implement reversal inline using three pointers and carefully reconnect. Using `reverseList` improves readability.

**Q: Why use a dummy node?**
A: Avoids special-case handling when the head of the list changes (first chunk reversed). Makes code simpler and less error-prone.

**Q: Does this work for `k = 0`?**
A: `k = 0` is invalid; best to assume `k >= 1`. The function checks `k <= 1` and returns early for `k == 1`.

---
