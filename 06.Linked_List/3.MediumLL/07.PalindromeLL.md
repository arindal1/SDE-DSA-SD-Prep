# 🔁 Palindrome Linked List — In-Depth Notes


## 📄 Problem statement

Given the `head` of a singly linked list, determine **whether the list is a palindrome** — i.e., it reads the same forwards and backwards. Return `true` if it is a palindrome, otherwise `false`.

Example:

```
1 → 2 → 2 → 1   → true
1 → 2 → 3       → false
```

---

## 💡 High-level intuition

A palindrome reads the same forwards and backwards. For a linked list we can:

1. Find the middle of the list (so we know where to split).
2. Reverse the second half in-place.
3. Compare node-by-node the first half and the reversed second half.
4. Restore the original list (reverse the second half back) — optional but good practice.
5. Return the comparison result.

This runs in **O(n)** time and uses **O(1)** extra space (only pointers), making it an optimal approach for this problem.

---

## 🐢 Brute-force approach

* Copy the linked-list values into an array/vector.
* Use two-pointer technique (left/right indices) to check palindrome.

```cpp
vector<int> vals;
for (ListNode* cur = head; cur; cur = cur->next) vals.push_back(cur->val);
int l = 0, r = vals.size()-1;
while (l < r) {
    if (vals[l++] != vals[r--]) return false;
}
return true;
```

* **Time:** O(n)
* **Space:** O(n) (extra vector)

Works and simple, but uses extra O(n) memory.

---

## 🚀 Optimal approach — in place (two-pointer + reverse second half)

### Key steps

1. **Edge cases:** empty list or single node → `true`.
2. **Find middle:** use slow/fast pointers. When loop ends, `slow` points to the *end of the first half* (for our chosen convention).
3. **Reverse second half:** `reverseLinkedList(slow->next)` returns the head of reversed second half.
4. **Compare:** iterate `first = head` and `second = reversedHead`, comparing values until `second` is exhausted.
5. **Restore:** reverse the reversed half again and attach back to `slow->next`.
6. **Return** the result.

This returns the list to its original shape (important when the input should not be mutated).

---

## ✅ Correct and robust code

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x=0): val(x), next(nullptr) {}
};

// Reverse a linked list and return new head.
ListNode* reverseLinkedList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* cur  = head;
    while (cur != nullptr) {
        ListNode* nxt = cur->next;
        cur->next = prev;
        prev = cur;
        cur = nxt;
    }
    return prev;
}

// Returns the last node of the first half (for even and odd length lists).
ListNode* endOfFirstHalf(ListNode* head) {
    ListNode* slow = head;
    ListNode* fast = head;
    // Move fast by 2 and slow by 1. Stop when fast reaches end.
    while (fast->next != nullptr && fast->next->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

bool isPalindrome(ListNode* head) {
    if (head == nullptr || head->next == nullptr) return true;

    // 1. Find end of first half
    ListNode* firstHalfEnd = endOfFirstHalf(head);

    // 2. Reverse second half
    ListNode* secondHalfStart = reverseLinkedList(firstHalfEnd->next);

    // 3. Compare first half and reversed second half
    ListNode* p1 = head;
    ListNode* p2 = secondHalfStart;
    bool result = true;
    while (p2 != nullptr) {           // only need to compare length of second half
        if (p1->val != p2->val) {
            result = false;
            break;
        }
        p1 = p1->next;
        p2 = p2->next;
    }

    // 4. Restore the list (reverse the second half again and attach)
    firstHalfEnd->next = reverseLinkedList(secondHalfStart);

    return result;
}

// --- Helper functions for testing ---
ListNode* buildList(const vector<int>& vals) {
    if (vals.empty()) return nullptr;
    ListNode* head = new ListNode(vals[0]);
    ListNode* tail = head;
    for (size_t i = 1; i < vals.size(); ++i) {
        tail->next = new ListNode(vals[i]);
        tail = tail->next;
    }
    return head;
}

void freeList(ListNode* head) {
    while (head) {
        ListNode* nxt = head->next;
        delete head;
        head = nxt;
    }
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    vector<vector<int>> tests = {
        {},                // empty
        {1},               // single
        {1,2},             // not palindrome
        {1,2,1},           // odd palindrome
        {1,2,2,1},         // even palindrome
        {1,2,3,2,1},       // odd palindrome
        {1,2,3,4,2,1},     // not palindrome
    };

    for (auto &t : tests) {
        ListNode* head = buildList(t);
        cout << "List: ";
        printList(head);
        cout << "Is palindrome? " << (isPalindrome(head) ? "Yes" : "No") << '\n';
        cout << "After check, list restored: ";
        printList(head);
        cout << "-----------------------------\n";
        freeList(head);
    }

    // Interactive test (optional)
    /*
    int n;
    if (cin >> n) {
        vector<int> vals(n);
        for (int i = 0; i < n; ++i) cin >> vals[i];
        ListNode* h = buildList(vals);
        cout << (isPalindrome(h) ? "Palindrome\n" : "Not palindrome\n");
        printList(h); // restored
        freeList(h);
    }
    */

    return 0;
}
```

---

## 🧪 Test cases

Use these to validate behavior:

1. `[]` → `true` (empty list is palindrome by definition)
2. `[1]` → `true`
3. `[1,2]` → `false`
4. `[1,2,1]` → `true`
5. `[1,2,2,1]` → `true`
6. `[1,2,3,2,1]` → `true`
7. `[1,2,3,4]` → `false`
8. Long list edge cases for performance.

---

## ⏱ Complexity analysis

* **Time:** `O(n)` — we traverse the list a constant number of times:

  * find middle: O(n/2)
  * reverse second half: O(n/2)
  * compare: O(n/2)
  * restore: O(n/2)
* **Space:** `O(1)` extra space — only a few pointers are used.

---

## ✅ Why we restore the list?

* Good API hygiene: callers generally don’t expect the input structure to be mutated permanently by a check.
* Restoring allows further validations or use of the list after the palindrome check.
* If performance or simplicity is primary and the caller allows mutation, you *could* skip restoration — but document that behavior.

---

## 🔧 Implementation notes & common pitfalls

* **Choosing the middle:** We used `endOfFirstHalf` with loop condition `fast->next != nullptr && fast->next->next != nullptr`. This places `slow` at the end of first half:

  * For **odd** length `2k+1`, `slow` points to node `k+1` (1-based) — first half length `k+1` and second half length `k`.
  * For **even** length `2k`, `slow` points to node `k` — first half length `k` and second half length `k`.
* **Compare only up to `secondHalfStart` length.** We iterate while `p2 != nullptr` (second half length), because second half is always equal or shorter.
* **Null checks**: always guard against `head == nullptr` or short lists.
* **Be careful with pointer restoration** — if you `return` early on mismatch, first restore the list to avoid leaving it modified.
* **Use `nullptr` instead of `NULL`** in C++11+ for clarity.

---

## 🔁 Variations

* **Non-restoring version**: reverse the second half and return result without restoring — slightly faster but destructive.
* **Using stack**: push first half values onto stack and then pop while traversing second half (O(n) time, O(n/2) extra space).
* **Recursive comparison**: compare nodes using recursion — uses O(n) stack memory.

---

## ❓ FAQs

**Q:** Why reverse the second half and not the first?
**A:** Reversing the second half lets us compare forward from head and forward in the reversed second half — both in the same direction. Reversing first half is also possible but requires more careful pointer management.

**Q:** Can we detect palindrome without modifying the list and using O(1) space?
**A:** Not reliably. The optimal O(1)-space approach does temporarily modify the list (reverse part of it) but restores it. Any truly no-modify O(1) approach would require extra assumptions.

**Q:** Why not use recursion to compare ends?
**A:** Recursion would use O(n) stack memory. It’s simpler conceptually (push nodes on recursion return), but not memory-optimal.

---

