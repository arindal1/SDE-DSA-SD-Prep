# ğŸŒ€ Detect Cycle in a Linked List â€” In-depth Explanation

---

## ğŸ§© Problem Statement

> Given the `head` of a singly linked list, determine if the linked list contains a **cycle**.

A **cycle** exists if any node in the list can be reached again by continuously following the `next` pointer.

---

### ğŸ§  Example

#### âœ… Example 1: (Cycle Exists)

```
Input: head = [3,2,0,-4], pos = 1
Linked List: 3 â†’ 2 â†’ 0 â†’ -4
                    â†‘       |
                    |_______|
Output: true
```

#### âŒ Example 2: (No Cycle)

```
Input: head = [1,2], pos = -1
Linked List: 1 â†’ 2 â†’ NULL
Output: false
```

---

## ğŸ’­ Intuition

Imagine two runners (ğŸ¢ slow and ğŸ‡ fast) running on a circular track.

* If the track is **straight**, the faster one will reach the end â€” no meeting happens.
* If the track is **circular**, the faster runner will eventually **lap the slower one**, meaning theyâ€™ll meet!

This is exactly what we exploit using the **Floydâ€™s Cycle Detection Algorithm** (also called *Tortoise and Hare Algorithm*).

---

## ğŸ§® Algorithm Approaches

---

### ğŸš¶ Brute Force Approach

#### ğŸ’¡ Idea

Use a **hash set** to store every visited node.
If we ever encounter the same node again, a **cycle exists**.

#### ğŸ§© Code (Brute Force)

```cpp
bool hasCycle(ListNode* head) {
    unordered_set<ListNode*> visited;
    while (head != nullptr) {
        if (visited.find(head) != visited.end())
            return true;
        visited.insert(head);
        head = head->next;
    }
    return false;
}
```

#### â±ï¸ Complexity

| Metric    | Value | Explanation               |
| --------- | ----- | ------------------------- |
| **Time**  | O(N)  | Each node is visited once |
| **Space** | O(N)  | Stores visited nodes      |

#### âš ï¸ Limitation

* Uses **extra memory**.
* Not efficient for large lists.

---

### ğŸï¸ Optimal Approach â€” *Floydâ€™s Cycle Detection Algorithm*

#### ğŸ’¡ Intuition

We use two pointers:

* `slow` â†’ moves one step at a time ğŸ¢
* `fast` â†’ moves two steps at a time ğŸ‡

If there's a **cycle**, theyâ€™ll **eventually meet** inside the loop.
If not, the `fast` pointer will reach `NULL`.

---

### ğŸ§© Code (Optimal)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    bool hasCycle(ListNode *head) {
        // Base case
        if (head == nullptr || head->next == nullptr)
            return false;

        ListNode* slow = head;
        ListNode* fast = head;

        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;           // Move slow by 1
            fast = fast->next->next;     // Move fast by 2

            if (slow == fast)            // They meet â‡’ Cycle
                return true;
        }
        return false;                    // No cycle found
    }
};
```

---

### ğŸ” Step-by-Step Visualization

#### Example:

`1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 2 (cycle starts again)`

| Iteration | slow | fast | Comment                                   |
| --------- | ---- | ---- | ----------------------------------------- |
| 1         | 1    | 1    | Both start at head                        |
| 2         | 2    | 3    | Move slow +1, fast +2                     |
| 3         | 3    | 5    | Move again                                |
| 4         | 4    | 3    | fast wrapped around (cycle detected next) |
| 5         | 5    | 5    | Both meet â†’ **Cycle detected âœ…**          |

---

## ğŸ§® Complexity Analysis

| Metric               | Complexity | Explanation                        |
| -------------------- | ---------- | ---------------------------------- |
| **Time Complexity**  | O(N)       | Each node is visited at most twice |
| **Space Complexity** | O(1)       | Only two pointers used             |

âœ… **Most optimal solution** â€” uses constant memory and linear time.

---

## ğŸ§ª Example Test Cases

| Input                      | Output  | Explanation     |
| -------------------------- | ------- | --------------- |
| `head = [3,2,0,-4], pos=1` | `true`  | Cycle at node 2 |
| `head = [1,2], pos=0`      | `true`  | Cycle at node 1 |
| `head = [1], pos=-1`       | `false` | No cycle        |
| `head = []`                | `false` | Empty list      |

---

## âš™ï¸ Full Testable Code (with I/O)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool hasCycle(ListNode* head) {
    if (head == nullptr || head->next == nullptr)
        return false;

    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
            return true;
    }
    return false;
}

int main() {
    // Creating example list with cycle
    ListNode* head = new ListNode(3);
    head->next = new ListNode(2);
    head->next->next = new ListNode(0);
    head->next->next->next = new ListNode(-4);

    // Creating a cycle: tail connects to node 2
    head->next->next->next->next = head->next;

    cout << (hasCycle(head) ? "Cycle detected âœ…" : "No cycle âŒ") << endl;
}
```

---

## ğŸ’¡ Tips & Tricks

* **Donâ€™t check for `fast->next->next` first!**
  Always ensure `fast` and `fast->next` are not `nullptr` before moving.

* The **meeting point** of `slow` and `fast` can later be used to **find the exact starting node** of the cycle (LeetCode #142).

* If you ever get stuck in an infinite loop, re-check your **while condition** or **pointer updates**.

---

## ğŸ§± Variations

1. ğŸ” **Find the node where the cycle begins**
   â†’ Use *Floydâ€™s algorithm + one more phase*
   (Leetcode #142: *Linked List Cycle II*)

2. ğŸ”„ **Detect and remove the cycle**
   â†’ Once cycle detected, find the meeting point and unlink it.

3. ğŸ§® **Count the length of the cycle**
   â†’ After detection, keep moving until `slow` meets `fast` again.

---

## â“ FAQs

**Q1: Why do slow and fast meet if thereâ€™s a cycle?**

> Because the fast pointer moves twice as fast â€” it eventually laps the slow pointer inside the loop.

**Q2: Can there be multiple cycles?**

> No â€” a linked list can have **only one cycle** (if any).

**Q3: Why not use recursion?**

> Thereâ€™s no benefit here â€” pointer-based iteration is simpler and avoids stack overhead.

**Q4: What happens for a 1-node cycle?**

> The function correctly returns `true`, since `head->next == head`.

---

## âœ… Summary

| Concept       | Key Point                                                           |
| ------------- | ------------------------------------------------------------------- |
| Problem       | Detect if a cycle exists in a linked list                           |
| Best Solution | Floydâ€™s Cycle Detection (Two Pointer)                               |
| Time          | O(N)                                                                |
| Space         | O(1)                                                                |
| Key Idea      | Two pointers moving at different speeds meet only if a cycle exists |

---

âœ¨ **In short:**

> Two runners, one slow and one fast.
> If they meet again on the same track â€” youâ€™ve got a loop! ğŸŒ€
