# 🌀 Detect Cycle in a Linked List — In-depth Explanation

---

## 🧩 Problem Statement

> Given the `head` of a singly linked list, determine if the linked list contains a **cycle**.

A **cycle** exists if any node in the list can be reached again by continuously following the `next` pointer.

---

### 🧠 Example

#### ✅ Example 1: (Cycle Exists)

```
Input: head = [3,2,0,-4], pos = 1
Linked List: 3 → 2 → 0 → -4
                    ↑       |
                    |_______|
Output: true
```

#### ❌ Example 2: (No Cycle)

```
Input: head = [1,2], pos = -1
Linked List: 1 → 2 → NULL
Output: false
```

---

## 💭 Intuition

Imagine two runners (🐢 slow and 🐇 fast) running on a circular track.

* If the track is **straight**, the faster one will reach the end — no meeting happens.
* If the track is **circular**, the faster runner will eventually **lap the slower one**, meaning they’ll meet!

This is exactly what we exploit using the **Floyd’s Cycle Detection Algorithm** (also called *Tortoise and Hare Algorithm*).

---

## 🧮 Algorithm Approaches

---

### 🚶 Brute Force Approach

#### 💡 Idea

Use a **hash set** to store every visited node.
If we ever encounter the same node again, a **cycle exists**.

#### 🧩 Code (Brute Force)

```cpp
bool hasCycle(ListNode* head) {
    unordered_set<ListNode*> visited;
    while (head != nullptr) {
        if (visited.find(head) != visited.end())
            return true;
        visited.insert(head);
        head = head->next;
    }
    return false;
}
```

#### ⏱️ Complexity

| Metric    | Value | Explanation               |
| --------- | ----- | ------------------------- |
| **Time**  | O(N)  | Each node is visited once |
| **Space** | O(N)  | Stores visited nodes      |

#### ⚠️ Limitation

* Uses **extra memory**.
* Not efficient for large lists.

---

### 🏎️ Optimal Approach — *Floyd’s Cycle Detection Algorithm*

#### 💡 Intuition

We use two pointers:

* `slow` → moves one step at a time 🐢
* `fast` → moves two steps at a time 🐇

If there's a **cycle**, they’ll **eventually meet** inside the loop.
If not, the `fast` pointer will reach `NULL`.

---

### 🧩 Code (Optimal)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    bool hasCycle(ListNode *head) {
        // Base case
        if (head == nullptr || head->next == nullptr)
            return false;

        ListNode* slow = head;
        ListNode* fast = head;

        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;           // Move slow by 1
            fast = fast->next->next;     // Move fast by 2

            if (slow == fast)            // They meet ⇒ Cycle
                return true;
        }
        return false;                    // No cycle found
    }
};
```

---

### 🔍 Step-by-Step Visualization

#### Example:

`1 → 2 → 3 → 4 → 5 → 2 (cycle starts again)`

| Iteration | slow | fast | Comment                                   |
| --------- | ---- | ---- | ----------------------------------------- |
| 1         | 1    | 1    | Both start at head                        |
| 2         | 2    | 3    | Move slow +1, fast +2                     |
| 3         | 3    | 5    | Move again                                |
| 4         | 4    | 3    | fast wrapped around (cycle detected next) |
| 5         | 5    | 5    | Both meet → **Cycle detected ✅**          |

---

## 🧮 Complexity Analysis

| Metric               | Complexity | Explanation                        |
| -------------------- | ---------- | ---------------------------------- |
| **Time Complexity**  | O(N)       | Each node is visited at most twice |
| **Space Complexity** | O(1)       | Only two pointers used             |

✅ **Most optimal solution** — uses constant memory and linear time.

---

## 🧪 Example Test Cases

| Input                      | Output  | Explanation     |
| -------------------------- | ------- | --------------- |
| `head = [3,2,0,-4], pos=1` | `true`  | Cycle at node 2 |
| `head = [1,2], pos=0`      | `true`  | Cycle at node 1 |
| `head = [1], pos=-1`       | `false` | No cycle        |
| `head = []`                | `false` | Empty list      |

---

## ⚙️ Full Testable Code (with I/O)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool hasCycle(ListNode* head) {
    if (head == nullptr || head->next == nullptr)
        return false;

    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
            return true;
    }
    return false;
}

int main() {
    // Creating example list with cycle
    ListNode* head = new ListNode(3);
    head->next = new ListNode(2);
    head->next->next = new ListNode(0);
    head->next->next->next = new ListNode(-4);

    // Creating a cycle: tail connects to node 2
    head->next->next->next->next = head->next;

    cout << (hasCycle(head) ? "Cycle detected ✅" : "No cycle ❌") << endl;
}
```

---

## 💡 Tips & Tricks

* **Don’t check for `fast->next->next` first!**
  Always ensure `fast` and `fast->next` are not `nullptr` before moving.

* The **meeting point** of `slow` and `fast` can later be used to **find the exact starting node** of the cycle (LeetCode #142).

* If you ever get stuck in an infinite loop, re-check your **while condition** or **pointer updates**.

---

## 🧱 Variations

1. 🔁 **Find the node where the cycle begins**
   → Use *Floyd’s algorithm + one more phase*
   (Leetcode #142: *Linked List Cycle II*)

2. 🔄 **Detect and remove the cycle**
   → Once cycle detected, find the meeting point and unlink it.

3. 🧮 **Count the length of the cycle**
   → After detection, keep moving until `slow` meets `fast` again.

---

## ❓ FAQs

**Q1: Why do slow and fast meet if there’s a cycle?**

> Because the fast pointer moves twice as fast — it eventually laps the slow pointer inside the loop.

**Q2: Can there be multiple cycles?**

> No — a linked list can have **only one cycle** (if any).

**Q3: Why not use recursion?**

> There’s no benefit here — pointer-based iteration is simpler and avoids stack overhead.

**Q4: What happens for a 1-node cycle?**

> The function correctly returns `true`, since `head->next == head`.

---

## ✅ Summary

| Concept       | Key Point                                                           |
| ------------- | ------------------------------------------------------------------- |
| Problem       | Detect if a cycle exists in a linked list                           |
| Best Solution | Floyd’s Cycle Detection (Two Pointer)                               |
| Time          | O(N)                                                                |
| Space         | O(1)                                                                |
| Key Idea      | Two pointers moving at different speeds meet only if a cycle exists |

---

✨ **In short:**

> Two runners, one slow and one fast.
> If they meet again on the same track — you’ve got a loop! 🌀
