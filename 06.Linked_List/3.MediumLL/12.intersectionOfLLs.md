# 🔗 **Intersection Point of Two Linked Lists — In-Depth Notes**


## 🧩 Problem Statement

You are given the heads of **two singly linked lists**, `headA` and `headB`.
Your task is to **find the node where the two linked lists intersect**.
If there is no intersection, return `nullptr`.

### Example 1

```
List A: 4 → 1 → 8 → 4 → 5  
List B: 5 → 6 → 1 ↘  
                   8 → 4 → 5
```

**Output:** Node with value `8`

---

## 💡 Intuition

When two linked lists intersect, all nodes **after** the intersection are **shared** between both lists.

If the lists are of **different lengths**, a direct traversal will misalign them — the longer one will reach the intersection later.

👉 The trick is to **equalize the distance** both pointers travel.

By switching each pointer to the **other list** after reaching the end, they both:

* Traverse **the same total number of nodes**,
* Eventually meet at the **intersection point**, or both reach `nullptr` (no intersection).

---

## 🧠 Step-by-step Intuition (2-pointer approach)

Let's take an example:

```
A: 1 → 9 → 1 → 2 → 4  
B:       3 → 2 → 4
```

Intersection starts at node with value `2`.

* Initially:

  * `p1` = headA (1)
  * `p2` = headB (3)
* Both move one node at a time:

  * When `p1` reaches end of A, jump to head of B.
  * When `p2` reaches end of B, jump to head of A.
* Eventually, both traverse the same number of nodes (lengthA + lengthB),
  and **meet at the intersection node**.

If they don’t intersect, both will reach `nullptr` at the same time.

---

## 🧾 Algorithm

### Steps

1. Initialize two pointers:

   ```
   temp1 = headA
   temp2 = headB
   ```
2. Traverse both lists simultaneously.
3. If `temp1` or `temp2` becomes `nullptr`, redirect it to the head of the other list.
4. Continue until `temp1 == temp2`.
5. Return either `temp1` or `nullptr` if no intersection.

---

## ✅ Full Code (with main function to test)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* temp1 = headA;
    ListNode* temp2 = headB;

    while (temp1 != temp2) {
        temp1 = (temp1 == nullptr) ? headB : temp1->next;
        temp2 = (temp2 == nullptr) ? headA : temp2->next;
    }
    return temp1;  // intersection node or nullptr
}

// Utility: build list from vector
ListNode* buildList(const vector<int>& vals) {
    if (vals.empty()) return nullptr;
    ListNode* head = new ListNode(vals[0]);
    ListNode* tail = head;
    for (int i = 1; i < vals.size(); i++) {
        tail->next = new ListNode(vals[i]);
        tail = tail->next;
    }
    return head;
}

// Utility: print list
void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << "\n";
}

// Example demo
int main() {
    // Creating intersection manually:
    // A: 4 -> 1 -> 8 -> 4 -> 5
    // B:      5 -> 6 -> 1 ↘
    //                      8 -> 4 -> 5

    ListNode* common = buildList({8, 4, 5});

    ListNode* headA = new ListNode(4);
    headA->next = new ListNode(1);
    headA->next->next = common;

    ListNode* headB = new ListNode(5);
    headB->next = new ListNode(6);
    headB->next->next = new ListNode(1);
    headB->next->next->next = common;

    cout << "List A: ";
    printList(headA);
    cout << "List B: ";
    printList(headB);

    ListNode* intersection = getIntersectionNode(headA, headB);

    if (intersection)
        cout << "Intersection at node with value: " << intersection->val << "\n";
    else
        cout << "No intersection.\n";

    return 0;
}
```

---

## 🧮 Complexity Analysis

| Type      | Complexity | Explanation                              |
| --------- | ---------- | ---------------------------------------- |
| **Time**  | `O(m + n)` | Each pointer traverses both lists once.  |
| **Space** | `O(1)`     | No extra data structures, just pointers. |

---

## 🧪 Test Cases

| Input (List A & B)               | Output            | Explanation     |
| -------------------------------- | ----------------- | --------------- |
| A = [1,9,1,2,4], B = [3,2,4]     | Node with val = 2 | Intersects at 2 |
| A = [2,6,4], B = [1,5]           | nullptr           | No intersection |
| A = [1,2,3], B = [3] (same node) | Node with val = 3 | Shared node     |
| A = [], B = []                   | nullptr           | Empty lists     |

---

## 🧭 Alternate Approach (Brute Force)

1. For each node in `headA`, check every node in `headB` for equality (same address).
2. If found, return that node.

**Complexity:**

* Time: `O(m * n)` — very slow for large lists.
* Space: `O(1)`.

---

## ⚙️ Hashing Approach (Intermediate)

1. Store all nodes of `headA` in a hash set.
2. Traverse `headB` — first node found in the set is the intersection.

**Complexity:**

* Time: `O(m + n)`
* Space: `O(m)` — needs extra memory.

Used when constant-space pointer-switch trick isn’t obvious.

---

## 💡 Key Observations

* The intersection is defined by **node reference**, *not by value*.
* Both lists may have different lengths before intersection.
* Once pointers are equal (`temp1 == temp2`), that node is the intersection (same memory address).

---

## 🧭 Dry Run Example

```
A = [4, 1, 8, 4, 5]
B = [5, 6, 1, 8, 4, 5]

Initial:
p1 = 4 (A)
p2 = 5 (B)

Move both → eventually:
p1 = nullptr → switch to B’s head (5)
p2 = nullptr → switch to A’s head (4)

Now both have traveled equal total distance (lenA + lenB)
→ they meet at node with val = 8.
```

---

## ⚡ Tips & Tricks

* Intersection depends on **pointer equality**, not values.
* The switching logic works even if there is **no intersection** (both become `nullptr` together).
* This is a common **interview problem** to test pointer manipulation and logic reasoning.

---

## 🔄 Related Problems

* 🧭 *Detect cycle in a linked list* (Floyd’s algorithm)
* 🔁 *Find start node of cycle*
* 🔃 *Find length of cycle*
* 🧱 *Merge two sorted linked lists*

---

## ❓ FAQs

**Q1. Why do we reset pointers to the other list?**
→ This ensures both traverse the **same total distance**. After one full pass + switching, they align.

**Q2. What if there’s no intersection?**
→ Both reach `nullptr` simultaneously — return `nullptr`.

**Q3. Does this modify the lists?**
→ No. It only reads and moves pointers.

**Q4. Why not count lengths?**
→ Counting works too (subtract lengths and advance the longer one), but the two-pointer trick is **cleaner and faster to implement**.

---
