# Merge nodes between Zeros ➕0️⃣

### Problem statement 📝

You are given the head of a linked list which contains integers. The list always starts with `0` and ends with `0`, and there are zero or more groups of nodes between zeros. For each contiguous group of non-zero nodes between two zeros, compute the sum of node values in that group and append that sum as one node in a new resulting linked list. Return the head of the new list (the result should not include zeros).

>Input:
```
0 -> 3 -> 1 -> 0 -> 4 -> 5 -> 2 -> 0
```

> Output:

```
4 -> 11
```

Assumptions (typical LeetCode variant):

* Input always has at least two zeros (start and end).
* Groups between zeros are non-empty (there is at least one non-zero between zeros).
* You may create new nodes for the result (or reuse nodes if you prefer an in-place variant).

---

### Intuition ✨

Walk the list skipping the initial zero. Maintain a running `sum` of values until you encounter the next `0`. When you hit a `0`, the group ended — append `sum` as a node to the result list, then reset `sum` to `0` and continue. Repeat until you reach the final `0`.

This is naturally a single-pass algorithm: **one traversal**, O(n) time, constant extra space (besides the result).


### Brute force (conceptual) 🐌

You could copy values into arrays, group between zero indices, compute sums and build result — but that uses extra memory and is unnecessary. The one-pass streaming approach is simplest and optimal.


### Correct approach ✅

**Algorithm (safe iterative):**

1. Create a stack-allocated dummy node `ListNode dummy(0); ListNode* tail = &dummy;`.
2. Set `curr = head->next` (skip initial zero). Use a defensiveness: if `head == nullptr` return `nullptr`.
3. Initialize `sum = 0`.
4. While `curr != nullptr`:

   * If `curr->val != 0`: `sum += curr->val`.
   * Else (`curr->val == 0`): create `tail->next = new ListNode(sum)`, `tail = tail->next`, reset `sum = 0`.
   * Move `curr = curr->next`.
5. Return `dummy.next`.

This ensures:

* You only append sums when you hit a delimiter zero.
* You never dereference null pointers.
* You use a stack dummy node (no heap leak).


### Iterative implementation

```cpp
    ListNode* mergeNodes(ListNode* head) {
        if (!head) return nullptr;           // defensive
        ListNode dummy(0);
        ListNode* tail = &dummy;

        ListNode* curr = head->next;         // skip initial zero
        int sum = 0;
        while (curr != nullptr) {
            if (curr->val == 0) {
                // end of group
                tail->next = new ListNode(sum);
                tail = tail->next;
                sum = 0;
            } else {
                sum += curr->val;
            }
            curr = curr->next;
        }
        return dummy.next;
    }
```


### Recursive implementation [I prefer this]

* **Step 1:**
  Skip the first `0`, because it’s just a marker and not part of the sum.

  ```cpp
  head = head->next;
  ```

* **Step 2:**
  If the list is empty now (`head == nullptr`), just return — nothing more to merge.

* **Step 3:**
  Create a temporary pointer `temp` starting at `head`, and initialize a `sum = 0`.

* **Step 4:**
  Move through the list, adding values until you hit the next `0`.
  This loop accumulates all the values between two zeros.

  ```cpp
  while (temp != nullptr && temp->val != 0) {
      sum += temp->val;
      temp = temp->next;
  }
  ```

* **Step 5:**
  Replace the current node’s value (`head->val`) with the sum you just calculated.

* **Step 6:**
  Recursively call the same function on `temp` (which now points to the next `0`),
  to process the rest of the list.
  Link the current node’s `next` pointer to the result of that recursive call.

* **Step 7:**
  Return the `head` node — which now represents one merged node of the new list.



Each recursive call processes **one segment** between zeros, computes its sum,
and connects it to the result of processing the remaining segments.

So conceptually:

```
(0) [3,1] (0) [4,5,2] (0)
→ compute sum(3+1)=4, link it to merge([4,5,2])
→ compute sum(4+5+2)=11
→ link and return
```

```cpp
    ListNode* mergeNodes(ListNode* head) {
        head = head->next;
        if (head == nullptr)
            return head;
        ListNode* temp = head;    
        int sum = 0;
        while (temp != nullptr && temp->val != 0) {
            sum += temp->val;
            temp = temp->next;
        }
        head->val = sum;
        head->next = mergeNodes(temp);
        return head;
    }
```


### In-place variant (reuse nodes) 🔁♻️

If you must **not allocate new nodes** and instead reuse nodes from the input (some problems accept this), you can accumulate sums into the node immediately following each zero (or into the zero node itself) and relink. This is trickier and more error-prone; the above *allocate-new-node* approach is simpler and clean. If desired, I can provide an in-place variant.


## Complexity analysis 📊

* **Time complexity:** `O(n)` where `n` is the number of nodes in input — single pass.
* **Space complexity:** `O(m)` where `m` is the number of groups (result nodes) because we allocate one node per group. Additional *auxiliary* space is `O(1)`.

If you implement in-place reusing nodes, extra space is `O(1)`.


### Test cases & expected outputs 🧪

1. **Example**

   * Input: `0 -> 3 -> 1 -> 0 -> 4 -> 5 -> 2 -> 0`
   * Output: `4 -> 11`

2. **Single group**

   * Input: `0 -> 5 -> 6 -> 0` → Output: `11`

3. **Multiple groups**

   * Input: `0 -> 1 -> 0 -> 2 -> 0 -> 3 -> 0` → Output: `1 -> 2 -> 3`

4. **Minimum valid list**

   * Input: `0 -> 0` → Output: (empty list) — depending on problem statement this may be invalid; if valid, there are no groups and you should return `nullptr`.

5. **Malformed / defensive**

   * Input: `nullptr` → return `nullptr`.
   * Input: `0 -> 1 -> 2` (no trailing zero) — defensive code returns the sum only when it sees a terminating zero; behavior undefined if problem guarantees trailing zero.

6. **Large input**

   * Performance: linear.


### Tips & tricks ✨

* **Always check pointers before dereference** — `if (cur && cur->val == 0)` or reorder conditions `cur != nullptr && cur->val != 0`.
* Use a **stack-allocated dummy** (`ListNode dummy(0)`) to avoid small heap-leaks from `new`ing the dummy head.
* Be explicit about assumptions: if the input *guarantees* leading and trailing zeros and non-empty groups, code is simpler; otherwise add defensive checks.
* If memory allocation is a concern, consider **reusing nodes** instead of allocating new ones.
* For readability, isolate group-processing logic into a helper function (see recursive `mergeFrom`).


### Variations & extensions 🔁

* **Return list of sums as vector<int>** if you don't need a linked-list output.
* **In-place merging**: overwrite the first element of each group with the sum and relink to remove the nodes between zeros (saves allocations).
* **Allow zeros within groups**: if zeros may appear inside groups and delimiter is something else, adjust logic.
* **Streaming version**: if numbers come as a stream with separators, you can output sums on-the-fly.

### FAQs ❓

**Q: Why create new nodes instead of reusing?**
> A: Creating new nodes simplifies logic and avoids pointer-surgery on the input list; it’s typically accepted. Reusing nodes can be done but is more bug-prone.

**Q: What if input lacks final zero?**
> A: Problem statements usually guarantee final zero. If not, you must decide whether to append the final `sum` at the end of traversal.

**Q: Are zeros allowed consecutively?**
> A: If zeros may be consecutive (e.g., `0 -> 0`), that indicates an empty group. Your implementation should decide whether to append `0` or skip (usually skip empty groups). The canonical LeetCode problem guarantees non-empty groups.

**Q: Should result contain zeros?**
> A: No — result nodes are group sums only (non-zero).
