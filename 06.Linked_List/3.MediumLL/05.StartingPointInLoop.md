# üß≠ Find the Starting Node of Cycle in a Linked List

**(Floyd‚Äôs Tortoise and Hare Algorithm ‚Äî Extended)**

---

## üß© Problem Statement

> Given the `head` of a linked list, return the **node where the cycle begins**.
> If there is **no cycle**, return `nullptr`.

---

### üß† Example

#### ‚úÖ Example 1: Cycle Exists

```
Input: head = [3,2,0,-4], pos = 1
Output: node with value 2
Explanation: Tail connects to node index 1 ‚Üí cycle starts at node 2.
```

#### ‚ùå Example 2: No Cycle

```
Input: head = [1,2], pos = -1
Output: nullptr
Explanation: No cycle present in the list.
```

---

## üí≠ Intuition

We already know from the previous problem how to **detect if a cycle exists** using **slow** and **fast** pointers.
But once we confirm there *is* a cycle, how do we find *where* it starts?

Let‚Äôs break it down with Floyd‚Äôs mathematical insight üëá

---

## üßÆ Conceptual Understanding

Let‚Äôs say:

* The **head** of the list is at point **A**.
* The **cycle starts** at node **C**.
* **slow** and **fast** meet at point **M** inside the cycle.

We define:

* `d1` = distance from head to start of cycle (A ‚Üí C)
* `d2` = distance from start of cycle to meeting point (C ‚Üí M)
* `d3` = remaining distance from M ‚Üí C (to complete the loop)

---

### üìê Key Observation

At the meeting point:

```
Distance covered by slow = d1 + d2
Distance covered by fast = d1 + d2 + n*(d2 + d3)   // n full loops
```

Since `fast` moves twice as fast:

```
2 * (d1 + d2) = d1 + d2 + n*(d2 + d3)
=> d1 = n*(d2 + d3) - d2
=> d1 = (n-1)*(d2 + d3) + d3
```

This means:

> If we move one pointer from **head** and another from the **meeting point**, both moving **one step at a time**, they‚Äôll meet at the **start of the cycle**.

That‚Äôs the magic formula! ‚ú®

---

## üß© Step-by-Step Algorithm

1. **Check for empty or single-node list**

   * If `head == nullptr` or `head->next == nullptr`, no cycle possible ‚Üí return `nullptr`.

2. **Use Floyd‚Äôs Cycle Detection**

   * Move `slow` by 1 and `fast` by 2 until:

     * They meet ‚Üí cycle exists.
     * Or `fast`/`fast->next` becomes `nullptr` ‚Üí no cycle.

3. **Find start of cycle**

   * When they meet, move `slow` back to `head`.
   * Move both `slow` and `fast` one step at a time.
   * The node where they meet again ‚Üí **start of the cycle**.

---

## üß© Optimal Code Implementation

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        if (head == nullptr || head->next == nullptr)
            return nullptr;

        ListNode* slow = head;
        ListNode* fast = head;

        // Phase 1: Detect if a cycle exists
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;

            if (slow == fast) // Cycle detected
                break;
        }

        // Phase 2: Find the start node of the cycle
        if (slow == fast) {
            slow = head;  // Move slow to head
            while (slow != fast) {
                slow = slow->next;
                fast = fast->next;
            }
            return slow;  // Both meet at start of cycle
        }

        return nullptr;  // No cycle
    }
};
```

---

## üîç Dry Run Example

Let‚Äôs visualize the list:

```
3 ‚Üí 2 ‚Üí 0 ‚Üí -4
      ‚Üë       |
      |_______|
```

| Step | slow                       | fast                    | Comment                        |
| ---- | -------------------------- | ----------------------- | ------------------------------ |
| 1    | 3                          | 3                       | Start                          |
| 2    | 2                          | 0                       | slow +1, fast +2               |
| 3    | 0                          | 2                       | slow +1, fast +2               |
| 4    | -4                         | -4                      | Meet at node -4 ‚áí cycle exists |
| 5    | slow = head (3), fast = -4 | Now move both +1        |                                |
| 6    | slow = 2, fast = 2         | Meet ‚áí Start of cycle ‚úÖ |                                |

---

## üß™ Test Cases

| Input        | pos | Output    | Explanation                    |
| ------------ | --- | --------- | ------------------------------ |
| `[3,2,0,-4]` | 1   | node(2)   | Tail connects to node 2        |
| `[1,2]`      | 0   | node(1)   | Cycle starts at head           |
| `[1,2,3]`    | -1  | `nullptr` | No cycle                       |
| `[1]`        | -1  | `nullptr` | Single node, no cycle          |
| `[1]`        | 0   | node(1)   | Single node pointing to itself |

---

## ‚è±Ô∏è Complexity Analysis

| Metric    | Complexity | Explanation                         |
| --------- | ---------- | ----------------------------------- |
| **Time**  | O(N)       | Each node visited at most twice     |
| **Space** | O(1)       | Constant space, no extra structures |

---

## ‚öôÔ∏è Full Testable Code (with Input Simulation)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* detectCycle(ListNode* head) {
    if (head == nullptr || head->next == nullptr)
        return nullptr;

    ListNode* slow = head;
    ListNode* fast = head;

    // Detect cycle
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)
            break;
    }

    // Find start node
    if (slow == fast) {
        slow = head;
        while (slow != fast) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
    return nullptr;
}

int main() {
    // Create linked list: 3 -> 2 -> 0 -> -4
    ListNode* head = new ListNode(3);
    head->next = new ListNode(2);
    head->next->next = new ListNode(0);
    head->next->next->next = new ListNode(-4);

    // Create cycle: tail connects to node 2
    head->next->next->next->next = head->next;

    ListNode* cycleNode = detectCycle(head);
    if (cycleNode)
        cout << "Cycle starts at node with value: " << cycleNode->val << " ‚úÖ" << endl;
    else
        cout << "No cycle detected ‚ùå" << endl;

    return 0;
}
```

---

## üí° Tips & Tricks

* **Cycle detected first, not found immediately!**

  * You must *first confirm a cycle exists* before trying to locate its start.
* **Two phases, one insight:**

  * Phase 1 ‚Üí Detect loop
  * Phase 2 ‚Üí Identify entry point
* **Avoid premature slow reset** before the first meeting.
* Great follow-up question after *‚ÄúDetect Cycle in Linked List‚Äù*.

---

## üß± Variations

| Variant                    | Description                                         |
| -------------------------- | --------------------------------------------------- |
| üîÅ **Detect cycle (bool)** | Return true/false ‚Äî Leetcode #141                   |
| üîç **Find start of cycle** | Current problem ‚Äî Leetcode #142                     |
| üîÑ **Remove cycle**        | After finding start, set last node‚Äôs next = nullptr |
| üìè **Cycle length**        | Count nodes after meeting until pointers meet again |

---

## ‚ùì FAQs

**Q1: Why reset `slow` to head after the meeting?**

> Because the distance from head to cycle start equals the distance from meeting point to cycle start.

**Q2: Can we find cycle start without detecting first?**

> No ‚Äî we must first know *where* they meet to use the distance relationship.

**Q3: What if the cycle starts at the head?**

> Works perfectly ‚Äî both pointers will meet at the head after the reset.

**Q4: Can we modify the list to mark visited nodes?**

> Not recommended ‚Äî breaks the list‚Äôs structure and violates immutability in interviews.

---
