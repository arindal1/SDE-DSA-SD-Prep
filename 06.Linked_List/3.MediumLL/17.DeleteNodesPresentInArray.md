# Remove Nodes whose values appear in a given Array üß©üîó


## Problem statement üìù

You are given:

* An integer array `nums` (may contain distinct values or duplicates), and
* The head of a singly-linked list `head`.

Remove **every node** from the linked list whose `val` appears in `nums`. Return the head of the modified list.

**Example**

```
nums = [2,5]
head = 1 -> 2 -> 3 -> 5 -> 4 -> 2

Output: 1 -> 3 -> 4
```


### Intuition ‚ú®

We need fast membership checks of whether a node's value is in `nums`. Converting `nums` into an `unordered_set<int>` gives average O(1) lookups. Then we iterate the list once, keeping a pointer to the previous node (`prev`), and:

* If current node's value is in the set ‚Üí skip it by `prev->next = cur->next` (or move head if `prev` is null), and free the removed node if you want to avoid memory leaks.
* Otherwise ‚Üí advance `prev` to `cur`.

This single pass removes all matching nodes in linear time.


### Brute-force alternative (not recommended) üêå

A naive approach would, for each value in `nums`, scan the entire list and remove matching nodes. That is `O(m * n)` time in the worst case and is inefficient if `m` and `n` are large. The hash-set approach is both simpler and faster.



### Improved CPP code ‚úÖ


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

ListNode* modifiedList(const vector<int>& nums, ListNode* head) {
    if (!head) return head;

    // Build membership set
    unordered_set<int> s(nums.begin(), nums.end());

    // Dummy simplifies deletions at the head
    ListNode dummy(0);
    dummy.next = head;
    ListNode* prev = &dummy;
    ListNode* cur = head;

    while (cur != nullptr) {
        ListNode* nextNode = cur->next;
        if (s.find(cur->val) != s.end()) {
            // unlink and free cur
            prev->next = nextNode;
            delete cur; // avoid memory leak (do this unless memory ownership disallows)
        } else {
            prev = cur;
        }
        cur = nextNode;
    }

    return dummy.next;
}
```

> If your runtime environment (like LeetCode) doesn‚Äôt require deleting nodes (they run tests in short-lived processes), you can omit `delete cur`. But in production code freeing removed nodes is best practice.


### Why use a dummy node? ü§î

> A dummy node placed before the `head` avoids special-casing removals at the head. Without a dummy, removing head needs separate code to reassign `head = head->next`. Dummy simplifies logic: always update `prev->next`.


### Complexity analysis üìä

Let `m = nums.size()` and `n = number of nodes in the list`.

* **Time complexity:**

  * Building the unordered set: `O(m)` average (hashing each value).
  * Single pass through the list: `O(n)` average.
  * **Total:** `O(n + m)` average-case.
* **Space complexity:**

  * `O(m)` extra for the hash set (worst-case all `m` distinct).

---

### Test cases & examples üß™

1. **Basic removal**

   * `nums = [2,5]`
     `head = 1->2->3->5->4->2` ‚Üí result `1->3->4`

2. **Remove head nodes**

   * `nums = [1]`
     `head = 1->1->2` ‚Üí result `2`

3. **Remove all nodes**

   * `nums = [1]`
     `head = 1->1->1` ‚Üí result `nullptr` (empty list)

4. **No removals**

   * `nums = [7]`
     `head = 1->2->3` ‚Üí result unchanged `1->2->3`

5. **Empty list**

   * `nums = [1,2]`, `head = nullptr` ‚Üí result `nullptr`

6. **Duplicates in nums**

   * `nums = [2,2,3]` behaves the same as `[2,3]` ‚Äî set handles duplicates.

7. **Large input**

   * `nums` large, list large ‚Üí performance remains linear.


### Edge cases & gotchas ‚ö†Ô∏è

* **`nums` empty:** nothing removed ‚Äî return original `head`.
* **Large integer values:** `unordered_set<int>` accepts any 32-bit int; if values exceed `int` range, use `long long` and matching set type.
* **Memory ownership:** If the list nodes are managed elsewhere (smart pointers, memory pools), do **not** `delete` them. Adjust behavior to the ownership model.
* **Thread-safety:** This function is not thread-safe; if multiple threads may modify shared lists, add synchronization.

### Variations & extensions üîÅ

* **Return count of removed nodes** ‚Äî track a counter when deleting.
* **Remove nodes not in `nums`** ‚Äî change set to contain allowed values and keep only nodes whose value is in the set.
* **Remove nodes by predicate** ‚Äî generalize: remove if `predicate(node->val)` is true.
* **Filter in-place but keep memory** ‚Äî unlink nodes but don‚Äôt free, returning a second list of removed nodes for later processing.
* **Multi-list cleanup** ‚Äî apply same `nums` set to multiple lists efficiently.


### Tips & best practices ‚úÖ

* Use `unordered_set` for average O(1) membership; use `std::set` (ordered) only if you need ordered iteration or guaranteed worst-case behavior (but `set` operations are O(log m)).
* Use a dummy node to simplify head deletion logic.
* Free removed nodes (with `delete`) if you own them; in managed environments (smart pointers), rely on RAII.
* If `nums` is very large and memory is constrained, consider sorting `nums` and using two-pointer or binary_search per node (`O(n log m)`), but usually hash-set is best.


### Frequently Asked Questions (FAQs) ‚ùì

**Q: If `nums` contains duplicates, does it matter?**
> A: No. We convert `nums` to an `unordered_set`, so duplicates collapse. Behavior is unchanged.

**Q: Should I worry about overflow or value ranges?**
> A: Use the same integer type the list uses. If list values are `int`, `unordered_set<int>` is fine.

**Q: Is the removal stable?**
> A: The relative order of the remaining nodes is preserved because we only splice out nodes; we don't reorder nodes.

**Q: Can I do this in-place without extra space?**
> A: In general no, because you need to check membership of each node against `nums`. If `nums` is stored in a data structure with O(1) membership (like a boolean hash table for a small value range), you can avoid extra dynamic memory. But typically `O(m)` extra space for the set is acceptable.

**Q: What if I must keep deleted nodes for later?**
> A: Instead of `delete`ing, splice removed nodes to a separate list (e.g., `removedTail->next = cur`) and return both lists or process later.
