# ðŸ§® Find the Length of Loop in a Linked List

**(Using Floydâ€™s Cycle Detection Algorithm)**

---

## ðŸ§© Problem Statement

> Given the `head` of a singly linked list, return the **length of the cycle (loop)** if it exists.
> If there is **no cycle**, return **0**.

---

### ðŸ“˜ Example 1

```
Input: head = [1,2,3,4,5], tail connects to node index 1
Output: 4
Explanation: The cycle is 2 â†’ 3 â†’ 4 â†’ 5 â†’ 2 â†’ ... (length = 4)
```

---

### ðŸ“˜ Example 2

```
Input: head = [1,2,3,4,5], no cycle
Output: 0
```

---

## ðŸ§  Intuition

This problem builds on the **Floydâ€™s Cycle Detection Algorithm (Tortoise and Hare)**.
We already know how to **detect** if a loop exists â€” using **slow** and **fast** pointers.

Now, once we *find* the point where both meet inside the cycle ðŸŒ€, we can easily determine **the cycle length**.

Hereâ€™s the idea:

> After the first meeting point inside the loop, keep one pointer fixed, and move the other one step at a time until they meet again.
> The number of steps taken = **length of the cycle** âœ…

---

## ðŸªœ Step-by-Step Algorithm

### ðŸ”¹ Step 1: Detect if there is a cycle

Use the standard **Floydâ€™s algorithm**:

* Initialize two pointers `slow` and `fast` at `head`.
* Move `slow` one step, `fast` two steps.
* If they ever meet â†’ cycle exists.
* If `fast` or `fast->next` becomes `nullptr` â†’ no cycle.

### ðŸ”¹ Step 2: Find cycle length

* Keep one pointer (`slow`) fixed at the meeting point.
* Move another pointer (`temp`) step by step through the loop.
* Count how many steps it takes to reach back to the same node.

That count = **length of the cycle**.

---

## ðŸ’¡ Example Walkthrough

Letâ€™s take this linked list:

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5
        â†‘       â†“
        â†â€“â€“â€“â€“â€“â€“â€“
```

* slow and fast both start at 1.
* After a few steps, they meet at node 4.

Now, to find loop length:

* Keep `slow` at 4.
* Move another pointer until it reaches 4 again:

  * 4 â†’ 5 â†’ 3 â†’ 4 â†’ stop.
* Steps = 3 â†’ loop length = **3**

---

## ðŸ§© Brute Force Approach (âŒ)

1. Traverse each node and store visited nodes in a `set`.
2. If a node is revisited â†’ start of loop found.
3. Continue until same node appears again â†’ count nodes.

### âŒ Disadvantages:

* Time Complexity: O(N)
* Space Complexity: O(N)
* Not optimal â€” uses extra space.

---

## âš¡ Optimal Approach (âœ… Using Floydâ€™s Algorithm)

### âœ¨ Core Idea

We can reuse the **meeting point** from Floydâ€™s cycle detection phase and simply traverse the cycle once more to count its nodes.

---

### âœ… C++ Implementation

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    int countCycleLength(ListNode* head) {
        if (head == nullptr || head->next == nullptr)
            return 0;

        ListNode* slow = head;
        ListNode* fast = head;

        // Phase 1: Detect if a cycle exists
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;

            if (slow == fast) { // Cycle detected
                return countLength(slow);
            }
        }

        return 0; // No cycle
    }

private:
    int countLength(ListNode* meetingNode) {
        int length = 1;
        ListNode* temp = meetingNode->next;

        while (temp != meetingNode) {
            length++;
            temp = temp->next;
        }
        return length;
    }
};
```

---

## ðŸ§  Function Explanation

### `countCycleLength()`

* Detects cycle using two-pointer method.
* If `slow == fast`, it means weâ€™re inside a loop.
* Calls `countLength(slow)` to measure loop size.

### `countLength()`

* Starts counting from the meeting node.
* Moves one pointer through the loop.
* Stops when it returns to the same node.
* Returns the count (loop size).

---

## ðŸ§ª Dry Run Example

### Input:

```
head = [1,2,3,4,5], tail connects to node 2
```

**Execution Table:**

| Step | slow | fast | Comment               |
| ---- | ---- | ---- | --------------------- |
| 1    | 1    | 1    | start                 |
| 2    | 2    | 3    | move pointers         |
| 3    | 3    | 5    | move pointers         |
| 4    | 4    | 3    | move pointers         |
| 5    | 5    | 5    | meet â†’ cycle detected |

**Now count loop length:**

* Start from node 5.
* Move next â†’ 3 â†’ 4 â†’ 5 â†’ stop.
* Count = 3.

âœ… **Cycle Length = 3**

---

## ðŸ§¾ Full Testable Code with Input Simulation

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

int countLength(ListNode* meetingNode) {
    int length = 1;
    ListNode* temp = meetingNode->next;

    while (temp != meetingNode) {
        length++;
        temp = temp->next;
    }
    return length;
}

int countCycleLength(ListNode* head) {
    if (head == nullptr || head->next == nullptr)
        return 0;

    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) {
            return countLength(slow);
        }
    }
    return 0;
}

int main() {
    // Create linked list: 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    // Create cycle: tail connects to node 2
    head->next->next->next->next->next = head->next;

    int len = countCycleLength(head);
    if (len)
        cout << "Cycle length: " << len << " âœ…" << endl;
    else
        cout << "No cycle detected âŒ" << endl;

    return 0;
}
```

---

## â±ï¸ Complexity Analysis

| Metric    | Complexity | Explanation                              |
| --------- | ---------- | ---------------------------------------- |
| **Time**  | O(N)       | Traverses list once + one loop traversal |
| **Space** | O(1)       | Constant space, no extra DS used         |

---

## ðŸ§© Test Cases

| Linked List   | Cycle Connection | Output | Explanation      |
| ------------- | ---------------- | ------ | ---------------- |
| `[1,2,3,4,5]` | Tail â†’ Node(2)   | 4      | Loop is 2â†’3â†’4â†’5  |
| `[1,2,3,4]`   | Tail â†’ Node(3)   | 2      | Loop is 3â†’4      |
| `[1,2]`       | No cycle         | 0      | No loop present  |
| `[1]`         | Head â†’ Head      | 1      | Single node loop |

---

## ðŸ§± Variations

| Problem                    | Description                            |
| -------------------------- | -------------------------------------- |
| ðŸ”¹ Detect if loop exists   | Return true/false                      |
| ðŸ”¹ Find length of loop     | Current problem                        |
| ðŸ”¹ Find start node of loop | Using Floyd + reset slow               |
| ðŸ”¹ Remove loop             | Detect + find last node and break link |

---

## ðŸª„ Tips & Tricks

* **Meeting point logic is key!**
  Always reuse the intersection node to measure loop properties.
* Keep helper functions (`countLength`) modular for clean code.
* Donâ€™t try to â€œguessâ€ the cycle length during traversal â€” detect first.
* Combine this with *start node detection* for advanced problems.

---

## â“ FAQs

**Q1: Can I find length without detecting first?**

> No. You must first confirm a cycle exists; otherwise, traversal can run infinitely.

**Q2: What happens if the loop starts at the head?**

> Works fine â€” meeting node will still be part of the loop.

**Q3: What if there is no cycle?**

> `fast` or `fast->next` becomes `nullptr` â†’ return 0.

**Q4: Why not just count all visited nodes?**

> That would require O(N) extra space â€” inefficient for large lists.

---
