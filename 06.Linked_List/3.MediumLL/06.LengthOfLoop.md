# 🧮 Find the Length of Loop in a Linked List

**(Using Floyd’s Cycle Detection Algorithm)**

---

## 🧩 Problem Statement

> Given the `head` of a singly linked list, return the **length of the cycle (loop)** if it exists.
> If there is **no cycle**, return **0**.

---

### 📘 Example 1

```
Input: head = [1,2,3,4,5], tail connects to node index 1
Output: 4
Explanation: The cycle is 2 → 3 → 4 → 5 → 2 → ... (length = 4)
```

---

### 📘 Example 2

```
Input: head = [1,2,3,4,5], no cycle
Output: 0
```

---

## 🧠 Intuition

This problem builds on the **Floyd’s Cycle Detection Algorithm (Tortoise and Hare)**.
We already know how to **detect** if a loop exists — using **slow** and **fast** pointers.

Now, once we *find* the point where both meet inside the cycle 🌀, we can easily determine **the cycle length**.

Here’s the idea:

> After the first meeting point inside the loop, keep one pointer fixed, and move the other one step at a time until they meet again.
> The number of steps taken = **length of the cycle** ✅

---

## 🪜 Step-by-Step Algorithm

### 🔹 Step 1: Detect if there is a cycle

Use the standard **Floyd’s algorithm**:

* Initialize two pointers `slow` and `fast` at `head`.
* Move `slow` one step, `fast` two steps.
* If they ever meet → cycle exists.
* If `fast` or `fast->next` becomes `nullptr` → no cycle.

### 🔹 Step 2: Find cycle length

* Keep one pointer (`slow`) fixed at the meeting point.
* Move another pointer (`temp`) step by step through the loop.
* Count how many steps it takes to reach back to the same node.

That count = **length of the cycle**.

---

## 💡 Example Walkthrough

Let’s take this linked list:

```
1 → 2 → 3 → 4 → 5
        ↑       ↓
        ←–––––––
```

* slow and fast both start at 1.
* After a few steps, they meet at node 4.

Now, to find loop length:

* Keep `slow` at 4.
* Move another pointer until it reaches 4 again:

  * 4 → 5 → 3 → 4 → stop.
* Steps = 3 → loop length = **3**

---

## 🧩 Brute Force Approach (❌)

1. Traverse each node and store visited nodes in a `set`.
2. If a node is revisited → start of loop found.
3. Continue until same node appears again → count nodes.

### ❌ Disadvantages:

* Time Complexity: O(N)
* Space Complexity: O(N)
* Not optimal — uses extra space.

---

## ⚡ Optimal Approach (✅ Using Floyd’s Algorithm)

### ✨ Core Idea

We can reuse the **meeting point** from Floyd’s cycle detection phase and simply traverse the cycle once more to count its nodes.

---

### ✅ C++ Implementation

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    int countCycleLength(ListNode* head) {
        if (head == nullptr || head->next == nullptr)
            return 0;

        ListNode* slow = head;
        ListNode* fast = head;

        // Phase 1: Detect if a cycle exists
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;

            if (slow == fast) { // Cycle detected
                return countLength(slow);
            }
        }

        return 0; // No cycle
    }

private:
    int countLength(ListNode* meetingNode) {
        int length = 1;
        ListNode* temp = meetingNode->next;

        while (temp != meetingNode) {
            length++;
            temp = temp->next;
        }
        return length;
    }
};
```

---

## 🧠 Function Explanation

### `countCycleLength()`

* Detects cycle using two-pointer method.
* If `slow == fast`, it means we’re inside a loop.
* Calls `countLength(slow)` to measure loop size.

### `countLength()`

* Starts counting from the meeting node.
* Moves one pointer through the loop.
* Stops when it returns to the same node.
* Returns the count (loop size).

---

## 🧪 Dry Run Example

### Input:

```
head = [1,2,3,4,5], tail connects to node 2
```

**Execution Table:**

| Step | slow | fast | Comment               |
| ---- | ---- | ---- | --------------------- |
| 1    | 1    | 1    | start                 |
| 2    | 2    | 3    | move pointers         |
| 3    | 3    | 5    | move pointers         |
| 4    | 4    | 3    | move pointers         |
| 5    | 5    | 5    | meet → cycle detected |

**Now count loop length:**

* Start from node 5.
* Move next → 3 → 4 → 5 → stop.
* Count = 3.

✅ **Cycle Length = 3**

---

## 🧾 Full Testable Code with Input Simulation

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

int countLength(ListNode* meetingNode) {
    int length = 1;
    ListNode* temp = meetingNode->next;

    while (temp != meetingNode) {
        length++;
        temp = temp->next;
    }
    return length;
}

int countCycleLength(ListNode* head) {
    if (head == nullptr || head->next == nullptr)
        return 0;

    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) {
            return countLength(slow);
        }
    }
    return 0;
}

int main() {
    // Create linked list: 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    // Create cycle: tail connects to node 2
    head->next->next->next->next->next = head->next;

    int len = countCycleLength(head);
    if (len)
        cout << "Cycle length: " << len << " ✅" << endl;
    else
        cout << "No cycle detected ❌" << endl;

    return 0;
}
```

---

## ⏱️ Complexity Analysis

| Metric    | Complexity | Explanation                              |
| --------- | ---------- | ---------------------------------------- |
| **Time**  | O(N)       | Traverses list once + one loop traversal |
| **Space** | O(1)       | Constant space, no extra DS used         |

---

## 🧩 Test Cases

| Linked List   | Cycle Connection | Output | Explanation      |
| ------------- | ---------------- | ------ | ---------------- |
| `[1,2,3,4,5]` | Tail → Node(2)   | 4      | Loop is 2→3→4→5  |
| `[1,2,3,4]`   | Tail → Node(3)   | 2      | Loop is 3→4      |
| `[1,2]`       | No cycle         | 0      | No loop present  |
| `[1]`         | Head → Head      | 1      | Single node loop |

---

## 🧱 Variations

| Problem                    | Description                            |
| -------------------------- | -------------------------------------- |
| 🔹 Detect if loop exists   | Return true/false                      |
| 🔹 Find length of loop     | Current problem                        |
| 🔹 Find start node of loop | Using Floyd + reset slow               |
| 🔹 Remove loop             | Detect + find last node and break link |

---

## 🪄 Tips & Tricks

* **Meeting point logic is key!**
  Always reuse the intersection node to measure loop properties.
* Keep helper functions (`countLength`) modular for clean code.
* Don’t try to “guess” the cycle length during traversal — detect first.
* Combine this with *start node detection* for advanced problems.

---

## ❓ FAQs

**Q1: Can I find length without detecting first?**

> No. You must first confirm a cycle exists; otherwise, traversal can run infinitely.

**Q2: What happens if the loop starts at the head?**

> Works fine — meeting node will still be part of the loop.

**Q3: What if there is no cycle?**

> `fast` or `fast->next` becomes `nullptr` → return 0.

**Q4: Why not just count all visited nodes?**

> That would require O(N) extra space — inefficient for large lists.

---
