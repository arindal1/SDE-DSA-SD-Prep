# 🧠 Reverse a Singly Linked List

## 🧩 Problem Statement

> Given the `head` of a singly linked list, reverse the list and return the new head.

**Example:**

```
Input:  1 → 2 → 3 → 4 → 5 → NULL  
Output: 5 → 4 → 3 → 2 → 1 → NULL
```

---

## 💭 Intuition

When we “reverse” a linked list, every node’s `next` pointer should point to its **previous** node instead of the next one.

The trick is —
👉 *At any moment, we need to carefully rearrange pointers so that no link gets lost.*


## ⚙️ Iterative Method (Optimal and Efficient)

### 🧩 Code

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp = head;
        ListNode* prev = nullptr;
        ListNode* front = nullptr;

        while (temp != nullptr) {
            front = temp->next;   // Save next node
            temp->next = prev;    // Reverse pointer
            prev = temp;          // Move prev forward
            temp = front;         // Move temp forward
        }
        return prev; // prev becomes the new head
    }
};
```

---

### 🔍 Step-by-Step Example

Initial list:

```
1 → 2 → 3 → 4 → 5 → NULL
```

| Iteration | temp | prev | Operation          | New Links           |
| --------- | ---- | ---- | ------------------ | ------------------- |
| 1         | 1    | NULL | Reverse `1 → NULL` | `1 ← NULL`          |
| 2         | 2    | 1    | Reverse `2 → 1`    | `2 → 1`             |
| 3         | 3    | 2    | Reverse `3 → 2`    | `3 → 2 → 1`         |
| 4         | 4    | 3    | Reverse `4 → 3`    | `4 → 3 → 2 → 1`     |
| 5         | 5    | 4    | Reverse `5 → 4`    | `5 → 4 → 3 → 2 → 1` |

Final: `prev` points to 5 — new head.

---

### ⚙️ Complexity Analysis

| Metric               | Complexity | Explanation               |
| -------------------- | ---------- | ------------------------- |
| **Time Complexity**  | O(N)       | Each node is visited once |
| **Space Complexity** | O(1)       | Only a few pointers used  |

---

## 🧩 Comparison Table

| Feature          | Recursive                | Iterative                |
| ---------------- | ------------------------ | ------------------------ |
| Simplicity       | ✅ Easy to understand     | ✅ Simple to code         |
| Space Complexity | ❌ O(N) (Stack)           | ✅ O(1)                   |
| Performance      | ⚠️ Slightly slower       | ⚡ Fastest                |
| Use case         | Small lists / conceptual | Production / performance |

---

## 🧪 Example Test Cases

```cpp
Input:  head = [1,2,3,4,5]
Output: [5,4,3,2,1]

Input:  head = [1,2]
Output: [2,1]

Input:  head = []
Output: []
```

---

## 💡 Tips & Tricks

* Always **store the next node** before breaking links.
* For recursive approach, ensure **base case correctness** — `(head == nullptr || head->next == nullptr)`.
* You can also **reverse only a subpart** of the linked list — this variation is used in “Reverse Linked List II”.

---

## 🧱 Variations

1. 🔁 **Reverse first `k` nodes**
2. 🎯 **Reverse nodes in k-groups** — Leetcode #25
3. 🔄 **Reverse between positions `left` and `right`**
4. 🪞 **Check if Linked List is Palindrome** (uses reversal of second half)

---

## 🧩 Full Testable Code (Iterative)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode* temp = head;
    ListNode* prev = nullptr;
    ListNode* front = nullptr;

    while (temp != nullptr) {
        front = temp->next;
        temp->next = prev;
        prev = temp;
        temp = front;
    }
    return prev;
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << "\n";
}

int main() {
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    cout << "Original List: ";
    printList(head);

    head = reverseList(head);

    cout << "Reversed List: ";
    printList(head);
}
```

---

## ❓ FAQs

**Q1: What happens if the list is empty?**

> It simply returns `nullptr`.

**Q2: Will recursion cause memory issues for large lists?**

> Yes. Recursion uses the call stack — for very long lists, prefer the iterative approach.

**Q3: Why return `prev` at the end (iterative)?**

> Because after the loop, `prev` points to the new head of the reversed list.

**Q4: Can we reverse the list in-place?**

> Yes — both approaches are *in-place* since they don’t allocate new nodes.

