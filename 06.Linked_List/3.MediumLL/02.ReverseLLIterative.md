# ğŸ§  Reverse a Singly Linked List

## ğŸ§© Problem Statement

> Given the `head` of a singly linked list, reverse the list and return the new head.

**Example:**

```
Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ NULL  
Output: 5 â†’ 4 â†’ 3 â†’ 2 â†’ 1 â†’ NULL
```

---

## ğŸ’­ Intuition

When we â€œreverseâ€ a linked list, every nodeâ€™s `next` pointer should point to its **previous** node instead of the next one.

The trick is â€”
ğŸ‘‰ *At any moment, we need to carefully rearrange pointers so that no link gets lost.*


## âš™ï¸ Iterative Method (Optimal and Efficient)

### ğŸ§© Code

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp = head;
        ListNode* prev = nullptr;
        ListNode* front = nullptr;

        while (temp != nullptr) {
            front = temp->next;   // Save next node
            temp->next = prev;    // Reverse pointer
            prev = temp;          // Move prev forward
            temp = front;         // Move temp forward
        }
        return prev; // prev becomes the new head
    }
};
```

---

### ğŸ” Step-by-Step Example

Initial list:

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ NULL
```

| Iteration | temp | prev | Operation          | New Links           |
| --------- | ---- | ---- | ------------------ | ------------------- |
| 1         | 1    | NULL | Reverse `1 â†’ NULL` | `1 â† NULL`          |
| 2         | 2    | 1    | Reverse `2 â†’ 1`    | `2 â†’ 1`             |
| 3         | 3    | 2    | Reverse `3 â†’ 2`    | `3 â†’ 2 â†’ 1`         |
| 4         | 4    | 3    | Reverse `4 â†’ 3`    | `4 â†’ 3 â†’ 2 â†’ 1`     |
| 5         | 5    | 4    | Reverse `5 â†’ 4`    | `5 â†’ 4 â†’ 3 â†’ 2 â†’ 1` |

Final: `prev` points to 5 â€” new head.

---

### âš™ï¸ Complexity Analysis

| Metric               | Complexity | Explanation               |
| -------------------- | ---------- | ------------------------- |
| **Time Complexity**  | O(N)       | Each node is visited once |
| **Space Complexity** | O(1)       | Only a few pointers used  |

---

## ğŸ§© Comparison Table

| Feature          | Recursive                | Iterative                |
| ---------------- | ------------------------ | ------------------------ |
| Simplicity       | âœ… Easy to understand     | âœ… Simple to code         |
| Space Complexity | âŒ O(N) (Stack)           | âœ… O(1)                   |
| Performance      | âš ï¸ Slightly slower       | âš¡ Fastest                |
| Use case         | Small lists / conceptual | Production / performance |

---

## ğŸ§ª Example Test Cases

```cpp
Input:  head = [1,2,3,4,5]
Output: [5,4,3,2,1]

Input:  head = [1,2]
Output: [2,1]

Input:  head = []
Output: []
```

---

## ğŸ’¡ Tips & Tricks

* Always **store the next node** before breaking links.
* For recursive approach, ensure **base case correctness** â€” `(head == nullptr || head->next == nullptr)`.
* You can also **reverse only a subpart** of the linked list â€” this variation is used in â€œReverse Linked List IIâ€.

---

## ğŸ§± Variations

1. ğŸ” **Reverse first `k` nodes**
2. ğŸ¯ **Reverse nodes in k-groups** â€” Leetcode #25
3. ğŸ”„ **Reverse between positions `left` and `right`**
4. ğŸª **Check if Linked List is Palindrome** (uses reversal of second half)

---

## ğŸ§© Full Testable Code (Iterative)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode* temp = head;
    ListNode* prev = nullptr;
    ListNode* front = nullptr;

    while (temp != nullptr) {
        front = temp->next;
        temp->next = prev;
        prev = temp;
        temp = front;
    }
    return prev;
}

void printList(ListNode* head) {
    while (head) {
        cout << head->val << " ";
        head = head->next;
    }
    cout << "\n";
}

int main() {
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    cout << "Original List: ";
    printList(head);

    head = reverseList(head);

    cout << "Reversed List: ";
    printList(head);
}
```

---

## â“ FAQs

**Q1: What happens if the list is empty?**

> It simply returns `nullptr`.

**Q2: Will recursion cause memory issues for large lists?**

> Yes. Recursion uses the call stack â€” for very long lists, prefer the iterative approach.

**Q3: Why return `prev` at the end (iterative)?**

> Because after the loop, `prev` points to the new head of the reversed list.

**Q4: Can we reverse the list in-place?**

> Yes â€” both approaches are *in-place* since they donâ€™t allocate new nodes.

