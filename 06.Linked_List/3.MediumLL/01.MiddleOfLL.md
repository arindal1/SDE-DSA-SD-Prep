# Middle of the Linked List ðŸ§­

## Problem statement

Given the head of a singly linked list, return the **middle node** of the list.

* If the list has **odd** number of nodes, there is a single middle node â€” return it.
* If the list has **even** number of nodes, there are two "middle" nodes; **this implementation returns the second middle node** (this matches LeetCode problem *876. Middle of the Linked List*).

---

## Intuition (why slow & fast works)

Use two pointers:

* `slow` moves **one step** at a time.
* `fast` moves **two steps** at a time.

When `fast` reaches the end of the list, `slow` will have advanced half as many steps, i.e. it will be at the middle.

* For **odd** length `n = 2k+1`: after `k` iterations `fast` points to last node, `slow` points to node `k+1` (the middle).
* For **even** length `n = 2k`: after `k` iterations `fast` becomes `nullptr` (passed the last node), `slow` points to node `k+1` â€” the *second* middle node.

This method is O(n) time and O(1) extra space and finds the *second* middle node by the standard loop condition `while (fast && fast->next)`.

---

## Brute Force approach

1. Traverse the list once and count nodes `n`.
2. Traverse again to the node at index `n/2` (0-based) and return it.

```cpp
ListNode* middleNode_bruteforce(ListNode* head) {
    int n = 0;
    ListNode* cur = head;
    while (cur) { n++; cur = cur->next; }
    int steps = n / 2;              // integer division
    cur = head;
    while (steps--) cur = cur->next;
    return cur;
}
```

* **Time:** O(n) (two passes)
* **Space:** O(1)

Brute force is perfectly fine, but slow-fast is cleaner and does it in a single pass.

---

## Optimal approach (slow & fast)

### Key code (given function â€” correct and idiomatic)

```cpp
ListNode* middleNode(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    
    ListNode* slow = head;
    ListNode* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        fast = fast->next->next;
        slow = slow->next;
    }
    return slow;
}
```

* **What it returns:** the node pointed by `slow` when the loop ends â€” *the middle*, and in even-length lists the **second** middle.
* **Loop condition:** `fast != nullptr && fast->next != nullptr` ensures `fast->next->next` access safe.

---

## Correctness note & variant (first middle vs second middle)

* The code above returns the **second** middle for even-length lists (common convention).

  * Example: list `1->2->3->4` â†’ returns node `3`.
* If you require the **first** middle (i.e. return node `2` in the example), use this variant:

```cpp
ListNode* middleNode_first(ListNode* head) {
    if (!head) return nullptr;
    ListNode* slow = head;
    ListNode* fast = head->next; // start fast one step ahead
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow; // first middle for even-length lists
}
```

* Here `fast` starts at `head->next`, so `slow` moves fewer times, landing at the first middle when length is even.

---

## Full runnable example (read input & print result)

Below is a complete program you can compile/run. It:

1. reads `n` (number of nodes),
2. then reads `n` integers (node values),
3. builds a singly linked list,
4. finds the middle (second-middle convention),
5. prints the value stored in that middle node (or a message for empty list).

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x): val(x), next(nullptr) {}
};

ListNode* middleNode(ListNode* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        fast = fast->next->next;
        slow = slow->next;
    }
    return slow;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin >> n)) return 0;
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    for (int i = 0; i < n; ++i) {
        int x; cin >> x;
        ListNode* node = new ListNode(x);
        if (!head) { head = tail = node; }
        else { tail->next = node; tail = node; }
    }

    ListNode* mid = middleNode(head);
    if (!mid) cout << "List is empty\n";
    else cout << "Middle node value: " << mid->val << "\n";

    // cleanup: free nodes
    ListNode* cur = head;
    while (cur) {
        ListNode* nxt = cur->next;
        delete cur;
        cur = nxt;
    }
    return 0;
}
```

---

## Test cases

Use these to validate behavior:

1. **Odd length**

   * Input: `n=5, values=1 2 3 4 5` â†’ Middle = `3`
2. **Even length**

   * Input: `n=4, values=1 2 3 4` â†’ Middle = `3` (second middle)
3. **Single node**

   * Input: `n=1, values=99` â†’ Middle = `99`
4. **Empty list**

   * Input: `n=0` â†’ prints `"List is empty"`
5. **Long list**

   * Input large `n` ensures O(n) performance and no extra memory.

---

## Complexity analysis

* **Time complexity:** `O(n)` â€” single pass over list (fast pointer moves twice as fast but still O(n) iterations total).
* **Space complexity:** `O(1)` extra memory â€” only two pointers used.

---

## Tips, tricks & pitfalls

* **Loop condition matters:** use `while (fast && fast->next)` to avoid dereferencing null pointers.
* **Which middle you need:** clarify whether *first* or *second* middle is required. The standard LeetCode problem expects the **second** middle (the given implementation does that).
* **Empty list handling:** always handle `head == nullptr` early to avoid crashes.
* **Memory cleanup:** if you allocate nodes in tests, `delete` them to avoid leaks.
* **Use sentinel node** for other operations that change the list head; not needed here.
* **Debugging tip:** print pointer addresses or indexes for slow/fast during dry runs to understand pointer movement.

---

## Variations & related problems

* **Return index of middle** instead of node pointer. (Compute index with slow/fast or two-pass.)
* **Find k-th node from middle** or from end (use two-pointer offset technique).
* **Detect cycle**: slow/fast can also detect cycles (Floydâ€™s algorithm).
* **Find cycle start**: after detection, reposition one pointer at head, move both one step until equal.

---

## FAQs

**Q: Why does the algorithm return the second middle for even-length lists?**
A: Because the loop advances `slow` every time `fast` advances two steps. For even `2k` nodes, when `fast` becomes `nullptr` after `k` double steps, `slow` will have advanced `k` steps â€” pointing to node index `k` (1-based), i.e. second middle.

**Q: Can I get the first middle instead?**
A: Yes â€” as shown above, initialize `fast = head->next` (or adjust loop) to get the first middle.

**Q: Is one-pass always better than two-pass?**
A: One-pass (slow-fast) is usually preferred for simplicity and slightly fewer traversals. Two-pass (count then step) is also O(n) and sometimes easier to write/read.

**Q: Will this work for very long lists (millions of nodes)?**
A: Yes â€” runtime is linear and memory is constant (aside from nodes themselves).

---
