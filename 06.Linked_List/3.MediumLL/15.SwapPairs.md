# Swap Nodes in Pairs üîÅüß†

### Problem statement üìù

Given a singly-linked list, swap every two adjacent nodes and return its head.

* Example: `1 -> 2 -> 3 -> 4 -> nullptr` becomes `2 -> 1 -> 4 -> 3 -> nullptr`.
* If the list length is odd, the last node remains in place: `1 -> 2 -> 3` ‚Üí `2 -> 1 -> 3`.
* You must swap nodes (pointer changes), **not** just values.

Assumed `ListNode` struct:

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode(): val(0), next(nullptr) {}
    ListNode(int x): val(x), next(nullptr) {}
    ListNode(int x, ListNode *next): val(x), next(next) {}
};
```

### Intuition ‚ú®

Swapping nodes in pairs can be done by re-linking pointers in groups of two. Work left-to-right and maintain a pointer (`prev`) to the node just *before* the pair you want to swap. For each pair:

* Identify nodes `first = prev->next` and `second = first->next`.
* Rewire pointers so that `prev -> second -> first -> following`.
* Move `prev` forward by two nodes (to `first`, which is now the second of the swapped pair) and repeat.

A **dummy** node (a node before the head) simplifies edge cases (swapping at the head) and removes need for special-case handling.

---

### Brute force (for comparison) üêå

* Build a new list by consuming original list two nodes at a time and appending them in swapped order, allocating new nodes. This uses O(n) additional memory ‚Äî unnecessary if reusing nodes in-place is allowed.
* Another "brute" is to swap values of nodes pairwise (just swap `val` between adjacent nodes). This is trivial but violates requirements that may insist on swapping nodes rather than values (if node identity matters).

The iterative pointer-rewiring approach is preferred.


### Optimal approach (iterative, in-place) ‚úÖ

Algorithm outline (what the provided code does):

1. Create a stack-allocated dummy node `dummy` whose `next = head`.
2. Initialize `prev = &dummy`.
3. While `prev->next` and `prev->next->next` are both non-null (i.e., there are at least two nodes remaining):

   * Let `first = prev->next`.
   * Let `second = first->next`.
   * Rewire:

     * `prev->next = second;`
     * `first->next = second->next;`
     * `second->next = first;`
   * Advance `prev = first;` (which is now the node after the swapped pair).
4. Return `dummy.next`.

This visits each node a constant number of times ‚Üí **O(n)** time, and uses only a few pointers ‚Üí **O(1)** space.


### Step-by-step pointer diagram (one iteration) üîç

Suppose current list (and `prev` points to node P):

```
P -> A -> B -> C
```

where `first = A`, `second = B`, and `C` is `B->next`.

After swapping the pair A and B, we want:

```
P -> B -> A -> C
```

Pointer changes in code:

1. `prev->next = second;`
   Now: `P -> B` (but B still points to C, A still points to B)
2. `first->next = second->next;`
   `A->next` becomes `C` (break A->B)
3. `second->next = first;`
   `B->next = A` completes `P->B->A->C`
4. `prev = first;` (move prev to A, the tail of the swapped pair), ready for next pair.

This sequence avoids temporary detours by using a stable `prev` anchor.

---


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // Dummy simplifies head swap and avoids special-casing.
        ListNode dummy(0);
        dummy.next = head;
        ListNode* prev = &dummy;

        // While there are at least two nodes to swap
        while (prev->next != nullptr && prev->next->next != nullptr) {
            ListNode* first = prev->next;        // node A
            ListNode* second = first->next;     // node B

            // perform the swap: prev -> B -> A -> following
            prev->next = second;
            first->next = second->next;
            second->next = first;

            // move prev to the tail of the swapped pair (first)
            prev = first;
        }
        return dummy.next;
    }
};
```



### Recursive alternative üîÅ


```cpp
ListNode* swapPairsRecursive(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode* first = head;
    ListNode* second = head->next;

    // swap and recursively process rest
    first->next = swapPairsRecursive(second->next);
    second->next = first;
    return second;
}
```

* This reads nicely: swap first two, then attach swapped rest.
* Complexity: O(n) time, O(n/2) recursion depth ‚Üí O(n) stack space. For very long lists, iterative is safer.


### Complexity analysis üìä

* **Time complexity:** `O(n)` where `n` is the number of nodes. Each node is visited a constant number of times.
* **Space complexity:** `O(1)` extra space for the iterative approach (just a few pointers). The recursive version uses `O(n)` call stack in worst case.


## Test cases & expected outputs üß™

1. **Even size list**

   * Input: `1->2->3->4`
     Output: `2->1->4->3`

2. **Odd size list**

   * Input: `1->2->3`
     Output: `2->1->3`

3. **Single node**

   * Input: `1` ‚Üí Output: `1`

4. **Empty list**

   * Input: `nullptr` ‚Üí Output: `nullptr`

5. **Long list**

   * Input: `1->2->3->4->5->6->7->8->9->10`
     Output: `2->1->4->3->6->5->8->7->10->9`

6. **Repeated values**

   * Input: `1->1->1->1` ‚Üí Output: `1->1->1->1` (nodes swapped, values same but node identities change)


### Tips, tricks & gotchas ‚ú®

* **Always use a dummy node** for pointer surgery that might modify the head ‚Äî it avoids fragile special-case logic.
* **Advance `prev` by two nodes** (set to `first`) after swapping, not by one. Setting `prev = prev->next` would be wrong because `prev->next` is now `second`.
* **Be mindful of null checks**: ensure `prev->next` and `prev->next->next` are non-null before dereferencing.
* **Do not swap values** if node identity matters (some problems care about node addresses).
* **Prefer iterative for production** (no stack overflow risk). Use recursive only when brevity matters and lists are small.


### Variations & related problems üîÅ

* **Reverse nodes in k-group:** similar pointer-work but group size is `k` instead of `2`. More general and a bit trickier.
* **Swap nodes by value:** given two values, swap the corresponding nodes (not just adjacent pairs).
* **Swap every k-th pair:** generalization where you swap nodes at specific positions.
* **Rotate list / reverse list / remove nth node:** other classic pointer-manipulation problems.


### FAQs ‚ùì

**Q: Why is dummy node preferred?**
A: Dummy allows uniform handling for the head being part of a swapped pair. Without it, you'd need an `if` branch to update `head` when swapping the first two nodes.

**Q: Can I implement this by swapping `val` instead of nodes?**
A: Yes, swapping values is simpler but changes node contents rather than topology. Some problems forbids value swapping when node identity matters.

**Q: Is the loop safe for very short lists?**
A: Yes ‚Äî it only enters the loop if there are at least two nodes remaining.

**Q: Does the algorithm work in-place?**
A: Yes ‚Äî it reuses and re-links the existing nodes, requiring O(1) extra memory.

**Q: Which is better: iterative or recursive?**
A: Iterative is better for large lists (stack overflow avoidance). Recursive is elegant and short for interviews where list sizes are small or constraints are unspecified.
