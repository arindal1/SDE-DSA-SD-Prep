# 🔁 Odd-Even Linked List — In-Depth Notes


## 📄 Problem statement

Rearrange a singly linked list so that **all nodes at odd positions** come first, followed by **all nodes at even positions**.
Positions are 1-based (head is position 1). The relative order within the odd group and within the even group must be preserved.

**Examples**

* Input: `head = [1,2,3,4,5]`
  Output: `[1,3,5,2,4]`

* Input: `head = [2,1,3,5,6,4,7]`
  Output: `[2,3,6,7,1,5,4]`

---

## 💡 Intuition

* Walk the list and **split** it into two lists:

  * one containing nodes at **odd indices**,
  * another containing nodes at **even indices**.
* Because you traverse in order and reattach `next` pointers, you **preserve relative order** inside each group.
* Finally, **concatenate** the even list to the tail of the odd list.

This can be done **in-place** with constant extra memory and a single traversal.

---

## 🐢 Brute-force approach (not optimal)

* Copy nodes/values into two arrays (odds and evens) during a pass.
* Rebuild a new linked list by first creating nodes from `odds` then from `evens`.

**Complexity:**

* Time: `O(n)`
* Space: `O(n)` for arrays and newly created nodes (allocates new nodes vs in-place)

Not ideal if you want an in-place solution or to avoid extra memory.

---

## 🚀 Optimal approach — In-place re-linking (one pass)

### Key idea

Maintain three pointers:

* `oddTail` — tail of the odd-position list (initially head),
* `evenHead` — head of even-position list (initially `head->next`) — saved to attach later,
* `evenTail` — tail of the even list (initially `head->next`).

Iteratively:

1. Link `oddTail->next` to the node after `evenTail` (the next odd).
2. Advance `oddTail` to that node.
3. Link `evenTail->next` to the node after `oddTail` (the next even).
4. Advance `evenTail` to that node.
   Stop when there are no more nodes to process.

Finally, connect `oddTail->next = evenHead`.

This preserves order and runs in linear time with O(1) extra space.

---

## ✅ Correct & Readable Code (with user input)


```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x=0): val(x), next(nullptr) {}
};

// Reorders list: odd-position nodes first, then even-position nodes.
// Example: 1->2->3->4->5  => 1->3->5->2->4
ListNode* oddEvenList(ListNode* head) {
    if (!head || !head->next) return head;

    ListNode* oddTail = head;            // tail of odd-indexed nodes
    ListNode* evenHead = head->next;     // head of even-indexed nodes (to attach later)
    ListNode* evenTail = evenHead;       // tail of even-indexed nodes

    while (evenTail && evenTail->next) {
        // Connect next odd
        oddTail->next = evenTail->next;
        oddTail = oddTail->next;

        // Connect next even
        evenTail->next = oddTail->next;
        evenTail = evenTail->next;
    }

    // Attach even list after odd list
    oddTail->next = evenHead;
    return head;
}

// Helper: build linked list from vector
ListNode* buildList(const vector<int>& vals) {
    if (vals.empty()) return nullptr;
    ListNode* head = new ListNode(vals[0]);
    ListNode* tail = head;
    for (size_t i = 1; i < vals.size(); ++i) {
        tail->next = new ListNode(vals[i]);
        tail = tail->next;
    }
    return head;
}

// Helper: print linked list
void printList(ListNode* head) {
    bool first = true;
    while (head) {
        if (!first) cout << " ";
        cout << head->val;
        first = false;
        head = head->next;
    }
    cout << "\n";
}

// Helper: free nodes
void freeList(ListNode* head) {
    while (head) {
        ListNode* nxt = head->next;
        delete head;
        head = nxt;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin >> n)) return 0;
    vector<int> vals(n);
    for (int i = 0; i < n; ++i) cin >> vals[i];

    ListNode* head = buildList(vals);
    head = oddEvenList(head);
    printList(head);
    freeList(head);
    return 0;
}
```

---

## 🧪 Walkthrough / Dry run

Input: `1 -> 2 -> 3 -> 4 -> 5`

* Initialization:

  * `oddTail = 1`
  * `evenHead = evenTail = 2`
* Iteration 1:

  * `oddTail->next = evenTail->next` → `1->3`
  * `oddTail = 3`
  * `evenTail->next = oddTail->next` → `2->4`
  * `evenTail = 4`
* Iteration 2:

  * `oddTail->next = evenTail->next` → `3->5`
  * `oddTail = 5`
  * `evenTail->next = oddTail->next` → `4->nullptr`
  * `evenTail = nullptr` (loop ends)
* Attach: `oddTail->next = evenHead` → `5->2`
  Result: `1->3->5->2->4`

---

## ⏱ Complexity analysis

* **Time complexity:** **O(n)** — single pass, each node visited/relinked a constant number of times.
* **Space complexity:** **O(1)** extra space — only a few pointers used; nodes are rearranged in place.

---

## ✅ Correctness & Edge cases

* `n == 0` (empty list) → returns `nullptr`.
* `n == 1` → returns head unchanged.
* `n == 2` → returns same list (odd then even).
* Works for both odd and even length lists.
* The algorithm preserves the **relative order** inside odd group and inside even group.

---

## 🔧 Implementation notes & small improvements

* Use clear variable names: `oddTail`, `evenHead`, `evenTail` — improves readability.
* The `while` condition `while (evenTail && evenTail->next)` is safe and avoids dereferencing `nullptr`.
* No need to set `oddTail->next = nullptr` mid-loop; final `oddTail->next = evenHead` handles correct tailing.
* This approach **does not allocate** new nodes and does not use extra containers.

---

## 🔁 Variations & related problems

* **Group nodes by k** (LeetCode 25 variant): reverse nodes in groups of `k`.
* **Partition by value**: reorder nodes so that nodes `< x` come before `>= x` while preserving relative order within partitions (like partition list problem).
* **Even-odd by value**: reordering nodes with even values before odd values (different problem — based on node value not index).

---

## 💡 Tips & tricks

* When you need to split into two logical lists (odd/even, small/large), keep a pointer to the head of the second list so you can concatenate later.
* Always check `nullptr` before dereferencing `->next`.
* If you frequently insert at tail, maintaining an explicit tail pointer gives O(1) appends.
* If asked in interview, explain why the algorithm is stable (it preserves relative order) and why it's in-place & single pass.

---

## ❓ FAQs

**Q: Does the algorithm change node values or create new nodes?**
**A:** No — it only changes `next` pointers; node objects and values are preserved.

**Q: Will it break for very long lists?**
**A:** No — it’s linear and uses constant extra memory. The only potential limit is system memory for the original list.

**Q: Which nodes are considered “odd” or “even”?**
**A:** Positions are 1-based: first node is odd (position 1), second node even (position 2), etc.

**Q: Does it matter if the list has cycles?**
**A:** The problem assumes a well-formed acyclic singly linked list. If the list had a cycle, this routine could loop infinitely — cycle detection is a separate concern.

---

