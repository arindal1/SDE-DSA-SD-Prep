# 🧭 Remove N-th Node From End of List — In-Depth Notes


## 📄 Problem statement

Given the head of a singly-linked list and an integer `n`, remove the **n-th node from the end** of the list and return the head of the modified list.

* The list is 1-indexed from the front for typical descriptions, but the problem asks about the n-th from the **end**.
* Example:
  Input: `head = [1,2,3,4,5]`, `n = 2`
  Output: `[1,2,3,5]`  (the 2nd from the end is `4`, remove it)

---

## 💡 Intuition

If you want to remove the n-th node from the **end**, you can think of it like removing the `(L - n + 1)`-th node from the start (where `L` is list length). A two-pass solution first counts length `L`, then removes the node at position `L-n`.

But we can do this in **one pass** using the *two-pointer* (fast/slow) trick:

1. Move the **fast** pointer `n` steps ahead.
2. Then move **both** pointers (fast and slow) together until `fast` reaches the end.
3. At that point, **slow** will be right before the target node to remove.
4. Adjust links and free the removed node.

To simplify head-removal edge cases, we often use a **dummy** node that points to the head.

---

## 🐢 Brute-force approach (two-pass)

1. Traverse the list to compute `L` (length).
2. If `n == L`, remove head and return `head->next`.
3. Otherwise, traverse to the `(L - n)`-th node and unlink its `next`.

**Complexity:**

* Time: `O(L)` (two passes)
* Space: `O(1)`

Works well and is simple; the one-pass trick is preferable when asked explicitly for a single traversal.

---

## 🚀 Optimal approach — One-pass (fast & slow), robust version

**Key points / fixes from the original snippet:**

* The original logic is correct in principle but has two practical issues:

  1. If `n` equals the list length, the original method returned `head->next` *without deleting the removed node*, causing a memory leak.
  2. If `n` is larger than the list length (invalid input), the original code would dereference `nullptr` when advancing the fast pointer `n` times. It's safer to guard against that (either assume input valid, or handle invalid `n` gracefully).
* Using a **dummy node** simplifies deletion logic (no special case for deleting the head).
* Always `delete` the removed node to avoid memory leaks.

---

## ✅ Corrected & Robust C++ Implementation (one-pass with dummy, safe checks)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x=0) : val(x), next(nullptr) {}
};

// Remove nth node from end (1 <= n). Returns new head.
ListNode* removeNthFromEnd(ListNode* head, int n) {
    if (head == nullptr) return nullptr;

    // Dummy simplifies deleting head node
    ListNode dummy(0);
    dummy.next = head;
    ListNode* fast = &dummy;
    ListNode* slow = &dummy;

    // Move fast n steps forward (from dummy -> moves n times lands n nodes ahead of dummy)
    for (int i = 0; i < n; ++i) {
        if (fast->next == nullptr) {
            // n is larger than length; invalid input.
            // Option A: return original list unchanged.
            // Option B: treat as delete head: here we return head unchanged.
            return head;
        }
        fast = fast->next;
    }

    // Now move both until fast is at the last node
    while (fast->next != nullptr) {
        fast = fast->next;
        slow = slow->next;
    }

    // slow->next is the node to delete
    ListNode* nodeToDelete = slow->next;
    slow->next = nodeToDelete->next;
    delete nodeToDelete;

    return dummy.next;
}

// ----------- Helpers for testing ----------
ListNode* buildList(const vector<int>& v) {
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    for (int x : v) {
        ListNode* node = new ListNode(x);
        if (!head) head = tail = node;
        else {
            tail->next = node;
            tail = node;
        }
    }
    return head;
}

void printList(ListNode* head) {
    bool first = true;
    while (head) {
        if (!first) cout << " ";
        cout << head->val;
        first = false;
        head = head->next;
    }
    cout << "\n";
}

void freeList(ListNode* head) {
    while (head) {
        ListNode* nxt = head->next;
        delete head;
        head = nxt;
    }
}

// Example interactive main
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin >> n)) return 0;              // number of nodes
    vector<int> vals(n);
    for (int i = 0; i < n; ++i) cin >> vals[i];
    int k;                                  // n-th from end to remove
    cin >> k;

    ListNode* head = buildList(vals);
    head = removeNthFromEnd(head, k);
    printList(head);
    freeList(head);
    return 0;
}
```

---

## 🧪 Test Cases

1. **Standard**

   * Input: `[1,2,3,4,5]`, `n=2` → Output: `[1,2,3,5]`
2. **Remove head (n == length)**

   * Input: `[1,2]`, `n=2` → Output: `[2]`
3. **Single node**

   * Input: `[10]`, `n=1` → Output: `[]` (empty)
4. **n larger than length** (invalid input)

   * Input: `[1,2,3]`, `n=5` → Behavior: returns original list (could also be specified as error)
5. **Remove last node (n=1)**

   * Input: `[1,2,3]`, `n=1` → Output: `[1,2]`
6. **Even / Odd lengths**

   * Input: `[1,2,3,4]`, `n=2` → Output: `[1,2,4]`

---

## ⏱ Complexity analysis

* **Time complexity:** `O(L)` where `L` is the number of nodes (single pass + pointer moves).
* **Space complexity:** `O(1)` extra (only a few pointers and a dummy node on stack).

---

## 🧠 Tips, tricks & pitfalls

* **Use a dummy node** to unify the head-deletion case: it removes special-case logic.
* **Advance fast from the dummy**, not head, so that after moving `n` steps `fast` is `n` nodes ahead of `slow` (which also points at dummy). When `fast->next` is `nullptr`, `slow->next` is the node to remove.
* **Delete the removed node** to avoid memory leaks.
* Validate `n` if inputs might be invalid. You can choose to handle invalid `n` by returning the original list, throwing an exception, or clamping to a valid value — be explicit.
* Avoid dereferencing `nullptr`. Check `fast->next` during the initial `n` step moves to guarantee safety.

---

## 🔄 Variations

* **Two-pass counting approach:** First count list length `L`, compute `idx = L - n`, then walk to the `(idx-1)`th node and delete `idx`th node. Slightly simpler to reason about; still `O(L)` time, O(1) space.
* **Recursive solution:** Use recursion to reach the end and maintain a counter on return to delete when count equals `n`. Uses `O(L)` stack space (not recommended for large lists).
* **Return deleted node or value:** Sometimes APIs want the removed node/value returned rather than head.

---

## ❓ FAQs

**Q:** What if `n` equals the number of nodes?
**A:** That removes the head. Using the dummy makes this trivial — `dummy.next` will be updated to the new head, and the old head is deleted.

**Q:** What if `n` is 0 or negative?
**A:** Problem typically guarantees `n >= 1`. If not, handle as invalid input (return unchanged list).

**Q:** Can this be done in one pass?
**A:** Yes — the above one-pass two-pointer method is the standard approach.

**Q:** Why check `fast->next` rather than `fast` in the final loop?
**A:** After moving `fast` `n` steps, we want to stop when `fast` is at the last node, so that `slow->next` is the target. The loop `while (fast->next != nullptr)` achieves that: when it ends, `fast` is last node and `slow` points to the node *before* the one to delete.

---

## ✅ Summary

* The two-pointer one-pass solution is elegant and efficient.
* Use a **dummy** node for safe and simple head deletion handling.
* Always handle memory correctly (`delete` removed node).
* Validate inputs if the problem domain could include invalid `n`.

---
