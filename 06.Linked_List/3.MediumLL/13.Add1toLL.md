# Add One to a Number Represented by a Linked List — In-depth Notes 🧾


# Problem statement ✅

Given a singly-linked list where each node contains a single digit (0–9), and the head holds the most significant digit, **add 1** to the number represented by the list and return the new head.

Example:

* Input: `1 -> 2 -> 3 -> 4 -> 5` (represents 12345)
* Output: `1 -> 2 -> 3 -> 4 -> 6` (represents 12346)

Edge cases to handle:

* Sequence of 9s: `9 -> 9 -> 9` → `1 -> 0 -> 0 -> 0`
* Single node: `9` → `1 -> 0`
* Empty list (defensive behavior) — either return `nullptr` or treat as `0` → `1` depending on API.

---

# Intuition 🧠

There are two natural ways to add 1:

1. **Right-to-left addition** (like normal addition): we should start at least significant digit (tail) and propagate carry leftwards. But singly-linked lists don't let you go backwards easily.
2. Workaround: **reverse the list**, add from head (now least significant), handle carry, then **reverse back**. This is simple and efficient: single traversal to reverse, then one pass to add+propagate, then reverse again.

Other options:

* Use a **stack** to simulate reverse order (no list mutation), or
* Use **recursion** to reach tail and propagate carry back up.

Your code follows the reverse → add → reverse approach.

---

# Brute force & alternatives 🔁

* Brute force would mean converting list → integer (in a big integer type or string), add 1, then convert back to list. This is *not* suitable for very long lists (overflow) and is more work.
* Better: single-pass algorithms that avoid reversing by using a stack or recursion.

---

# Production-ready implementation (annotated) ✅


```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// Reverse a singly linked list; returns new head.
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* cur = head;
    while (cur != nullptr) {
        ListNode* nxt = cur->next;
        cur->next = prev;
        prev = cur;
        cur = nxt;
    }
    return prev;
}

// Add 1 to the number represented by the linked list.
// If head == nullptr, we treat it as 0 and return a new node with value 1.
ListNode* addOne(ListNode* head) {
    if (head == nullptr) {
        return new ListNode(1);
    }

    // Reverse to make addition easy (least significant digit first).
    head = reverseList(head);

    ListNode* cur = head;
    int carry = 1;

    // Add carry while there is a carry and nodes left.
    while (cur != nullptr && carry) {
        int sum = cur->val + carry;
        cur->val = sum % 10;
        carry = sum / 10;

        // If at last node and still have carry, append a new node with carry.
        if (cur->next == nullptr && carry) {
            cur->next = new ListNode(carry);
            carry = 0; // handled the remaining carry
        }

        cur = cur->next;
    }

    // Reverse back to restore original most-significant-first order.
    head = reverseList(head);
    return head;
}

// Utility: print list (space separated digits).
void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << '\n';
}

// Example usage:
int main() {
    // Create list 1->2->3->4->5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    head = addOne(head);

    printList(head); // Expect: 1 -> 2 -> 3 -> 4 -> 6

    // Note: In production, free the list nodes to avoid memory leaks.
    return 0;
}
```
---

# Other approaches (no reversing) 🛠️

### 1) **Stack-based solution**

* Push nodes onto a stack while traversing.
* Pop and add carry from least significant to most.
* Stop early when carry is 0.
* If after popping all nodes carry still 1, create new head node with value 1.
* Pros: avoids modifying original list order until final. Cons: uses O(n) stack space.

### 2) **Recursive solution**

* Recurse to the tail, return carry from deeper calls.
* Each frame adds carry to node's value and returns possible carry upward.
* Pros: clean, no reversing or stack. Cons: recursion depth = list length → stack overflow for huge lists.

Pseudo recursive:

```cpp
int addOneRecursive(ListNode* node) {
    if (!node) return 1; // base: carry 1 to add
    int carry = addOneRecursive(node->next);
    int sum = node->val + carry;
    node->val = sum % 10;
    return sum / 10;
}
```

* After call, if returned carry is 1, create new head `1`.

### 3) **Find rightmost non-9 node trick (single pass, O(1) extra)**

* Keep pointer `lastNonNine` to rightmost node whose value != 9.
* Traverse list once; increment that node, set all nodes after it to 0.
* If no such node (all 9s), create new head `1` and set all existing nodes to 0.
* This is elegant and O(n) time, O(1) space, no reversing.

Pseudo:

```text
dummy -> head
lastNonNine = dummy
for node in list:
    if node.val != 9: lastNonNine = node
// increment lastNonNine by 1, set all following nodes val = 0
```

---

# Test cases (comprehensive) ✅

1. **Normal add (no carry propagation)**

   * Input: `1->2->3` + 1 → `1->2->4`

2. **Propagation through digits**

   * Input: `1->2->9` + 1 → `1->3->0`

3. **All nines**

   * Input: `9->9->9` + 1 → `1->0->0->0`

4. **Single 9**

   * Input: `9` + 1 → `1->0`

5. **Trailing zeros**

   * Input: `1->9->9->0` + 1 → `1->9->9->1`

6. **Empty list** (defensive behavior)

   * Input: `nullptr` → `1` (depending on chosen API)

7. **Large list (performance)**

   * Test with 10^5 nodes to ensure linear time.

8. **Random digits**

   * Many random lists, compare with big integer string add (for correctness verification).

---

# Complexity analysis 📊

For the reverse→add→reverse method:

* **Time complexity:** `O(n)` where `n` is number of nodes (two reversals + one linear carry pass).
* **Space complexity:** `O(1)` extra (in-place), aside from new node only when needed.

Other approaches:

* Stack: `O(n)` time, `O(n)` extra space.
* Recursion: `O(n)` time, `O(n)` call stack.
* Rightmost non-9 trick: `O(n)` time, `O(1)` extra.

---

# Tips, tricks & best practices ✨

* Prefer the **rightmost non-9 trick** if you want minimal operations and no reversal:

  * Single linear pass, constant extra space, easy to implement.
* Always **document** whether `nullptr` is valid input and how it's handled.
* Free nodes when you no longer need them (in full programs) to avoid leaks.
* Use `unique_ptr` or library containers if ownership semantics matter.
* Add unit tests to check edge cases: `9` sequences, empty list, single node.

---

# Variations & extensions 🔁

* **Add an arbitrary integer k (k > 1)**: carry logic changes to add `k` at head of reversed list or use the same methods but with carry possibly >1.
* **Subtract 1** — similar but careful with borrow (need to handle leading zeros).
* **Multiply by small integer** — generalize carry propagation (val*mult + carry).
* **Base other than 10** — adapt modulo/base operations accordingly.

---

# FAQs (short) ❓

**Q:** Why reverse the list instead of recursion?
**A:** Reversing is iterative, uses O(1) extra stack, and is safe for very long lists (no recursion depth issues).

**Q:** Does this work for adding numbers larger than 1?
**A:** Yes — replace initial `carry = 1` with `carry = k` and propagate similarly; careful to append nodes as needed.

**Q:** Is the appended node value always 1 when creating new node?
**A:** Yes — because carry can only be 1 in addition of 1. For general `k`, it could be different and you should use `carry` value.

**Q:** Is there a version that avoids even touching digits when no carry needed?
**A:** Yes — your loop `while(cur && carry)` already stops early — so digits after the carry is resolved aren't touched.

---
