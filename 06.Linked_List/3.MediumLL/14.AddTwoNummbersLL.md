# Add Two Numbers ‚Äî In-depth Notes & Guide üßÆ‚ú®


# Problem statement (concise) ‚úÖ

Given two non-empty linked lists `l1` and `l2` whose nodes store digits `0‚Äì9` in reverse order, add the two numbers and return the sum as a linked list in the same reverse order. Each node contains a single digit. The two numbers do not contain any leading zeros, except the number 0 itself.

Example:

* `l1: 2 -> 4 -> 3`  (represents 342)
* `l2: 5 -> 6 -> 4`  (represents 465)
* Output: `7 -> 0 -> 8`  (represents 807 because 342 + 465 = 807)

---

# Intuition üß†

Add digit-by-digit like elementary addition from least significant digit to most significant:

* Use two pointers to traverse both lists.
* Maintain a `carry` (initially `0`).
* For each position, sum `val1 + val2 + carry`, append `sum % 10` to result, update `carry = sum / 10`.
* Continue while either list has nodes or `carry != 0`.
* Use a **dummy head** to simplify result list construction.

This yields a single-pass (`O(n)`) solution with constant extra memory (excluding output).

---

# Brute force (conceptual) vs Optimal

**Brute force (not recommended):**

* Convert each list to integer (or string/bignum), add them, convert back to linked list. Problems: integer overflow, extra conversions, more complex.

**Optimal (what we do):**

* Linear scan combining digits and carry ‚Äî `O(max(len1, len2))` time, `O(1)` extra space (plus output list).



---

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x = 0) : val(x), next(nullptr) {} // default value 0 provided
};

// Add two numbers represented by linked lists l1 and l2 (reverse order).
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);          // stack-allocated dummy avoids heap leak
    ListNode* tail = &dummy;    // tail points to last node in result
    int carry = 0;

    while (l1 != nullptr || l2 != nullptr || carry) {
        int sum = carry;
        if (l1 != nullptr) {
            sum += l1->val;
            l1 = l1->next;
        }
        if (l2 != nullptr) {
            sum += l2->val;
            l2 = l2->next;
        }

        carry = sum / 10;
        tail->next = new ListNode(sum % 10);
        tail = tail->next;
    }

    return dummy.next; // caller owns returned list and must free eventually
}

// Helper: create linked list from vector of ints (least significant first).
ListNode* make_list(const vector<int>& digits) {
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    for (int d : digits) {
        ListNode* node = new ListNode(d);
        if (!head) head = tail = node;
        else { tail->next = node; tail = node; }
    }
    return head;
}

// Helper: print list (reverse-order representation).
void printList(ListNode* head) {
    while (head) {
        cout << head->val;
        if (head->next) cout << " -> ";
        head = head->next;
    }
    cout << '\n';
}

// Helper: free list to avoid memory leaks in longer running programs.
void freeList(ListNode* head) {
    while (head) {
        ListNode* tmp = head->next;
        delete head;
        head = tmp;
    }
}

int main() {
    // Example 1: 342 + 465 = 807
    ListNode* l1 = make_list({2,4,3}); // 342
    ListNode* l2 = make_list({5,6,4}); // 465
    ListNode* res = addTwoNumbers(l1, l2);
    printList(res); // expect 7 -> 0 -> 8

    freeList(l1);
    freeList(l2);
    freeList(res);

    // Example 2: 999 + 1 = 1000
    ListNode* a = make_list({9,9,9});
    ListNode* b = make_list({1});
    ListNode* r2 = addTwoNumbers(a, b);
    printList(r2); // expect 0 -> 0 -> 0 -> 1

    freeList(a);
    freeList(b);
    freeList(r2);

    return 0;
}
```

---

# Complexity analysis üìä

* **Time:** `O(max(n, m))` where `n`, `m` are lengths of `l1`, `l2`. We traverse each list once (plus constant-time operations per node).
* **Space:** `O(max(n, m) + 1)` for the output list (not counting input lists). Extra auxiliary space is `O(1)`.

---

# Test cases (exhaustive-ish) ‚úÖ

1. **Equal length, no carry across digits**

   * `l1 = [2,4,3]`, `l2 = [5,6,4]` ‚Üí `7->0->8` (342+465=807)

2. **Different lengths**

   * `l1 = [9,9]` (99), `l2 = [1]` (1) ‚Üí `0->0->1` (100)

3. **Both single node**

   * `l1 = [0]`, `l2 = [0]` ‚Üí `0`

4. **Carry at end**

   * `l1 = [9,9,9]`, `l2 = [9]` ‚Üí `8 -> 0 -> 0 -> 1`? Wait: compute correctly ‚Äî 999 + 9 = 1008 ‚Üí result (8->0->0->1)

5. **One list empty (if allowed)**

   * `l1 = nullptr`, `l2 = [1,2,3]` ‚Üí should treat `nullptr` as 0 and return `1->2->3` (if you want this behavior; current code expects non-empty lists but will work if `nullptr` is passed).

6. **Very long lists**

   * Performance test: 10^5 digits each ‚Äî should run in linear time.

---

# Tips, tricks & variations üí°

* **Reverse-order vs forward-order**: This problem uses reverse order (ones digit at head). If digits are in forward order (most significant at head), you need a different approach (reverse both lists, use same algorithm; or use stacks/recursion).
* **In-place modification**: You could modify one of the input lists to be the result if allowed (to avoid allocating new nodes), but be careful with ownership and trailing carry.
* **Use `unique_ptr`** to manage node memory in modern C++ if building a production system ‚Äî it simplifies cleanup.
* **Edge-contracts**: Document what happens if `nullptr` is passed in ‚Äî either assume valid inputs as per problem or make function defensive.

---

# Variations & follow-ups üîÅ

* **Add k numbers** (more than two): generalize loop to sum many lists simultaneously.
* **Add numbers in forward order**: use stacks or reverse lists first.
* **Multiply two numbers represented by linked lists**: more complex, simulate grade-school multiplication.
* **Perform addition in different base**: change modulus/division base from 10 to `B`.

---

# Frequently Asked Questions (FAQs) ‚ùì

**Q: Why use a dummy node?**
A: It simplifies list construction. Without dummy, you'd have to special-case creating the head node on the first iteration.

**Q: Is it okay to `new` nodes and never `delete` them?**
A: In short-lived program runs (competitive programming), leaks are tolerated. In real systems, always `delete` or use smart pointers.

**Q: Can we reuse one input list for output to save memory?**
A: Yes ‚Äî if allowed. Iterate both lists and overwrite nodes of the longer list, creating nodes only if final carry remains. But be careful: inputs may be used elsewhere; document ownership semantics.

**Q: Why not use recursion/stack?**
A: Recursion adds call stack overhead and is unnecessary for this simple digit-by-digit addition when lists are already in *reverse* order. Stacks are useful for forward-order addition.

---

