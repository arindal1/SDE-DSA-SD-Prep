# ðŸ§© Sort a Singly Linked List â€” In-Depth Notes (Merge-Sort)

---

## ðŸ“„ Problem statement

Given the `head` of a singly linked list, **sort the list in ascending order** and return the sorted list's head.

**Example**

```
Input:  head = [4,2,1,3]
Output: [1,2,3,4]
```

**Goal:** implement a fast, memory-efficient sort for singly linked lists.

---

## ðŸ’¡ Key idea / Intuition

Arrays are often sorted with quicksort or mergesort. For **singly linked lists**, *merge sort* is the natural fit:

* **Splitting** a linked list into halves is easy using the *slow/fast* pointer technique.
* **Merging** two sorted linked lists can be done in-place by relinking `next` pointers.
* Merge sort on a list requires **O(n log n)** time and uses **O(log n)** call-stack space in the recursive implementation.

Why not quicksort? Quicksort needs random access (to pick good pivots) or heavy pointer manipulation and can degrade on some inputs; merge sort is stable and guaranteed O(n log n) for lists.

---

## ðŸ¢ Brute-force approach (not recommended)

* Copy list values into a vector, `std::sort` the vector, then rebuild the linked list from sorted values.
* **Time:** O(n log n) (sorting vector)
* **Space:** O(n) (vector + possibly new nodes)

Works and is simple to code, but it requires **O(n)** extra memory and rebuilds the list (extra allocations).

---

## ðŸš€ Optimal approach: Merge Sort (Top-down) â€” One-pass merging, no extra vector

### Steps

1. **Base case:** if list is empty or single node â†’ already sorted.
2. **Split** the list into two halves using slow/fast pointers:

   * `slow` moves one step, `fast` moves two steps.
   * Keep a `midPrev` pointer to cut the list in two (`midPrev->next = nullptr`).
3. **Recursively sort** left and right halves.
4. **Merge** the two sorted halves with `mergeList(list1, list2)` which relinks nodes.

### Why itâ€™s good

* **Time:** O(n log n) â€” each level does O(n) merging, there are O(log n) levels.
* **Space:** O(log n) recursion stack. The algorithm itself uses O(1) extra heap space (no auxiliary arrays).

---

## âœ… Clear Code (classical top-down merge sort)


```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x): val(x), next(nullptr) {}
};

// Merge two sorted lists and return head of merged list
ListNode* mergeList(ListNode* list1, ListNode* list2) {
    ListNode dummy(-1);
    ListNode* tail = &dummy;

    while (list1 && list2) {
        if (list1->val <= list2->val) {
            tail->next = list1;
            list1 = list1->next;
        } else {
            tail->next = list2;
            list2 = list2->next;
        }
        tail = tail->next;
    }

    tail->next = (list1 ? list1 : list2);
    return dummy.next;
}

// Top-down merge sort for linked list
ListNode* sortList(ListNode* head) {
    if (!head || !head->next) return head;

    // Find middle (slow/fast) and previous pointer to cut
    ListNode* midPrev = nullptr;
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        midPrev = slow;
        slow = slow->next;
        fast = fast->next->next;
    }

    // split into two lists: head..midPrev and slow..end
    midPrev->next = nullptr;

    ListNode* left = sortList(head);
    ListNode* right = sortList(slow);

    return mergeList(left, right);
}

// Helpers for testing
ListNode* buildList(const vector<int>& v) {
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    for (int x : v) {
        ListNode* node = new ListNode(x);
        if (!head) head = tail = node;
        else { tail->next = node; tail = node; }
    }
    return head;
}

void printList(ListNode* head) {
    bool first = true;
    while (head) {
        if (!first) cout << " ";
        cout << head->val;
        first = false;
        head = head->next;
    }
    cout << "\n";
}

void freeList(ListNode* head) {
    while (head) {
        ListNode* nxt = head->next;
        delete head;
        head = nxt;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin >> n)) return 0;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];

    ListNode* head = buildList(a);
    head = sortList(head);
    printList(head);
    freeList(head);
    return 0;
}
```

---

## ðŸ§ª Example testcases

```
Input:  n=5, list = 4 2 1 3 0
Output: 0 1 2 3 4

Input: n=0 (empty)
Output: (blank line)

Input: n=1, list = [42]
Output: 42

Input: n=6, list = 2 1 3 5 6 4
Output: 1 2 3 4 5 6
```

---

## â± Complexity Analysis

* **Time complexity:** **O(n log n)**

  * Splitting into halves costs O(log n) levels Ã— each level merges O(n) nodes.
* **Space complexity:** **O(log n)** recursion stack (top-down).

  * In-place merging uses O(1) extra heap memory.

**Note:** There is also a bottom-up iterative merge sort for linked lists that achieves **O(1)** extra space (no recursion) and still O(n log n) time. That version avoids recursion stack and is preferred if recursion depth is a concern.

---

## ðŸ” Correctness & edge cases / notes

* **`midPrev` usage:** We record `midPrev` before moving `slow`. After the loop `slow` points to start of right half and `midPrev` to end of left half. We set `midPrev->next = nullptr` to split.
* **Safety:** Base case `if (!head || !head->next) return head;` guarantees `midPrev` will not be `nullptr` when we split (because list has at least two nodes).
* **Stability:** Merge sort is stable â€” equal elements maintain relative order if you use `<=` when choosing from left (as in the code).
* **Memory:** This implementation reuses the existing nodes (no new nodes allocated during sorting).

---

## âœ… Tips & tricks

* If recursion depth is a worry (very long lists), prefer **iterative bottom-up merge sort**:

  * Repeatedly merge list parts of size `1,2,4,8,...` until full list sorted.
  * No recursion, uses O(1) extra space.
* When merging, use a dummy head node to simplify pointer handling.
* Always free nodes if you allocate them during testing to avoid leaks.
* When splitting, be cautious about `midPrev` being null â€” the base case prevents that.

---

## ðŸ”€ Variations & related problems

* **Sort List (LeetCode #148)** â€” same problem; many accepted solutions use either top-down or bottom-up merge sort.
* **Bottom-up merge for linked lists** â€” iterative alternative avoids recursion.
* **Sort list of integers with duplicates** â€” stable sort preserves original relative order for equal values.
* **Sort doubly linked list** â€” similar approach but easier to split/merge due to backward pointers.

---

## â“ FAQs

**Q: Why merge sort, not quicksort?**
A: Quicksort requires random access for efficient partitioning or can degrade on certain inputs. Merge sort works naturally on linked lists because splitting and merging are pointer-based, linear operations.

**Q: Is this in-place?**
A: Yes in the sense that we reuse existing nodes and only change `next` pointers. However the recursion consumes O(log n) stack space.

**Q: Can we do O(1) space total?**
A: Yes â€” use a bottom-up (iterative) merge sort for linked lists to avoid recursion stack.

**Q: Is the algorithm stable?**
A: Yes, since we use `<=` when choosing nodes from left or right, elements equal in value from the left list appear before those from the right.

---

## Bottom-up merge sort (short note)

If you want the no-recursion version, the bottom-up algorithm:

1. Start with `subLength = 1`.
2. While `subLength < n`:

   * For the whole list, repeatedly cut two lists of size `subLength` and merge them.
   * Double `subLength`.
3. Uses only pointer manipulations and a dummy head; avoids recursion.

This is slightly more complex to implement but removes the O(log n) stack usage.

---
