# 🧠 Reverse a Singly Linked List 


## 🧩 Problem Statement

> Given the `head` of a singly linked list, reverse the list and return the new head.

**Example:**

```
Input:  1 → 2 → 3 → 4 → 5 → NULL  
Output: 5 → 4 → 3 → 2 → 1 → NULL
```

---

## 💭 Intuition

When we “reverse” a linked list, every node’s `next` pointer should point to its **previous** node instead of the next one.

The trick is —
👉 *At any moment, we need to carefully rearrange pointers so that no link gets lost.*

---

## 🪜 Recursive Method (Elegant and Clean)

### 🧩 Code

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // Base condition — if list is empty or has only one node
        if (head == nullptr || head->next == nullptr)
            return head;

        // Step 1: Recurse for the remaining list
        ListNode* newHead = reverseList(head->next);

        // Step 2: Adjust the links
        ListNode* front = head->next;
        front->next = head;

        // Step 3: Mark the current node as the new tail
        head->next = nullptr;

        // Step 4: Return new head
        return newHead;
    }
};
```

---

### 🧠 Dry Run (Example)

For list: `1 → 2 → 3 → NULL`

| Step | Call Stack               | Operation                          | Result                  |
| ---- | ------------------------ | ---------------------------------- | ----------------------- |
| 1    | `reverseList(1)`         | Calls `reverseList(2)`             | waiting                 |
| 2    | `reverseList(2)`         | Calls `reverseList(3)`             | waiting                 |
| 3    | `reverseList(3)`         | Base case (returns 3)              | starts unwinding        |
| 4    | Back to `reverseList(2)` | `3->next = 2`, `2->next = nullptr` | Partial list: `3 → 2`   |
| 5    | Back to `reverseList(1)` | `2->next = 1`, `1->next = nullptr` | Final list: `3 → 2 → 1` |

---

### 🧩 Time & Space Complexity

| Metric               | Complexity | Reason                       |
| -------------------- | ---------- | ---------------------------- |
| **Time Complexity**  | O(N)       | Each node is visited once    |
| **Space Complexity** | O(N)       | Recursion stack depth is `N` |

---

### 🧠 Key Points

* Very **clean and readable**, but recursion may cause **stack overflow** for large lists.
* Good for conceptual understanding.

---

## 🧩 Comparison Table

| Feature          | Recursive                | Iterative                |
| ---------------- | ------------------------ | ------------------------ |
| Simplicity       | ✅ Easy to understand     | ✅ Simple to code         |
| Space Complexity | ❌ O(N) (Stack)           | ✅ O(1)                   |
| Performance      | ⚠️ Slightly slower       | ⚡ Fastest                |
| Use case         | Small lists / conceptual | Production / performance |

---

## ❓ FAQs

**Q1: What happens if the list is empty?**

> It simply returns `nullptr`.

**Q2: Will recursion cause memory issues for large lists?**

> Yes. Recursion uses the call stack — for very long lists, prefer the iterative approach.

**Q3: Why return `prev` at the end (iterative)?**

> Because after the loop, `prev` points to the new head of the reversed list.

**Q4: Can we reverse the list in-place?**

> Yes — both approaches are *in-place* since they don’t allocate new nodes.

---
