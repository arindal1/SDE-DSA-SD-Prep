# ðŸ§  Reverse a Singly Linked List 


## ðŸ§© Problem Statement

> Given the `head` of a singly linked list, reverse the list and return the new head.

**Example:**

```
Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ NULL  
Output: 5 â†’ 4 â†’ 3 â†’ 2 â†’ 1 â†’ NULL
```

---

## ðŸ’­ Intuition

When we â€œreverseâ€ a linked list, every nodeâ€™s `next` pointer should point to its **previous** node instead of the next one.

The trick is â€”
ðŸ‘‰ *At any moment, we need to carefully rearrange pointers so that no link gets lost.*

---

## ðŸªœ Recursive Method (Elegant and Clean)

### ðŸ§© Code

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // Base condition â€” if list is empty or has only one node
        if (head == nullptr || head->next == nullptr)
            return head;

        // Step 1: Recurse for the remaining list
        ListNode* newHead = reverseList(head->next);

        // Step 2: Adjust the links
        ListNode* front = head->next;
        front->next = head;

        // Step 3: Mark the current node as the new tail
        head->next = nullptr;

        // Step 4: Return new head
        return newHead;
    }
};
```

---

### ðŸ§  Dry Run (Example)

For list: `1 â†’ 2 â†’ 3 â†’ NULL`

| Step | Call Stack               | Operation                          | Result                  |
| ---- | ------------------------ | ---------------------------------- | ----------------------- |
| 1    | `reverseList(1)`         | Calls `reverseList(2)`             | waiting                 |
| 2    | `reverseList(2)`         | Calls `reverseList(3)`             | waiting                 |
| 3    | `reverseList(3)`         | Base case (returns 3)              | starts unwinding        |
| 4    | Back to `reverseList(2)` | `3->next = 2`, `2->next = nullptr` | Partial list: `3 â†’ 2`   |
| 5    | Back to `reverseList(1)` | `2->next = 1`, `1->next = nullptr` | Final list: `3 â†’ 2 â†’ 1` |

---

### ðŸ§© Time & Space Complexity

| Metric               | Complexity | Reason                       |
| -------------------- | ---------- | ---------------------------- |
| **Time Complexity**  | O(N)       | Each node is visited once    |
| **Space Complexity** | O(N)       | Recursion stack depth is `N` |

---

### ðŸ§  Key Points

* Very **clean and readable**, but recursion may cause **stack overflow** for large lists.
* Good for conceptual understanding.

---

## ðŸ§© Comparison Table

| Feature          | Recursive                | Iterative                |
| ---------------- | ------------------------ | ------------------------ |
| Simplicity       | âœ… Easy to understand     | âœ… Simple to code         |
| Space Complexity | âŒ O(N) (Stack)           | âœ… O(1)                   |
| Performance      | âš ï¸ Slightly slower       | âš¡ Fastest                |
| Use case         | Small lists / conceptual | Production / performance |

---

## â“ FAQs

**Q1: What happens if the list is empty?**

> It simply returns `nullptr`.

**Q2: Will recursion cause memory issues for large lists?**

> Yes. Recursion uses the call stack â€” for very long lists, prefer the iterative approach.

**Q3: Why return `prev` at the end (iterative)?**

> Because after the loop, `prev` points to the new head of the reversed list.

**Q4: Can we reverse the list in-place?**

> Yes â€” both approaches are *in-place* since they donâ€™t allocate new nodes.

---
