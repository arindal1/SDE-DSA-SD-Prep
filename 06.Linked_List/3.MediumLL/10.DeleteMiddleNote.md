## 🧩 Problem: Delete Middle Node of Linked List

Given the `head` of a singly linked list, **delete the middle node** and return the head of the modified list.

If the list has only one node, return `nullptr`.

---

### ✅ Example

```
Input:  1 -> 3 -> 4 -> 7 -> 1 -> 2 -> 6
Output: 1 -> 3 -> 4 -> 1 -> 2 -> 6
```

(The middle node is `7` — 4th node of 7 total nodes.)

---

## 💡 Approach: Slow–Fast Pointer Technique

We use two pointers:

* `fast` moves **2 steps** each time.
* `slow` moves **1 step** each time.
* When `fast` reaches the end, `slow` is at the **middle node**.

We also maintain a `prev` pointer to keep track of the node **before** `slow`, so we can remove `slow` by:

```cpp
prev->next = slow->next;
delete slow;
```

---

## ✅ Full Working Code (C++17)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        // Base case: empty list or single node
        if (head == nullptr || head->next == nullptr) {
            return nullptr;
        }

        ListNode* fast = head;
        ListNode* slow = head;
        ListNode* prev = nullptr;

        // Move fast (2x) and slow (1x)
        while (fast != nullptr && fast->next != nullptr) {
            prev = slow;
            slow = slow->next;
            fast = fast->next->next;
        }

        // 'slow' now points to middle, 'prev' is before middle
        prev->next = slow->next;
        delete slow; // free memory

        return head;
    }
};

ListNode* buildList(const vector<int>& v) {
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    for (int x : v) {
        ListNode* node = new ListNode(x);
        if (!head) head = tail = node;
        else {
            tail->next = node;
            tail = node;
        }
    }
    return head;
}

void printList(ListNode* head) {
    bool first = true;
    while (head) {
        if (!first) cout << " ";
        cout << head->val;
        first = false;
        head = head->next;
    }
    cout << "\n";
}

void freeList(ListNode* head) {
    while (head) {
        ListNode* nxt = head->next;
        delete head;
        head = nxt;
    }
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];

    ListNode* head = buildList(a);

    Solution sol;
    head = sol.deleteMiddle(head);

    printList(head);
    freeList(head);
    return 0;
}
```

---

## 🧪 Example Runs

### **Input**

```
7
1 3 4 7 1 2 6
```

**Output**

```
1 3 4 1 2 6
```

---

### **Input**

```
1
9
```

**Output**

```
(empty line)
```

Because only one node → list becomes `nullptr`.

---

### **Input**

```
4
1 2 3 4
```

**Output**

```
1 2 4
```

Middle node is the 3rd (0-indexed 2).

---

## ⚙️ Complexity

| Operation | Complexity           |
| --------- | -------------------- |
| **Time**  | O(n) — one traversal |
| **Space** | O(1) — in-place      |

---

## 🧠 Edge Cases

| Case        | Input                   | Output               | Reason                      |
| ----------- | ----------------------- | -------------------- | --------------------------- |
| Single node | `[5]`                   | `[]`                 | Delete only node            |
| Two nodes   | `[1, 2]`                | `[2]`                | Delete first (middle = 1st) |
| Even nodes  | `[1, 2, 3, 4]`          | `[1, 2, 4]`          | Deletes 3rd                 |
| Odd nodes   | `[1, 3, 4, 7, 1, 2, 6]` | `[1, 3, 4, 1, 2, 6]` | Deletes exact middle        |

---

### 🧩 Summary

| Feature             | Value                   |
| ------------------- | ----------------------- |
| **Algorithm**       | Slow-Fast Pointer       |
| **Deletes**         | Middle node (if exists) |
| **In-place?**       | ✅ Yes                   |
| **Memory usage**    | Constant                |
| **Time complexity** | O(n)                    |

---
---


# 🧮 Delete Middle — Two-Pass (Count-then-delete) Approach

---

## 💡 Idea (short)

1. **First pass:** Traverse the list to count the number of nodes `n`.
2. Compute the index of the middle node to delete:

   * Using 1-based indexing, the middle node is at position `m = (n / 2) + 1` when `n` is odd and at `m = (n / 2) + 1` when `n` is even — i.e. integer `m = n/2 + 1`.
   * Equivalently, for 0-based indexing delete index `n/2`.
3. **Second pass:** Walk to the node just *before* the middle (`m-1`th node) and unlink the middle node.
4. Free the deleted node and return the (possibly changed) head.

This is simple and robust: two linear scans, constant extra space.

---

## ✅ When to use

* When clarity or simplicity matters.
* When you prefer an explicit count (easier to reason about in some contexts).
* Works fine when recursion or two-pointer trick is unfamiliar.

---

## 🔧 Correct & Safe C++ Implementation (full program)

```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x=0) : val(x), next(nullptr) {}
};

// Two-pass approach: count nodes first, then delete the node at index n/2 (0-based)
ListNode* deleteMiddleTwoPass(ListNode* head) {
    if (head == nullptr) return nullptr;

    // First pass: count nodes
    int n = 0;
    ListNode* cur = head;
    while (cur) {
        ++n;
        cur = cur->next;
    }

    // If only one node, delete it and return nullptr
    if (n == 1) {
        delete head;
        return nullptr;
    }

    // Index to delete in 0-based indexing
    int deleteIndex = n / 2; // e.g., n=7 -> 3, n=4 -> 2

    // Second pass: stop at node just before deleteIndex
    cur = head;
    for (int i = 0; i < deleteIndex - 1; ++i) {
        cur = cur->next;
    }

    // cur now points to node at (deleteIndex-1)
    ListNode* nodeToDelete = cur->next;
    cur->next = nodeToDelete->next;
    delete nodeToDelete;

    return head;
}

// Helpers for testing
ListNode* buildList(const vector<int>& v) {
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    for (int x : v) {
        ListNode* node = new ListNode(x);
        if (!head) head = tail = node;
        else { tail->next = node; tail = node; }
    }
    return head;
}

void printList(ListNode* head) {
    bool first = true;
    while (head) {
        if (!first) cout << " ";
        cout << head->val;
        first = false;
        head = head->next;
    }
    cout << "\n";
}

void freeList(ListNode* head) {
    while (head) {
        ListNode* nxt = head->next;
        delete head;
        head = nxt;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Example interactive usage:
    // First read n then n values.
    int n;
    if (!(cin >> n)) return 0;
    vector<int> vals(n);
    for (int i = 0; i < n; ++i) cin >> vals[i];

    ListNode* head = buildList(vals);
    head = deleteMiddleTwoPass(head);
    printList(head);
    freeList(head);
    return 0;
}
```

---

## ⏱ Complexity

* **Time:** `O(n)` — two passes over the list (count + unlink).
* **Space:** `O(1)` — only a few pointers / counters.

---

## ✅ Edge cases & behavior

* **Empty list (`head == nullptr`)** → returns `nullptr`.
* **Single node (`n == 1`)** → deletes the node and returns `nullptr`.
* **Even length** e.g. `n = 4`: `n/2` = 2 (0-based index), so deletes the 3rd node (1-based), matching the usual convention used earlier.
* **Odd length** e.g. `n = 7`: `n/2` = 3 (0-based index), so deletes the 4th node (exact middle).
* Works for all integer sizes (watch for huge `n` only if memory is a concern, but single linked list size dictates that).

---

## 🔁 Comparison: Two-Pass vs Slow–Fast (One-Pass)

| Feature            |                     Two-Pass (count) |                 Slow–Fast (one-pass) |
| ------------------ | -----------------------------------: | -----------------------------------: |
| Passes             |                                    2 |                                    1 |
| Time               | O(n) (with slightly larger constant) |                                 O(n) |
| Space              |                                 O(1) |                                 O(1) |
| Simplicity         |    Very simple, easy to reason about |      Slightly trickier but idiomatic |
| Edge-case handling |  Explicit (count ensures safe index) |         Also safe; uses prev pointer |
| Preference         |         Good for clarity / beginners | Slightly better for single traversal |

Both are fine — prefer slow-fast when you want a single pass. Use two-pass when you want extra readability or to avoid pointer juggling.

---

## ⚠️ Implementation tips & common pitfalls

* Make sure to free the removed node (`delete`) to avoid memory leaks.
* When `n == 1`, return `nullptr` after deleting the only node.
* Be careful when computing loop bounds in the second pass — ensure `cur` ends up at the node just before the one to delete.
* Use 0-based indexing consistently: deleting at `n/2` (0-based) is equivalent to removing the `(n/2 + 1)`-th node in 1-based indexing.

