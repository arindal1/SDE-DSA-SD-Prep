# Remove all nodes with a given key from a doubly-linked list ‚Äî Deep Notes üß†üí°

## Problem statement üìù

Given a **doubly linked list** and an integer `key`, remove **all nodes** whose `data == key` and return the (possibly new) head of the list.

**Input example**

```cpp
vector<int> arr = {12, 22, 24, 14, 22, 5};
int key = 22;
```

**Expected output**
Linked list printed left-to-right after removals:

```
12  24  14  5
```

(Spacing shown as in the `PrintLL` function ‚Äî two spaces between values.)

---

## Quick Intuition ‚ú®

A doubly linked list node has `next` and `prev`. If we find a node to remove:

* Connect `prev->next` to `next`.
* Connect `next->prev` to `prev`.
* If the node is the head, update `head` to `next`.
* Free the node.

Because we have both `prev` and `next` pointers available, we can remove nodes in **O(1)** time per node (no need to scan from head for predecessor). Doing one pass through the list removes all matching nodes ‚Äî giving **O(n)** time and **O(1)** extra space.

---

## Brute force approach (conceptual) üê¢

If you *didn‚Äôt* have `prev` pointers (i.e., a singly linked list), a brute force method to remove a node often requires:

* For each node, scan from head to find its predecessor ‚Äî O(n) for a single removal.
* Removing all matches by doing these scans leads to **O(n¬≤)** worst-case.

So for a doubly linked list the natural optimal method leverages `prev`.

---

## Optimal approach (one pass) ‚úÖ

**Algorithm** (one pass, constant extra space):

1. Start at `temp = head`.
2. For each `temp`:

   * Save `nxt = temp->next` (so after deletion we know where to continue).
   * If `temp->data == key`:

     * If `temp->prev` exists: `temp->prev->next = temp->next`.
     * Else: `head = temp->next` (we deleted the head).
     * If `temp->next` exists: `temp->next->prev = temp->prev`.
     * `delete temp`.
   * Move `temp = nxt`.
3. After the loop, return `head`.

This correctly handles deletions in all positions (head, tail, middle, all nodes, no nodes).

---

## Step-by-step worked example üîç

List: `12 <-> 22 <-> 24 <-> 14 <-> 22 <-> 5`, `key = 22`.

Pass through nodes:

* `temp=12`: not equal ‚Üí move forward.
* `temp=22` (first 22): equals:

  * `prev=12` exists ‚Üí `12->next = 24`.
  * `24->prev = 12`.
  * delete the `22` node.
  * continue at `24`.
* `temp=24`: not equal ‚Üí move forward.
* `temp=14`: not equal ‚Üí move forward.
* `temp=22` (second 22): equals:

  * `prev=14` exists ‚Üí `14->next = 5`.
  * `5->prev = 14`.
  * delete `22`.
  * continue at `5`.
* `temp=5`: not equal ‚Üí move forward (`nullptr`).
* Done.

Resulting list: `12 <-> 24 <-> 14 <-> 5`.

---

## Potential pitfalls & fixes ‚úÖüîß

The original code is **mostly correct**. A few things I would explicitly improve for clarity and robustness:

* Make `head->prev = nullptr;` explicit in `Arr2LL` to be clear, even though constructor default does that.
* Consider adding a helper `freeList(Node* head)` to centralize cleanup.
* Optionally, use a *dummy/sentinel* node to simplify head deletions (not necessary, but common).
* For production code, consider smart pointers or RAII wrappers to manage memory automatically ‚Äî raw `new`/`delete` is fine for educational code but error-prone in large systems.

I will present a cleaned, commented version of the code below with minor stylistic improvements.

---

## Full (improved & annotated) code üß©

```cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node* prev;

    // Constructor with defaults for next/prev
    Node(int data1, Node* next1 = nullptr, Node* prev1 = nullptr) {
        data = data1;
        next = next1;
        prev = prev1;
    }
};

// Convert vector to doubly linked list.
// Returns head (nullptr if arr empty).
Node* Arr2LL(const vector<int> &arr) {
    if (arr.empty()) return nullptr;

    Node* head = new Node(arr[0]);
    head->prev = nullptr; // explicit for clarity
    Node* tail = head;

    for (size_t i = 1; i < arr.size(); ++i) {
        Node* node = new Node(arr[i], nullptr, tail);
        tail->next = node;
        tail = node;
    }
    return head;
}

// Print list left to right (two spaces between elements like original).
void PrintLL(Node* head) {
    while (head) {
        cout << head->data;
        if (head->next) cout << "  ";
        head = head->next;
    }
    cout << "\n";
}

// Remove all nodes with data == key and return new head.
Node* RemoveKs(Node* head, int key) {
    Node* temp = head;

    while (temp != nullptr) {
        Node* nxt = temp->next; // store next before any possible deletion

        if (temp->data == key) {
            // Link previous node (if any) to next
            if (temp->prev) {
                temp->prev->next = temp->next;
            } else {
                // Deleting head -> update head
                head = temp->next;
            }
            // Link next node (if any) back to previous
            if (temp->next) {
                temp->next->prev = temp->prev;
            }

            // Safe cleanup (optional - reset pointers)
            temp->next = nullptr;
            temp->prev = nullptr;
            delete temp; // free memory of removed node
        }

        temp = nxt; // continue traversal from saved next
    }

    return head;
}

// Utility to free entire list and avoid memory leak
void FreeList(Node* head) {
    while (head) {
        Node* nxt = head->next;
        delete head;
        head = nxt;
    }
}

int main() {
    vector<int> arr = {12, 22, 24, 14, 22, 5};
    int key = 22;

    Node* head = Arr2LL(arr);

    head = RemoveKs(head, key);

    PrintLL(head);

    FreeList(head);
    return 0;
}
```

---

## Complexity analysis üìä

* **Time complexity:** **O(n)** where `n` is the number of nodes. Each node is visited exactly once; removal is O(1).
* **Space complexity:** **O(1)** extra memory (in-place). We only use a couple of pointer variables.

---

## Test cases üß™

1. **Basic case**

   * Input: `arr = {12, 22, 24, 14, 22, 5}`, `key=22`
   * Output: `12  24  14  5`

2. **Key not present**

   * Input: `arr = {1,2,3}`, `key=10`
   * Output: `1  2  3`

3. **All nodes equal to key ‚Üí empty list**

   * Input: `arr = {7,7,7}`, `key=7`
   * Output: (print nothing; newline only)

4. **Single-node list**

   * Input: `arr = {5}`, `key=5`
   * Output: (empty)

5. **Delete tail**

   * Input: `arr = {1,2,3}`, `key=3`
   * Output: `1  2`

6. **Delete head**

   * Input: `arr = {9,1,2}`, `key=9`
   * Output: `1  2`

7. **No nodes (empty vector)**

   * Input: `arr = {}`, `key = anything`
   * Output: (empty; program should handle gracefully)

---

## Tips & tricks ‚ú®

* **Always store `next` before deleting a node**: after `delete temp`, accessing `temp->next` is undefined. That's why we store `nxt = temp->next` early.
* **Be explicit with head updates**: deleting the head needs special handling (set new head, ensure `head->prev == nullptr`).
* **Reset pointers before `delete` (optional)**: `temp->next = temp->prev = nullptr; delete temp;` helps avoid accidental use-after-free in debugging.
* **Consider a dummy (sentinel) node** when deleting many nodes near the head ‚Äî it simplifies code by avoiding separate head-case logic.
* **Use RAII/smart pointers** for production C++ ‚Äî `unique_ptr` + custom deleter or a container wrapper frees you from manual `delete`.
* **Prefer `nullptr` over `NULL`** in modern C++.

---

## Variations & extensions üîÅ

1. **Remove only the first occurrence** ‚Äî stop after the first deletion.
2. **Remove nodes based on predicate** ‚Äî e.g. `remove if node->data%2==0`.
3. **Singly linked list variant** ‚Äî need to maintain `prev` by tracking previous pointer during traversal. Slightly different code.
4. **Return count of removed nodes** ‚Äî keep a counter and return it for statistics.
5. **Make the function recursive** ‚Äî possible but not recommended for long lists (stack overflow risk).
6. **In-place duplicate removal, dedup by value** ‚Äî use a hash set to remove nodes whose value seen already (O(n) time, O(n) extra space).

---

## Frequently Asked Questions (FAQs) ‚ùì

**Q: What happens when all nodes are deleted?**
A: `RemoveKs` will set `head` to `nullptr` when the head is removed and no nodes remain. The `FreeList`/cleanup code must check for `nullptr` and handle it (while loop won't execute).

**Q: Can removing nodes cause invalid pointer accesses?**
A: Only if you access deleted nodes. To avoid this, always store `next` before deleting and do not use pointers after `delete`.

**Q: Do we need to update `prev` for the new head?**
A: Yes ‚Äî in our code we set `temp->next->prev = temp->prev`. If `temp` was head, `temp->prev` is `nullptr`, so the new head's `prev` becomes `nullptr` automatically.

**Q: Could we do this with singly linked lists?**
A: Yes ‚Äî but you need to keep track of the previous node during traversal. Removing a node requires `prev->next = curr->next`. Head removal is special (update head pointer).

**Q: Should I use smart pointers instead of `new/delete`?**
A: Yes for production code. `unique_ptr` with custom deleters or wrapper classes is safer. But raw pointers are fine for simple exercises.

---
