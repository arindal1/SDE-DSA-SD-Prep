# Remove consecutive duplicates from a **sorted doubly linked list** üß†‚ú®

## Problem statement üìù

You are given a **sorted** doubly linked list (ascending order) which may contain duplicates next to each other. Remove duplicate nodes so every value appears **only once** in the final list. Keep the *first* instance of each value and free memory of removed nodes.

**Example**
Input:

```
1 <-> 2 <-> 2 <-> 3 <-> 4 <-> 4 <-> 4 <-> 5
```

Output:

```
1 <-> 2 <-> 3 <-> 4 <-> 5
```

---

## Intuition ‚ú®

Because the list is sorted, any duplicates for a value appear **consecutively**. We can iterate with a pointer `curr` that always points to the *first* node of a (value) group. For the next nodes while their value equals `curr->data`, delete them and keep moving forward until we hit the next distinct value. Then link `curr->next` to that new node and continue.

This approach requires a **single pass** and only constant extra memory.


## Brute force (not recommended) üêå

* Scan each node `n` and for each `n` search ahead to find duplicates then remove them ‚Äî still O(n) in this case because duplicates are consecutive, but a poorly written solution might re-scan previously handled regions and waste time.
* The simple one-pass strategy below is clearer and optimal.


## Optimal approach (one-pass) ‚úÖ

Algorithm:

1. If `head == nullptr` return `nullptr`.
2. Let `curr = head`.
3. While `curr != nullptr` and `curr->next != nullptr`:

   * Let `runner = curr->next`.
   * While `runner != nullptr && runner->data == curr->data`:

     * Keep `to_delete = runner`, move `runner = runner->next`, `delete to_delete`.
   * Set `curr->next = runner`.
   * If `runner != nullptr` set `runner->prev = curr`.
   * Move `curr = curr->next` (which is `runner`).
4. Return `head`.

Key points:

* Always store `runner->next` before deleting `runner`.
* Update both `next` and `prev` links to preserve list integrity.
* Deleting nodes frees memory; ensure you don't access deleted memory.



## Full improved & annotated code üß©

```cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node* prev;

    // two constructors for convenience
    Node(int data1, Node* next1 = nullptr, Node* prev1 = nullptr) {
        data = data1;
        next = next1;
        prev = prev1;
    }
};

// Build doubly linked list from vector (returns head).
Node* Arr2LL(const vector<int> &arr) {
    if (arr.empty()) return nullptr;

    Node* head = new Node(arr[0]);
    head->prev = nullptr; // explicit
    Node* tail = head;

    for (size_t i = 1; i < arr.size(); ++i) {
        Node* node = new Node(arr[i], nullptr, tail);
        tail->next = node;
        tail = node;
    }
    return head;
}

// Print doubly linked list using "<->" between nodes.
void PrintLL(Node* head) {
    Node* temp = head;
    while (temp) {
        cout << temp->data;
        if (temp->next != nullptr) cout << " <-> ";
        temp = temp->next;
    }
    cout << "\n";
}

// Remove consecutive duplicates in-place and free removed nodes.
// Keeps the first occurrence of each value.
Node* deleteDuplicates(Node* head) {
    if (head == nullptr) return head;

    Node* curr = head;

    while (curr != nullptr && curr->next != nullptr) {
        Node* runner = curr->next;

        // remove all consecutive nodes equal to curr->data
        while (runner != nullptr && runner->data == curr->data) {
            Node* to_delete = runner;
            runner = runner->next;
            delete to_delete; // free memory
        }

        // link curr to the first distinct node (may be nullptr)
        curr->next = runner;
        if (runner != nullptr) runner->prev = curr;

        // advance to next distinct element
        curr = curr->next;
    }

    return head;
}

// Free entire list to avoid memory leaks
void FreeList(Node* head) {
    while (head) {
        Node* nxt = head->next;
        delete head;
        head = nxt;
    }
}

int main() {
    vector<int> arr = {1, 2, 2, 3, 4, 4, 4, 5};

    Node* head = Arr2LL(arr);
    cout << "Original list:\n";
    PrintLL(head);

    head = deleteDuplicates(head);
    cout << "After removing duplicates:\n";
    PrintLL(head);

    FreeList(head);
    return 0;
}
```

---

## Complexity analysis üìä

* **Time complexity:** **O(n)** where `n` is the number of nodes. Each node is visited once by either `curr` or `runner` and deleted at most once.
* **Space complexity:** **O(1)** extra space (in-place). Only a few pointer variables used. Output and input are not counted.

---

## Test cases & edge cases üß™

1. **Basic case (given)**

   * Input: `1,2,2,3,4,4,4,5` ‚Üí Output: `1 <-> 2 <-> 3 <-> 4 <-> 5`
2. **No duplicates**

   * Input: `1,2,3` ‚Üí Output unchanged.
3. **All duplicates**

   * Input: `2,2,2,2` ‚Üí Output: `2` (head remains single node).
4. **Duplicates at head**

   * Input: `1,1,1,2,3` ‚Üí Output: `1 <-> 2 <-> 3`
5. **Duplicates at tail**

   * Input: `1,2,3,3,3` ‚Üí Output: `1 <-> 2 <-> 3`
6. **Empty list**

   * Input: `{}` ‚Üí Output: nothing (no crash).
7. **Single node**

   * Input: `{5}` ‚Üí Output: `{5}`

---

## Tips & tricks ‚ú®

* **Sorted list assumption**: This algorithm relies on the input list being sorted. If not sorted, duplicates might not be adjacent and you need a different approach (e.g., hash set).
* **Never access deleted memory**: Always move the pointer (`runner = runner->next`) before `delete`ing the node you want to remove.
* **Update both `next` and `prev`** when relinking; forgetting one leads to corrupted list or runtime errors.
* **Use `size_t` for indexing loops** to avoid signed/unsigned warnings.
* **Free memory** for removed nodes and for the final list before program end to be correct in larger programs.

---

## Variations & extensions üîÅ

1. **Remove all occurrences of duplicates** (not keep first): If you want to remove any value that appears more than once entirely (keep only unique values), you must detect groups with size > 1 and delete the entire group including the first node.
2. **Unsorted list dedup**: Use an `unordered_set<int>` and remove any node whose value has been seen before ‚Äî O(n) time, O(n) extra space.
3. **Return count of removed nodes**: Keep a counter whenever you `delete` a node.
4. **Recursive variant**: Could be implemented recursively but not recommended for long lists (stack depth).
5. **Smart pointers**: Use `unique_ptr` wrappers in C++ to automatically manage node lifetime in production code.

---

## Frequently Asked Questions (FAQs) ‚ùì

**Q: Does this handle non-consecutive duplicates?**
A: No ‚Äî this code assumes the list is sorted so duplicates are consecutive. For non-consecutive duplicates use a hash set.

**Q: Will head ever change?**
A: The algorithm keeps the first occurrence of each value, including the head's first occurrence. If you wanted to remove the first node as part of removing duplicates (e.g., remove every value that appears >1 times entirely), head might change and you must handle that separately.

**Q: Is deletion safe?**
A: Yes ‚Äî we always advance `runner` before calling `delete` on the node being removed.

**Q: Can this be used on a singly linked list?**
A: Yes ‚Äî logic is similar but you only update `next` pointers. You won't have `prev` to update.
