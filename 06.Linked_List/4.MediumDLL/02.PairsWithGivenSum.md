# Find all pairs with given sum in a **sorted doubly linked list**

---

# Problem statement üìù

You are given a sorted doubly linked list (ascending order) and an integer `target`. Return all distinct pairs of node values `(x, y)` such that `x + y == target`. Each pair should be output once (order inside pair: left value then right value). Example:

Input:

```cpp
vector<int> arr = {1, 2, 4, 5, 6, 8, 9};
int target = 7;
```

Expected output (each pair on its own line):

```
1 6
2 5
```

---

# Intuition ‚ú®

Because the list is **sorted**, we can maintain two pointers:

* `left` starting at the head (small values),
* `right` starting at the tail (large values).

Compute `sum = left->data + right->data`:

* If `sum == target`: record the pair, move `left` forward and `right` backward.
* If `sum < target`: move `left` forward to increase sum.
* If `sum > target`: move `right` backward to decrease sum.

Stop when the two pointers meet or cross. This yields a single-pass O(n) algorithm and returns each valid pair exactly once.

---

# Brute force approach (for comparison) üêå

The brute force approach would check every unordered pair of nodes:

* For each node `a`, scan all nodes `b` after `a` and check if `a->data + b->data == target`.
* Complexity: O(n¬≤) time, O(1) space.
* Not acceptable for large lists. Two-pointer is superior because of the sorted property.


---

# Optimal approach (one-pass two-pointer) ‚úÖ

Algorithm:

1. If `head == nullptr`, return empty result.
2. Move `right` from `head` to last node (tail).
3. Initialize `left = head`.
4. Loop while `left != right && left->prev != right`:

   * Compute `sum = left->data + right->data`.
   * If `sum == target`: record `{left->data, right->data}`, advance `left`, retreat `right`.
   * If `sum < target`: advance `left`.
   * If `sum > target`: retreat `right`.
5. Return list of pairs.

This visits each node at most once -> **O(n)** time, **O(1)** extra space (excluding output).

---

# Full improved & annotated code üß©

```cpp
#include <bits/stdc++.h>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node* prev;

    Node(int data1, Node* next1 = nullptr, Node* prev1 = nullptr) {
        data = data1;
        next = next1;
        prev = prev1;
    }
};

// Build a doubly linked list from vector (head->...->tail).
Node* Arr2LL(const vector<int> &arr) {
    if (arr.empty()) return nullptr;
    Node* head = new Node(arr[0]);
    head->prev = nullptr; // explicit
    Node* tail = head;
    for (size_t i = 1; i < arr.size(); ++i) {
        Node* node = new Node(arr[i], nullptr, tail);
        tail->next = node;
        tail = node;
    }
    return head;
}

// Print result pairs: each pair on its own line
void PrintPairs(const vector<vector<int>> &res) {
    if (res.empty()) {
        cout << "No pairs found\n";
        return;
    }
    for (const auto &p : res) {
        if (p.size() == 2) cout << p[0] << " " << p[1] << "\n";
    }
}

// Find all pairs in sorted doubly linked list that sum to target
vector<vector<int>> SumFind(Node* head, int target) {
    vector<vector<int>> res;
    if (!head) return res;

    // Move right to the tail
    Node* right = head;
    while (right->next) right = right->next;

    Node* left = head;

    // Stop when left meets or crosses right.
    // left->prev == right indicates left has moved past right.
    while (left != right && left->prev != right) {
        int sum = left->data + right->data;
        if (sum == target) {
            res.push_back({left->data, right->data});
            left = left->next;
            right = right->prev;
        } else if (sum < target) {
            left = left->next;
        } else { // sum > target
            right = right->prev;
        }
    }
    return res;
}

// Free memory of list
void FreeList(Node* head) {
    while (head) {
        Node* nxt = head->next;
        delete head;
        head = nxt;
    }
}

int main() {
    vector<int> arr = {1, 2, 4, 5, 6, 8, 9};
    int target = 7;

    Node* head = Arr2LL(arr);

    vector<vector<int>> res = SumFind(head, target);

    PrintPairs(res);

    FreeList(head);
    return 0;
}
```

---

# Complexity analysis üìä

* **Time complexity:** **O(n)** ‚Äî each pointer moves towards the other at most `n` steps in total.
* **Space complexity:** **O(1)** extra space (excluding the output `res`, which may be up to O(n) in worst case if many pairs are found).

---

# Test cases üß™

1. **Given example**

   * `arr = {1,2,4,5,6,8,9}`, `target = 7`
     Output:

   ```
   1 6
   2 5
   ```

2. **No pairs**

   * `arr = {1,3,5,7}`, `target = 2` ‚Üí `No pairs found`

3. **Single pair (head & tail)**

   * `arr = {1,2,3,7}`, `target = 8` ‚Üí `1 7`

4. **Duplicates allowed**

   * `arr = {1,1,2,3,4}`, `target = 2` ‚Üí `1 1` (pair uses distinct nodes: two different nodes both containing 1)

5. **All elements pairable (multiple pairs)**

   * `arr = {1,2,3,4,5,6}`, `target = 7` ‚Üí `1 6`, `2 5`, `3 4`

6. **Empty list**

   * `arr = {}`, `target = 5` ‚Üí `No pairs found` (handled)

7. **Single node only**

   * `arr = {3}`, `target = 6` ‚Üí `No pairs found`

---

# Tips & tricks ‚ú®

* **Sorted list assumption is crucial.** Without sorted order, the two-pointer method doesn't apply. For unsorted list, you can use a hash set (O(n) time, O(n) extra space) or sort first (O(n log n)).
* **Be careful with loop termination.** For linear lists the `left->prev != right` check prevents pointers crossing.
* **Handle duplicates intentionally.** The algorithm treats nodes as distinct even if values duplicate. If you want *unique value* pairs (no repeated values), you'd need extra checks or a set to deduplicate results.
* **If using a circular doubly linked list**, use `right->next != left` as the stopping condition ‚Äî but be sure list is circular.
* **Always check `head==nullptr`** before dereferencing pointers.

---

# Variations & extensions üîÅ

* **Return indices instead of values** (if nodes had indices / positions).
* **Find triplets (three-sum)** in a sorted doubly linked list: fix one node and use two-pointer on the remaining (O(n¬≤)).
* **Unsorted list**: use a hash map to find complements (O(n) time, O(n) space).
* **List with negative numbers**: algorithm still works as long as list sorted in ascending order.
* **Avoid duplicates in result**: after finding a valid pair, advance left while `left->data == prev_left_value`, similarly for right ‚Äî akin to two-sum with duplicates handling.

---

# Frequently Asked Questions (FAQs) ‚ùì

**Q: Why must the list be sorted?**
A: The two-pointer technique relies on monotonic change in `sum` when moving left or right. Without sorting, moving left or right gives no predictable change in sum.

**Q: What about using `right->next != left`?**
A: That condition is for circular lists. For linear lists `right->next` becomes `nullptr` and will not equal `left`; the loop would not terminate properly.

**Q: Do we need to free memory?**
A: Yes ‚Äî if your program runs long or is part of a larger system, free nodes. In short-lived examples it's optional but still good practice (see `FreeList`).

**Q: Can pairs overlap (use same node twice)?**
A: No ‚Äî `left` and `right` are distinct pointers and we never pair a node with itself because we stop when `left == right` or they cross.

**Q: What if we want the first matching pair only?**
A: Return immediately when you find `sum == target` instead of collecting all pairs.

