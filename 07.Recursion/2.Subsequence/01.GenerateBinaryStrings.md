# ğŸ”¢ Generate Binary Strings



## ğŸ“Œ Problem Statement

Given an integer `n`, generate **all binary strings of length `n`** such that:

* The string contains only `'0'` and `'1'`
* **No two consecutive `1`s** are allowed

ğŸ¯ **Goal:**
Print or return all such valid binary strings.



### Example

```text
Input:  n = 3
Output: 000 001 010 100 101
```



## ğŸ§  Intuition

At each position in the string, you have choices:

* You can **always** add `'0'`
* You can add `'1'` **only if the previous character is not `'1'`**

So the constraint is **local**:

> A `'1'` is allowed only when the last character isnâ€™t `'1'`.

This makes the problem perfect for **recursive backtracking**.



## ğŸªœ Brute Force Approach (Why Not)

* Generate all `2^n` binary strings
* Filter out strings containing `"11"`

â›” Time complexity: `O(n Ã— 2^n)`
â›” Wastes work generating invalid strings

We can do better by **never generating invalid states** in the first place.



## ğŸš€ Optimal Recursive / Backtracking Approach

### Strategy

Build the string **one character at a time**:

1. If the current string length is `n` â†’ store it.
2. Always try adding `'0'`.
3. Try adding `'1'` **only if**:

   * The string is empty, or
   * The last character is `'0'`.

This ensures:

* Constraint is respected at every step
* No invalid strings are generated



## ğŸ§© Code Walkthrough

Your implementation ğŸ‘‡

```cpp
void generate(int n, string curr, vector<string>& result) {
    if (curr.length() == n) {
        result.push_back(curr);
        return;
    }
```

### 1ï¸âƒ£ Base Case

If current string length equals `n`:

* Itâ€™s valid
* Store it
* Stop recursion for this path



### 2ï¸âƒ£ Always Add `'0'`

```cpp
generate(n, curr + "0", result);
```

* Adding `'0'` never violates the rule
* So this branch is always allowed



### 3ï¸âƒ£ Conditionally Add `'1'`

```cpp
if (curr.empty() || curr.back() != '1') {
    generate(n, curr + "1", result);
}
```

We add `'1'` only if:

* The string is empty (first position), or
* The previous character is not `'1'`

This prevents `"11"` from ever appearing.



## ğŸ§ª Dry Run Example

### Input

```cpp
n = 3
```

### Recursive Tree (Simplified)

```
"" 
 â”œâ”€â”€ "0"
 â”‚    â”œâ”€â”€ "00"
 â”‚    â”‚    â”œâ”€â”€ "000" âœ…
 â”‚    â”‚    â””â”€â”€ "001" âœ…
 â”‚    â””â”€â”€ "01"
 â”‚         â””â”€â”€ "010" âœ…
 â””â”€â”€ "1"
      â””â”€â”€ "10"
           â”œâ”€â”€ "100" âœ…
           â””â”€â”€ "101" âœ…
```

### Output

```text
000 001 010 100 101
```

âœ” No consecutive `1`s
âœ” All valid strings generated



## â±ï¸ Time & Space Complexity

### Time Complexity

* Number of valid strings â‰ˆ Fibonacci sequence
* Approximately `O(F(n))`, where:

  ```
  F(n) â‰ˆ 2^n (upper bound)
  ```

In practice, much less than `2^n` due to pruning.



### Space Complexity

* Recursion stack: `O(n)`
* Output storage: depends on number of valid strings



## ğŸ§  Why This Works

* Constraint is **local**, so it can be enforced greedily at each step
* Backtracking avoids exploring invalid paths
* Ensures correctness by construction

This is a classic **â€œbuild + validate while buildingâ€** recursion pattern.



## âœ¨ Cleaner Variant (Using Reference)

To avoid string copying:

```cpp
void generate(int n, string &curr, vector<string>& result) {
    if (curr.size() == n) {
        result.push_back(curr);
        return;
    }

    curr.push_back('0');
    generate(n, curr, result);
    curr.pop_back();

    if (curr.empty() || curr.back() != '1') {
        curr.push_back('1');
        generate(n, curr, result);
        curr.pop_back();
    }
}
```

More efficient, same logic.



## ğŸ” Iterative / DP Insight (Bonus)

Number of valid binary strings follows Fibonacci:

* Let `dp[i]` = number of valid strings of length `i`
* Then:

  ```
  dp[i] = dp[i-1] + dp[i-2]
  ```

But DP only counts, recursion **generates** them.



## ğŸ™‹ FAQs

### â“ Why can we always add `'0'`?

Because `'0'` doesnâ€™t affect the constraint.



### â“ Why check only the previous character?

Because the rule is *no consecutive* `1`s â€” only adjacency matters.



### â“ Is this similar to parentheses generation?

Yes! Both use:

* Recursion
* Constraints enforced during construction



### â“ Can this be generalized?

Yes â€” for any rule like:

* No consecutive X
* At most K consecutive characters
* Binary strings with constraints
