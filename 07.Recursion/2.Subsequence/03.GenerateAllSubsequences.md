# ğŸ”¡ Generate All Subsequences of a String (Recursion + Backtracking)



## ğŸ“Œ Problem Statement

Given a string `s`, generate **all possible subsequences** of the string.

ğŸ“Œ **Rules:**

* A subsequence preserves the **relative order** of characters.
* Characters may be **skipped**, but not rearranged.
* The **empty string** is also a valid subsequence.

ğŸ¯ **Goal:**
Return all subsequences of `s`.



### Example

```text
Input:  "abc"
Output:
""
"c"
"b"
"bc"
"a"
"ac"
"ab"
"abc"
```

(Order may vary)



## ğŸ§  Intuition

At each character, you have **two choices**:

1. **Exclude** the character
2. **Include** the character

This creates a binary decision tree:

```
include / exclude
```

For a string of length `n`:

* Total subsequences = `2^n`

This is the same idea as generating the **power set**.



## ğŸªœ Brute Force Approach (Conceptual)

* Generate all `2^n` subsets using bitmasks.
* Convert each mask into a string.

Works, but:

* Less intuitive
* Harder to extend with constraints

Recursion mirrors the problem naturally.



## ğŸš€ Recursive Backtracking Approach

### Strategy

1. Start at index `0`.
2. For each character:

   * Recurse **without** including it.
   * Recurse **including** it.
3. When index reaches end of string:

   * Store current subsequence.

This guarantees:

* All subsequences are generated
* Order is preserved
* No duplicates



## ğŸ§© Code Walkthrough

Your implementation ğŸ‘‡

```cpp
void helper(string &s, int index, string &current, vector<string> &result) {
    if (index == s.size()) {
        result.push_back(current);
        return;
    }
```

### 1ï¸âƒ£ Base Case

If we reach the end of the string:

* `current` holds one valid subsequence
* Add it to `result`



### 2ï¸âƒ£ Exclude Current Character

```cpp
helper(s, index + 1, current, result);
```

We skip `s[index]` and move forward.



### 3ï¸âƒ£ Include Current Character

```cpp
current.push_back(s[index]);
helper(s, index + 1, current, result);
current.pop_back(); // backtrack
```

* Add character to subsequence
* Recurse
* Remove it (backtracking) to restore state



### 4ï¸âƒ£ Entry Function

```cpp
vector<string> getSubsequences(string s) {
    vector<string> result;
    string current = "";
    helper(s, 0, current, result);
    return result;
}
```

Starts recursion from index `0`.



## ğŸ§ª Dry Run Example

### Input

```cpp
s = "abc"
```

### Recursive Tree

```
"" 
 â”œâ”€â”€ exclude 'a'
 â”‚    â”œâ”€â”€ exclude 'b'
 â”‚    â”‚    â”œâ”€â”€ exclude 'c' â†’ ""
 â”‚    â”‚    â””â”€â”€ include 'c' â†’ "c"
 â”‚    â””â”€â”€ include 'b'
 â”‚         â”œâ”€â”€ exclude 'c' â†’ "b"
 â”‚         â””â”€â”€ include 'c' â†’ "bc"
 â””â”€â”€ include 'a'
      â”œâ”€â”€ exclude 'b'
      â”‚    â”œâ”€â”€ exclude 'c' â†’ "a"
      â”‚    â””â”€â”€ include 'c' â†’ "ac"
      â””â”€â”€ include 'b'
           â”œâ”€â”€ exclude 'c' â†’ "ab"
           â””â”€â”€ include 'c' â†’ "abc"
```

### Output

```text
""
"c"
"b"
"bc"
"a"
"ac"
"ab"
"abc"
```

âœ” All subsequences generated
âœ” Order preserved



## â±ï¸ Time & Space Complexity

### Time Complexity

* Total subsequences: `2^n`
* Each subsequence takes up to `O(n)` to copy

Overall:

```
O(n Ã— 2^n)
```



### Space Complexity

* Recursion stack: `O(n)`
* Output storage: `O(n Ã— 2^n)`



## ğŸ§  Why Backtracking Works

* Each decision is **local** (include or exclude)
* Backtracking restores state after each recursive call
* Guarantees full coverage of solution space

This is a **core recursion pattern** youâ€™ll reuse everywhere.



## âœ¨ Cleaner Variant (Avoid Extra Copies)

Your code already does this well by passing `current` by reference ğŸ‘

This is optimal.



## ğŸ” Iterative Bitmask Version (Alternative)

```cpp
vector<string> subsequences(string s) {
    int n = s.size();
    vector<string> res;

    for (int mask = 0; mask < (1 << n); mask++) {
        string cur = "";
        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) {
                cur.push_back(s[i]);
            }
        }
        res.push_back(cur);
    }
    return res;
}
```

Same output, different approach.



## ğŸ™‹ FAQs

### â“ Why include the empty string?

Because subsequence means *zero or more characters*.



### â“ Are subsequences same as substrings?

âŒ No.

* Subsequence: skip allowed (`"ac"` from `"abc"`)
* Substring: contiguous only (`"ac"` âŒ)



### â“ Can duplicates appear?

Only if the input string has duplicate characters.



### â“ How to handle duplicates?

Sort input and skip duplicates, or use a `set`.

