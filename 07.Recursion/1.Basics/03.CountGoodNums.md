

# ğŸ”¢ Count Good Numbers [#1922](https://leetcode.com/problems/count-good-numbers/)



## ğŸ“Œ Problem Statement

You are given a number `n` representing the **length** of a digit string.

A digit string is called **good** if:

* Digits at **even indices** (0-based) can be **even digits**
  â†’ `{0, 2, 4, 6, 8}` â†’ **5 choices**
* Digits at **odd indices** can be **prime digits**
  â†’ `{2, 3, 5, 7}` â†’ **4 choices**

ğŸ¯ **Goal:**
Return the **total number of good digit strings of length `n`**, modulo `10^9 + 7`.



## ğŸ§  Intuition

This problem is not about strings ... itâ€™s about **counting choices**.

At each position:

* Even index â†’ 5 choices
* Odd index â†’ 4 choices

So the total number of good strings is simply the **product of choices at each index**.



## ğŸ§® Math Breakdown

Let:

* `evenCount` = number of even indices
* `oddCount` = number of odd indices

For a string of length `n`:

* `evenCount = (n + 1) / 2`
* `oddCount = n / 2`

Total good numbers:

```
(5 ^ evenCount) Ã— (4 ^ oddCount)
```



## âš¡ Key Optimization Insight

Notice:

```
5 ^ evenCount Ã— 4 ^ oddCount
= 5 Ã— (5 Ã— 4)^(n/2)   if n is odd
= (5 Ã— 4)^(n/2)       if n is even
```

Since:

```
5 Ã— 4 = 20
```

We can compute:

* If `n` is even:

  ```
  20^(n/2)
  ```
* If `n` is odd:

  ```
  20^(n/2) Ã— 5
  ```

This dramatically simplifies computation.



## ğŸš€ Why Fast Exponentiation?

* `n` can be as large as `10^15`
* Direct power computation is impossible
* We use **binary exponentiation** to compute:

  ```
  O(log n)
  ```



## ğŸ§© Code Walkthrough

Your solution:

```cpp
class Solution {
public:
    int M = 1e9+7;
```

Modulo constant to prevent overflow.



### ğŸ”¹ Fast Power Function

```cpp
long long power(long long b, long long e, long long ans) {
    if (e == 0)
        return ans;
    if (e & 1)
        return power(b, e - 1, (ans * b) % M);
    else
        return power((b * b) % M, e / 2, ans);
}
```

This is **recursive binary exponentiation**.

#### What it does:

* If exponent is `0` â†’ return accumulated answer
* If exponent is odd:

  * Multiply `ans` by `b`
  * Reduce exponent by 1
* If exponent is even:

  * Square base
  * Halve exponent

All operations are modulo `M`.



### ğŸ”¹ Main Logic

```cpp
int countGoodNumbers(long long n) {
    long long temp = power(20, n/2, 1);
    return (n & 1) ? (temp * 5) % M : temp;
}
```

Step-by-step:

1. Compute:

   ```
   20^(n/2) % M
   ```
2. If `n` is odd:

   * Multiply by `5`
3. Return result modulo `M`



## ğŸ§ª Dry Run Examples



### Example 1

```cpp
n = 1
```

* Even indices = 1
* Odd indices = 0

Total:

```
5^1 Ã— 4^0 = 5
```

Code:

```
power(20, 0) = 1
odd â†’ 1 Ã— 5 = 5
```

âœ” Correct



### Example 2

```cpp
n = 2
```

* Even indices = 1
* Odd indices = 1

Total:

```
5 Ã— 4 = 20
```

Code:

```
power(20, 1) = 20
```

âœ” Correct



### Example 3

```cpp
n = 4
```

* even = 2
* odd = 2

Total:

```
5^2 Ã— 4^2 = 25 Ã— 16 = 400
```

Code:

```
power(20, 2) = 400
```

âœ” Correct



### Example 4

```cpp
n = 5
```

* even = 3
* odd = 2

Total:

```
5^3 Ã— 4^2 = 125 Ã— 16 = 2000
```

Code:

```
power(20, 2) = 400
odd â†’ 400 Ã— 5 = 2000
```

âœ” Correct



## â±ï¸ Time & Space Complexity

| Metric | Value                          |
| -- |--  |
| Time   | **O(log n)**                   |
| Space  | **O(log n)** (recursion stack) |



## ğŸ§  Why This Works (Greedy / Math Insight)

* Each index contributes **independently**
* Multiplication of choices gives total combinations
* Fast exponentiation makes it feasible for huge `n`

This is a classic **combinatorics + modular arithmetic** problem.



## âš ï¸ Small Improvements (Optional)

### 1ï¸âƒ£ Cleaner Iterative Power

Avoid recursion stack:

```cpp
long long modPow(long long base, long long exp) {
    long long res = 1;
    while (exp > 0) {
        if (exp & 1) res = (res * base) % M;
        base = (base * base) % M;
        exp >>= 1;
    }
    return res;
}
```



### 2ï¸âƒ£ Slightly Cleaner Main Function

```cpp
int countGoodNumbers(long long n) {
    long long half = n / 2;
    long long ans = modPow(20, half);
    if (n & 1) ans = (ans * 5) % M;
    return ans;
}
```

Same logic, clearer intent.



## ğŸ™‹ FAQs

### â“ Why even indices get 5 choices?

Digits `{0,2,4,6,8}` are even.



### â“ Why odd indices get 4 choices?

Prime digits `{2,3,5,7}`.



### â“ Why modulo `1e9+7`?

* Prevent overflow
* Standard competitive programming prime modulus



### â“ Is this DP?

No ... itâ€™s pure math + fast exponentiation.



