# ğŸ“Š MedianFinder [#259](https://leetcode.com/problems/find-median-from-data-stream/description/)

## ğŸ§© Problem Statement

You need to design a data structure that supports:

| Operation      | Meaning                                   |
| -------------- | ----------------------------------------- |
| `addNum(num)`  | Insert a number into the stream           |
| `findMedian()` | Return the median of all inserted numbers |

ğŸ”¹ The data stream updates in **real-time**
ğŸ”¹ Median should be available **efficiently** any time


## ğŸ” What is Median?

For a sorted list:

* If size `n` is **odd** â†’ median = middle element
* If size `n` is **even** â†’ median = average of two middle elements

Example:
`[1, 2, 3]` â†’ 2
`[1, 2, 3, 4]` â†’ (2 + 3) / 2 = 2.5

We **donâ€™t** want to sort the stream every time.
Thatâ€™s super slow â›”


## âš  Brute Force Approach (Not Recommended)

### Approach

* Insert into vector
* Sort every time before finding median

### Complexity

* `O(n log n)` **per** insertion â†’ ğŸ˜­
* Too slow for large data streams


## ğŸš€ Optimal Approach â€“ Two Heaps

We maintain **two priority queues**:

| Heap      | Type     | Purpose                            |
| --------- | -------- | ---------------------------------- |
| `maxHeap` | Max-Heap | Stores **smaller half** of numbers |
| `minHeap` | Min-Heap | Stores **larger half** of numbers  |

### Rules

âš– Balance the sizes:

* `maxHeap` may have **at most 1 extra element** over `minHeap`

ğŸ’ Make sure:

* Every element in `maxHeap` â‰¤ every element in `minHeap`

ğŸ“Œ Median is always:

| Case         | Median                |
| ------------ | --------------------- |
| Equal size   | Avg of both heap tops |
| Unequal size | Top of `maxHeap`      |


### ğŸ§  Why This Works?

This setup ensures:

* The **center** elements (candidates for median) always stay at the heap tops
* Insertions are **O(log n)** due to heap push/pop
* No need to re-sort full data

Very efficient for real-time operations like:

âœ” Stock market updates
âœ” Maps location tracking
âœ” Activity monitoring (Fitbit/Strava)


## ğŸ§± Full Code Explanation

```cpp
class MedianFinder {
private:
    priority_queue<int> maxHeap;
    priority_queue<int, vector<int>, greater<int>> minHeap;
```

* `maxHeap`: biggest element on top
* `minHeap`: smallest element on top


### addNum()

```cpp
void addNum(int num) {
    maxHeap.push(num);

    minHeap.push(maxHeap.top());
    maxHeap.pop();

    if (minHeap.size() > maxHeap.size()) {
        maxHeap.push(minHeap.top());
        minHeap.pop();
    }
}
```

Step by step:

1ï¸âƒ£ Push new number into `maxHeap`
2ï¸âƒ£ Move the **largest** from `maxHeap â†’ minHeap`
3ï¸âƒ£ If `minHeap` grows bigger â†’ rebalance by moving top back to `maxHeap`

After this:

* Size is balanced
* `maxHeap.top()` remains â‰¤ `minHeap.top()`


### findMedian()

```cpp
double findMedian() {
    if (maxHeap.size() == minHeap.size()) {
        return (maxHeap.top() + minHeap.top()) / 2.0;
    }

    return maxHeap.top();
}
```

Simply follows:

* If equal sizes â†’ take average
* Else â†’ `maxHeap` has the middle element


## ğŸ§ª Example Run

```cpp
mf.addNum(1);        // maxHeap=[1], minHeap=[]
mf.addNum(2);        // maxHeap=[1], minHeap=[2]
findMedian() -> 1.5  // (1+2)/2

mf.addNum(3);        // maxHeap=[2,1], minHeap=[3]
findMedian() -> 2
```

Perfectly matches expectations âœ”


## â± Complexity

| Operation    | Time     | Space |
| ------------ | -------- | ----- |
| addNum()     | O(log n) | O(n)  |
| findMedian() | O(1)     | O(n)  |

ğŸ”¥ Very efficient for continuous, large input data


## ğŸ™‹ FAQs

### Q1: Why push into `maxHeap` first?

Ensures new value enters the **smaller half** first and gets compared to center boundary.


### Q2: Why ensure `maxHeap.size() >= minHeap.size()`?

It helps the median always be:

* `maxHeap.top()` if odd number of elements


### Q3: Can this handle negative numbers?

Absolutely âœ” Heaps donâ€™t care as long as order is maintained.


### Q4: What if total data is huge?

This approach is scalable since we only ever store data once.


### Q5: Why an integer division + 2.0?

`/ 2.0` ensures **floating point** median.
Without it â†’ integer truncation ğŸ˜¬

