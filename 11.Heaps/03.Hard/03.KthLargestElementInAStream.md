
# ğŸ† Kth Largest Element in a Stream [[Tuf](https://takeuforward.org/plus/dsa/problems/kth-largest-element-in-a-stream-of-running-integers)]

## ğŸ“Œ Problem Statement

You are given:

* An integer `k`.
* An initial list of integers `nums`.

You must support updating the list dynamically with:

```cpp
int add(int val)
```

Every time `add` is called:

* Insert `val` into the stream.
* Return the **Kth largest** element from the updated list.


## ğŸ¯ Goal

Design a class:

```cpp
class KthLargest {
public:
    KthLargest(int k, vector<int>& nums);
    int add(int val);
};
```

that efficiently:

âœ” Maintains the K largest elements
âœ” Responds fast to every new incoming value
âœ” Always returns the Kth largest element


## ğŸ§  Intuition

Letâ€™s think about how to get the **Kth largest** element quickly:

If you always maintain only the **K largest** numbers:

* The **smallest** among them = **Kth largest overall**

ğŸ¤¯ Boom.

So all we need is:

ğŸ“Œ A **min-heap** of size at most **k**

Why?

* Min-heapâ€™s `top()` = smallest element inside
* That means:

  * `pq.top()` = Kth largest among all added elements!


## ğŸªœ Greedy / Optimal Strategy

### Maintain min-heap of size `k`

When a new value comes in:

1. If heap has < k elements
   â†’ just push it in
2. Else if `val > pq.top()`
   â†’ pop the smallest
   â†’ push `val`
3. Return `pq.top()`

Heap contents always represent the top K biggest elements!


### ğŸš« Brute Force (Why we avoid)

Store all values â†’ sort on every `add` call â†’ take `n - k` index

Sorting every time:

* Time = `O(n log n)` per update
* If there are many calls â†’ slow like installing Windows updates


## ğŸš€ Optimal Solution Using Min-Heap

### Benefits

âœ” Efficient updates
âœ” Only O(log k) per insertion
âœ” Scales to very large streams


## âœ¨ Code Explanation

```cpp
class KthLargest {
    int k;
    priority_queue<int, vector<int>, greater<int>> pq;
```

* `k`: we want Kth largest
* `pq`: a *min-heap* holding **exactly k** largest values seen so far

---

### Constructor

```cpp
KthLargest(int k, vector<int>& nums) : k(k) {
    for (int x : nums) {
        add(x);
    }
}
```

* Initialize heap using `add` logic to enforce `k` size rule

---

### add Function

```cpp
int add(int val) {
    if (pq.size() < k) {
        pq.push(val);
    } else if (val > pq.top()) {
        pq.pop();
        pq.push(val);
    }
    return pq.top();
}
```

Rules applied:

| Condition                    | Meaning                | Action                        |
| ---------------------------- | ---------------------- | ----------------------------- |
| Heap has less than k values  | Still collecting top K | Just push                     |
| New val > smallest of top K  | val enters top K       | pop old smallest and push new |
| New val <= smallest of top K | val irrelevant         | ignore it                     |

Finally:

```cpp
return pq.top(); // Kth largest ğŸ”¥
```


## â±ï¸ Complexity Analysis

| Operation  | Time Complexity | Space Complexity |
| ---------- | --------------- | ---------------- |
| add(val)   | **O(log k)**    | **O(k)**         |
| initialize | O(n log k)      | O(k)             |

Lean. Efficient. Beautiful. ğŸ’…


## ğŸ§ª Example Walkthrough

Initial:

```
k = 3
nums = [1, 2, 3, 4]
```

Min-heap will store **3 largest**:
`[2, 3, 4]` â†’ top() = `2` (3rd largest)

Calling:

```
add(5): [3,4,5] â†’ top = 3
add(2): ignored â†’ top = 3
add(7): [4,5,7] â†’ top = 4
```

âœ” Results: `3 3 4`
Matches expected output.


## ğŸ® Full Working Code (As Provided)

```cpp
#include <bits/stdc++.h>
using namespace std;

class KthLargest {
    int k;
    priority_queue<int, vector<int>, greater<int>> pq;

public:
    KthLargest(int k, vector<int>& nums) : k(k) {
        for (int x : nums) {
            add(x);
        }
    }

    int add(int val) {
        if (pq.size() < k) {
            pq.push(val);
        } else if (val > pq.top()) {
            pq.pop();
            pq.push(val);
        }
        return pq.top();
    }
};

int main() {
    // Example 1
    cout << "Example 1:" << endl;
    vector<int> nums1 = {1, 2, 3, 4};
    KthLargest kth1(3, nums1);
    cout << kth1.add(5) << endl;  // 3
    cout << kth1.add(2) << endl;  // 3
    cout << kth1.add(7) << endl;  // 4

    // Example 2
    cout << "\nExample 2:" << endl;
    vector<int> nums2 = {5, 5, 5, 5};
    KthLargest kth2(2, nums2);
    cout << kth2.add(2) << endl;  // 5
    cout << kth2.add(6) << endl;  // 5
    cout << kth2.add(60) << endl; // 6

    return 0;
}
```


## ğŸ™‹ FAQs

### âœ” What if fewer than `k` numbers have arrived?

The function returns the **smallest among what's available**.
Still correct by definition â†’ Kth largest not yet defined â†’ return smallest.

### âœ” Why not a max-heap?

Because then we'd have to store **all** numbers.

Min-heap keeps only k numbers â†’ much more efficient.


### âœ” Can this handle negative numbers?

Yup ğŸ‘
Numbers do not matter. Order does.

### âœ” Can this handle streaming real-time data?

Yes!
This is literally made for streaming.


## ğŸ’¡ Tricks & Tips

| Goal                          | Fix                        |
| ----------------------------- | -------------------------- |
| Want Kth **smallest** instead | Use max-heap               |
| Stream is extremely large     | Keep `k` small             |
| Need fast batch insert        | Use same constructor logic |

