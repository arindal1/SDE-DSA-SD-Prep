# ü™µ Connect Sticks (Huffman Coding) [[TuF](https://takeuforward.org/plus/dsa/problems/minimum-cost-to-connect-sticks)]

## üìå Problem Statement

You are given `n` sticks, each having some positive length.

You want to **connect all** the sticks into **one single stick**.
Connecting **two sticks** of lengths `a` and `b` costs **a + b**.

Your goal is simple:

> ‚ú® **Find the minimum total cost to connect all sticks.**

This is a classic greedy / priority-queue (min-heap) problem.


## üß† Intuition

Every time you connect two sticks:

* You pay a cost equal to **their sum**.
* The resulting stick is pushed back and can be used again.

Because this resulting stick will be used in future merges, its cost "propagates" into future operations.

So if you merge two *big* sticks early, you‚Äôll pay a big sum again and again.
This is bad. Like picking all legendary Pok√©mons at the start‚Ä¶ but they faint and take all your revives üò≠

### üîë Key Insight

To keep the total cost minimum:

> Always merge the **two smallest sticks** first.

This is exactly the famous **Huffman Coding** greedy principle.


## ü™ú Brute Force Approach (Bad Idea‚Ñ¢)

### Idea

Repeatedly:

1. Sort the list of sticks.
2. Pick the **two smallest**.
3. Merge them.
4. Insert the merged stick back into the list.
5. Repeat.

### Complexity

* Sorting every time ‚Üí `O(n log n)` each merge.
* Total merges = `n - 1`.
* Worst-case time: **O(n¬≤ log n)**.

You don‚Äôt want this. Even Jarvis would judge you.


## üí° Optimal Approach (Greedy + Min-Heap)

Instead of sorting repeatedly, use a **min-heap**:

1. Push all sticks into a min-heap.
2. While more than 1 stick remains:

   * Pop 2 smallest.
   * Merge them ‚Üí cost is added.
   * Push merged stick back.
3. Final accumulated cost is the minimum.

### Why it works?

Because:

* Min-heap gives O(log n) pop & push.
* Always ensures we merge the smallest two.

This is optimal and mathematically proven using greedy-choice + optimal-substructure (Huffman logic).



## üß© Step-by-Step Walkthrough of Your Code


```cpp
long long connectSticks(const vector<int> &arr) {
    int n = arr.size();
    if (n <= 1) return 0;

    priority_queue<int, vector<int>, greater<int>> pq(arr.begin(), arr.end());

    long long res = 0;

    while (pq.size() > 1) {
        int st1 = pq.top(); pq.pop();
        int st2 = pq.top(); pq.pop();

        long long sum = (long long)st1 + st2;
        res += sum;
        pq.push((int)sum);
    }

    return res;
}
```

### ‚úîÔ∏è Explanation

#### 1. Edge case: 0 or 1 stick

```cpp
if (n <= 1) return 0;
```

No merging needed ‚Üí cost is 0.


#### 2. Build a min-heap

```cpp
priority_queue<int, vector<int>, greater<int>> pq(arr.begin(), arr.end());
```

* Using `greater<int>` makes it a **min-heap**.
* All sticks go in.


#### 3. Merge until one stick remains

```cpp
while (pq.size() > 1) {
    int st1 = pq.top(); pq.pop();
    int st2 = pq.top(); pq.pop();
```

We always pick the **two smallest** sticks.


#### 4. Merge cost

```cpp
long long sum = (long long)st1 + st2;
res += sum;
```

We accumulate cost in a `long long` to avoid overflow.


#### 5. Push merged stick back

```cpp
pq.push((int)sum);
```

This merged stick participates in future merges.

#### 6. When one stick left ‚Üí all done!

```cpp
return res;
```


### üß™ Example

#### Input

```
arr = [1, 8, 3, 5]
```

#### Steps

| Step | Pick  | Cost | Push | Heap Becomes |
| ---- | ----- | ---- | ---- | ------------ |
| 1    | 1 + 3 | 4    | 4    | [4, 5, 8]    |
| 2    | 4 + 5 | 9    | 9    | [8, 9]       |
| 3    | 8 + 9 | 17   | 17   | [17]         |

#### Total Cost = 4 + 9 + 17 = **30**


## üìå Complete Final Code (Cleaned + Structured)

```cpp
#include <bits/stdc++.h>
using namespace std;

long long connectSticks(const vector<int> &arr) {
    int n = arr.size();
    if (n <= 1) return 0;   // No cost if 0 or 1 stick

    // Min-heap
    priority_queue<int, vector<int>, greater<int>> pq(arr.begin(), arr.end());

    long long totalCost = 0;

    while (pq.size() > 1) {
        int a = pq.top(); pq.pop();
        int b = pq.top(); pq.pop();

        long long merged = (long long)a + b;
        totalCost += merged;

        pq.push((int)merged);
    }

    return totalCost;
}

int main() {
    vector<int> arr = {1, 8, 3, 5};
    cout << connectSticks(arr);
    return 0;
}
```

## ‚è±Ô∏è Time & Space Complexity

| Operation               | Complexity     |
| ----------------------- | -------------- |
| Building min-heap       | O(n)           |
| Each merge (push + pop) | O(log n)       |
| Number of merges        | n - 1          |
| **Total Time**          | **O(n log n)** |
| **Space**               | **O(n)**       |

Optimal and fast üî•


## üí° Tips, Tricks & Variations

### ‚≠ê Variation 1: "Connect Ropes" Problem

Exactly the same problem but with ropes ‚Üí same logic, same heap.

### ‚≠ê Variation 2: If asked to return the sequence of merges

You can store the pairs merged at each step.

### ‚≠ê Variation 3: If the cost formula changes

Example:
Cost = `2a + 3b`
‚Üí Still use a heap, but adjust merge cost.

### ‚≠ê Think of this as:

* Building a binary tree bottom-up
* Same as Huffman Coding
* Always combine the two smallest elements


# üôã‚Äç‚ôÇÔ∏è FAQs

### **Q1: Why does merging smallest two first give optimal solution?**

This is a proven greedy algorithm.
If you merge large sticks early, their cost "ripples" into future merges repeatedly.

Small first ‚Üí minimal cumulative impact.


### **Q2: Why a min-heap, not max-heap?**

We always want the two **smallest** sticks.
Max-heap would be the opposite.

### **Q3: Why use `long long`?**

To safely store sums, especially when stick lengths can be large or many merges occur.


### **Q4: What if array is empty?**

Answer ‚Üí `0`
No sticks ‚Üí no cost ‚Üí logical ‚úîÔ∏è

### **Q5: Why is heap push casted to `(int)`?**

Because individual stick lengths fit in `int`.
Only *sum* and *total cost* needs `long long`.

