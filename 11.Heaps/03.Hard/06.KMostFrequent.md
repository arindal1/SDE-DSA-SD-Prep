
# ğŸ”¢ Top K Frequent Elements [#347](https://leetcode.com/problems/top-k-frequent-elements/description/)

## ğŸ“Œ Problem Statement

Given an integer array `nums` and an integer `k`, return the **k most frequent elements**.

* You **donâ€™t** need to return them in sorted order.
* You just need the elements that appear most often.

Example:

```txt
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]   // 1 appears 3 times, 2 appears 2 times
```


## ğŸ§  Intuition

We want the **k elements with highest frequency**.

Steps that scream out intuitively:

1. Count how many times each number appears â†’ frequency map.
2. Out of those frequencies, we want the **top k**.

This is basically **"Top K (by frequency)"**, which is a perfect fit for:

* Heap (priority queue)
* Or bucket sort / quickselect

Your solution uses a **min-heap of size k** âœ elegant & optimal âœ…


## ğŸªœ Brute Force Approach

### Idea

1. Count frequencies with `unordered_map<int,int> freq`.
2. Put all `(num, freq)` pairs into a vector.
3. Sort by frequency in **descending** order.
4. Take first `k` elements.

### Complexity

* Counting: `O(n)`
* Sorting: `O(m log m)` where `m` is number of distinct elements
* Overall: `O(n + m log m)`

This is fineâ€¦ but we can do better, especially when `k` is small and `m` is big.


## ğŸš€ Optimal Approach (Your Code) â€“ Min-Heap of Size K

### Core Idea

Instead of sorting all elements by frequency, we:

* Maintain a **min-heap** (smallest frequency at top) of size at most `k`.
* For each `(num, freq)`:

  * Push into heap.
  * If heap size > `k`, pop the **smallest** frequency.
* At the end, heap contains **k elements with highest frequency**!

Thatâ€™s like maintaining a **Top K leaderboard** and kicking out the least popular whenever a more popular one shows up ğŸ˜


## ğŸ§© Code Walkthrough

Letâ€™s break it down ğŸ‘‡


#### 1ï¸âƒ£ Frequency Map

```cpp
unordered_map<int, int> freq;
for (int n : nums)
    freq[n]++;
```

* `freq[x]` = how many times `x` appears in `nums`.

Example: `nums = [1,1,2,3,3,3]` â†’
`freq = {1:2, 2:1, 3:3}`


#### 2ï¸âƒ£ Min-Heap of (frequency, value)

```cpp
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;
```

* Using `greater<pair<int,int>>` makes it a **min-heap**.
* Heap stores entries as: `{frequency, value}`

Why `{freq, value}` instead of `{value, freq}`?

ğŸ‘‰ Because we want the heap to order primarily by **frequency**.


#### 3ï¸âƒ£ Filling the Heap

```cpp
for (auto& p : freq) {
    minHeap.push({p.second, p.first});
    if (minHeap.size() > k)
        minHeap.pop();
}
```

For each `(value, frequency)` in `freq`:

* Push `{freq, value}` into heap.
* If heap exceeds size `k`:

  * Remove the **smallest** frequency â†’ keeps only top `k`.

So after this loop:

* Heap contains exactly `k` elements.
* All of them have higher or equal frequency than any elements not in heap.


#### 4ï¸âƒ£ Extracting the Result

```cpp
vector<int> result;
while (!minHeap.empty()) {
    result.push_back(minHeap.top().second);
    minHeap.pop();
}

return result;
```

We pop each pair:

* `.second` is the **value**.
* `.first` was frequency, but we no longer need it.

Note: Order of result doesn't matter per problem statement, so no need to reverse or sort.


## ğŸ§ª Example Dry Run

### Example

```txt
nums = [1,1,1,2,2,3]
k = 2
```

1. Frequency map:

```txt
1 â†’ 3
2 â†’ 2
3 â†’ 1
```

2. Heap filling (store as `{freq, num}`):

* Push `{3,1}` â†’ heap: `[(3,1)]`
* Push `{2,2}` â†’ heap: `[(2,2), (3,1)]` â†’ size 2 â‰¤ k
* Push `{1,3}` â†’ heap: `[(1,3), (3,1), (2,2)]` â†’ size 3 > k â†’ pop smallest `(1,3)`

Final heap: `{(2,2), (3,1)}` â†’ top K frequent elements: `2` and `1`.

Order of result may be `[2,1]` or `[1,2]` â†’ both valid âœ…


## â±ï¸ Time & Space Complexity

Let:

* `n` = size of `nums`
* `m` = number of distinct elements (`m â‰¤ n`)

### Time Complexity

1. Build frequency map: `O(n)`
2. Push each of `m` elements to heap:

   * Each push/pop: `O(log k)`
   * Total: `O(m log k)`

ğŸ‘‰ **Total Time**: `O(n + m log k)`
Since `m â‰¤ n`, this is basically `O(n log k)` in worst case.

### Space Complexity

* Frequency map: `O(m)`
* Heap: `O(k)`
* Result: `O(k)`

ğŸ‘‰ **Total Space**: `O(m + k)` â†’ `O(n)` in worst case.



### âœ¨ Full, Clean Code

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 1. Count frequencies
        unordered_map<int, int> freq;
        for (int n : nums) {
            freq[n]++;
        }
        
        // 2. Min-heap of {frequency, value}
        priority_queue<
            pair<int, int>,
            vector<pair<int, int>>,
            greater<pair<int, int>>
        > minHeap;
        
        // 3. Keep only top k frequent elements in heap
        for (auto &p : freq) {
            minHeap.push({p.second, p.first});
            if (minHeap.size() > (size_t)k) {
                minHeap.pop();
            }
        }
        
        // 4. Extract values from heap
        vector<int> result;
        while (!minHeap.empty()) {
            result.push_back(minHeap.top().second);
            minHeap.pop();
        }
        
        return result; // Order doesn't matter
    }
};
```

Your logic is 100% correct âœ…


## ğŸ’¡ Tips, Tricks & Variations

#### â­ Variation 1 â€“ Return Top K in Sorted Order

If interviewer asks for output sorted by frequency or value, you can:

* Sort `result` after extraction, or
* Use a different data structure (e.g. vector + sort).


#### â­ Variation 2 â€“ Using Bucket Sort (Even Faster)

Since frequency of an element can be at most `n`, we can do:

* `vector<vector<int>> buckets(n + 1);`
* For each `(num, freq)` â†’ push into `buckets[freq]`
* Traverse buckets from `freq = n down to 1`, collecting numbers until you have `k`

This gives time close to `O(n)`.


#### â­ Variation 3 â€“ Using Max-Heap

Instead of min-heap of size k:

* Build a **max-heap** of all `(freq, num)`
* Pop k times

Time: `O(m log m)`, worse when `m` is large.

Your min-heap solution is more scalable when `k` is small compared to `m`.


## ğŸ™‹ FAQs

#### Q1: Why store `(freq, num)` and not `(num, freq)` in heap?

Heap compares by first element of pair:

* We want ordering by **frequency**, not value.
* So `{frequency, value}` makes sense.


#### Q2: Does the result order matter?

In standard LeetCode `Top K Frequent Elements` problem:
ğŸ‘‰ **Order does not matter**.
You just need the right set of elements.


#### Q3: What if `k` equals number of distinct elements?

Then the heap will eventually store all distinct elements, and you will simply return all of them.


#### Q4: Any edge cases?

* `nums` with all same values â†’ frequency 1 element, answer is just `[that element]`.
* Large `k`, small `nums` size â†’ still works, since heap size is bounded by `m`.

