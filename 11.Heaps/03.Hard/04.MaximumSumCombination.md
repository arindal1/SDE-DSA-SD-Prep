# üí• Maximum Sum Combination [[TuF](https://takeuforward.org/data-structure/maximum-sum-combination)]

## üìå Problem Statement

You are given two arrays:

* `arr1` of size `n`
* `arr2` of size `m`

You want to form pairs `(arr1[i], arr2[j])` such that:

* Each pair uses **one element from `arr1` and one from `arr2`**
* The **sum** of each pair is `arr1[i] + arr2[j]`

üéØ Goal:

> Return the **top `k` largest sums** you can form from these pairs.


## üß† Intuition

If you think about all pairs:

* Total pairs = `n * m`
* Each pair has a sum `arr1[i] + arr2[j]`
* We want the **k largest** of these sums.

The naive idea is:

> Generate all `n * m` sums and pick the largest `k`.

But that can be huge if arrays are big.

So we need a smarter way.

### Key Insight

If both arrays are sorted in **descending** order:

* The **largest sum** is clearly `arr1[0] + arr2[0]`.
* The next possible candidates are:

  * `arr1[1] + arr2[0]`
  * `arr1[0] + arr2[1]`

We can treat this like exploring a 2D grid of indices `(i, j)`:

* Each cell has value `arr1[i] + arr2[j]`
* Top-left cell `(0,0)` is the maximum
* Its right and down neighbors are the next best candidates

We use a **max-heap** to always pick the best available unexplored sum and then push its neighbors.


## ü™ú Brute Force Approach

### Idea

1. For every `i` in `arr1`
   For every `j` in `arr2`
   ‚Üí compute `arr1[i] + arr2[j]`

2. Store all sums in a list.

3. Sort the list in descending order.

4. Take first `k` elements.

### Complexity

* Generate all pairs: `O(n * m)`
* Sorting them: `O(n * m * log(n * m))`
* Total: **Too slow** when `n` and `m` are large.


## üí° Optimal Approach ‚Äì Max-Heap + Visited Set

### Strategy

1. Sort both `arr1` and `arr2` in **descending** order.
2. Use a **max-heap** where each entry is:

   ```cpp
   (sum, i, j)
   ```

   * `sum = arr1[i] + arr2[j]`
   * `(i, j)` are indices from `arr1` and `arr2`
3. Start with the **largest** pair:

   * `(0, 0)` ‚Üí sum = `arr1[0] + arr2[0]`
4. Use a `visited` set to avoid pushing the same `(i, j)` pair multiple times.
5. Repeat `k` times:

   * Pop the largest `(sum, i, j)` from the heap.
   * Add `sum` to the result.
   * Push its valid neighbors:

     * `(i + 1, j)` if not visited
     * `(i, j + 1)` if not visited

This is like doing a controlled BFS over the 2D sum grid, always expanding from the **current best**.


## üß© Code Walkthrough


### 1. Edge Case Handling

```cpp
if (arr1.empty() || arr2.empty() || k <= 0) return {};
```

If either array is empty or `k <= 0`, there are no valid sums to return.


### 2. Sorting in Descending Order

```cpp
sort(arr1.begin(), arr1.end(), greater<int>());
sort(arr2.begin(), arr2.end(), greater<int>());
```

We want largest elements at front so indices `(0, 0)` represent **max sum**.


### 3. Max-Heap and Visited Set

```cpp
priority_queue<tuple<int, int, int>> maxHeap;
set<pair<int, int>> visited;
```

* `maxHeap` elements are `(sum, i, j)`.
* `set` tracks which `(i, j)` pairs we have already pushed.


### 4. Initial State

```cpp
maxHeap.push(make_tuple(arr1[0] + arr2[0], 0, 0));
visited.insert({0, 0});
```

Start with the **best possible** pair: `(0, 0)`.


### 5. Main Loop

```cpp
while (k-- && !maxHeap.empty()) {
    auto top = maxHeap.top();
    maxHeap.pop();

    int sum = get<0>(top);
    int i   = get<1>(top);
    int j   = get<2>(top);

    result.push_back(sum);
```

* Pop current largest sum.
* Add to result.


### 6. Push Neighbors

```cpp
    if (i + 1 < (int)arr1.size() && !visited.count({i + 1, j})) {
        maxHeap.push(make_tuple(arr1[i + 1] + arr2[j], i + 1, j));
        visited.insert({i + 1, j});
    }

    if (j + 1 < (int)arr2.size() && !visited.count({i, j + 1})) {
        maxHeap.push(make_tuple(arr1[i] + arr2[j + 1], i, j + 1));
        visited.insert({i, j + 1});
    }
}
```

For each popped `(i, j)` we explore:

* `(i + 1, j)` ‚Üí move down in `arr1`
* `(i, j + 1)` ‚Üí move right in `arr2`

Both represent next potentially high sums given current position.

`visited` prevents revisiting the same `(i, j)` pair, which would cause duplicates and potentially infinite processing.


## üß™ Example Dry Run

Input:

```cpp
arr1 = {3, 4, 5}
arr2 = {2, 6, 3}
k = 2
```

### Step 1: Sort descending

* `arr1` ‚Üí `[5, 4, 3]`
* `arr2` ‚Üí `[6, 3, 2]`

Think of all pair sums (just to see):

| arr1 | arr2 | sum |
| ---- | ---- | --- |
| 5    | 6    | 11  |
| 5    | 3    | 8   |
| 5    | 2    | 7   |
| 4    | 6    | 10  |
| 4    | 3    | 7   |
| 4    | 2    | 6   |
| 3    | 6    | 9   |
| 3    | 3    | 6   |
| 3    | 2    | 5   |

Top 2 sums = `11, 10`

Let‚Äôs see if the algorithm finds them.


### Heap Trace

**Initial:**

* Push `(5 + 6, 0, 0)` ‚Üí `(11, 0, 0)`

Heap: `[(11,0,0)]`
Result: `[]`


**Iteration 1:**

* Pop `(11, 0, 0)` ‚Üí result: `[11]`
* Neighbors:

  * `(1, 0)` ‚Üí `4 + 6 = 10`
  * `(0, 1)` ‚Üí `5 + 3 = 8`

Heap: `[(10,1,0), (8,0,1)]`


**Iteration 2:**

* Pop `(10, 1, 0)` ‚Üí result: `[11, 10]`
* Neighbors:

  * `(2, 0)` ‚Üí `3 + 6 = 9`
  * `(1, 1)` ‚Üí `4 + 3 = 7`

Heap now: `[(9,2,0), (8,0,1), (7,1,1)]`

We only need `k = 2`, so we stop here.
Final result: `[11, 10]` ‚úî


## ‚úÖ Full Code

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> sumCombi(vector<int> &arr1, vector<int> &arr2, int k) {
    if (arr1.empty() || arr2.empty() || k <= 0) return {};

    sort(arr1.begin(), arr1.end(), greater<int>());
    sort(arr2.begin(), arr2.end(), greater<int>());

    priority_queue<tuple<int, int, int>> maxHeap;
    set<pair<int, int>> visited;

    maxHeap.push(make_tuple(arr1[0] + arr2[0], 0, 0));
    visited.insert({0, 0});

    vector<int> result;

    while (k-- && !maxHeap.empty()) {
        auto top = maxHeap.top();
        maxHeap.pop();

        int sum = get<0>(top);
        int i   = get<1>(top);
        int j   = get<2>(top);

        result.push_back(sum);

        if (i + 1 < (int)arr1.size() && !visited.count({i + 1, j})) {
            maxHeap.push(make_tuple(arr1[i + 1] + arr2[j], i + 1, j));
            visited.insert({i + 1, j});
        }

        if (j + 1 < (int)arr2.size() && !visited.count({i, j + 1})) {
            maxHeap.push(make_tuple(arr1[i] + arr2[j + 1], i, j + 1));
            visited.insert({i, j + 1});
        }
    }

    return result;
}

int main() {
    vector<int> arr1 = {3, 4, 5};
    vector<int> arr2 = {2, 6, 3};
    int k = 2;

    vector<int> res = sumCombi(arr1, arr2, k);

    for (int x : res) cout << x << " ";
    cout << endl;

    return 0;
}
```

Code is logically correct and clean ‚úÖ


## ‚è±Ô∏è Complexity Analysis

Let:

* `n = arr1.size()`
* `m = arr2.size()`

### Time

* Sorting:

  * `O(n log n + m log m)`
* Each loop iteration:

  * Heap operations = `O(log k)` or `O(log(n * m))`
  * At most two new pushes per iteration
* Loop runs at most `k` times

Total:

```text
O(n log n + m log m + k log k)
```

This is much better than `O(n * m * log(n * m))` for brute force.

### Space

* Heap stores up to `O(k)` elements
* `visited` also up to `O(k)`
* Result size min(`k`, `n * m`)

So:

```text
Space: O(k)
```


## üí° Tips, Tricks & Variations

### ‚≠ê Variation 1 ‚Äì Top K Minimum Pair Sums

* Sort arrays in **ascending** order.
* Use **min-heap** instead of max-heap.
* Same neighbor exploration.


### ‚≠ê Variation 2 ‚Äì Handle k > n * m

Current code naturally handles this:

* When heap empties, loop stops.
* You just return as many sums as possible.


### ‚≠ê Variation 3 ‚Äì Using `unordered_set` for visited

For performance, you could switch `set<pair<int,int>>` to `unordered_set` with a custom hash to improve from `O(log k)` to `O(1)` average lookups.


## üôã FAQs

### Q1: Why do we only explore `(i + 1, j)` and `(i, j + 1)`?

Because arrays are sorted in descending order:

* Increasing `i` in `arr1` ‚Üí smaller value.
* Increasing `j` in `arr2` ‚Üí smaller value.

From `(i, j)` the only possible next candidates that could still be part of the top sums are to move:

* Down in `arr1` (i+1) with same `j`
* Right in `arr2` (j+1) with same `i`

Anything like `(i + 1, j + 1)` will be considered through those paths eventually.


### Q2: Why do we need `visited`?

Without `visited`, the same `(i, j)` pair could be pushed multiple times via different paths, causing:

* Duplicate sums
* Extra heap operations
* Possibly infinite-like behavior

So `visited` ensures each `(i, j)` is processed only once.


### Q3: What if arrays contain negative numbers?

Still works perfectly ‚úÖ

Sorting descending still gives the correct relative order, and sums are computed as usual.


### Q4: Is using `tuple<int,int,int>` necessary?

Not strictly.

Alternatives:

* A struct with custom comparator
* `pair<int, pair<int,int>>`

Using `tuple` is neat and readable though.

