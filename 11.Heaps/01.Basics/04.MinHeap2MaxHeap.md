# ğŸ† Convert Min Heap to Max Heap

## ğŸ§¾ Problem Statement

You are given a binary heap stored in an array (0-based), and:

* It is currently a **min-heap** (i.e., parent â‰¤ children),
* You want to **convert it into a max-heap** (i.e., parent â‰¥ children),
* You must do this **in-place** (no extra array),
* And you want it to work generically for any type `T` that supports comparison.

In short:

> **Given an array representation of a min-heap, transform it into a valid max-heap in O(n) time, in-place.**


## ğŸ§  Intuition

For heap stored in an array:

* Parent index: `i`
* Left child: `2*i + 1`
* Right child: `2*i + 2`

A **max-heap** must satisfy:

* `data[i] >= data[left(i)]` and `data[i] >= data[right(i)]` for all valid `i`.

How do you construct a max-heap from *any* array?

ğŸ‘‰ Use the â€œbuild-heapâ€ algorithm:

1. Consider all elements as part of a tree.
2. Start from the **last internal node** (the last index that can have children).
3. For each node going backward toward the root, **sift it down** using a `heapify` or `siftDown` function that enforces the max-heap property.

This works whether the input is:

* Completely random,
* Already a min-heap,
* Or just partially heap-like.

So â€œconvert min-heap to max-heapâ€ is really just â€œbuild a max-heap from this arrayâ€.


### ğŸ§® Brute Force-ish Idea (Not What We Do)

One naive approach:

* Create a new empty max-heap.
* Repeatedly extract the minimum from the min-heap and insert it into a max-heap.
* Or just copy elements into a new array and insert one by one into a max-heap.

That would be:

* `n` inserts â†’ `O(n log n)` time,
* Extra space for another heap.

We can do better.


### âš¡ Optimal Approach â€” Bottom-Up Heapify (O(n))

We take advantage of the classic bottom-up heap construction:

1. The array `heap` is of size `n`.
2. All indices from `0` to `(n - 2) / 2` are internal nodes (can have children).
3. For each of these internal nodes, starting from the **last one** and moving toward index 0:

   * Call `siftDownMax` to push the element down until the max-heap property is satisfied.

This gives an **O(n)** build time (famous heap property: bottom-up heapify runs in linear time).

## ğŸ”§ Function 1: `siftDownMax` (Max-Heapify)

### Purpose

Given:

* A container `data`,
* A heap size `n`,
* An index `index`,

we assume the subtrees at its children are already max-heaps, and we **push data[index] down** until the max-heap property is restored.

### Code

```cpp
// Generic max-heapify (sift-down) on a 0-based array-like container.
// Assumes that subtrees rooted at left and right children are already max-heaps.
template <typename T>
void siftDownMax(std::vector<T>& data, std::size_t n, std::size_t index) {
    assert(index < n);
    for (;;) {
        std::size_t largest = index;
        std::size_t left    = 2 * index + 1;
        std::size_t right   = 2 * index + 2;

        if (left < n && data[left] > data[largest]) {
            largest = left;
        }
        if (right < n && data[right] > data[largest]) {
            largest = right;
        }

        if (largest == index) {
            break; // heap property satisfied
        }

        std::swap(data[index], data[largest]);
        index = largest;
    }
}
```

### Whatâ€™s happening?

* We repeatedly:

  * Find the largest among the node and its children.
  * If one child is larger, swap and continue from that child.
  * If the node is already â‰¥ children, weâ€™re done.

**Time complexity:** `O(h) = O(log n)` per call (height of tree from that node).
But remember weâ€™ll call this in a special pattern that makes the total time O(n).


## ğŸ”§ Function 2: `convertMinHeapToMaxHeap`

### Purpose

Build a **max-heap** from an existing array (which might be a min-heap or just arbitrary).

### Code

```cpp
// Build a max-heap from an arbitrary array (or from a min-heap).
template <typename T>
void convertMinHeapToMaxHeap(std::vector<T>& heap) {
    const std::size_t n = heap.size();
    if (n <= 1) return;

    // Start from the last internal node and sift down.
    // Last internal node = (n / 2) - 1 in 0-based indexing.
    for (std::size_t i = n / 2; i-- > 0; ) {
        siftDownMax(heap, n, i);
    }
}
```

### The funky loop: `for (std::size_t i = n / 2; i-- > 0; )`

This is an idiomatic C++ way to loop **backwards over `0..(n/2 - 1)`**:

* Start `i` at `n/2`.
* In each iteration, decrement first, then check `i >= 0`.
* Since `i` is unsigned, we canâ€™t use `i >= 0` directly; instead we use `i-- > 0`.

This results in `i` taking values:

* `n/2 - 1`,
* `n/2 - 2`,
* ...,
* `0`.

Exactly what we need for bottom-up heapify.


## ğŸ§ª Small Demo (main)

```cpp
// Small demo
int main() {
    // Example: this is a valid min-heap (0-based array representation)
    std::vector<int> minHeap = {1, 3, 2, 7, 6, 4, 5};

    convertMinHeapToMaxHeap(minHeap);

    std::cout << "Array as max-heap: ";
    for (int x : minHeap) {
        std::cout << x << ' ';
    }
    std::cout << '\n';

    return 0;
}
```

After conversion, `minHeap` now represents a **valid max-heap** in-place.
The exact array contents may differ depending on the structure, but:

* `minHeap[0]` will be the maximum element,
* For any parent index `i`, `heap[i] >= heap[left(i)]` and `heap[i] >= heap[right(i)]`.


## âœ… Full Polished Code (with minor improvement)

One tiny standard-compliance improvement: include `<algorithm>` for `std::swap`.

```cpp
#include <vector>
#include <cassert>
#include <iostream>
#include <algorithm> // for std::swap

// Generic max-heapify (sift-down) on a 0-based array-like container.
// Assumes that subtrees rooted at left and right children are already max-heaps.
template <typename T>
void siftDownMax(std::vector<T>& data, std::size_t n, std::size_t index) {
    assert(index < n);
    for (;;) {
        std::size_t largest = index;
        std::size_t left    = 2 * index + 1;
        std::size_t right   = 2 * index + 2;

        if (left < n && data[left] > data[largest]) {
            largest = left;
        }
        if (right < n && data[right] > data[largest]) {
            largest = right;
        }

        if (largest == index) {
            break; // heap property satisfied
        }

        std::swap(data[index], data[largest]);
        index = largest;
    }
}

// Build a max-heap from an arbitrary array (or from a min-heap).
template <typename T>
void convertMinHeapToMaxHeap(std::vector<T>& heap) {
    const std::size_t n = heap.size();
    if (n <= 1) return;

    // Start from the last internal node and sift down.
    // Last internal node = (n / 2) - 1 in 0-based indexing.
    for (std::size_t i = n / 2; i-- > 0; ) {
        siftDownMax(heap, n, i);
    }
}

// Small demo
int main() {
    // Example: this is a valid min-heap (0-based array representation)
    std::vector<int> minHeap = {1, 3, 2, 7, 6, 4, 5};

    convertMinHeapToMaxHeap(minHeap);

    std::cout << "Array as max-heap: ";
    for (int x : minHeap) {
        std::cout << x << ' ';
    }
    std::cout << '\n';

    return 0;
}
```

---

### â± Complexity Analysis

* `siftDownMax` per call: **O(log n)** in the worst case (height of the heap from that node).
* `convertMinHeapToMaxHeap`:

  * Runs `siftDownMax` only on internal nodes (`â‰ˆ n/2` nodes).
  * Nodes closer to the bottom have smaller heights.
  * Total cost sums to **O(n)** (classic result for bottom-up heapify).

**Space:**

* In-place, just uses a few local variables â†’ **O(1)** extra space.


## ğŸ§ª Test Cases / Ideas

1. Already a max-heap:

   ```cpp
   {10, 9, 8, 7, 6, 5, 4}
   ```

   Running convert wonâ€™t break it.

2. Strict min-heap:

   ```cpp
   {1, 3, 2, 7, 6, 4, 5}
   ```

3. Random array:

   ```cpp
   {4, 10, 3, 5, 1}
   ```

   After conversion, check max-heap property manually.

4. Edge cases:

   * Empty vector `{}`
   * Single element `{42}`


## ğŸ’¡ Tips & Variations

* You can easily write a corresponding `siftDownMin` to build a **min-heap** instead.

* To check correctness, you can write a helper:

  ```cpp
  bool isMaxHeap(const std::vector<int>& a);
  ```

  using the same parent/child checks we discussed earlier.

* This is basically the same logic used in:

  * `std::make_heap`
  * `std::priority_queue` under the hood (with some wrapping).


## â“ FAQs

**Q: Why start from `n / 2` and go downwards?**
Because indices â‰¥ `n/2` are leaves; leaves are already trivially heaps. You only need to `siftDown` internal nodes.

**Q: Does it matter that the input is a min-heap?**
Nope. The algorithm treats it just as an arbitrary array. The fact it is already a valid min-heap doesnâ€™t hurt, but itâ€™s not required.

**Q: Can this break if `T` doesnâ€™t have `operator>`?**
Yes. This template assumes `T` supports comparison via `>` (and is movable/swappable). For custom types, you may need to provide an appropriate comparator or overload `operator>`.

