# â›ï¸ Is Array a Min Heap?

## ðŸ§¾ Problem Statement

> Given an array `arr` representing a **binary tree** in **array/heap representation**, check whether it satisfies the **min-heap** property.

For a **min-heap**:

* Itâ€™s a *complete binary tree* (array representation already encodes that).
* For every index `i`:

  * `arr[i] <= arr[left(i)]` (if left child exists)
  * `arr[i] <= arr[right(i)]` (if right child exists)


## ðŸ§  Intuition

In an array-based heap:

* Parent index: `i`
* Left child index: `2 * i + 1`
* Right child index: `2 * i + 2`

To verify min-heap:

1. Only parents matter (nodes that have at least one child).
2. For each such parent, check that:

   * It is â‰¤ left child, if exists.
   * It is â‰¤ right child, if exists.
3. If any violation occurs â†’ not a min-heap.
4. If no violations â†’ valid min-heap âœ…

The last parent index is:

```cpp
lastParent = (n - 2) / 2;
```

All indices from `0` to `lastParent` (inclusive) can have children.


### ðŸ¢ Brute Force Thought

You could recursively check each node:

```cpp
isMinHeap(i):
    if i >= n: return true
    if left child exists and arr[i] > arr[left]: return false
    if right child exists and arr[i] > arr[right]: return false
    return isMinHeap(left) && isMinHeap(right)
```

Time: O(n), Space: O(h) recursion.
But with array indices, an iterative scan is simpler.

---


### âœ… Clean CPP Code


```cpp
#include <bits/stdc++.h>
using namespace std;

// Checks if the array represents a valid min-heap
bool isMinHeap(const vector<int> &arr) {
    int n = arr.size();
    if (n == 0) {
        // You can treat empty array as a valid heap.
        return true;
    }

    // Last index that can have at least a left child
    // (n-2)/2 is the index of the last internal node
    for (int i = 0; i <= (n - 2) / 2; ++i) {
        int leftChild = 2 * i + 1;
        int rightChild = 2 * i + 2;

        // If left child exists and violates min-heap property
        if (leftChild < n && arr[i] > arr[leftChild])
            return false;

        // If right child exists and violates min-heap property
        if (rightChild < n && arr[i] > arr[rightChild])
            return false;
    }

    return true;
}

int main() {
    vector<int> arr = {10, 20, 30, 21, 23};

    if (isMinHeap(arr))
        cout << "Is a Min Heap";
    else
        cout << "Is not a Min Heap";

    return 0;
}
```


## â± Complexity

* **Time:** O(n)
  You iterate over each parent node once.

* **Space:** O(1) extra
  Just a few variables.

This is about as optimal as it gets.


## ðŸ§ª Test Cases

Try these:

```cpp
{10, 20, 30, 40, 50}          // âœ… min-heap
{10, 15, 20, 17, 25}          // âœ… min-heap
{10, 9, 20}                   // âŒ not min-heap (child < parent)
{}                            // usually âœ… (depending on design)
{5}                           // âœ…
{2, 3, 4, 5, 1}               // âŒ
```


## ðŸ’¡ Tips / Variations

* To check **max-heap**, just flip the comparisons:

  * Instead of `arr[i] > child`, check `arr[i] < child`.
* This function assumes the array already represents a **complete tree** (like heap storage).
  If you had a sparse tree structure, youâ€™d need extra checks.

