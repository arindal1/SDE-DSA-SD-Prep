# üêç Binary Min Heap

## üßæ Problem / Goal

Implement a **binary min-heap** supporting:

* `Insert(x)` ‚Äì insert a new key
* `getMin()` ‚Äì return the minimum element
* `ExtractMin()` ‚Äì remove & return the minimum element
* `DecreaseKey(i, val)` ‚Äì decrease the value at index `i`
* `Delete(i)` ‚Äì delete the element at index `i`
* Internal helpers: `Heapify`, `parent`, `left`, `right`, etc.

The heap is stored as an **array** representing a complete binary tree:

* Index `0` ‚Üí root
* `left(i) = 2*i + 1`
* `right(i) = 2*i + 2`
* `parent(i) = (i - 1) / 2`

For a **min-heap**, every node‚Äôs key is ‚â§ its children‚Äôs keys.


### üß† Intuition: How a Min-Heap Works

A min-heap is basically a *binary tree in an array* with two rules:

1. **Heap property**:
   `arr[i] <= arr[left(i)]` and `arr[i] <= arr[right(i)]` (if those children exist).
2. **Shape property**:
   The tree is *complete* ‚Äì all levels filled except possibly last, which is filled left to right.

We use the array index math to ‚Äújump‚Äù between parent/child without pointers.

### Why this is useful?

* `getMin()` is `O(1)` (the min is always at `arr[0]`).
* `Insert`, `ExtractMin`, `DecreaseKey`, and `Delete` run in `O(log n)` because they‚Äôre based on bubbling up or down the tree.

Think of it as a ‚Äúself-organizing leaderboard‚Äù where smallest always floats to the top. üèÜ



## üß± Operation-by-Operation Breakdown

### 1. `Insert(int x)`

**Idea:**

1. Place `x` at the end (`arr[size]`).
2. ‚ÄúBubble it up‚Äù while it‚Äôs smaller than its parent to restore min-heap property.

```cpp
void Insert(int x) {
    if (size == capacity) {
        cout << "Heap Overflow" << endl;
        return;
    }

    arr[size] = x;
    int i = size;
    size++;

    while (i != 0 && arr[parent(i)] > arr[i]) {
        mySwap(arr[parent(i)], arr[i]);
        i = parent(i);
    }
}
```

**Complexity:** `O(log n)` (height of heap).


### 2. `Heapify(int i)` (a.k.a. `minHeapify`)

**Idea:**
Assume left and right subtrees of index `i` are heaps, but `arr[i]` may be larger than one of its children. We need to ‚Äúbubble it down‚Äù:

1. Find the smallest among `i`, `left(i)`, `right(i)`.
2. If one child is smaller, swap with that child.
3. Recursively `Heapify` that child index.

```cpp
void Heapify(int i) {
    int li = left(i);
    int ri = right(i);
    int smallest = i;

    if (li < size && arr[li] < arr[smallest])
        smallest = li;
    if (ri < size && arr[ri] < arr[smallest])
        smallest = ri;

    if (smallest != i) {
        mySwap(arr[i], arr[smallest]);
        Heapify(smallest);
    }
}
```

**Used in:**

* `ExtractMin()` after moving last element to root
* Potentially in bulk build-heap operations (not shown here)

**Complexity:** `O(log n)`


### 3. `getMin()`

Returns the root element.

```cpp
int getMin() {
    if (size == 0) {
        throw runtime_error("Heap is empty");
    }
    return arr[0];
}
```

> Your version returned `arr[0]` without checking `size`. It‚Äôs okay for controlled use, but in a robust implementation, check for empty heap.

**Complexity:** `O(1)`


### 4. `ExtractMin()`

**Idea:**

1. Save `arr[0]` as the min.
2. Move the last element in the heap to index 0.
3. Decrease `size`.
4. Call `Heapify(0)` to restore heap property.

```cpp
int ExtractMin() {
    if (size <= 0)
        return INT_MAX; // or throw

    if (size == 1) {
        size--;
        return arr[0];
    }

    int root = arr[0];
    arr[0] = arr[size - 1];
    size--;
    Heapify(0);

    return root;
}
```

**Complexity:** `O(log n)`


### 5. `DecreaseKey(int i, int val)`

If we **decrease** the key at index `i`, it might become smaller than its parent. That‚Äôs a violation of min-heap property, so we ‚Äúbubble up‚Äù.

```cpp
void DecreaseKey(int i, int newVal) {
    if (i < 0 || i >= size) return; // optional safety
    arr[i] = newVal;

    while (i != 0 && arr[parent(i)] > arr[i]) {
        mySwap(arr[parent(i)], arr[i]);
        i = parent(i);
    }
}
```

**Complexity:** `O(log n)`


### 6. `Delete(int i)`

Classic trick:

1. Decrease the key at index `i` to `-‚àû` (here `INT_MIN`).
2. That will move it to the root via `DecreaseKey`.
3. Then call `ExtractMin()` to remove it.

```cpp
void Delete(int i) {
    DecreaseKey(i, INT_MIN);
    ExtractMin();
}
```

**Complexity:** `O(log n)` for decrease + `O(log n)` for extract ‚Üí still `O(log n)`.


### ‚úÖ CPP Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class BinaryHeap {
public:
    int capacity;
    int size;
    int *arr;

    BinaryHeap(int cap) {
        capacity = cap;
        size = 0;
        arr = new int[capacity];
    }

    ~BinaryHeap() {
        delete[] arr;
    }

    int parent(int i) { return (i - 1) / 2; }
    int left(int i)   { return 2 * i + 1; }
    int right(int i)  { return 2 * i + 2; }

    void mySwap(int &x, int &y) {
        int temp = x;
        x = y;
        y = temp;
    }

    void Insert(int x) {
        if (size == capacity) {
            cout << "Heap Overflow" << endl;
            return;
        }

        // Insert at end
        int i = size;
        arr[size] = x;
        size++;

        // Bubble up
        while (i != 0 && arr[parent(i)] > arr[i]) {
            mySwap(arr[parent(i)], arr[i]);
            i = parent(i);
        }
    }

    void Heapify(int i) {
        int li = left(i);
        int ri = right(i);
        int smallest = i;

        if (li < size && arr[li] < arr[smallest])
            smallest = li;
        if (ri < size && arr[ri] < arr[smallest])
            smallest = ri;

        if (smallest != i) {
            mySwap(arr[i], arr[smallest]);
            Heapify(smallest);
        }
    }

    int getMin() {
        if (size == 0) {
            cout << "Heap is empty" << endl;
            return INT_MAX; // or throw
        }
        return arr[0];
    }

    int ExtractMin() {
        if (size <= 0)
            return INT_MAX;

        if (size == 1) {
            size--;
            return arr[0];
        }

        int mini = arr[0];
        arr[0] = arr[size - 1];
        size--;
        Heapify(0);
        return mini;
    }

    void DecreaseKey(int i, int newVal) {
        if (i < 0 || i >= size) return;
        arr[i] = newVal;

        while (i != 0 && arr[parent(i)] > arr[i]) {
            mySwap(arr[parent(i)], arr[i]);
            i = parent(i);
        }
    }

    void Delete(int i) {
        if (i < 0 || i >= size) return;
        DecreaseKey(i, INT_MIN);
        ExtractMin();
    }

    void print() {
        for (int i = 0; i < size; i++) {
            cout << arr[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    BinaryHeap h(20);
    h.Insert(4);
    h.Insert(1);
    h.Insert(2);
    h.Insert(6);
    h.Insert(7);
    h.Insert(3);
    h.Insert(8);
    h.Insert(5);

    cout << "Min value is: " << h.getMin() << endl;

    h.Insert(-1);
    cout << "Min value is: " << h.getMin() << endl;

    h.DecreaseKey(3, -2);
    cout << "Min value is: " << h.getMin() << endl;

    h.ExtractMin();
    cout << "Min value is: " << h.getMin() << endl;

    h.Delete(0);
    cout << "Min value is: " << h.getMin() << endl;

    return 0;
}
```


### ‚è± Complexity Summary

For a heap with `n` elements:

| Operation     | Time Complexity |
| ------------- | --------------- |
| `Insert`      | `O(log n)`      |
| `Heapify`     | `O(log n)`      |
| `ExtractMin`  | `O(log n)`      |
| `DecreaseKey` | `O(log n)`      |
| `Delete`      | `O(log n)`      |
| `getMin`      | `O(1)`          |

Space: `O(capacity)` for array.


### üí° Tips / Things Interviewers Might Ask

* Why `left = 2*i + 1`, `right = 2*i + 2`?
  ‚Üí Derived from breadth-first indexing of a complete binary tree.

* Why is `Heapify` `O(log n)`?
  ‚Üí In worst case, you move from root to a leaf (height of heap is `log n`).

* How to turn this into a **max-heap**?
  ‚Üí Flip the comparisons: instead of ‚Äúsmallest‚Äù, track ‚Äúlargest‚Äù.

* How does this compare to `std::priority_queue`?
  ‚Üí `priority_queue` is typically a max-heap by default; under the hood, it‚Äôs very similar.


### ‚ùì FAQs

**Q: What happens if we call `getMin()` on an empty heap?**
Right now, we print a message and return `INT_MAX`. In a real library, we‚Äôd probably `throw` an exception.

**Q: Is using `INT_MIN` for `Delete` safe?**
As long as you know your keys are > `INT_MIN`, yes. In a more robust implementation, you‚Äôd track a special sentinel or adjust interface, but for learning it‚Äôs fine.

**Q: Why use an array instead of pointers and tree nodes?**
Arrays are more memory/cache efficient and simpler: we get parent/child indices with O(1) arithmetic.

