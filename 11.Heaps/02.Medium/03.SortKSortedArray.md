# üßÆ Sort a K-Sorted Array Using Min-Heap


## üìå Problem Statement

You‚Äôre given:

* An array `arr` where **every element is at most `k` positions away** from its correct sorted position.
* Your job: sort this array efficiently.

This type of array is called a **k-sorted / nearly sorted array**.

Example:

```cpp
arr = {6, 5, 3, 2, 8, 10, 9}
k = 3
```

üëâ Each element is no more than 3 positions from its sorted place.

Goal output:

```cpp
[2, 3, 5, 6, 8, 9, 10]
```


## üß† Intuition

In a normal unsorted array, we‚Äôd need full sorting ‚Üí `O(n log n)`.

But here‚Ä¶

> Each number is already **close** to where it belongs.

So what if we always keep a **window** of size `k` in a min-heap?

Think:

* The smallest element in any `k+1` window must be one of these `k+1` numbers.
* Using a min-heap lets us extract that smallest efficiently.

So the plan:

1. Traverse array and push elements into a min-heap
2. If heap size > k:

   * Pop the smallest ‚Üí place it into the result
3. After finishing scanning the array:

   * Pop and append remaining heap elements

Boom. Sorted. More efficient than sorting everything from scratch.


### üê¢ Brute Force

Just call:

```cpp
sort(arr.begin(), arr.end());
```

### Complexity

* Time: `O(n log n)`
* Space: `O(1)` or `O(log n)`

Correct but **wastes the structural advantage** that array is almost sorted.


### ‚ö° Optimal Approach ‚Äî Min-Heap of Size (k + 1)

Why `(k + 1)`?
Because an element can be displaced by at most `k` positions ‚Üí correct element will always be present in the heap once we‚Äôve collected `k + 1` elements.


### üîß Code

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> sortNearlySorted(vector<int> &arr, int k) {
    int n = arr.size();
    vector<int> res;
    priority_queue<int, vector<int>, greater<int>> pq; // min-heap

    for (int i = 0; i < n; i++) {
        pq.push(arr[i]);

        if (pq.size() > k) {
            res.push_back(pq.top());
            pq.pop();
        }
    }

    // Empty remaining elements
    while (!pq.empty()) {
        res.push_back(pq.top());
        pq.pop();
    }

    return res;
}

int main() {
    vector<int> arr = {6, 5, 3, 2, 8, 10, 9};
    int k = 3;

    vector<int> res = sortNearlySorted(arr, k);

    cout << "[ ";
    for (int x : res) cout << x << " ";
    cout << "]" << endl;
}
```

‚û° Your logic is perfect ‚úî
‚û° I just separated output from logic for cleaner structure.


### üîç Dry Run Example

```text
arr = [6, 5, 3, 2, 8, 10, 9], k = 3
```

| Step | Push | Heap       | Pop?    | Result    |
| ---- | ---- | ---------- | ------- | --------- |
| 1    | 6    | {6}        | ‚ùå       | []        |
| 2    | 5    | {5,6}      | ‚ùå       | []        |
| 3    | 3    | {3,5,6}    | ‚ùå       | []        |
| 4    | 2    | {2,3,5,6}  | ‚úî pop 2 | [2]       |
| 5    | 8    | {3,5,6,8}  | ‚úî pop 3 | [2,3]     |
| 6    | 10   | {5,6,8,10} | ‚úî pop 5 | [2,3,5]   |
| 7    | 9    | {6,8,10,9} | ‚úî pop 6 | [2,3,5,6] |

Then empty heap:
Final result ‚Üí `[2,3,5,6,8,9,10]` ‚úî


### ‚è± Complexity Analysis

| Aspect           | Value          |
| ---------------- | -------------- |
| Heap size        | ‚â§ (k + 1)      |
| Insert           | `O(log k)`     |
| Pop              | `O(log k)`     |
| For `n` elements | **O(n log k)** |
| Space            | **O(k)**       |

Much better than `O(n log n)` when `k` ‚â™ `n`.


### üß™ Test Cases

```cpp
// Already sorted
arr = {1,2,3,4}, k = 1 ‚Üí {1,2,3,4}

// Reverse small displacement
arr = {3,1,2}, k = 2 ‚Üí {1,2,3}

// Single element
arr = {5}, k = 0 ‚Üí {5}

// k = 0 => array already sorted
arr = {4,1,3,2}, k = 0 ‚Üí ERROR? (should treat as normal case)
```

You may want to handle:

```cpp
if (k <= 0) return arr;
```


### üí° Tips & Variations üéØ

| Variation                                           | Trick                            |
| --------------------------------------------------- | -------------------------------- |
| Sort **K nearly sorted objects** in streaming input | Use same heap method             |
| K-th smallest/largest                               | Change heap type                 |
| Merge K sorted lists                                | Use multiple pointers + min-heap |
| Realtime leaderboard                                | Maintain a heap of size k        |

This pattern is super-reusable across many top interview problems.

Reputation: S-tier ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê


### ‚ùì FAQs

**Q: Why min-heap not max-heap?**
We always want to output the **smallest among seen candidates** first ‚Üí min-heap fits perfectly.

**Q: What if array is not k-sorted?**
Still works ‚Äî just won‚Äôt be optimal. Falls back to approx. `O(n log n)` behavior.

**Q: Must k be known ahead of time?**
Yes ‚Äî you need the constraint to know heap size.

