

# ğŸ“ K Closest Points to Origin [Leetcode #[973](https://leetcode.com/problems/k-closest-points-to-origin/description/)]

## ğŸ“Œ Problem Statement

You are given an array `points` where:

```
points[i] = [xi, yi]
```

Each point represents a coordinate on a 2D plane.

Return the **k points closest to the origin (0,0)**.

Distance formula:

```
distance = sqrt(xÂ² + yÂ²)
```

Since sqrt is monotonic, we compare:

```
xÂ² + yÂ²
```



## ğŸ§  Why this problem matters

This problem tests:

* Priority Queues (Heaps)
* Selection algorithms
* Custom comparators
* Optimization trade-offs

Itâ€™s a **minimax selection problem** in disguise.

Think of it as:

> â€œAmong all PokÃ©mon on the map, which `k` are closest to you?â€ ğŸ§­ğŸ˜„



## ğŸ‘€ Example

### Input

```
points = [[1,3],[-2,2],[5,8],[0,1]]
k = 2
```

### Output (any order)

```
[[-2,2],[0,1]]
```



# ğŸŒ Brute Force Approach

### âŒ Naive Idea

* Compute distance for every point
* Sort all points by distance
* Take first `k`

### Complexity

```
Time: O(N log N)
Space: O(N)
```

Works, but not optimal.



# âœ… Optimal Approach 1: Max Heap (Priority Queue)

### Idea

Keep only the **k smallest elements** using a **max heap**.

We:

* Push each point into heap
* If heap size > k â†’ pop largest

Heap always contains the k closest so far.



## ğŸ’» Code: Max Heap Solution

```cpp
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<pair<int, vector<int>>> dist;

        for (auto& p : points) {
            int d = p[0] * p[0] + p[1] * p[1];
            dist.push({d, p});

            if (dist.size() > k)
                dist.pop();
        }

        vector<vector<int>> res;
        while (!dist.empty()) {
            res.push_back(dist.top().second);
            dist.pop();
        }
        return res;
    }
};
```



## ğŸ§  How this works

* `priority_queue` is a **max heap by default**
* Largest distance stays at top
* When size exceeds `k`, we remove the farthest



## â± Complexity (Heap)

| Metric | Value          |
| - | -- |
| Time   | **O(N log K)** |
| Space  | **O(K)**       |

Great when:

* `k` is small
* Data is streaming



# ğŸš€ Optimal Approach 2: Quickselect (`nth_element`)

This is the **absolute fastest** method in practice.

### Idea

Rearrange the array so that:

* First `k` elements are the k smallest
* Order inside them does NOT matter

Just like partial sorting.



## ğŸ’» Code: Quickselect Solution

```cpp
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        nth_element(points.begin(), points.begin() + k, points.end(),
            [](auto &a, auto &b) {
                return a[0]*a[0] + a[1]*a[1] <
                       b[0]*b[0] + b[1]*b[1];
            });
        return vector<vector<int>>(points.begin(), points.begin() + k);
    }
};
```



## ğŸ§  How `nth_element` works

It uses a **Quickselect-style partitioning**:

After execution:

* Element at index `k` is in correct position
* All before it are smaller
* All after it are larger

But:

* No full sorting
* Much faster than sort



## â± Complexity (Quickselect)

| Metric | Value            |
| - | - |
| Time   | **O(N)** average |
| Space  | **O(1)**         |

This is the **best possible solution**.



# ğŸ§ª Test Cases

| points            | k       | Output   |
| -- | - | -- |
| [[1,3],[-2,2]]    | 1       | [[-2,2]] |
| [[0,1],[1,0]]     | 2       | both     |
| Large input       | small k | correct  |
| All same distance | any     | any k    |



# ğŸ§  Key Observations

* Never compute `sqrt`
* Compare squared distances
* Order does not matter
* Two-pointer & greedy ideas appear here



# ğŸ†š Heap vs Quickselect (Interview Gold)

| Method      | When to Use               |
| -- | - |
| Max Heap    | Streaming data, dynamic k |
| Quickselect | Static array, fastest     |
| Sort        | Only if constraints small |



# â“ FAQs

### Q1: Why not use min heap?

Because you'd need to pop `n-k` elements.



### Q2: Is `nth_element` stable?

No. Order is not guaranteed.



### Q3: Is worst case for quickselect bad?

Yes, O(NÂ²), but extremely rare.



### Q4: Which one do interviewers prefer?

Both.
But knowing **both** is elite-level.



### Q5: Is this a greedy problem?

Yes. Itâ€™s a **selection greedy problem**.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Distance = xÂ² + yÂ²
Heap â†’ O(N log K)
nth_element â†’ O(N)
No sqrt
Order doesn't matter
```

