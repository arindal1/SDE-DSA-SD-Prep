# üßæ Task Scheduler [#621](https://leetcode.com/problems/task-scheduler/description/)

You are given:

* A list of tasks `tasks`, where each task is a capital letter (like `'A'`, `'B'`, etc).
* A non-negative integer `n` which is the cooldown time.

Each task takes 1 unit of time.
You must schedule all tasks so that:

* The same task type must be separated by at least `n` intervals.
* In each unit, you can either:

  * execute a task, or
  * stay idle.

üëâ **Goal:** Return the minimum number of time units needed to finish all tasks.

### Example

```text
tasks = ['A','A','A','B','B','B'], n = 2

One optimal schedule: A B idle A B idle A B
Total time = 8
```


### üß† Intuition

This is basically a "cooldown" problem.

* Same task must be at least `n` time units apart.
* If one task appears *a lot* (e.g. `'A'` 6 times), it controls the structure of the schedule.
* We want to arrange tasks so that we:

  * avoid unnecessary idle slots
  * and respect the cooldown constraint.

A neat way to do this is:

> Always execute the tasks that still need to run the most times
> and simulate the process in "chunks" or "cycles" of size `n + 1`.

Why `n + 1`?

* In a window of `n + 1` positions, you can place:

  * one occurrence of a particular task only once (because then it needs `n` cooldown),
  * and up to `n` different other tasks or idles.
* So a full "cycle" is `n + 1` wide.

We greedily fill each cycle with the most frequent remaining tasks.


## üëÄ High-Level Algorithm

1. Count how many times each task appears.
2. Use a **max-heap** (priority queue) where each entry is a task's remaining count.
3. While there are still tasks to schedule:

   * Open a "cycle" of length `n + 1`.
   * In that cycle, repeatedly:

     * pick the task with highest remaining count from the heap,
     * execute it (decrease its count),
     * store it temporarily if it still has remaining executions,
     * increment total `time`.
   * After the cycle:

     * push back all still-needed tasks into the heap.
     * if the heap is not empty and the cycle was not completely filled, then:

       * you need to add idle time to complete the full `n + 1` block.

By doing this, we always prioritize tasks that are most constrained and avoid wasting idle slots unless we absolutely must.


## üß© CPP Code

```cpp
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        unordered_map<char, int> freq;
        for (auto ch : tasks) {
            freq[ch]++;
        }

        priority_queue<int> pq;
        for (auto it : freq) {
            pq.push(it.second);
        }

        int time = 0;

        while (!pq.empty()) {
            vector<int> temp;

            int cycle = n + 1, i = 0;

            while (i < cycle && !pq.empty()) {
                int cnt = pq.top();
                pq.pop();
                cnt--;

                if (cnt > 0)
                    temp.push_back(cnt);
                
                time++;
                i++;
            }

            for (int val : temp)
                pq.push(val);

            if (pq.empty())
                break;
            
            time += (cycle - i);
        }

        return time;
    }
};
```

Good news:

* The logic is correct.
* No functional change is needed.
* Just explanations and understanding.


### üîç Step-by-Step Explanation

### 1. Frequency count

```cpp
unordered_map<char, int> freq;
for (auto ch : tasks) {
    freq[ch]++;
}
```

We count how many times each task appears:

* Example: `tasks = [A, A, A, B, B, B]`

  * `freq['A'] = 3`
  * `freq['B'] = 3`


### 2. Max-heap of task counts

```cpp
priority_queue<int> pq;
for (auto it : freq) {
    pq.push(it.second);
}
```

We don‚Äôt care about *which* task it is, only how many times it still needs to be executed.
So we push only the counts into a max-heap.

* For the example: heap contains `[3, 3]` initially.


### 3. Time simulation using cycles

We simulate the execution timeline.

```cpp
int time = 0;
while (!pq.empty()) {
    vector<int> temp;
    int cycle = n + 1, i = 0;

    while (i < cycle && !pq.empty()) {
        int cnt = pq.top();
        pq.pop();
        cnt--;

        if (cnt > 0)
            temp.push_back(cnt);

        time++;
        i++;
    }

    for (int val : temp)
        pq.push(val);

    if (pq.empty())
        break;

    time += (cycle - i);
}
```

Let‚Äôs break this down.


### 3.1 Inside each cycle

Each cycle has `cycle = n + 1` slots.

For each slot in the cycle:

* We take the most frequent remaining task (largest count).
* Execute it once (`cnt--`).
* If it still needs more runs (`cnt > 0`), store it in `temp` to reinsert later.
* Increase the global `time`.
* Increase `i` (how many slots we actually filled in this cycle).

This loop:

```cpp
while (i < cycle && !pq.empty()) {
    // pick and run one task
    ...
}
```

ensures:

* We use at most `n + 1` tasks in this cycle.
* If there aren't enough different tasks in the heap, we will use fewer tasks and later fill the rest with idle time.


### 3.2 After executing tasks in the cycle

All tasks that still need to be run again are in `temp` with decremented counts.

We push them back into the heap:

```cpp
for (int val : temp)
    pq.push(val);
```

If the heap is now empty, it means we finished all tasks exactly at the last executed time, so no more idle needed and we `break`.

Otherwise:

```cpp
time += (cycle - i);
```

This adds the remaining idle slots needed to finish the full cycle of length `n + 1`.

Example: if `n = 2`, `cycle = 3`:

* If we only managed to execute 2 tasks in this cycle (`i = 2`), then 1 idle is needed ‚Üí `time += (3 - 2)`.


### üß™ Example Walkthrough

Take:

```text
tasks = [A, A, A, B, B, B], n = 2
```

Step 1: freq = {A: 3, B: 3}
Step 2: pq = [3, 3] (both counts)

Cycle length = n + 1 = 3.

### Cycle 1:

* i = 0

  * pick 3 (A's), run one A ‚Üí A left: 2
  * temp = [2]
  * time = 1
* i = 1

  * pick 3 (B's), run one B ‚Üí B left: 2
  * temp = [2, 2]
  * time = 2
* i = 2

  * pick 2 (A or B), run it ‚Üí say A ‚Üí A left: 1
  * temp = [2, 1]
  * time = 3
* i = 3 -> cycle ended (3 slots)

Push back [2, 1] into heap.

Heap not empty, so no extra idle for this cycle (i already equals cycle).

### Cycle 2:

* similar pattern, time increases, idle slots get injected if we cannot fill the whole cycle with actual tasks.

Final result for this input will be 8, matching the known optimal schedule.


### ‚è± Complexity

Let:

* T = number of tasks = `tasks.size()`
* U = number of unique task types (bounded by 26 if tasks are A‚ÄìZ)

Operations:

* Building the freq map: O(T)
* Initial heap build: O(U log U)
* Each cycle:

  * We pop and push at most U times, but total pushes/pops across the whole process is bounded by T.
  * Each push/pop is O(log U).

Total:

* Time: O(T log U)
  If tasks are uppercase letters, U ‚â§ 26, so it is effectively O(T).
* Space:

  * freq map: O(U)
  * heap: O(U)
  * temp vector: at most O(U)
  * Overall: O(U)


### üß† Tips, Tricks, And Gotchas

* If `n = 0`:

  * There is no cooldown constraint.
  * You can just execute tasks back to back.
  * This algorithm still works:

    * cycle = 1
    * inner loop runs tasks one by one
    * no idle is ever added
* You don't actually need to track which task is which, only how many of each remain.
* Using `priority_queue<int>` is enough; no need for chars in the heap.
* This problem has a math-based greedy solution too (without simulation), but the heap solution is very intuitive for interviews.


### üîÅ Variations

* CPU task scheduling with cooldown:

  * exactly this problem with different wording.
* Rearranging string so that no two adjacent characters are equal:

  * also uses frequency + max-heap.
* Scheduling to minimize idle slots given multiple constraints:

  * slight twists on this pattern.



### ‚ùì FAQs

**Q: Why use n + 1 for cycle length?**
Because after executing a task once, we need at least n other units (task or idle) before we can execute the same task again. So a block of `(current run + n cooldown)` is length `n + 1`.

---

**Q: What if in some cycles we don‚Äôt fill all `n + 1` slots with tasks?**
If there are still tasks left in the heap, we must add idle slots to complete the cycle. That is exactly:

```cpp
time += (cycle - i);
```

If there are no tasks left, we skip adding idle time, since we finished.

---

**Q: Could we do this without a heap?**
Yes, there is a formula-based approach using the max frequency of any task, but the heap simulation is often easier to implement and reason about.

---

**Q: Is unordered_map necessary? What about vector<int> of size 26?**
Since tasks are uppercase English letters, we could do:

```cpp
vector<int> freq(26, 0);
for (char c : tasks) freq[c - 'A']++;
```

This is slightly faster and simpler, but your unordered_map version is perfectly fine and more general.

