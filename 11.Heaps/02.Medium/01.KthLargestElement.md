# üßÆ `findKthLargest` with a Min-Heap [#215](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)

## üìå Problem Statement

> Given an integer array `nums` and an integer `k`, return the **k-th largest element** in the array.

Important details:

* You are looking for the **k-th largest**, not k-th distinct largest.
* The array is unsorted.
* You do not need to sort the entire array, just find that one element.

Example:

```text
nums = [3, 2, 1, 5, 6, 4], k = 2
Output = 5

Sorted array = [1, 2, 3, 4, 5, 6]
2nd largest element = 5
```


## üß† Intuition

Imagine you have a stream of numbers coming in one by one, and you want to always know the **k-th largest so far**.

One way to think:

* Keep only the **top k largest** elements you have seen.
* If you had a magic box that always kept the smallest of those k elements on top, then:

  * That smallest element among the top k is exactly the **k-th largest overall**.

That magic box is a **min-heap of size k**.

So the plan:

1. Use a min-heap.
2. Push every element into it.
3. If the heap grows larger than k, remove the smallest.
4. At the end, the heap contains the **k largest elements in the array**, and the smallest among them (heap top) is the **k-th largest**.

It‚Äôs like maintaining the top 10 players on a leaderboard: if a new player comes in with a score better than the worst on the board, you kick the worst off. The worst of the ‚Äútop 10‚Äù is exactly rank 10.



### üê¢ Brute Force Approach

### 1. Sort Everything

The simplest approach:

1. Sort the array in **descending** order.
2. Return the element at index `k - 1`.

Or:

1. Sort ascending.
2. Return element at index `n - k`.

Code:

```cpp
int findKthLargest(vector<int>& nums, int k) {
    sort(nums.begin(), nums.end());          // ascending
    return nums[nums.size() - k];            // k-th largest
}
```

### Complexity

* Time: `O(n log n)` due to sorting.
* Space: `O(1)` or `O(log n)` depending on sorting implementation.

It works, but we are doing more work than necessary if we only need a single element, not a fully sorted list.



### ‚ö° Optimal (Heap) Approach Used In The Code

### Idea

Use a **min-heap of size k**:

* Keep the **k largest elements** seen so far.
* For each number:

  * Push it to the min-heap.
  * If heap size exceeds k, pop the smallest (the top).
* After processing all numbers:

  * The heap contains the k largest elements.
  * The smallest among these k is the **k-th largest overall**, so `minHeap.top()` is the answer.

### Why a min-heap?

* If we used a **max-heap of all n elements**, we‚Äôd need to pop `k - 1` times to get the k-th largest.
* With a min-heap of size `k`, we keep memory usage smaller and operations focused on only the top k.


### ‚úÖ C++ Code


```cpp
#include <vector>
#include <queue>
#include <functional>
#include <stdexcept>
using namespace std;

class Solution {
public:
    int findKthLargest(const vector<int>& nums, int k) {
        int n = nums.size();
        if (k < 1 || k > n) {
            throw invalid_argument("k is out of range");
        }

        priority_queue<int, vector<int>, greater<int>> minHeap; // min-heap

        for (int num : nums) {
            minHeap.push(num);
            if ((int)minHeap.size() > k) {
                minHeap.pop(); // remove smallest, keep only k largest so far
            }
        }

        return minHeap.top();
    }
};
```

> On LeetCode, you can skip the `k` range check, because constraints guarantee `1 ‚â§ k ‚â§ n`.

---

### üîç Step-By-Step Example

Let:

```text
nums = [3, 2, 1, 5, 6, 4], k = 2
```

We want the 2nd largest element.

Initialize `minHeap = {}` (empty).

Process each number:

1. Insert 3
   Heap: `{3}` (size 1 ‚â§ 2, ok)
2. Insert 2
   Heap: `{2, 3}` (min is 2, size 2 ‚â§ 2, ok)
3. Insert 1
   Heap: `{1, 3, 2}`, size 3 > 2 ‚Üí pop min ‚Üí `{2, 3}`
4. Insert 5
   Heap: `{2, 3, 5}`, size 3 > 2 ‚Üí pop min ‚Üí `{3, 5}`
5. Insert 6
   Heap: `{3, 5, 6}`, size 3 > 2 ‚Üí pop min ‚Üí `{5, 6}`
6. Insert 4
   Heap: `{4, 6, 5}`, size 3 > 2 ‚Üí pop min ‚Üí `{5, 6}`

Now heap holds `{5, 6}` which are the 2 largest numbers in the array.
The smallest among them (`5`) is the **2nd largest**. So answer = 5.


### ‚è± Complexity Analysis

Let:

* `n` = size of `nums`
* Heap size never exceeds `k`

For each of the `n` elements:

* `push` is `O(log k)`
* Sometimes `pop` is also `O(log k)`

So:

* **Time:** `O(n log k)`
* **Space:** `O(k)` for the heap

Compare:

* Sorting: `O(n log n)` time, `O(1)` extra space
* Heap approach: `O(n log k)` time, `O(k)` space

If `k` is much smaller than `n` (like `k = 10` and `n = 10^5`), the heap approach is significantly faster.


### üß™ Test Cases

### 1. Basic

```cpp
nums = {3, 2, 1, 5, 6, 4}, k = 2 ‚Üí 5
nums = {3, 2, 3, 1, 2, 4, 5, 5, 6}, k = 4 ‚Üí 4
```

### 2. Edge-ish

```cpp
nums = {1}, k = 1 ‚Üí 1
nums = {7, 7, 7, 7}, k = 3 ‚Üí 7  // duplicates are fine
nums = {-1, -2, -3, -4}, k = 1 ‚Üí -1
nums = {-1, -2, -3, -4}, k = 4 ‚Üí -4
```

### 3. Large k and n conceptually

```cpp
nums = [1, 2, 3, ..., 100000], k = 100000 ‚Üí 1
nums = [random_big_array], k = 1 ‚Üí max element
```

These help confirm edge behavior.

---

### üéØ Alternative Optimal Approach: Quickselect

Apart from heaps, there is another classic solution: **Quickselect**, a selection algorithm based on QuickSort partitioning.

* It partitions the array around a pivot.
* After partition:

  * If pivot index is `n - k`, you found the k-th largest.
  * If pivot index is too small, search right side.
  * If too large, search left side.

Average time:

* **O(n)** expected time.
* **O(1)** extra space (in-place).

But worst-case time is `O(n¬≤)` if pivots are consistently bad, unless you add median-of-medians or randomization.

Compared to the heap method:

* Quickselect is often faster in practice for a single query.
* Heap is more flexible for streaming or if you want to always keep ‚Äútop k‚Äù as data keeps coming.


### üß© Tips, Tricks, And Variations

* For **k-th smallest** element:

  * You can:

    * Use a max-heap of size `k`, or
    * Reuse the same logic but interpret it differently.
* For **streaming data** (numbers keep coming forever):

  * This exact min-heap of size `k` pattern is ideal.
  * At any moment, `top()` is the k-th largest so far.
* For **finding top k largest elements** (not just k-th):

  * After this algorithm, the heap itself holds the top k elements (in no particular order).
* For **multiple queries** (same array, many different k‚Äôs):

  * Sorting once and answering in O(1) per query might be simpler and efficient enough.


### ‚ùì FAQs

**Q: Why a min-heap and not a max-heap?**
Because we only want to keep the largest `k` elements. Using a min-heap makes it easy to always remove the smallest of them when we have more than `k`. With a max-heap, we‚Äôd have to store everything or pop many times.

**Q: What if `k` is 1?**
The min-heap will always keep only the largest element so far. At the end, `top()` is just the maximum of the array.

**Q: What if `k == nums.size()`?**
Then we keep all elements in the heap. The top of the min-heap is the smallest element, which is the k-th largest. Works fine.

**Q: Can k be invalid (like 0 or > n)?**
Mathematically, that doesn‚Äôt make sense. In coding platforms like LeetCode, constraints usually guarantee `1 ‚â§ k ‚â§ n`. In more general code, you‚Äôd want to check this and throw or handle appropriately.

**Q: Is this stable with duplicate values?**
Yes. We are just comparing values, not relying on uniqueness. Duplicates are handled naturally.

