# ğŸ” Find K-th Smallest Using a Max-Heap

## ğŸ“Œ Problem Statement

> Given an unsorted integer array `nums` and a positive integer `k`, return the **k-th smallest** element in the array.

âœ” Array can contain duplicates
âœ” You only need the element itself, not sorted order
âŒ Donâ€™t use sorting as first instinct! (Interview twist ğŸ˜ˆ)

### Example

```text
Input:
nums = [7, 10, 4, 3, 20, 15], k = 3

Sorted = [3, 4, 7, 10, 15, 20] â†’ answer = 7
```


## ğŸ§  Intuition

We want the **k smallest elements**, but our real goal is just:

> The **largest** among those k smallest elements

So imagine always maintaining the **top k smallest** seen so far.

* But among those top k, you want the largest easily accessible.
* That means the **root = the k-th smallest**
* So a **max-heap of size k** is perfect âœ”

Workflow:

1. Insert every number into a **max-heap**
2. If heap > k elements â†’ pop max
   (kick out the largest since it canâ€™t be in the smallest k anymore)
3. After processing all nums â†’
   root/top holds the **k-th smallest element** ğŸ¯

Itâ€™s like a VIP club with only `k` seats.
Anyone bigger than the biggest VIP â†’ gets kicked.
Top dog inside the club = rank k smallest ğŸ’¼


### ğŸ¢ Brute Force Approach

Sort the array:

```cpp
sort(nums.begin(), nums.end());
return nums[k-1];
```

### Complexity

| Type    | Time       | Space         |
| ------- | ---------- | ------------- |
| Sorting | O(n log n) | O(1) / O(log n) |

Simple, but slower than necessary for large n / small k.


### âš¡ Optimal Heap Approach (Used Here)

#### Data Structure

```cpp
priority_queue<int> maxHeap; // max-heap by default in C++
```

#### Why Max-Heap?

* We keep **k smallest** inside the heap.
* The root (max of those k) = **k-th smallest**.

#### Conditions

* Size of heap should *never exceed k*
* If size > k â†’ remove **max element** â†’ only smaller remain

#### Steps

1. Traverse array
2. Push each element into heap
3. If size > k â†’ pop
4. Final answer = maxHeap.top()


### ğŸ“¦ Clean, Polished Full Code

```cpp
#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
    int findKthSmallest(const vector<int>& nums, int k) {
        priority_queue<int> maxHeap; 

        for (int num : nums) {
            maxHeap.push(num);
            if ((int)maxHeap.size() > k) {
                maxHeap.pop();
            }
        }

        return maxHeap.top(); // the k-th smallest
    }
};
```

Your original logic is perfect âœ”
Just added `const` correctness and a minor safety cast.


### ğŸ” Dry Run Example

```text
nums = [7, 10, 4, 20, 15], k = 4
```

| Step | Push | Heap Contents (size â‰¤4) | Pop? | Top (k-th smallest tracker) |
| ---- | ---- | ----------------------- | ---- | --------------------------- |
| 1    | 7    | [7]                     | âŒ    | 7                           |
| 2    | 10   | [10, 7]                 | âŒ    | 10                          |
| 3    | 4    | [10, 7, 4]              | âŒ    | 10                          |
| 4    | 20   | [20, 10, 4, 7]          | âŒ    | 20                          |
| 5    | 15   | [20,10,4,7,15] â†’ pop 20 | âœ”    | 15                          |

Answer = **15**
Sorted: [4,7,10,15,20] â†’ 4th smallest = 15 ğŸ‘


### â± Complexity Analysis

Let:

* `n` = nums size
* Heap size capped at `k` always

| Operation        | Cost       |
| ---------------- | ---------- |
| Insert           | O(log k)   |
| Remove           | O(log k)   |
| Total operations | O(n log k) |
| Space            | O(k)       |

**Big win when k â‰ª n ğŸ’¥**


### ğŸ§ª Test Cases

#### âœ“ Basic

```cpp
nums = {7, 10, 4, 3, 20, 15}, k = 3 â†’ 7
nums = {1}, k = 1 â†’ 1
nums = {5,5,5,5}, k = 2 â†’ 5
```

#### âœ“ Negative and mixed

```cpp
nums = {-1,-5,-10,-3}, k = 1 â†’ -10 (smallest)
nums = {-1,-5,-10,-3}, k = 4 â†’ -1
```

#### âœ“ Edge

```cpp
nums = [10,9,8,7], k = 4 â†’ 10
nums = [10,9,8,7], k = 1 â†’ 7
```


### ğŸ’¡ Tips & Variations

| Variant         | Data Structure     | Result        |
| --------------- | ------------------ | ------------- |
| k-th *largest*  | Min-heap of size k | minHeap.top() |
| k-th *smallest* | Max-heap of size k | maxHeap.top() |

ğŸ‘‰ *Same logic, opposite heap.*

Other related apps:

* Top-K frequent elements
* K closest points
* K largest sum pairs
  (Same pattern: keep a heap of size k!)


### â“ FAQs

**Q: Why not use min-heap here?**
Because then youâ€™d keep the **k largest**, not the **k smallest**.

**Q: Does this support duplicates?**
Yes â€“ duplicates play nicely in heaps.

**Q: What if k == nums.size()?**
Then heap stores all elements â€” top() returns the largest â†’ correct since that's the k-th smallest.

**Q: Worst case performance?**
Still `O(n log k)`, which is excellent when `k` is small.

