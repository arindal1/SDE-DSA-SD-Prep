

# ğŸŒ³ Maximum Depth (Height) of a Binary Tree [#104](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, return its **maximum depth**.

ğŸ‘‰ **Maximum Depth** is defined as:

> The number of nodes on the **longest path from the root to a leaf**.



## ğŸ§  Why this problem matters

This is **not just a beginner problem**.
Maximum depth is the **foundation** for many advanced tree problems:

* Checking if a tree is **balanced**
* Calculating **diameter**
* Tree DP (bottom-up problems)
* Understanding recursion on trees

If you understand this problem deeply, **half of tree recursion makes sense** ğŸ’¡



## ğŸ‘€ Example

### Example 1

```
        1
       / \
      2   3
     /
    4
```

**Maximum Depth = 3**



### Example 2

```
1
 \
  2
   \
    3
```

**Maximum Depth = 3**
(yes, skewed trees still count ğŸ˜„)



## ğŸ§© Intuition (the â€œahaâ€ moment)

At **every node**, ask:

> â€œWhat is the depth of my left subtree?â€

> â€œWhat is the depth of my right subtree?â€

> â€œI am 1 level above the deeper one.â€

Thatâ€™s it.
Trees + recursion = self-similar logic ğŸŒ±


### ğŸ’» Code

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr)
            return 0;
        
        int lh = maxDepth(root->left);
        int rh = maxDepth(root->right);

        return 1 + max(lh, rh);
    }
};
```


## ğŸ§  Algorithm (Recursive DFS â€“ Optimal)

### ğŸ’¡ Steps

1. If tree is empty â†’ depth = 0
2. Recursively compute left subtree depth
3. Recursively compute right subtree depth
4. Return `1 + max(leftDepth, rightDepth)`



### ğŸ”‘ Why this works

* Every subtree is a smaller tree
* Leaves contribute depth = 1
* Maximum path bubbles up to root



## ğŸŒ Brute Force Approach (Conceptual)

Some naive approaches:

* Compute height by traversing each path repeatedly
* Store all root-to-leaf paths

âŒ Inefficient and unnecessary <br>
ğŸ‘‰ Single DFS pass solves it optimally



# ğŸ”„ Alternative Approach (Iterative using BFS)

Sometimes interviewers ask:

> â€œCan you do it without recursion?â€



### ğŸ§  Idea

* Traverse tree level by level <br>
* Count how many levels exist



### ğŸ’» Code (BFS)

```cpp
int maxDepth(TreeNode* root) {
    if (!root) return 0;

    queue<TreeNode*> q;
    q.push(root);
    int depth = 0;

    while (!q.empty()) {
        int size = q.size();
        depth++;

        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front();
            q.pop();

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    return depth;
}
```



### â± Complexity (BFS)

* **Time:** O(N)
* **Space:** O(N)



## â± Complexity Analysis (Recursive)

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of the tree

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree          | Output |
| - | - |
| Empty tree    | 0      |
| Single node   | 1      |
| Balanced tree | logâ‚‚N  |
| Left skewed   | N      |
| Right skewed  | N      |



## ğŸ§  Key Observations

* Height depends on **longest path**
* Base case matters a lot
* Used in many follow-up problems
* Recursive solution is **bottom-up**



# ğŸš€ Common Variations & Follow-ups

### 1ï¸âƒ£ Minimum Depth of Binary Tree

(root â†’ nearest leaf)

### 2ï¸âƒ£ Diameter of Binary Tree

(longest path between any two nodes)

### 3ï¸âƒ£ Balanced Binary Tree

(height difference â‰¤ 1)

### 4ï¸âƒ£ Maximum Path Sum

(tree DP problem)



## âš ï¸ Common Mistakes

âŒ Returning `-1` instead of `0` (depends on definition) <br>
âŒ Forgetting base case <br>
âŒ Confusing **depth** with **height** <br>
âŒ Counting edges instead of nodes unintentionally <br>



# â“ FAQs

### Q1: Whatâ€™s the difference between height and depth?

* **Height of tree** = max depth of root
* **Depth of node** = distance from root to that node

Often used interchangeably, but context matters.



### Q2: Why return 0 for empty tree?

Because:

* No nodes = no depth
* Makes recursive formula clean



### Q3: Can this cause stack overflow?

Yes, for highly skewed trees.
Use BFS or iterative DFS if tree is very deep.



### Q4: Which approach is better in interviews?

* Recursive â†’ simplest
* BFS â†’ avoids recursion stack
* Explain both â†’ â­ bonus points



### Q5: Can this be optimized further?

No.
Every node must be visited at least once.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Max Depth = 1 + max(left, right)
Empty tree â†’ 0
Leaf â†’ 1
DFS or BFS both work
```
