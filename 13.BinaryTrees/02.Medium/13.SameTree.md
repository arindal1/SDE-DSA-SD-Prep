# ğŸŒ³ Same Tree (Structural & Value Equality) [#100](https://leetcode.com/problems/same-tree/description/)

## ğŸ“Œ Problem Statement

Given the roots of **two binary trees `p` and `q`**, determine whether they are **the same tree**.

ğŸ‘‰ Two trees are considered the **same** if:

* They have the **same structure**
* Corresponding nodes have the **same values**



## ğŸ§  Why this problem matters

This problem is often underestimated, but it tests:

* Correct **base case handling**
* Understanding of **tree structure**
* Clean recursive reasoning

Itâ€™s also a building block for:

* Subtree checking
* Tree comparison problems
* Serialization & validation tasks

Think of it as:

> â€œAre these two trees **clones**, not just siblings?â€ ğŸŒ±ğŸŒ±



## ğŸ‘€ Example

### Same Trees âœ…

```
Tree p:           Tree q:
    1                 1
   / \               / \
  2   3             2   3
```



### Different Trees âŒ (structure mismatch)

```
Tree p:           Tree q:
    1                 1
   /                   \
  2                     2
```



### Different Trees âŒ (value mismatch)

```
Tree p:           Tree q:
    1                 1
   / \               / \
  2   3             2   4
```



## ğŸ§© Intuition (the core idea)

At every step, we must check **three things**:

1. Are both nodes **null**?
2. Are their **values equal**?
3. Are their **left subtrees equal** AND **right subtrees equal**?

If **any one** fails â†’ trees are not the same âŒ



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Naive Idea

* Serialize both trees
* Compare serialized strings or arrays

âŒ Extra space
âŒ Complicated
âŒ Loses elegance



# âœ… Optimal Approach (Recursive DFS)

### ğŸ”¥ Key Insight

Trees are **recursive structures**.
Two trees are the same **if and only if**:

* Roots are equal
* Left subtrees are equal
* Right subtrees are equal



### ğŸ’» Code

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr || q == nullptr)
            return p == q;

        return (p->val == q->val &&
                isSameTree(p->left, q->left) &&
                isSameTree(p->right, q->right));
    }
};
```





## ğŸ§  Algorithm (Recursive DFS)

### ğŸ’¡ Steps

```
isSame(p, q):
    if both p and q are null:
        return true
    if one of them is null:
        return false
    if p.val != q.val:
        return false

    return isSame(p.left, q.left)
       AND isSame(p.right, q.right)
```



## ğŸ”‘ Why this works

* Ensures **structure alignment**
* Ensures **value equality**
* DFS guarantees all nodes are checked



# â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes (smaller tree)
* `H` = height of the tree

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree p                  | Tree q        | Output |
| -- | - | - |
| Both empty              | Both empty    | true   |
| One empty               | One non-empty | false  |
| Same shape & values     | Same          | true   |
| Same shape, diff values | âŒ             | false  |
| Diff shape              | âŒ             | false  |



## ğŸ§  Key Observations

* Value match alone is **not enough**
* Structure match alone is **not enough**
* Both must match simultaneously



# ğŸš€ Alternative Approach (Iterative BFS)

Sometimes interviewers ask:

> â€œCan you do this without recursion?â€



### ğŸ’¡ BFS using Queue

Compare nodes in pairs.

```cpp
bool isSameTree(TreeNode* p, TreeNode* q) {
    queue<TreeNode*> qu;
    qu.push(p);
    qu.push(q);

    while (!qu.empty()) {
        TreeNode* a = qu.front(); qu.pop();
        TreeNode* b = qu.front(); qu.pop();

        if (!a && !b) continue;
        if (!a || !b || a->val != b->val)
            return false;

        qu.push(a->left);
        qu.push(b->left);
        qu.push(a->right);
        qu.push(b->right);
    }
    return true;
}
```



# â“ FAQs

### Q1: Are two empty trees the same?

Yes âœ”ï¸
Both are structurally and value-wise identical.



### Q2: Is this preorder, inorder, or postorder?

Itâ€™s **DFS**, but not tied to one traversal order.
Structure matters more than order here.



### Q3: Can inorder traversal be used to check sameness?

No âŒ
Different trees can have the same inorder traversal.



### Q4: What if values match but structure differs?

Trees are **not the same**.



### Q5: Which approach is better in interviews?

* Recursive â†’ simplest and cleanest
* Iterative â†’ bonus points



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Same Tree = same structure + same values
Check nulls first
DFS both trees together
Time = O(N)
```

