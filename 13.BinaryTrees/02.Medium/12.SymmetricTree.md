
# ğŸŒ³ Symmetric Binary Tree (Mirror Check) [#101](https://leetcode.com/problems/symmetric-tree/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, determine whether the tree is **symmetric** around its center.

ğŸ‘‰ A binary tree is **symmetric** if:

> The left subtree is a **mirror reflection** of the right subtree.



## ğŸ§  Why this problem matters

This problem checks whether you understand:

* **Tree structure vs values**
* **Mirror recursion**
* Correct **base cases**

Itâ€™s a classic example of **â€œsame recursion, different directionâ€** ğŸ”„
Once you get this, mirror problems become easy.



## ğŸ‘€ Example

### Symmetric Tree âœ…

```
        1
       / \
      2   2
     / \ / \
    3  4 4  3
```



### Non-Symmetric Tree âŒ

```
        1
       / \
      2   2
       \   \
        3   3
```



## ğŸ§© Intuition (the core idea)

Two trees are **mirror images** if:

1. Their roots have the **same value**
2. Left child of one mirrors **right child** of the other
3. Right child of one mirrors **left child** of the other

So instead of comparing:

```
left vs left
right vs right
```

We compare:

```
left vs right
right vs left
```

Thatâ€™s the entire trick ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Naive Idea

* Serialize left subtree
* Serialize right subtree
* Reverse one and compare

âŒ Complicated
âŒ Extra space
âŒ Easy to mess up



# âœ… Optimal Approach (Recursive Mirror DFS)

### ğŸ”¥ Key Insight

Check symmetry **pairwise** using recursion:

* Compare two nodes at a time
* Traverse in opposite directions


## ğŸ’» Code

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr)
            return true;   // âœ… empty tree is symmetric

        return isMirror(root->left, root->right);
    }

private:
    bool isMirror(TreeNode* a, TreeNode* b) {
        if (!a || !b)
            return a == b;

        return (a->val == b->val &&
                isMirror(a->left, b->right) &&
                isMirror(a->right, b->left));
    }
};
```


## ğŸ§  Algorithm (Mirror DFS)

### ğŸ’¡ Steps

```
isMirror(a, b):
    if both null â†’ true
    if one null â†’ false
    if values differ â†’ false

    return isMirror(a.left, b.right)
       AND isMirror(a.right, b.left)
```

Final result:

```
isMirror(root.left, root.right)
```



## ğŸ”‘ Why this works

* Tree symmetry is **structural**
* Values and shape both matter
* Postorder-style recursion ensures correctness



# â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree           | Output |
| -- | - |
| Empty tree     | true   |
| Single node    | true   |
| Perfect mirror | true   |
| Shape mismatch | false  |
| Value mismatch | false  |



## ğŸ§  Key Observations

* Symmetry is checked **pairwise**
* Order of recursion matters
* `a.left â†” b.right` is crucial
* DFS beats serialization approaches



# ğŸš€ Alternative Approach (Iterative using Queue)

Sometimes interviewers ask:

> â€œCan you do it without recursion?â€



### ğŸ’¡ BFS / Queue Approach

Push nodes in pairs and compare.

```cpp
bool isSymmetric(TreeNode* root) {
    if (!root) return true;

    queue<TreeNode*> q;
    q.push(root->left);
    q.push(root->right);

    while (!q.empty()) {
        TreeNode* a = q.front(); q.pop();
        TreeNode* b = q.front(); q.pop();

        if (!a && !b) continue;
        if (!a || !b || a->val != b->val) return false;

        q.push(a->left);
        q.push(b->right);
        q.push(a->right);
        q.push(b->left);
    }
    return true;
}
```


# â“ FAQs

### Q1: Is an empty tree symmetric?

Yes âœ”ï¸
Thereâ€™s nothing to break symmetry.



### Q2: Is this preorder, inorder, or postorder?

Itâ€™s **mirror DFS**, closest to postorder reasoning.



### Q3: Can this be solved using inorder traversal?

No âŒ
Inorder loses structural information.



### Q4: Does symmetry mean identical subtrees?

No âŒ
It means **mirror images**, not identical copies.



### Q5: Which approach is better in interviews?

* Recursive â†’ simpler
* Iterative â†’ bonus points



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Symmetric = mirror image
Compare left â†” right
Empty tree â†’ true
DFS or BFS both work
```
