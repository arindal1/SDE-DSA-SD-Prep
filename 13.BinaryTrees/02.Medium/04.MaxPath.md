
# ğŸŒ³ Maximum Path Sum in a Binary Tree [#124](https://leetcode.com/problems/binary-tree-maximum-path-sum/description/)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return the **maximum path sum**.

ğŸ‘‰ A **path** is defined as:

* Any sequence of nodes connected by edges
* The path **does not need to pass through the root**
* The path **must contain at least one node**
* The path **cannot revisit nodes**



## ğŸ§  Why this problem matters

This problem is a **tree DP classic** and a common interview favorite because it tests:

* Postorder DFS
* Handling **negative values**
* Global vs local answers
* Knowing **when to discard paths**

If diameter was â€œtree DP liteâ€, this is the **boss fight** ğŸ’€â¡ï¸ğŸ‘‘



## ğŸ‘€ Examples

### Example 1

```
        1
       / \
      2   3
```

Maximum Path Sum:

```
2 â†’ 1 â†’ 3 = 6
```



### Example 2 (negative values)

```
       -10
       /  \
      9   20
         /  \
        15   7
```

Maximum Path Sum:

```
15 â†’ 20 â†’ 7 = 42
```



### Example 3 (single negative node)

```
    -3
```

Maximum Path Sum = **-3**
(not 0 âŒ)



## ğŸ§© Intuition (THIS is the key)

At every node, there are **two different questions**:

### 1ï¸âƒ£ What is the **best path that passes THROUGH this node**?

This path can include:

* node
* left child
* right child

```
node->val + leftContribution + rightContribution
```

This is used to update the **global answer**.



### 2ï¸âƒ£ What is the **best path I can extend to my parent**?

A parent can only take **one side**.

```
node->val + max(leftContribution, rightContribution)
```

This is what we **return upward**.

ğŸ‘‰ Separating these two ideas is the entire trick ğŸ§ âœ¨



## ğŸŒ Brute Force Approach (What NOT to do)

### âŒ Naive Idea

* Enumerate all paths
* Calculate sum of each path
* Take maximum

âŒ Exponential <br>
âŒ Impossible to implement cleanly <br>
âŒ Interview killer ğŸ˜¬ <br>



# âœ… Optimal Approach (Tree DP using Postorder DFS)

### ğŸ”¥ Key Insights

* Use **postorder traversal**
* Ignore negative paths (`max(0, â€¦)`)
* Maintain a **global maximum**



## âœ… CPP Code

### ğŸ’» Code

```cpp
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        int maxi = INT_MIN;
        path(root, maxi);
        return maxi;
    }

    int path(TreeNode* root, int &maxi) {
        if (root == nullptr)
            return 0;

        int leftS = max(0, path(root->left, maxi));
        int rightS = max(0, path(root->right, maxi));

        maxi = max(maxi, root->val + leftS + rightS);

        return root->val + max(leftS, rightS);
    }
};
```


## ğŸ§  Algorithm (Postorder Tree DP)

### ğŸ’¡ Step-by-step

```
dfs(node):
    if node is null:
        return 0

    left = max(0, dfs(left child))
    right = max(0, dfs(right child))

    maxPath = max(maxPath, node.val + left + right)

    return node.val + max(left, right)
```

Final Answer = `maxPath`



## ğŸ”‘ Why `max(0, â€¦)`?

Because:

* Negative paths **reduce** sum
* Youâ€™re allowed to **start a new path** at any node
* Ignoring negative contributions improves result



## ğŸ”‘ Why only one side returned?

Because a path going upward:

* Cannot split into two directions
* Must stay linear

But the global path **can split** at a node.



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of the tree

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree          | Output             |
| - | - |
| Single node   | node value         |
| All negative  | max single node    |
| Balanced tree | internal path      |
| Skewed tree   | max root-to-leaf   |
| Mixed values  | best internal path |



## ğŸ§  Key Observations

* Path may start & end anywhere
* Path must include at least one node
* Global answer â‰  returned value
* Negative values are tricky but handled cleanly



# ğŸš€ Common Variations & Follow-ups

### 1ï¸âƒ£ Maximum Path Sum (Leaf to Leaf)

Stricter version

### 2ï¸âƒ£ Diameter of Binary Tree

Same structure, different metric

### 3ï¸âƒ£ Maximum Sum BST in Binary Tree

Tree DP + BST validation

### 4ï¸âƒ£ Maximum Path Sum in DAG

Graph DP extension




# â“ FAQs

### Q1: Why initialize `maxi` to `INT_MIN`?

Because all values can be negative.
Initializing to `0` would give wrong answers âŒ



### Q2: Is this preorder or postorder?

**Postorder**
Children must be processed first.



### Q3: Can this path include the root?

Yes âœ”ï¸
But it doesnâ€™t have to.



### Q4: Is this a Tree DP problem?

Absolutely âœ”ï¸
One of the **best examples**.



### Q5: Is this harder than diameter?

Yes ğŸ˜„
Diameter is a special case of this idea.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Max Path Sum â‰  Root to Leaf
Ignore negative paths
Global max updates at each node
Return only one side upward
Use postorder DFS
```
