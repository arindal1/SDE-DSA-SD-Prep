# ğŸŒ³ Zigzag Level Order Traversal (Binary Tree) [#103](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return its **zigzag level order traversal**.

ğŸ‘‰ Zigzag order means:

* Level 0 â†’ **left to right**
* Level 1 â†’ **right to left**
* Level 2 â†’ **left to right**
* â€¦and so on

Each level should be returned as a **separate list**.



## ğŸ§  Why this problem matters

This problem is a **BFS variant**, but with:

* Direction control
* Index manipulation
* Clean space optimization

Itâ€™s commonly used to test:

* Queue-based BFS understanding
* Index math
* Avoiding unnecessary reversals

Think of it as:

> Level Order Traversalâ€¦ but someone keeps flipping the page direction ğŸ“–ğŸ”„



## ğŸ‘€ Example

### Input Tree

```
        1
       / \
      2   3
     / \   \
    4   5   6
```

### Zigzag Output

```
[
  [1],
  [3, 2],
  [4, 5, 6]
]
```



## ğŸ§© Intuition (the key idea)

We still do **normal BFS**:

* Process level by level
* Use a queue

The only difference is:

* For each level, decide **where to place the nodeâ€™s value**
* Use a boolean flag `leftToRight`

Instead of reversing arrays later âŒ
we **place values directly at the correct index** âœ”ï¸

This keeps the solution **clean and efficient** ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Naive Idea

1. Do normal level order traversal
2. Reverse every alternate level

Works, but:

* Extra O(N) work
* Less elegant
* More code

Interviewers prefer **index placement** ğŸ”¥



# âœ… Optimal Approach (BFS with Index Mapping)

### ğŸ”¥ Key Insight

For each level of size `n`:

* If `leftToRight` â†’ place at index `i`
* Else â†’ place at index `n - 1 - i`



### ğŸ’» Code

```cpp
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (root == nullptr)
            return result;

        queue<TreeNode*> q;
        q.push(root);

        bool leftToRight = true;
        while (!q.empty()) {
            int size = q.size();
            vector<int> level(size);

            for (int i = 0; i < size; ++i) {
                TreeNode* node = q.front();
                q.pop();

                int index = (leftToRight) ? i : size - 1 - i;
                level[index] = node->val;

                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
            leftToRight = !leftToRight;
            result.push_back(level);
        }
        return result;
    }
};
```


## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
If root is null â†’ return empty result

Push root into queue
Set leftToRight = true

While queue not empty:
    size = queue size
    create level array of size "size"

    For each node in this level:
        pop node from queue
        if leftToRight:
            level[i] = node.val
        else:
            level[size - 1 - i] = node.val

        push left and right children into queue

    flip leftToRight
    add level to result
```



## ğŸ”‘ Why this works

* Queue guarantees **level order**
* Index mapping guarantees **zigzag**
* No extra passes or reversals needed

Elegant and efficient ğŸ˜Œ



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(N)** |

Where:

* `N` = number of nodes

Queue and output both require space.



## ğŸ§ª Test Cases

| Tree          | Output             |
| - | - |
| Empty tree    | []                 |
| Single node   | [[1]]              |
| Two levels    | [[1], [2]]         |
| Balanced tree | Zigzag order       |
| Skewed tree   | Same as normal BFS |



## ğŸ§  Key Observations

* Zigzag is still **BFS**
* Direction changes **per level**
* Index math avoids reverse
* Very reusable pattern



# ğŸš€ Alternative Approaches (Good to Know)

### 1ï¸âƒ£ BFS + Reverse

* Reverse level array on odd levels
* Easier to think, slightly less efficient

### 2ï¸âƒ£ Two Stacks

* One stack for Lâ†’R
* One stack for Râ†’L
* More complex, less clean





# â“ FAQs

### Q1: Is this BFS or DFS?

**BFS**
Zigzag is a variation of level order traversal.



### Q2: Why not just reverse the vector?

You can, but:

* Extra pass
* Less elegant
* Index mapping is cleaner



### Q3: Is zigzag traversal stable?

Yes âœ”ï¸
Relative order within a level is preserved.



### Q4: Can this be done recursively?

Yes, but:

* Requires height calculation
* More complex
* BFS is preferred



### Q5: Where is this used?

* Tree visualizations
* Spiral traversal problems
* UI rendering trees level-by-level



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Zigzag = BFS + direction flag
Left â†’ Right on even levels
Right â†’ Left on odd levels
Use index mapping, not reverse
```



## ğŸ¬ Pop culture wrap-up

Zigzag traversal is like watching a tennis match ğŸ¾:

* Eyes go left â†’ right
* Then right â†’ left
* Repeat until the gameâ€™s over

Miss the direction switch, and youâ€™re watching the wrong rally ğŸ˜„



If you want next:

* ğŸ”¥ **Vertical Order Traversal**
* ğŸ§© Top / Bottom / Left / Right View of Tree
* ğŸ§ª BFS pattern problems
* ğŸ“„ Merge all BFS-based tree notes into one README

Just say the word ğŸš€
