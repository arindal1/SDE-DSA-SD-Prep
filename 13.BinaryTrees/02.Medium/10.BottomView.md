

# ğŸŒ³ Bottom View of a Binary Tree #[GFG](https://www.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return the **bottom view** of the tree.

ğŸ‘‰ The **bottom view** consists of the nodes visible when the tree is viewed from **below**.

* Nodes are reported **from left to right**
* For each vertical column, only the **bottommost node** is visible



## ğŸ§  Why this problem matters

This problem tests:

* BFS traversal
* Horizontal Distance (HD) concept
* Understanding of **overwriting vs preserving values**
* Clear distinction between **top view and bottom view**

Think of it as:

> â€œIf you look at the tree from underground ğŸŒ³â¬‡ï¸, which nodes block everything else?â€



## ğŸ‘€ Visual Example

### Tree

```
            20
          /    \
         8      22
        / \       \
       5   3       25
          / \
         10  14
```

### Bottom View Output

```
[5, 10, 3, 14, 25]
```

Why?

* For each horizontal distance, the **deepest node wins**



## ğŸ§© Core Intuition (VERY IMPORTANT)

We assign a **horizontal distance (HD)**:

* Root â†’ `HD = 0`
* Left child â†’ `HD - 1`
* Right child â†’ `HD + 1`

While doing **level order traversal (BFS)**:

* Every time we encounter a node at the same HD, we **overwrite** the value
* The last value written for each HD is the **bottommost node**

ğŸ‘‰ Difference from top view:

* **Top view** â†’ first node per HD
* **Bottom view** â†’ last node per HD



# ğŸŒ Brute Force Approach (What NOT to do)

### âŒ Naive Idea

* For each vertical column:

  * Traverse the tree
  * Pick the node with maximum depth

âŒ O(NÂ²)
âŒ Hard to manage depth comparisons
âŒ Interviewers wonâ€™t like it



# âœ… Optimal Approach (BFS + Map)

### ğŸ”¥ Key Insight

* BFS guarantees increasing depth order
* Overwriting map values ensures bottommost node remains




### ğŸ’» Code

```cpp
vector<int> bottomview(Node* root) {
    vector<int> res;
    if (!root)
        return res;

    map<int, int> mpp;
    queue<pair<Node*, int>> q;
    q.push({root, 0});

    while (!q.empty()) {
        auto p = q.front();
        q.pop();
        Node* n = p.first;
        int line = p.second;

        // Overwrite value at this horizontal distance
        mpp[line] = n->data;

        if (n->left)
            q.push({n->left, line - 1});
        if (n->right)
            q.push({n->right, line + 1});
    }

    for (auto it : mpp) {
        res.push_back(it.second);
    }

    return res;
}
```



## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
If root is null â†’ return empty list

Create map<HD, value>
Create queue of (node, HD)
Push root with HD = 0

While queue not empty:
    pop (node, HD)
    map[HD] = node value   // overwrite

    push left child with HD - 1
    push right child with HD + 1

Extract map values in sorted HD order
```



## ğŸ”‘ Why BFS works best

* BFS processes nodes level by level
* Deeper nodes appear later in traversal
* Overwriting ensures the deepest node remains

DFS could work, but:

* Requires tracking depth
* More bookkeeping
* BFS is cleaner



## â± Complexity Analysis

| Metric           | Value          |
| - | -- |
| Time Complexity  | **O(N log N)** |
| Space Complexity | **O(N)**       |

Why `log N`?

* Map insertions and ordered iteration



## ğŸ§ª Test Cases

| Tree Type     | Output                |
| - | - |
| Empty tree    | []                    |
| Single node   | [node]                |
| Balanced tree | Bottommost per column |
| Left skewed   | All nodes             |
| Right skewed  | All nodes             |



## ğŸ§  Key Observations

* Bottom view always overwrites values
* BFS naturally handles depth ordering
* Map ordering defines output order
* Bottom view â‰  vertical traversal



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Top View of Binary Tree

First node per HD

### 2ï¸âƒ£ Vertical Order Traversal

All nodes per HD with sorting

### 3ï¸âƒ£ Left / Right Side View

Per-level visibility instead of per-HD




# â“ FAQs

### Q1: Why overwrite map values?

Because the **last node seen** at a horizontal distance is the **bottommost**.



### Q2: Can DFS be used?

Yes, but you must:

* Track depth
* Compare and update manually

BFS is simpler.



### Q3: Is bottom view always unique?

Yes âœ”ï¸
For a given tree, bottom view is deterministic.



### Q4: How is this different from top view?

* Top view â†’ first node per HD
* Bottom view â†’ last node per HD



### Q5: Can unordered_map be used?

Only if you later sort keys âŒ
Ordered map is cleaner.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Bottom View = last node per horizontal distance
Use BFS
Overwrite map entries
Ordered map â†’ left to right output
```

