

# ğŸŒ³ Invert Binary Tree (Mirror Tree) [#226](https://leetcode.com/problems/invert-binary-tree/description/)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, **invert** the tree and return its root.

ğŸ‘‰ **Invert** means:

* Swap the **left and right children** of every node in the tree.



## ğŸ§  Why this problem matters

This problem is famous for a reason (yes, this is *that* Google interview question ğŸ‘€).

It tests:

* Understanding of **tree recursion**
* Comfort with **structural transformations**
* Ability to reason **bottom-up**

Itâ€™s less about difficulty and more about **clarity of thought**.



## ğŸ‘€ Example

### Original Tree

```
        4
       / \
      2   7
     / \ / \
    1  3 6  9
```

### Inverted Tree

```
        4
       / \
      7   2
     / \ / \
    9  6 3  1
```

Left and right are swapped at **every level** ğŸ”„



## ğŸ§© Intuition (the â€œobvious but importantâ€ idea)

At **every node**, do one simple thing:

> Swap its left child with its right child.

Then do the **same thing recursively** for both subtrees.

Trees are recursive structures â€” so this problem is *perfectly recursive* ğŸŒ±



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Overthinking It

Some people try to:

* Create a new tree
* Copy nodes
* Rebuild structure

âŒ Unnecessary
âŒ Extra space
âŒ Not asked in the problem



# âœ… Optimal Approach (Recursive DFS)

### ğŸ”¥ Key Insight

* Inversion at a node is **independent**
* Children can be inverted **after swapping**
* One DFS is enough




### ğŸ’» Code

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root)
            return nullptr;
        
        ::swap(root->left, root->right);

        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```



## ğŸ”§ Minor Cleanup (Optional)

You donâ€™t need the global `::` scope operator here.

### Cleaner Version

```cpp
swap(root->left, root->right);
```

Thatâ€™s it. No logic change.



## ğŸ§  Algorithm (Recursive DFS)

### ğŸ’¡ Steps

```
invert(node):
    if node is null:
        return null

    swap(node.left, node.right)

    invert(node.left)
    invert(node.right)

    return node
```



## ğŸ”‘ Why this works

* Each node is handled independently
* Recursion ensures all nodes are visited
* Swap operation propagates throughout the tree



# â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree          | Result         |
| - | -- |
| Empty tree    | Empty          |
| Single node   | Same           |
| Balanced tree | Fully inverted |
| Left skewed   | Right skewed   |
| Right skewed  | Left skewed    |



## ğŸ§  Key Observations

* Inversion is **structural**
* Values donâ€™t matter
* Tree shape is completely mirrored
* DFS is natural here



# ğŸš€ Alternative Approaches

### 1ï¸âƒ£ Iterative (BFS using Queue)

Good when recursion depth is a concern.

```cpp
TreeNode* invertTree(TreeNode* root) {
    if (!root) return nullptr;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();

        swap(node->left, node->right);

        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
    return root;
}
```



### 2ï¸âƒ£ Iterative (DFS using Stack)

Same idea, stack instead of recursion.




# â“ FAQs

### Q1: Is this preorder, inorder, or postorder?

Traversal order doesnâ€™t matter here.
Swap happens **once per node**.



### Q2: Is an empty tree invertible?

Yes âœ”ï¸
Empty tree inverted is still empty.



### Q3: Is invert same as symmetric?

No âŒ

* **Invert** modifies the tree
* **Symmetric** checks mirror equality



### Q4: Does this destroy original tree?

Yes âœ”ï¸
Inversion modifies the tree **in-place**.



### Q5: Is recursion safe?

Usually yes, but for deep trees BFS is safer.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Invert = swap left & right
Do it at every node
DFS or BFS both work
Time = O(N)
```

