

# ğŸŒ³ Minimum Depth of a Binary Tree [#111](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, return its **minimum depth**.

ğŸ‘‰ **Minimum Depth** is defined as:

> The number of nodes along the **shortest path from the root to the nearest leaf node**.

âš ï¸ **Important**:
A leaf is a node with **no left and no right child**.



## ğŸ§  Why this problem matters

This problem looks similar to **maximum depth**, but the logic is **not symmetric**.

It teaches:

* Careful **edge-case handling**
* Difference between **null path vs leaf path**
* Correct bottom-up recursion

Many candidates fail this in interviews because they treat it like max depth ğŸ˜¬



## ğŸ‘€ Examples

### Example 1

```
        1
       / \
      2   3
```

Minimum Depth = **2**
(path: `1 â†’ 3`)



### Example 2 (classic trap)

```
        1
       /
      2
```

Minimum Depth = **2**
âŒ NOT 1
Because the root is **not a leaf**



### Example 3

```
        1
         \
          2
           \
            3
```

Minimum Depth = **3**



## ğŸ§© Intuition (this is the key)

At every node, ask:

* Whatâ€™s the minimum depth of my **left subtree**?
* Whatâ€™s the minimum depth of my **right subtree**?

BUTâ€¦

âš ï¸ If one child is **missing**, you **cannot take min(0, depth)**
because that path **does not reach a leaf**.

ğŸ‘‰ You must take the **non-zero path**.

This single insight is the heart of the problem ğŸ§ âœ¨



# ğŸŒ Brute Force / Incorrect Approach (What many people do wrong)

### âŒ Wrong Logic

```cpp
return 1 + min(minDepth(root->left), minDepth(root->right));
```

### âŒ Why this fails

If one child is `nullptr`, its depth = 0
`min(0, depth)` incorrectly chooses a **non-existent path**

This returns **wrong answers** for skewed trees ğŸš¨



# âœ… Optimal Recursive Approach

### ğŸ”¥ Key Insight

* If **both children exist** â†’ take the minimum
* If **only one child exists** â†’ take the non-zero one



## âœ… Given Code

### ğŸ’» Code

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr)
            return 0;
        
        return minD(root);
    }

private:
    int minD(TreeNode* root) {
        if (root == nullptr)
            return 0;
        
        int leftS = minD(root->left);
        int rightS = minD(root->right);

        if (leftS && rightS)
            return min(leftS, rightS) + 1;

        return max(leftS, rightS) + 1;
    }
};
```

## ğŸ§  Algorithm (Recursive DFS â€“ Bottom-Up)

### ğŸ’¡ Steps

```
minDepth(node):
    if node is null:
        return 0

    left = minDepth(node.left)
    right = minDepth(node.right)

    if left != 0 AND right != 0:
        return 1 + min(left, right)

    else:
        return 1 + max(left, right)
```



## ğŸ”‘ Why this works

* Only **valid root-to-leaf paths** are considered
* Null children are ignored correctly
* Depth builds upward from leaf nodes



## ğŸ”„ Alternative Approach (BFS â€“ Often Preferred)

ğŸ’¡ **Shortest path problems = BFS**



### ğŸ§  BFS Intuition

* Traverse level by level
* The **first leaf node encountered** gives minimum depth
* Stop early ğŸš€



### ğŸ’» BFS Code (C++)

```cpp
int minDepth(TreeNode* root) {
    if (!root) return 0;

    queue<TreeNode*> q;
    q.push(root);
    int depth = 1;

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front();
            q.pop();

            if (!node->left && !node->right)
                return depth;

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        depth++;
    }
    return depth;
}
```



## â± Complexity Analysis

### Recursive

| Metric | Value    |
| - | -- |
| Time   | **O(N)** |
| Space  | **O(H)** |

### BFS

| Metric | Value    |
| - | -- |
| Time   | **O(N)** |
| Space  | **O(N)** |



## ğŸ§ª Test Cases

| Tree          | Output             |
| - | - |
| Empty tree    | 0                  |
| Single node   | 1                  |
| Left skewed   | N                  |
| Right skewed  | N                  |
| Balanced tree | shortest rootâ†’leaf |



## ğŸ§  Key Observations

* Minimum depth â‰  maximum depth
* Leaf definition is critical
* BFS is naturally suited
* Recursive solution needs careful logic



# ğŸš€ Common Variations & Follow-ups

* Maximum Depth of Binary Tree
* Balanced Binary Tree
* Diameter of Binary Tree
* Minimum Depth using BFS only



# â“ FAQs

### Q1: Why not just use `min()` directly?

Because `nullptr` paths are **not valid leaf paths**.



### Q2: Which approach is better in interviews?

* BFS â†’ conceptually clean
* DFS â†’ elegant if done correctly
  Explain both â†’ â­



### Q3: Is an empty tree depth 0 or 1?

By convention â†’ **0**



### Q4: Can recursion cause stack overflow?

Yes, for skewed trees.
BFS avoids this.



### Q5: Is this problem harder than max depth?

Yes ğŸ˜„
Because **logic is asymmetric**



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Min Depth = shortest root â†’ leaf path
Ignore null children
If one child missing â†’ take the other
BFS stops at first leaf
```

