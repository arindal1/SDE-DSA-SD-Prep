# ğŸŒ³ Balanced Binary Tree (Height-Balanced Check) [#110](https://leetcode.com/problems/balanced-binary-tree/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, determine whether it is **height-balanced**.

ğŸ‘‰ A binary tree is **balanced** if:

> For **every node**,
> `|height(left subtree) - height(right subtree)| â‰¤ 1`



## ğŸ§  Why this problem matters

This is **not just a boolean check**.

It teaches you:

* **Postorder DFS**
* **Early termination**
* **Tree Dynamic Programming**
* How to **avoid O(NÂ²)** solutions

Many hard tree problems (diameter, max path sum, etc.) use this exact pattern ğŸ”¥



## ğŸ‘€ Example

### Balanced Tree âœ…

```
        1
       / \
      2   3
     /
    4
```

Height difference â‰¤ 1 at all nodes âœ”ï¸



### Unbalanced Tree âŒ

```
        1
       /
      2
     /
    3
```

Height difference = 2 âŒ



## ğŸ§© Intuition (the key idea)

At each node, ask:

1. Is my **left subtree balanced**?
2. Is my **right subtree balanced**?
3. Is my **height difference â‰¤ 1**?

If **any answer is â€œnoâ€**, the whole tree is unbalanced.

Instead of:

* calculating heights again and again
  we **combine height + balance check in one DFS**.

Thatâ€™s the trick ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (What NOT to do)

### âŒ Naive Idea

For each node:

* Compute height of left subtree
* Compute height of right subtree
* Check balance
* Recursively do this for children

### âŒ Code Shape (Conceptual)

```cpp
bool isBalanced(root) {
    if (!root) return true;
    if (abs(height(root->left) - height(root->right)) > 1)
        return false;
    return isBalanced(root->left) && isBalanced(root->right);
}
```

### âŒ Complexity

* Height = O(N)
* Called for every node â†’ **O(NÂ²)**

Interviewers **do not like this** ğŸ˜¬



# âœ… Optimal Approach ğŸŒŸ

### ğŸ”¥ Key Insight

Return:

* **height** if subtree is balanced
* **-1** if subtree is unbalanced

This lets us **fail fast** ğŸš¨



### ğŸ’» Code

```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return dfs(root) != -1;
    }

    int dfs(TreeNode* root) {
        if (root == nullptr)
            return 0;

        int leftS = dfs(root->left);
        if (leftS == -1)
            return -1;

        int rightS = dfs(root->right);
        if (rightS == -1)
            return -1;

        if (abs(leftS - rightS) > 1)
            return -1;

        return max(leftS, rightS) + 1;
    }
};
```





## ğŸ§  Algorithm (Postorder DFS â€“ Optimal)

### ğŸ’¡ Steps

```
DFS(node):
    If node is NULL:
        return 0

    leftHeight = DFS(left child)
    If leftHeight == -1:
        return -1

    rightHeight = DFS(right child)
    If rightHeight == -1:
        return -1

    If |leftHeight - rightHeight| > 1:
        return -1

    return 1 + max(leftHeight, rightHeight)
```

Final answer:

```
Tree is balanced if DFS(root) != -1
```



## ğŸ”‘ Why Postorder?

Because:

* Children must be processed **before** parent
* Height depends on children
* Balance depends on children

Postorder = **bottom-up reasoning** ğŸ§ 



# â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree          | Output |
| - | - |
| Empty tree    | true   |
| Single node   | true   |
| Balanced tree | true   |
| Skewed tree   | false  |
| Complete tree | true   |



## ğŸ§  Key Observations

* Height-balanced â‰  complete
* Balance must hold at **every node**
* Returning `-1` is a **sentinel trick**
* One DFS beats multiple height calls



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Diameter of Binary Tree

(same postorder idea)

### 2ï¸âƒ£ Maximum Depth

(height calculation only)

### 3ï¸âƒ£ AVL Trees

(self-balancing BSTs)

### 4ï¸âƒ£ Check Complete Binary Tree

(BFS-based)



## âš ï¸ Common Mistakes (Interview Traps)

âŒ Calculating height separately <br>
âŒ Ignoring early termination <br>
âŒ Checking balance only at root <br>
âŒ Confusing â€œbalancedâ€ with â€œcompleteâ€ <br>



# â“ FAQs

### Q1: Why return `-1`?

It acts as a **flag**:

* `-1` â†’ unbalanced subtree
* â‰¥0 â†’ valid height

This avoids extra checks.



### Q2: Can height be returned some other way?

Yes:

* Pair `{isBalanced, height}`
* Struct
* But sentinel `-1` is cleanest



### Q3: Is this DFS or BFS?

**DFS (postorder)**



### Q4: Will recursion cause stack overflow?

Possible for skewed trees.
Iterative solutions exist but are complex.



### Q5: Is a complete tree always balanced?

Yes âœ”ï¸
Is a balanced tree always complete?
No âŒ



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Balanced = |leftHeight - rightHeight| â‰¤ 1
Use postorder DFS
Return -1 if unbalanced
Time = O(N)
```
