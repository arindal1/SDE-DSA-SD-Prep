
# ğŸŒ³ Top View of a Binary Tree #[GFG](https://www.geeksforgeeks.org/problems/top-view-of-binary-tree/1)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return the **top view** of the tree.

ğŸ‘‰ The **top view** contains the nodes that are visible when the tree is viewed from **above**.

* Nodes are reported **from left to right**
* For each vertical column, only the **topmost node** is visible



## ğŸ§  Why this problem matters

This problem tests:

* BFS traversal
* **Horizontal Distance (HD)** concept
* Correct use of maps
* Choosing **first-seen nodes**

Itâ€™s closely related to:

* Bottom View
* Vertical Order Traversal
* Boundary Traversal

Think of it as:

> â€œIf you fly a drone over the tree ğŸŒ³ğŸš, which nodes do you see first?â€



## ğŸ‘€ Visual Example

### Tree

```
            1
          /   \
         2     3
          \     \
           4     5
```

### Horizontal Distances

```
HD -1 : 2
HD  0 : 1
HD +1 : 3
HD +2 : 5
```

### Top View Output

```
[2, 1, 3, 5]
```



## ğŸ§© Core Intuition (VERY IMPORTANT)

Assign a **horizontal distance (HD)** to each node:

* Root â†’ `HD = 0`
* Left child â†’ `HD - 1`
* Right child â†’ `HD + 1`

While doing **level order traversal (BFS)**:

* The **first node encountered** at each HD is part of the top view
* Ignore all later nodes with the same HD

ğŸ‘‰ BFS is crucial because it processes **top levels first**.



# ğŸŒ Brute Force Approach (What NOT to do)

### âŒ Naive Idea

* For each vertical column:

  * Scan the entire tree
  * Pick the node with minimum depth

âŒ O(NÂ²)
âŒ Hard to implement
âŒ Unnecessary



# âœ… Optimal Approach (BFS + Map)

### ğŸ”¥ Key Insight

* Use BFS to guarantee topmost nodes are visited first
* Use a map to store the **first value per horizontal distance**



## ğŸ§‘ğŸ¼â€ğŸ’» Code

```cpp
vector<int> topView(Node* root) {
    vector<int> res;
    if (!root)
        return res;

    map<int, int> mpp; // HD -> node value
    queue<pair<Node*, int>> q;
    q.push({root, 0});

    while (!q.empty()) {
        auto p = q.front();
        q.pop();

        Node* n = p.first;
        int line = p.second;

        // Take the first node encountered at this HD
        if (mpp.find(line) == mpp.end())
            mpp[line] = n->data;

        if (n->left)
            q.push({n->left, line - 1});
        if (n->right)
            q.push({n->right, line + 1});
    }

    for (auto it : mpp)
        res.push_back(it.second);

    return res;
}
```


## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
If root is null â†’ return empty list

Create map<HD, value>
Create queue of (node, HD)
Push root with HD = 0

While queue not empty:
    pop (node, HD)

    if HD not in map:
        map[HD] = node value

    push left child with HD - 1
    push right child with HD + 1

Extract map values from leftmost HD to rightmost
```



## ğŸ”‘ Why BFS is mandatory here

If you use DFS:

* You might reach a **deeper node first**
* That breaks the â€œtopmostâ€ guarantee

BFS ensures:

> First visit = topmost node âœ”ï¸



## â± Complexity Analysis

| Metric           | Value          |
| - | -- |
| Time Complexity  | **O(N log N)** |
| Space Complexity | **O(N)**       |

Why `log N`?

* Map insertions & ordered traversal



## ğŸ§ª Test Cases

| Tree Type     | Output             |
| - | - |
| Empty tree    | []                 |
| Single node   | [node]             |
| Balanced tree | Topmost per column |
| Left skewed   | All nodes          |
| Right skewed  | All nodes          |



## ğŸ§  Key Observations

* Only **first node per HD** matters
* BFS > DFS here
* Map keeps left-to-right ordering
* Top view â‰  vertical traversal



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Bottom View of Binary Tree

Take the **last node per HD**

### 2ï¸âƒ£ Vertical Order Traversal

Store **all nodes per HD**

### 3ï¸âƒ£ Left / Right View

Per level logic instead of HD



# â“ FAQs

### Q1: Why not overwrite map entries?

Because we want the **topmost node**, which appears first.



### Q2: Can unordered_map be used?

Not directly âŒ
Youâ€™d lose left-to-right ordering.



### Q3: Is this different from vertical order?

Yes âœ”ï¸
Vertical order stores **all nodes**, top view stores **one per column**.



### Q4: Does insertion order matter?

No â€” BFS + map ensures correctness.



### Q5: Is top view always unique?

Yes, for a given tree âœ”ï¸



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Top View = first node per horizontal distance
Use BFS
Map<HD, value>
Do not overwrite map entries
```

