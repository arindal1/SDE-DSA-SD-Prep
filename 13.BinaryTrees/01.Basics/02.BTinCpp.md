# üå≥ Binary Search Tree (BST) ‚Äî Complete C++ Guide

> *‚ÄúA BST is what happens when a Binary Tree grows up and starts following rules.‚Äù*



## üìå Problem Statement

A **Binary Search Tree (BST)** is a special type of Binary Tree where:

* Left subtree contains **only values smaller** than the node
* Right subtree contains **only values greater** than the node
* Both left and right subtrees are **also BSTs**

Formally, for every node `X`:

```
max(left subtree of X) < X < min(right subtree of X)
```



## üß† Intuition (Why BSTs matter)

BSTs allow us to:

* **Search efficiently** (like binary search, but on a tree)
* Maintain **sorted data dynamically**
* Perform operations like insert, delete, search in
  ‚è±Ô∏è **O(log N)** time (if balanced)

‚ö†Ô∏è Worst case?
If the BST becomes skewed (like a linked list), operations degrade to **O(N)**.
(Yes, trees can have bad days too.)



## üÜö BST vs Binary Tree

| Feature           | Binary Tree       | BST                   |
| -- | -- | -- |
| Ordering          | ‚ùå None            | ‚úÖ Ordered             |
| Inorder Traversal | Any order         | **Sorted order** üî•   |
| Search            | O(N)              | O(log N) avg          |
| Use cases         | General hierarchy | Search, range queries |



## üîß Core Operations in a BST

We‚Äôll cover:

1. Insert
2. Search
3. Delete (the boss fight üß†‚öîÔ∏è)
4. Traversals
5. Validate BST
6. Min / Max
7. LCA in BST
8. Floor & Ceil
9. Inorder Successor
10. Build BST from sorted array



## üß© BST Node Definition (C++)

```cpp
struct Node {
    int val;
    Node* left;
    Node* right;

    Node(int x) : val(x), left(nullptr), right(nullptr) {}
};
```



## ‚ûï Insertion in BST

### üéØ Intuition

* If value < node ‚Üí go left
* If value > node ‚Üí go right
* Insert at the first valid null position

### üêå Brute Force

Traverse all nodes ‚Üí unnecessary comparisons
‚è±Ô∏è O(N)

### ‚ö° Optimal (Recursive)

```cpp
Node* insertBST(Node* root, int key) {
    if (!root) return new Node(key);

    if (key < root->val)
        root->left = insertBST(root->left, key);
    else if (key > root->val)
        root->right = insertBST(root->right, key);

    return root;
}
```

### ‚è±Ô∏è Complexity

* Time: O(log N) avg, O(N) worst
* Space: O(H)



## üîç Search in BST

### üß† Intuition

Same logic as binary search.

```cpp
bool searchBST(Node* root, int key) {
    if (!root) return false;
    if (root->val == key) return true;

    if (key < root->val)
        return searchBST(root->left, key);
    else
        return searchBST(root->right, key);
}
```



## üåê Traversals in BST

### üî• Key Property

**Inorder traversal of BST gives sorted order**

```cpp
void inorder(Node* root, vector<int>& res) {
    if (!root) return;
    inorder(root->left, res);
    res.push_back(root->val);
    inorder(root->right, res);
}
```



## ‚ùå Deletion in BST (Important!)

### üéØ 3 Cases

1. **Leaf node** ‚Üí delete directly
2. **One child** ‚Üí replace node with child
3. **Two children** ‚Üí

   * Find **inorder successor** (smallest in right subtree)
   * Replace value
   * Delete successor

### üß† Helper: Find Minimum

```cpp
Node* findMin(Node* root) {
    while (root && root->left)
        root = root->left;
    return root;
}
```

### üß® Delete Code

```cpp
Node* deleteBST(Node* root, int key) {
    if (!root) return nullptr;

    if (key < root->val) {
        root->left = deleteBST(root->left, key);
    } 
    else if (key > root->val) {
        root->right = deleteBST(root->right, key);
    } 
    else {
        // Case 1 & 2
        if (!root->left) {
            Node* temp = root->right;
            delete root;
            return temp;
        }
        if (!root->right) {
            Node* temp = root->left;
            delete root;
            return temp;
        }

        // Case 3
        Node* succ = findMin(root->right);
        root->val = succ->val;
        root->right = deleteBST(root->right, succ->val);
    }
    return root;
}
```

üß† *Interview tip*: Always explain deletion visually.



## ‚úÖ Validate BST

### ‚ùå Wrong approach

Just checking left < root < right is **not enough**.

### ‚úÖ Correct Approach (Range-based)

```cpp
bool isValidBST(Node* root, long long minVal, long long maxVal) {
    if (!root) return true;
    if (root->val <= minVal || root->val >= maxVal)
        return false;

    return isValidBST(root->left, minVal, root->val) &&
           isValidBST(root->right, root->val, maxVal);
}
```

Call using:

```cpp
isValidBST(root, LLONG_MIN, LLONG_MAX);
```



## üîΩ Minimum & Maximum in BST

```cpp
int minValue(Node* root) {
    while (root->left) root = root->left;
    return root->val;
}

int maxValue(Node* root) {
    while (root->right) root = root->right;
    return root->val;
}
```



## üëë Lowest Common Ancestor (BST)

### üß† BST Superpower

You don‚Äôt need full traversal!

```cpp
Node* lcaBST(Node* root, int a, int b) {
    if (!root) return nullptr;

    if (a < root->val && b < root->val)
        return lcaBST(root->left, a, b);
    if (a > root->val && b > root->val)
        return lcaBST(root->right, a, b);

    return root;
}
```

‚è±Ô∏è O(log N)



## üìê Floor & Ceil in BST

* **Floor**: largest value ‚â§ key
* **Ceil**: smallest value ‚â• key

```cpp
int floorBST(Node* root, int key) {
    int ans = -1;
    while (root) {
        if (root->val == key) return key;
        if (root->val > key)
            root = root->left;
        else {
            ans = root->val;
            root = root->right;
        }
    }
    return ans;
}
```



## üèóÔ∏è Build BST from Sorted Array (Balanced)

```cpp
Node* buildBST(vector<int>& arr, int l, int r) {
    if (l > r) return nullptr;
    int mid = (l + r) / 2;
    Node* root = new Node(arr[mid]);
    root->left = buildBST(arr, l, mid - 1);
    root->right = buildBST(arr, mid + 1, r);
    return root;
}
```

üî• Used in converting sorted array ‚Üí balanced BST.



## üß™ Test Cases

```cpp
Insert: 5 3 7 2 4 6 8
Inorder: 2 3 4 5 6 7 8

Delete 7 ‚Üí Inorder: 2 3 4 5 6 8
Search 6 ‚Üí true
Search 10 ‚Üí false
LCA(2,4) ‚Üí 3
```



## ‚è±Ô∏è Complexity Summary

| Operation | Avg      | Worst |
| -- | -- | -- |
| Insert    | O(log N) | O(N)  |
| Search    | O(log N) | O(N)  |
| Delete    | O(log N) | O(N)  |
| Traversal | O(N)     | O(N)  |



## Full C++ code (clean, tested) üß©

This is a single-file C++ example implementing many utilities: creation from vector (level order, using `-1` as null sentinel ‚Äî you can change sentinel), traversals (recursive + iterative), BFS, height, size, diameter (optimal), isBalanced, LCA, serialize/deserialize (level-order with `null` markers), invert, and a small test harness.

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
  Binary Tree utilities.
  - Uses int values for nodes. Use -1 as a sentinel for "null" when building from vector.
  - All functions are safe for empty trees (nullptr).
*/

// Node definition
struct Node {
    int val;
    Node *left;
    Node *right;
    Node(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Build tree from level-order vector with sentinel (-1) for nulls.
// Example: {1,2,3,4,5,-1,6} builds the tree used in the notes.
Node* buildFromLevelOrder(const vector<int>& a, int sentinel = -1) {
    if (a.empty()) return nullptr;
    if (a[0] == sentinel) return nullptr;
    Node* root = new Node(a[0]);
    queue<Node*> q;
    q.push(root);
    size_t i = 1;
    while (!q.empty() && i < a.size()) {
        Node* cur = q.front(); q.pop();
        if (i < a.size() && a[i] != sentinel) {
            cur->left = new Node(a[i]);
            q.push(cur->left);
        }
        ++i;
        if (i < a.size() && a[i] != sentinel) {
            cur->right = new Node(a[i]);
            q.push(cur->right);
        }
        ++i;
    }
    return root;
}

// Recursive traversals
void preorderRec(Node* root, vector<int>& out) {
    if (!root) return;
    out.push_back(root->val);
    preorderRec(root->left, out);
    preorderRec(root->right, out);
}
void inorderRec(Node* root, vector<int>& out) {
    if (!root) return;
    inorderRec(root->left, out);
    out.push_back(root->val);
    inorderRec(root->right, out);
}
void postorderRec(Node* root, vector<int>& out) {
    if (!root) return;
    postorderRec(root->left, out);
    postorderRec(root->right, out);
    out.push_back(root->val);
}

// Iterative inorder (using stack)
vector<int> inorderIter(Node* root) {
    vector<int> res;
    stack<Node*> st;
    Node* cur = root;
    while (cur || !st.empty()) {
        while (cur) {
            st.push(cur);
            cur = cur->left;
        }
        cur = st.top(); st.pop();
        res.push_back(cur->val);
        cur = cur->right;
    }
    return res;
}

// Level-order (BFS)
vector<int> levelOrder(Node* root) {
    vector<int> res;
    if (!root) return res;
    queue<Node*> q;
    q.push(root);
    while (!q.empty()) {
        Node* cur = q.front(); q.pop();
        res.push_back(cur->val);
        if (cur->left) q.push(cur->left);
        if (cur->right) q.push(cur->right);
    }
    return res;
}

// Height (recursive) - height of empty tree = 0, single node = 1
int height(Node* root) {
    if (!root) return 0;
    return 1 + max(height(root->left), height(root->right));
}

// Size (number of nodes)
int sizeOf(Node* root) {
    if (!root) return 0;
    return 1 + sizeOf(root->left) + sizeOf(root->right);
}

// Count leaves
int countLeaves(Node* root) {
    if (!root) return 0;
    if (!root->left && !root->right) return 1;
    return countLeaves(root->left) + countLeaves(root->right);
}

// Max value in tree
int maxValue(Node* root) {
    if (!root) return INT_MIN;
    return max(root->val, max(maxValue(root->left), maxValue(root->right)));
}

// Diameter (optimal) - returns pair(height, diameter)
pair<int,int> diameterHelper(Node* root) {
    if (!root) return {0, 0}; // height=0, diameter=0
    auto L = diameterHelper(root->left);
    auto R = diameterHelper(root->right);
    int h = 1 + max(L.first, R.first);
    int diaThrough = L.first + R.first; // edges count between deepest leaves via root
    int best = max({diaThrough, L.second, R.second});
    return {h, best};
}
int diameter(Node* root) {
    return diameterHelper(root).second;
}

// isBalanced (optimal) - returns pair(isBalanced, height)
pair<bool,int> isBalancedHelper(Node* root) {
    if (!root) return {true, 0};
    auto L = isBalancedHelper(root->left);
    auto R = isBalancedHelper(root->right);
    bool ok = L.first && R.first && (abs(L.second - R.second) <= 1);
    int h = 1 + max(L.second, R.second);
    return {ok, h};
}
bool isBalanced(Node* root) {
    return isBalancedHelper(root).first;
}

// Lowest Common Ancestor (general binary tree)
Node* lca(Node* root, int a, int b) {
    if (!root) return nullptr;
    if (root->val == a || root->val == b) return root;
    Node* L = lca(root->left, a, b);
    Node* R = lca(root->right, a, b);
    if (L && R) return root;
    return L ? L : R;
}

// Serialize (level-order) using "-1" sentinel for nulls. Returns vector<int>.
vector<int> serialize(Node* root, int sentinel = -1) {
    vector<int> out;
    if (!root) return out;
    queue<Node*> q;
    q.push(root);
    while (!q.empty()) {
        Node* cur = q.front(); q.pop();
        if (!cur) {
            out.push_back(sentinel);
            continue;
        }
        out.push_back(cur->val);
        q.push(cur->left);
        q.push(cur->right);
    }
    // Trim trailing sentinels
    while (!out.empty() && out.back() == sentinel) out.pop_back();
    return out;
}

// Deserialize from vector<int> produced by serialize (sentinel for null)
Node* deserialize(const vector<int>& data, int sentinel = -1) {
    return buildFromLevelOrder(data, sentinel);
}

// Invert (mirror)
void invert(Node* root) {
    if (!root) return;
    swap(root->left, root->right);
    invert(root->left);
    invert(root->right);
}

// Utility for printing vectors
void printVec(const vector<int>& v) {
    cout << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        cout << v[i] << (i + 1 == v.size() ? "" : ", ");
    }
    cout << "]";
}

// Free memory (delete tree)
void freeTree(Node* root) {
    if (!root) return;
    freeTree(root->left);
    freeTree(root->right);
    delete root;
}

// Simple tests / demo
int main() {
    // Build example tree: {1,2,3,4,5,-1,6}
    vector<int> data = {1,2,3,4,5,-1,6};
    Node* root = buildFromLevelOrder(data, -1);

    vector<int> pre, in, post;
    preorderRec(root, pre);
    inorderRec(root, in);
    postorderRec(root, post);

    cout << "Preorder (rec): "; printVec(pre); cout << "\n";
    cout << "Inorder  (rec): "; printVec(in); cout << "\n";
    cout << "Postorder(rec): "; printVec(post); cout << "\n";

    cout << "Inorder (iter): "; printVec(inorderIter(root)); cout << "\n";
    cout << "Level-order: "; printVec(levelOrder(root)); cout << "\n";
    cout << "Height: " << height(root) << "\n";
    cout << "Size: " << sizeOf(root) << "\n";
    cout << "Leaf count: " << countLeaves(root) << "\n";
    cout << "Diameter (edges): " << diameter(root) << "\n";
    cout << "Is balanced: " << (isBalanced(root) ? "Yes" : "No") << "\n";

    Node* anc = lca(root, 4, 5);
    if (anc) cout << "LCA(4,5): " << anc->val << "\n";
    else cout << "LCA not found\n";

    vector<int> ser = serialize(root, -1);
    cout << "Serialized: "; printVec(ser); cout << "\n";

    Node* copy = deserialize(ser, -1);
    cout << "Deserialize -> level-order: "; printVec(levelOrder(copy)); cout << "\n";

    invert(copy);
    cout << "After invert(copy) -> level-order: "; printVec(levelOrder(copy)); cout << "\n";

    freeTree(root);
    freeTree(copy);
    return 0;
}
```

## üí° Tips & Tricks

* Inorder traversal = sorted array ‚Üí remember this like your PIN
* Always clarify **duplicates allowed or not**
* BST problems are usually **decision problems**, not traversal-heavy
* Skewed BST = Linked List (bad)
* Balanced BST = Happy life üòå



## ‚ùì FAQs

**Q: Is BST always balanced?**
Nope. Only AVL / Red-Black trees guarantee balance.

**Q: Can BST have duplicates?**
Depends on definition. Usually no, or duplicates go consistently left/right.

**Q: Why validate BST using range?**
Because local comparisons fail in deeper levels.

**Q: When to use BST vs unordered_set?**
Use BST when you need **ordered data**, range queries, floor/ceil.

