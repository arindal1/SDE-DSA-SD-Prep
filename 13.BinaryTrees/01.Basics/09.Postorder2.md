# ğŸŒ³ Postorder Traversal in Binary Tree (Recursive & Iterative) [#145](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, return the **postorder traversal** of its nodes.

ğŸ‘‰ **Postorder Traversal Order**:

```
Left â†’ Right â†’ Root
```



## ğŸ§  Why Postorder Traversal is special

Postorder traversal is the **most â€œbottom-upâ€** traversal.

It is heavily used in:

* **Deleting a tree**
* **Tree DP problems**
* **Height / Diameter / Balance checks**
* **Expression tree evaluation**

If preorder says *â€œme firstâ€*
and inorder says *â€œme in betweenâ€*
then postorder says:

> â€œKids firstâ€¦ Iâ€™ll go last.â€ ğŸ˜Œ



## ğŸ‘€ Example

Binary Tree:

```
        1
       / \
      2   3
     / \
    4   5
```

### Postorder Output

```
4 5 2 3 1
```



# 1ï¸âƒ£ Recursive Postorder Traversal ğŸŒ± (Simplest)

## âœ… Recursive Code

```cpp
class Solution {
public:
    void postorderTraversal(TreeNode* root, vector<int>& result) {

        if (!root) return;

        postorderTraversal(root->left, result);
        postorderTraversal(root->right, result);
        result.push_back(root->val);
    }
};
```



## ğŸ§  Algorithm (Recursive)

```
If root is NULL:
    return

Postorder(left)
Postorder(right)
Visit root
```



## â± Complexity

* **Time:** O(N)
* **Space:** O(H) recursion stack
  (H = height of tree)

âš ï¸ Risk of stack overflow in **degenerate trees**



## ğŸ§© When to use recursion

* When tree depth is small
* When clarity matters more than stack limits
* When interviewer doesnâ€™t restrict recursion



# 2ï¸âƒ£ Iterative Postorder Traversal (Using Two Stacks) ğŸ§±ğŸ”¥

This is the **most common iterative postorder solution**.


## âœ… Cleaned CPP Code

```cpp
vector<int> postorderTraversal(Node* root) {
    vector<int> postorder;
    if (!root) return postorder;

    stack<Node*> st1, st2;
    st1.push(root);

    while (!st1.empty()) {
        Node* node = st1.top();
        st1.pop();
        st2.push(node);

        if (node->left) st1.push(node->left);
        if (node->right) st1.push(node->right);
    }

    while (!st2.empty()) {
        postorder.push_back(st2.top()->val);
        st2.pop();
    }

    return postorder;
}
```



## ğŸ§  Core Intuition (VERY IMPORTANT)

Postorder =

```
Left â†’ Right â†’ Root
```

But iterative traversal naturally gives:

```
Root â†’ Left â†’ Right
```

So the trick is:

1. Generate **Root â†’ Right â†’ Left**
2. Reverse it â†’ **Left â†’ Right â†’ Root**

Thatâ€™s exactly what **two stacks** do ğŸ¯



## ğŸ§  Algorithm (Two Stacks)

1. Push root into `st1`
2. Pop from `st1`, push into `st2`
3. Push left & right children into `st1`
4. Once done, pop from `st2` â†’ postorder



## â± Complexity

* **Time:** O(N)
* **Space:** O(N) (two stacks)

âœ” No recursion
âœ” No stack overflow risk



## ğŸ§ª Test Cases

| Tree Type     | Output                 |
| - | - |
| Empty tree    | []                     |
| Single node   | [1]                    |
| Left skewed   | bottom â†’ root          |
| Right skewed  | bottom â†’ root          |
| Balanced tree | children before parent |



# ğŸ§  Comparison: Recursive vs Two-Stack Iterative

| Aspect              | Recursive   | Iterative (2 stacks) |
| - | -- | -- |
| Simplicity          | â­â­â­â­â­       | â­â­â­                  |
| Space               | O(H)        | O(N)                 |
| Stack overflow risk | Yes         | No                   |
| Interview usage     | Very common | Very common          |



# âš ï¸ Common Interview Mistakes

âŒ Forgetting root null check

âŒ Pushing children in wrong order

âŒ Mixing preorder logic

âŒ Forgetting why reversal is needed



# ğŸš€ Variations & Related Problems

* Postorder using **single stack** (harder)
* Morris Postorder Traversal (O(1) space)
* Tree deletion
* Expression tree evaluation
* Diameter / height / balanced tree checks



# â“ FAQs

### Q1: Why is postorder hardest to do iteratively?

Because root comes **last**, not first or middle.



### Q2: Which iterative postorder should I remember?

ğŸ‘‰ **Two-stack approach**
Itâ€™s the safest and most explainable.



### Q3: When should I avoid recursion?

* Very deep trees
* Memory-restricted environments



### Q4: Is Morris postorder required in interviews?

Almost never âŒ
Good to know, not required.



### Q5: Can postorder traversal sort a BST?

No âŒ
Only inorder traversal sorts BST values.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Postorder = Left â†’ Right â†’ Root
Recursive = easiest
Iterative = reverse (Root â†’ Right â†’ Left)
Two stacks = safest
```
