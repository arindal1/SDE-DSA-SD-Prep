# ğŸŒ³ Inorder Traversal in Binary Tree (BT) [#94](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, perform **Inorder Traversal** and return the sequence of visited nodes.

ğŸ‘‰ **Inorder Traversal Order**:

```
Left â†’ Root â†’ Right
```



## ğŸ§  Why Inorder Traversal matters

* Itâ€™s one of the **three fundamental DFS traversals**
* In a **Binary Search Tree**, inorder traversal gives **sorted order** ğŸ”¥
* Helps in:

  * Tree validation (BST check)
  * Expression tree evaluation
  * Tree flattening & transformations

Think of it like:

> â€œCheck the left side first, process yourself, then check the right sideâ€
> Very polite traversal ğŸ˜Œ



## ğŸ‘€ Example

Binary Tree:

![image](https://imgs.search.brave.com/V5XognGF0hNwIdQAPZDaaenn0Z-OeQqVvZeSPQerPjk/rs:fit:860:0:0:0/g:ce/aHR0cHM6Ly9pMC53/cC5jb20vdGVjaGll/ZGVsaWdodC5jb20v/d3AtY29udGVudC91/cGxvYWRzL0lub3Jk/ZXItVHJhdmVyc2Fs/LnBuZz9yZXNpemU9/MzQ0LDQzNyZzc2w9/MQ)

### Inorder Traversal Output

```
4 2 1 7 5 8 3 6
```



## ğŸ§© Intuition (the real understanding)

At every node:

1. **Completely explore the left subtree**
2. **Visit the current node**
3. **Completely explore the right subtree**

This recursive definition matches the treeâ€™s structure perfectly.
Trees and recursion are basically best friends ğŸ¤.



## ğŸŒ Brute Force Approach (conceptual)

Thereâ€™s no real â€œbrute forceâ€ traversal, but beginners often:

* Recompute paths
* Use unnecessary arrays
* Or simulate recursion badly

Still ends up O(N), but messy and inefficient.

ğŸ‘‰ **Better approach**: use recursion or a stack cleanly.



# âœ… Optimal Approaches

Weâ€™ll cover **three** versions:

1. Recursive (most intuitive)
2. Iterative using Stack (interview favorite)
3. Morris Traversal (O(1) space, big-brain mode ğŸ§ )



## 1ï¸âƒ£ Recursive Inorder Traversal ğŸŒ± (Most intuitive)

### ğŸ§  Idea

Use recursion to:

* Traverse left
* Process root
* Traverse right



### ğŸ’¡ Algorithm

```
If root is NULL:
    return

Inorder(root.left)
Visit root
Inorder(root.right)
```



### ğŸ’» Code (C++)

```cpp
void inorder(Node* root, vector<int>& result) {
    if (!root) return;

    inorder(root->left, result);
    result.push_back(root->val);
    inorder(root->right, result);
}
```



### âœ… Why this works

* Tree is recursive by nature
* Each node is visited exactly once
* Very readable and clean âœ¨



### â± Complexity

* **Time:** O(N)
* **Space:** O(H)
  (H = height of tree, recursion stack)



## 2ï¸âƒ£ Iterative Inorder Traversal (Using Stack) ğŸ§±

ğŸ”¥ **Interviewers LOVE this one**



### ğŸ§  Intuition

We manually simulate recursion using a stack:

* Go as left as possible
* Process node
* Move right

Like retracing steps in a maze ğŸ—ºï¸



### ğŸ’¡ Algorithm

1. Initialize empty stack
2. Set `current = root`
3. While `current != NULL` or stack not empty:

   * Push all left nodes
   * Pop stack, process node
   * Move to right child



### ğŸ’» Code (C++)

```cpp
vector<int> inorderTraversal(Node* root) {
    vector<int> result;
    stack<Node*> st;
    Node* curr = root;

    while (curr != nullptr || !st.empty()) {
        while (curr != nullptr) {
            st.push(curr);
            curr = curr->left;
        }

        curr = st.top();
        st.pop();
        result.push_back(curr->val);

        curr = curr->right;
    }

    return result;
}
```



### â± Complexity

* **Time:** O(N)
* **Space:** O(H) stack



### ğŸ’¬ Interview Tip

If recursion is banned âŒ
â†’ This is your go-to solution.



## 3ï¸âƒ£ Morris Inorder Traversal ğŸŒŸ (O(1) Space)

> â€œI bend the tree, but I donâ€™t break it.â€ â€“ Morris Traversal (probably)



### ğŸ§  Idea

* Temporarily create **threads** to predecessor
* Avoid stack & recursion
* Restore tree after traversal



### ğŸ’¡ Algorithm (High-level)

1. If left child is NULL â†’ visit node, move right
2. Else:

   * Find inorder predecessor
   * Create temporary link
   * Traverse left
3. Remove link after use



### ğŸ’» Code (C++)

```cpp
vector<int> inorderMorris(Node* root) {
    vector<int> result;
    Node* curr = root;

    while (curr) {
        if (!curr->left) {
            result.push_back(curr->val);
            curr = curr->right;
        } else {
            Node* prev = curr->left;
            while (prev->right && prev->right != curr)
                prev = prev->right;

            if (!prev->right) {
                prev->right = curr;
                curr = curr->left;
            } else {
                prev->right = nullptr;
                result.push_back(curr->val);
                curr = curr->right;
            }
        }
    }
    return result;
}
```



### â± Complexity

* **Time:** O(N)
* **Space:** O(1) ğŸ˜



### âš ï¸ Warning

* Harder to implement
* Easy to mess up
* Use only when space is critical



# ğŸ§ª Test Cases

| Tree         | Output           |
| - | - |
| Empty tree   | []               |
| Single node  | [1]              |
| Skewed left  | increasing order |
| Skewed right | same as preorder |
| BST          | Sorted output    |



# ğŸ§  Key Observations

* Inorder traversal of **BST = sorted array**
* Stack size depends on **tree height**
* Morris traversal modifies tree temporarily



# ğŸš€ Variations & Related Problems

* Validate Binary Search Tree
* Kth smallest element in BST
* Recover BST
* Flatten binary tree
* Inorder successor / predecessor



# â“ FAQs

### Q1: Why is inorder important for BST?

Because BST property ensures:

```
Left < Root < Right
```

So inorder gives sorted values ğŸ“ˆ



### Q2: Which inorder approach should I use in interviews?

* Recursive â†’ clarity
* Iterative â†’ preferred
* Morris â†’ flex ğŸ’ª (only if asked)



### Q3: Can inorder be done without recursion or stack?

Yes, **Morris Traversal**



### Q4: Does inorder traversal work the same for BT and BST?

Traversal order is same, but **meaning differs**
Only BST guarantees sorted output.



### Q5: What if tree height is very large?

Avoid recursion â†’ use iterative



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Inorder = Left â†’ Root â†’ Right
Recursive = clean
Iterative = stack
Morris = O(1) space
BST inorder = sorted
```
