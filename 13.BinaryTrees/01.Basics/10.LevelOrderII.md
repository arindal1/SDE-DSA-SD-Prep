

# ğŸŒ³ Level Order Traversal (Bottom-Up) [#107](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return its **level order traversal from bottom to top**.

ğŸ‘‰ That means:

* Traverse the tree **level by level**
* Return the levels starting from the **lowest level up to the root**



## ğŸ§  Why this problem matters

This problem tests:

* Mastery of **BFS / level order traversal**
* Handling of **result ordering**
* Understanding that traversal order and **output order can differ**

Itâ€™s also a stepping stone to:

* Tree views
* Zigzag traversal
* Vertical traversal

Think of it as:

> Normal level orderâ€¦ but youâ€™re reading it **upside down** ğŸ™ƒğŸ“–



## ğŸ‘€ Example

### Input Tree

```
        3
       / \
      9   20
         /  \
        15   7
```

### Normal Level Order

```
[
  [3],
  [9, 20],
  [15, 7]
]
```

### Bottom-Up Level Order

```
[
  [15, 7],
  [9, 20],
  [3]
]
```



## ğŸ§© Intuition (key idea)

The traversal itself **does not change**:

* Still BFS
* Still process level by level using a queue

The only difference:

* **Where** you place each level in the result

Two clean ways:

1. Insert each level at the **front**
2. Push normally, then **reverse at the end**

Your solution uses **method 1**.



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Naive Idea

* For each level, recompute depth
* Traverse tree multiple times

âŒ O(NÂ²)
âŒ Overkill
âŒ Interviewers wonâ€™t like it



# âœ… Optimal Approach (BFS + Result Reordering)

### ğŸ”¥ Key Insight

* BFS already gives correct grouping
* Just reverse the **order of levels**, not nodes



## ğŸ’» Code

```cpp
vector<vector<int>> levelOrderBottom(TreeNode* root) {
    vector<vector<int>> res;
    if (!root) return res;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int level = q.size();
        vector<int> lev;

        for (int i = 0; i < level; i++) {
            TreeNode* node = q.front();
            q.pop();

            lev.push_back(node->val);

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        res.push_back(lev);
    }

    reverse(res.begin(), res.end());
    return res;
}
```

## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
If root is null:
    return empty list

Push root into queue

While queue not empty:
    size = queue size
    create empty level list

    For each node in this level:
        pop node
        add value to level list
        push children if exist

    add level list to result

Reverse result
```



## ğŸ”‘ Why this works

* BFS guarantees correct level grouping
* Reversing levels gives bottom-up order
* No need to change traversal logic



## â± Complexity Analysis

### Your current approach (`insert at front`)

| Metric | Value                  |
| - | - |
| Time   | **O(NÂ²)** (worst case) |
| Space  | **O(N)**               |

### Optimized approach (reverse at end)

| Metric | Value    |
| - | -- |
| Time   | **O(N)** |
| Space  | **O(N)** |



## ğŸ§ª Test Cases

| Tree          | Output             |
| - | - |
| Empty tree    | []                 |
| Single node   | [[1]]              |
| Balanced tree | Bottom-up levels   |
| Left skewed   | One node per level |
| Right skewed  | One node per level |



## ğŸ§  Key Observations

* Traversal is still BFS
* Only output order changes
* Avoid front-insertion in vectors
* Reverse is cleaner and faster



# ğŸš€ Variations & Related Problems

* Normal Level Order Traversal
* Zigzag Level Order Traversal
* Right / Left Side View
* Bottom View of Binary Tree


# â“ FAQs

### Q1: Is this BFS or DFS?

**BFS**
Because traversal is level-based.



### Q2: Can this be done using DFS?

Yes, but:

* Requires height calculation
* More complex
* BFS is preferred



### Q3: Why reverse at the end instead of inserting at front?

Because `vector::insert(begin)` is **O(N)**
`reverse()` is **O(N)** once.



### Q4: Does this preserve left-to-right order?

Yes âœ”ï¸
Order within each level remains unchanged.



### Q5: Is this used in real systems?

Yes â€” tree visualization, UI layouts, hierarchical reporting.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Bottom-Up Level Order = BFS + reverse levels
Traversal unchanged
Reverse result, not each level
Avoid front insertion
```

