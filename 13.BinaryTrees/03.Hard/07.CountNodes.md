
 
# ğŸŒ³ Count Nodes in a Complete Binary Tree [LC #[222](https://leetcode.com/problems/count-complete-tree-nodes/description/)]

## ğŸ“Œ Problem Statement

Given the **root of a complete binary tree**, return the **total number of nodes**.

ğŸ‘‰ A **complete binary tree** is one where:

* All levels are completely filled **except possibly the last**
* The last level is filled **from left to right**



## ğŸ§  Why this problem matters

This problem tests:

* Knowledge of **complete binary tree properties**
* Height-based optimizations
* Avoiding unnecessary traversal
* Combining recursion with math

Think of it as:

> â€œCan you count smarter instead of counting harder?â€ ğŸ§ ğŸ“Š



## ğŸ‘€ Example

### Tree

```
            1
          /   \
         2     3
        / \   /
       4   5 6
```

### Output

```
6
```



## ğŸ§© Core Intuition (THIS is the key ğŸ”‘)

For a **perfect binary tree**:

```
Number of nodes = 2^height âˆ’ 1
```

Now hereâ€™s the magic âœ¨:

In a **complete binary tree**:

* If the **leftmost height** equals the **rightmost height**
* Then the tree is **perfect**

ğŸ‘‰ And we can count nodes in **O(1)** time.

Otherwise:

* Recurse into left and right subtrees



# ğŸŒ Brute Force Approach (Baseline)

### âŒ Naive Idea

* Traverse every node
* Count nodes one by one

### âŒ Code

```cpp
int countNodes(TreeNode* root) {
    if (!root) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}
```

â›” Time Complexity: **O(N)**
â›” Wastes the complete-tree property



# âœ… Optimal Approach (Height-Based Optimization)

### ğŸ”¥ Key Insight

* Complete binary trees have structure
* We exploit symmetry to skip large subtrees


### ğŸ’» Code

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (!root)
            return 0;

        int lh = leftHeight(root);
        int rh = rightHeight(root);

        if (lh == rh)
            return (1 << lh) - 1;

        return 1 + countNodes(root->left) + countNodes(root->right);
    }

    int leftHeight(TreeNode* root) {
        int height = 0;
        while (root) {
            height++;
            root = root->left;
        }
        return height;
    }

    int rightHeight(TreeNode* root) {
        int height = 0;
        while (root) {
            height++;
            root = root->right;
        }
        return height;
    }
};
```



## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
If root is null â†’ return 0

Compute left height (go left only)
Compute right height (go right only)

If leftHeight == rightHeight:
    Tree is perfect
    Return (2^height - 1)

Else:
    Return 1 + count(left subtree) + count(right subtree)
```



## ğŸ”‘ Why this works

* In a complete tree, imbalance appears only at lower levels
* Perfect subtrees can be counted instantly
* Recursion only continues where structure breaks



## â± Complexity Analysis

| Metric           | Value           |
| - | - |
| Time Complexity  | **O((log N)Â²)** |
| Space Complexity | **O(log N)**    |

### Why `(log N)Â²`?

* Height computation: O(log N)
* Done at most O(log N) times



## ğŸ§ª Test Cases

| Tree Type     | Output        |
| - | - |
| Empty tree    | 0             |
| Single node   | 1             |
| Perfect tree  | 2^h âˆ’ 1       |
| Complete tree | Correct count |
| Skewed tree   | Still works   |



## ğŸ§  Key Observations

* This works **only for complete binary trees**
* Height comparison is the core trick
* Big performance gain over DFS
* Clean mix of math + recursion



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Check if Tree is Complete

Level-order validation

### 2ï¸âƒ£ Count Nodes in Perfect Tree

Direct formula

### 3ï¸âƒ£ Height of Binary Tree

Foundation problem



# â“ FAQs

### Q1: Why `(1 << lh) - 1`?

Because:

```
2^lh âˆ’ 1 = total nodes in perfect binary tree
```



### Q2: Why not use `pow(2, lh)`?

* `pow()` uses floating point
* Bit shift is faster and safer



### Q3: Does this work for skewed trees?

Yes, but no optimization benefit there.



### Q4: Is this faster than DFS?

Yes â€” dramatically for large trees.



### Q5: Is this asked in interviews?

Very frequently âœ”ï¸



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Complete tree property
Compare leftmost & rightmost heights
Perfect tree â†’ use formula
Else recurse
```



## ğŸ¬ Pop culture wrap-up

This problem is like counting seats in a **stadium** ğŸŸï¸:

* If the entire section is full â†’ count instantly
* If not â†’ zoom in and count row by row

Why walk every seat when you can do math? ğŸ˜„



If you want next:

* ğŸ”¥ **Check Complete Binary Tree**
* ğŸ§© Count nodes in BST
* ğŸ§ª Binary tree math-based optimizations
* ğŸ“„ Merge all tree optimization tricks into one README

Just say the word ğŸš€
