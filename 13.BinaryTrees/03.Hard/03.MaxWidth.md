

# ğŸŒ³ Maximum Width of a Binary Tree  [#662](https://leetcode.com/problems/maximum-width-of-binary-tree/description/)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return the **maximum width** of the tree.

ğŸ‘‰ The **width** of a level is defined as:

```
(index of rightmost non-null node âˆ’ index of leftmost non-null node) + 1
```

âš ï¸ Important:

* Width counts **null gaps** between nodes
* The tree is treated like a **complete binary tree** for indexing



## ğŸ§  Why this problem matters

This problem tests:

* BFS traversal
* Understanding of **implicit indexing**
* Handling large indices safely
* Distinguishing between â€œnumber of nodesâ€ vs â€œwidthâ€

Think of it as:

> â€œHow wide does the tree look if it were laid out perfectly?â€ ğŸ“ğŸŒ³



## ğŸ‘€ Example

### Tree

```
            1
          /   \
         3     2
        / \     \
       5   3     9
```

### Indexing (Complete Binary Tree Style)

```
Level 0:        1 (0)
Level 1:    3 (1)     2 (2)
Level 2: 5 (3) 3 (4)   9 (6)
```

### Widths

* Level 0 â†’ 1
* Level 1 â†’ 2
* Level 2 â†’ `6 - 3 + 1 = 4` âœ…

### Output

```
4
```



## ğŸ§© Core Intuition (VERY IMPORTANT ğŸ”‘)

We assign **indices** to nodes as if the tree were a **complete binary tree**:

* Root â†’ index `0`
* Left child â†’ `2 * i + 1`
* Right child â†’ `2 * i + 2`

At each level:

* Track the **first index**
* Track the **last index**
* Width = `last - first + 1`

âš ï¸ Indices can grow very large â†’ we **normalize them per level** to avoid overflow.



# ğŸŒ Brute Force Approach (Why it fails)

### âŒ Naive Idea

* Count number of nodes at each level

âŒ Wrong answer
âŒ Ignores gaps between nodes
âŒ Width â‰  number of nodes



# âœ… Optimal Approach (BFS + Indexing)

### ğŸ”¥ Key Insights

* BFS ensures level-by-level traversal
* Indexing simulates a complete tree
* Normalizing indices prevents overflow




### ğŸ’» Code

```cpp
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if (!root)
            return 0;

        int maxWidth = 0;

        queue<pair<TreeNode*, long long>> q;
        q.push({root, 0});

        while (!q.empty()) {
            int line = q.size();
            long long minInd = q.front().second;
            long long first = 0, last = 0;

            for (int i = 0; i < line; ++i) {
                long long curInd = q.front().second - minInd;
                TreeNode* p = q.front().first;
                q.pop();

                if (i == 0)
                    first = curInd;
                if (i == line - 1)
                    last = curInd;

                if (p->left)
                    q.push({p->left, 2 * curInd + 1});
                if (p->right)
                    q.push({p->right, 2 * curInd + 2});
            }
            maxWidth = max(maxWidth, (int)(last - first + 1));
        }
        return maxWidth;
    }
};
```




## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
If root is null â†’ return 0

Push (root, index=0) into queue

While queue not empty:
    levelSize = queue size
    minIndex = index of first node in queue

    For each node in level:
        normalize index = index - minIndex

        if first node â†’ record first index
        if last node â†’ record last index

        push left child with index = 2*i + 1
        push right child with index = 2*i + 2

    update maxWidth = max(maxWidth, last - first + 1)
```



## ğŸ”‘ Why normalize indices?

Without normalization:

* Indices grow exponentially
* `long long` can overflow on deep trees

Normalization keeps values **small and safe** ğŸ›¡ï¸



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(N)** |

Queue can hold an entire level in the worst case.



## ğŸ§ª Test Cases

| Tree Type    | Output                      |
| - | - |
| Empty tree   | 0                           |
| Single node  | 1                           |
| Perfect tree | Width = nodes in last level |
| Sparse tree  | Includes gaps               |
| Skewed tree  | 1                           |



## ğŸ§  Key Observations

* Width counts **null positions**
* BFS is mandatory
* Indexing simulates complete tree layout
* Normalization avoids overflow bugs



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Maximum Width without Null Gaps

Simple node count per level

### 2ï¸âƒ£ Height of Binary Tree

Vertical property instead of horizontal

### 3ï¸âƒ£ Level Order Traversal

Foundation for this problem




# â“ FAQs

### Q1: Why not use `int` for indices?

Indices grow exponentially.
`int` will overflow âŒ



### Q2: Why BFS and not DFS?

Width is a **level-based property**.



### Q3: Does this count null nodes?

Yes âœ”ï¸
Thatâ€™s the whole point of the problem.



### Q4: Is width same as maximum nodes in a level?

No âŒ
Width includes **gaps**.



### Q5: Is this problem hard?

Conceptually â€” yes ğŸ˜„
Implementation â€” manageable once you get indexing.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Use BFS
Assign indices like complete binary tree
Normalize indices per level
Width = last - first + 1
```

