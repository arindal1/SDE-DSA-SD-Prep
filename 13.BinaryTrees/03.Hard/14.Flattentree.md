# ğŸŒ³ Flatten Binary Tree to Linked List [#114](http://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, flatten the tree into a **linked list in-place**.

ğŸ‘‰ The flattened tree should:

* Follow **preorder traversal** order

  ```
  Root â†’ Left â†’ Right
  ```
* Use only the **right pointers**
* Have all `left` pointers set to `nullptr`
* Be done **in-place** (no extra data structures)



## ğŸ§  Why this problem matters

This problem tests:

* Deep understanding of **tree traversal**
* **Pointer manipulation**
* In-place transformations
* Ability to simulate recursion iteratively

Itâ€™s basically:

> â€œCan you reshape a tree without breaking it?â€ ğŸ§ ğŸ”§



## ğŸ‘€ Example

### Original Tree

```
        1
       / \
      2   5
     / \   \
    3   4   6
```

### Flattened Tree (Linked List)

```
1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6
```

(All via `right` pointers)



## ğŸ§© Intuition (THIS is the key idea)

We want the tree to look like **preorder traversal**:

```
Root â†’ Left subtree â†’ Right subtree
```

At every node:

1. Take the **left subtree**
2. Find its **rightmost node**
3. Attach the **original right subtree** there
4. Move left subtree to the right
5. Set `left = nullptr`

Then move forward using `right`.

ğŸ‘‰ Think of it like **rewiring cables**, not rebuilding the structure.



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Naive Idea

1. Do preorder traversal
2. Store nodes in a vector
3. Reconnect them as a linked list

âŒ Uses extra space
âŒ Violates â€œin-placeâ€ requirement
âŒ Interviewers wonâ€™t like it



# âœ… Optimal Approach (Iterative, O(1) Extra Space)

### ğŸ”¥ Key Insight

This is basically **Morris-style traversal**:

* No recursion
* No stack
* Just pointer rewiring



## âœ…  Code

### ğŸ’» Code

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* curr = root;

        while (curr) {
            if (curr->left) {
                TreeNode* temp = curr->left;
                while (temp->right) {
                    temp = temp->right;
                }

                temp->right = curr->right;
                curr->right = curr->left;
                curr->left = nullptr;
            }
            curr = curr->right;
        }
    }
};
```


## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
curr = root

while curr is not null:
    if curr has a left child:
        find rightmost node of left subtree
        connect that nodeâ€™s right to currâ€™s right
        move left subtree to currâ€™s right
        set curr.left = null

    move curr to curr.right
```



## ğŸ”‘ Why this works

* Preorder = Root â†’ Left â†’ Right
* Left subtree is placed immediately after root
* Right subtree is preserved and attached at the end
* Traversal continues along the new right chain

Elegant and efficient ğŸ§ âœ¨



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(1)** |

Each node is visited a constant number of times.



## ğŸ§ª Test Cases

| Tree          | Result            |
| - | -- |
| Empty tree    | No change         |
| Single node   | Same node         |
| Left skewed   | Straight list     |
| Right skewed  | Already flattened |
| Balanced tree | Preorder list     |



## ğŸ§  Key Observations

* Output order is **preorder**
* Tree structure is destroyed (intentionally)
* This is pointer manipulation, not traversal output
* Similar thinking used in Morris Traversals



# ğŸš€ Alternative Approaches (Good to Know)

### 1ï¸âƒ£ Recursive (Postorder)

Simpler to write, but uses recursion stack.

```cpp
TreeNode* prev = nullptr;
void flatten(TreeNode* root) {
    if (!root) return;
    flatten(root->right);
    flatten(root->left);
    root->right = prev;
    root->left = nullptr;
    prev = root;
}
```



### 2ï¸âƒ£ Using Stack

* Preorder traversal with stack
* Uses O(N) space

Less optimal, but easier to reason.



# â“ FAQs

### Q1: Why preorder order?

Thatâ€™s what the problem explicitly asks for.
Flattened tree must match preorder traversal.



### Q2: Is this Morris traversal?

Very similar in spirit âœ”ï¸
Uses tree rewiring without extra space.



### Q3: Can this be undone?

No âŒ
Original tree structure is lost.



### Q4: Is recursion acceptable?

Yes, but iterative O(1) space is preferred.



### Q5: Is this DFS or BFS?

Conceptually **DFS (preorder)**, implemented iteratively.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Flatten = preorder linked list
Use rightmost of left subtree
Attach old right subtree
Set left = null
O(1) space
```

