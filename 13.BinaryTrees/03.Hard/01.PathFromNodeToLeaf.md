# ğŸŒ³ Root to Node Path in a Binary Tree (DFS + Backtracking)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree** and a value `k`, find the **path from the root to the node with value `k`**.

ğŸ‘‰ The path should be stored as a list of node values in **top-down order**.

If the node does not exist, return an **empty path**.



## ğŸ§  Why this problem matters

This is a **foundational tree pattern**.

It is used directly or indirectly in:

* Lowest Common Ancestor (LCA)
* Distance between two nodes
* Path Sum problems
* Print all root-to-leaf paths
* Tree backtracking problems

If you understand this, **half of tree DFS problems become easy** ğŸ§ âœ¨



## ğŸ‘€ Example

### Tree

```
        1
       / \
      2   3
     / \
    4   5
```

### Input

```
k = 5
```

### Output Path

```
[1, 2, 5]
```



## ğŸ§© Core Intuition (VERY IMPORTANT)

We do a **DFS traversal**:

1. Add the current node to the path
2. If this node is the target â†’ success âœ…
3. Otherwise, search left and right subtrees
4. If neither works â†’ **backtrack** (remove node)

ğŸ‘‰ The trick is **undoing work when a path fails**.

This is classic **backtracking** ğŸ§ ğŸ”




### ğŸ’» Code

```cpp
bool findPath(TreeNode* root, int k, vector<int>& path) {
    if (!root)
        return false;

    path.push_back(root->val);

    if (root->val == k)
        return true;

    if (findPath(root->left, k, path) || 
        findPath(root->right, k, path))
        return true;

    path.pop_back(); // backtrack
    return false;
}
```



## ğŸ§  Algorithm (DFS + Backtracking)

### ğŸ’¡ Steps

```
DFS(node):
    if node is null:
        return false

    add node to path

    if node value == target:
        return true

    if DFS(left) OR DFS(right):
        return true

    remove node from path
    return false
```



## ğŸ”‘ Why this works

* DFS explores all possible paths
* Backtracking removes wrong paths
* Path always reflects current recursion stack

This is **recursion + memory of path** ğŸ§ âœ¨



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree (recursion stack + path)

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree            | k    | Output    |
| - | - | - |
| Empty tree      | any  | []        |
| Single node     | root | [root]    |
| Node exists     | âœ”ï¸   | path      |
| Node not exists | âŒ    | empty     |
| Skewed tree     | âœ”ï¸   | long path |



## ğŸ§  Key Observations

* Path is **not copied**, only modified
* Backtracking is essential
* Stops early when target is found
* Works for any tree shape



# ğŸš€ Common Variations (VERY IMPORTANT)

### 1ï¸âƒ£ Root to Leaf Path

Check only when `node->left == nullptr && node->right == nullptr`



### 2ï¸âƒ£ Path Sum Problems

Track sum instead of node value



### 3ï¸âƒ£ Lowest Common Ancestor (LCA)

Find paths to both nodes, then compare



### 4ï¸âƒ£ Distance Between Two Nodes

Path + LCA logic


# â“ FAQs

### Q1: Why do we pop when returning false?

Because that node is **not part of the final path**.



### Q2: Why use DFS instead of BFS?

DFS naturally maintains the path via recursion.



### Q3: Can this be done iteratively?

Yes, but requires:

* Parent mapping
* Extra memory

DFS is cleaner.



### Q4: What if values are duplicated?

This finds the **first match encountered** in DFS order.



### Q5: Is this backtracking?

Yes âœ”ï¸
This is **textbook backtracking**.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Add node to path
If target found â†’ return true
Else search children
If fail â†’ pop (backtrack)
```

