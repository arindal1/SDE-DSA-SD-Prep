
# ğŸŒ³ Children Sum Property in a Binary Tree #[GFG](https://www.geeksforgeeks.org/problems/children-sum-parent/1)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, check whether the tree satisfies the **Children Sum Property**.

ğŸ‘‰ The **Children Sum Property** states:

> For every **non-leaf node**,
>
> ```
> node->data = left childâ€™s data + right childâ€™s data
> ```

* If a child is missing, its value is considered `0`
* Leaf nodes **automatically satisfy** the property

Return `true` if the tree satisfies the property, otherwise `false`.



## ğŸ§  Why this problem matters

This problem tests:

* Tree recursion
* Correct base cases
* Structural validation
* Bottom-up reasoning

Itâ€™s also a stepping stone to:

* Sum Tree
* Tree transformations
* Constraint-based tree problems

Think of it as:

> â€œEvery parent must equal the sum of its kidsâ€ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ğŸŒ³



## ğŸ‘€ Example

### Valid Tree

```
        10
       /  \
      8    2
     / \
    3   5
```

âœ”ï¸ `10 = 8 + 2`
âœ”ï¸ `8 = 3 + 5`

Output â†’ `true`



### Invalid Tree

```
        10
       /  \
      5    3
```

âŒ `10 â‰  5 + 3`

Output â†’ `false`



## ğŸ§© Core Intuition (VERY IMPORTANT)

At each node:

1. If itâ€™s a **leaf** â†’ valid âœ”ï¸
2. Otherwise:

   * Get left child value (or `0`)
   * Get right child value (or `0`)
   * Check:

     ```
     root->data == left + right
     ```
3. Recursively validate left and right subtrees

This is a **simple DFS validation problem** ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Naive Thinking

* Traverse tree multiple times
* Re-check children repeatedly

âŒ Unnecessary
âŒ Inefficient
âŒ Recursion already gives optimal traversal



# âœ… Optimal Approach (Recursive DFS)

### ğŸ”¥ Key Insight

* Each node only needs **local information**
* One DFS traversal is enough




### ğŸ’» Code

```cpp
class Solution {
  public:
    bool isSumProperty(Node *root) {
        if (!root)
            return true;
        if (!root->left && !root->right)
            return true;
            
        int left = root->left ? root->left->data : 0;
        int right = root->right ? root->right->data : 0;
            
        return ((root->data == left + right) &&
                isSumProperty(root->left) &&
                isSumProperty(root->right));
    }
};
```




## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
CheckSum(node):
    if node is null:
        return true

    if node is a leaf:
        return true

    leftValue = node.left ? node.left.data : 0
    rightValue = node.right ? node.right.data : 0

    return (node.data == leftValue + rightValue)
           AND CheckSum(node.left)
           AND CheckSum(node.right)
```



## ğŸ”‘ Why this works

* Property is **local to each node**
* DFS ensures all nodes are checked
* Leaf nodes are valid by definition



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree (recursion stack)

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree           | Output            |
| -- | -- |
| Empty tree     | true              |
| Single node    | true              |
| Valid sum tree | true              |
| Invalid parent | false             |
| Skewed tree    | depends on values |



## ğŸ§  Key Observations

* Leaf nodes always pass
* Missing child contributes `0`
* Property must hold at **every node**
* Early failure short-circuits recursion



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Sum Tree (Advanced)

Parent value = **sum of all nodes** in left & right subtrees



### 2ï¸âƒ£ Convert Tree to Children Sum Tree

Modify node values to satisfy the property



### 3ï¸âƒ£ Path Sum Problems

Different kind of sum validation



# â“ FAQs

### Q1: Is this the same as Sum Tree?

No âŒ

* **Children Sum Property** â†’ only immediate children
* **Sum Tree** â†’ entire subtree sums



### Q2: Why do leaves return true?

Because there are no children to violate the property.



### Q3: Can this be done iteratively?

Yes, but recursion is simpler and clearer.



### Q4: Does this work for negative values?

Yes âœ”ï¸
The logic is purely arithmetic.



### Q5: What if only one child exists?

The missing child contributes `0`.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Leaf â†’ valid
Parent value = left + right
Check recursively
One DFS traversal
```

