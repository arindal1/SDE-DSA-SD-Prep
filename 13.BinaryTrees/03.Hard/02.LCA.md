
# ğŸŒ³ Lowest Common Ancestor (LCA) in a Binary Tree #[236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

## ğŸ“Œ Problem Statement

Given a **binary tree**, find the **lowest common ancestor (LCA)** of two nodes `p` and `q`.

ğŸ‘‰ The **LCA** is defined as:

> The **lowest node** in the tree that has **both `p` and `q` as descendants**
> (a node can be a descendant of itself)



## ğŸ§  Why this problem matters

LCA is a **cornerstone problem**.

It is used in:

* Distance between two nodes
* Tree queries
* Network routing
* File systems
* Competitive programming

Interviewers love this because it tests:

* Tree recursion
* Bottom-up reasoning
* Correct base cases



## ğŸ‘€ Example

### Tree

```
            3
          /   \
         5     1
        / \   / \
       6   2 0   8
          / \
         7   4
```

### Queries

* LCA(5, 1) â†’ `3`
* LCA(5, 4) â†’ `5`



## ğŸ§© Core Intuition (THIS is the key ğŸ”‘)

Think **bottom-up**.

At every node:

* Ask left subtree: *Do you contain p or q?*
* Ask right subtree: *Do you contain p or q?*

Three possible situations:

1ï¸âƒ£ Both sides return non-null
ğŸ‘‰ Current node is the **LCA**

2ï¸âƒ£ Only one side returns non-null
ğŸ‘‰ That side contains both nodes, return it upward

3ï¸âƒ£ Both sides return null
ğŸ‘‰ Return null

This logic flows naturally with recursion ğŸŒŠ



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Path-Based Method

1. Find path from root to `p`
2. Find path from root to `q`
3. Compare paths to find last common node

âœ”ï¸ Works
âŒ Extra space
âŒ More code
âŒ Not elegant



# âœ… Optimal Approach (Single DFS Traversal)

### ğŸ”¥ Key Insight

* Each recursive call returns:

  * `nullptr` if no target found
  * A node if `p` or `q` found in subtree




### ğŸ’» Code

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q)
            return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        if (left == nullptr)
            return right;
        else if (right == nullptr)
            return left;
        else 
            return root;
    }
};
```




## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
If root is null or equals p or q:
    return root

left = LCA(left subtree)
right = LCA(right subtree)

If left and right are both non-null:
    return root

If only one is non-null:
    return that one

Else:
    return null
```



## ğŸ”‘ Why this works

* The first node where `p` and `q` split into different subtrees is the LCA
* Recursion bubbles results upward correctly
* No extra memory needed



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree                  | p  | q  | Output                             |
| - | -- | -- | - |
| Same node             | x  | x  | x                                  |
| One ancestor of other | p  | q  | p                                  |
| Separate subtrees     | âœ”ï¸ | âœ”ï¸ | correct LCA                        |
| Node missing          | âŒ  | âœ”ï¸ | undefined (problem assumes exists) |



## ğŸ§  Key Observations

* Works even if one node is ancestor of the other
* No parent pointers needed
* One traversal only
* Root can be LCA



# ğŸš€ Variations & Follow-ups (VERY IMPORTANT)

### 1ï¸âƒ£ LCA in a Binary Search Tree (BST)

Use ordering property â†’ O(H)



### 2ï¸âƒ£ LCA with Parent Pointers

No recursion needed



### 3ï¸âƒ£ LCA of Multiple Nodes

Generalized version



### 4ï¸âƒ£ Distance Between Two Nodes

`dist(p, q) = depth(p) + depth(q) - 2 * depth(LCA)`





# â“ FAQs

### Q1: Why return root when it equals p or q?

Because a node can be an ancestor of itself.



### Q2: Why not stop when first match is found?

Because the second node may lie in another subtree.



### Q3: Can this be done iteratively?

Yes, but recursive is cleaner and expected.



### Q4: Does this work if tree is not balanced?

Yes âœ”ï¸
Works for any shape.



### Q5: What if one node doesnâ€™t exist?

Problem usually assumes both nodes exist.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Bottom-up DFS
Return node if found
If both sides non-null â†’ LCA
Else bubble up non-null
```

