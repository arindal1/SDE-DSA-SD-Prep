

# ğŸ”¥ Burning Tree ([Minimum Time to Burn a Binary Tree - GFG](https://www.geeksforgeeks.org/problems/burning-tree/1))

## ğŸ“Œ Problem Statement

You are given:

* The **root** of a binary tree
* A **target node value**

ğŸ”¥ The tree starts **burning from the target node**.

Rules:

* In **1 unit of time**, fire spreads to:

  * Left child
  * Right child
  * Parent
* Return the **minimum time** required to burn the **entire tree**



## ğŸ§  Why this problem matters

This problem tests:

* Tree â†’ graph conversion
* BFS with time tracking
* Parent mapping
* Cycle prevention using `visited`

Itâ€™s a **classic interview favorite**, often asked after:

* Distance K from target
* LCA
* Tree views

Think of it as:

> â€œFire spreads like a wave ğŸŒŠ â€” how long until nothing is left?â€ ğŸ”¥ğŸŒ³



## ğŸ‘€ Example

### Tree

```
            1
          /   \
         2     3
        / \
       4   5
```

### Target = `5`

### Burning Timeline

```
t = 0 â†’ 5
t = 1 â†’ 2
t = 2 â†’ 4, 1
t = 3 â†’ 3
```

### Output

```
3
```



## ğŸ§© Core Intuition (THIS is the key ğŸ”‘)

A binary tree normally allows movement:

* **Down** â†’ left / right

ğŸ”¥ But fire spreads:

* Downward
* **Upward (parent)**

So the tree must be treated as an **undirected graph**.

### Strategy:

1. **Map parent pointers**
2. **Locate the target node**
3. **Run BFS from target**
4. Each BFS level = **1 unit of time**



# ğŸŒ Brute Force Approach (Why it fails)

âŒ Repeated DFS from target
âŒ Manual depth calculations
âŒ Recomputing parent paths

All lead to:

* O(NÂ²)
* Messy code
* High bug risk



# âœ… Optimal Approach (Tree â†’ Graph + BFS)

### ğŸ”¥ Three Clean Steps

1. Map parents
2. Find target node
3. BFS to simulate burning

This gives:

* Correct time
* O(N) complexity
* Clean logic



### ğŸ’» Full Code

```cpp
class Solution {
  public:
    int minTime(Node* root, int target) {
        if (!root)
            return 0;
            
        unordered_map<Node*, Node*> parentMap;
        trackParent(root, parentMap);

        Node* targetNode = findTarget(root, target);
        return timeToBurn(root, targetNode, parentMap);
    }
    
    Node* findTarget(Node* root, int target) {
        queue<Node*> q;
        q.push(root);
        
        while (!q.empty()) {
            Node* node = q.front();
            q.pop();
            
            if (node->data == target)
                return node;
            
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
        return nullptr;
    }
    
    void trackParent(Node* &root, unordered_map<Node*, Node*> &parentMap) {
        queue<Node*> q;
        q.push(root);
        
        while (!q.empty()) {
            Node* node = q.front();
            q.pop();
            
            if (node->left) {
                parentMap[node->left] = node;
                q.push(node->left);
            }
            if (node->right) {
                parentMap[node->right] = node;
                q.push(node->right);
            }
        }
    }
    
    int timeToBurn(Node* root, Node* target,
                   unordered_map<Node*, Node*> &parentMap) {
        int time = 0;
        unordered_set<Node*> visited;
        queue<Node*> q;
        
        q.push(target);
        visited.insert(target);
        
        while (!q.empty()) {
            int level = q.size();
            bool burned = false;
            
            for (int i = 0; i < level; ++i) {
                Node* node = q.front();
                q.pop();
                
                if (node->left && !visited.count(node->left)) {
                    burned = true;
                    visited.insert(node->left);
                    q.push(node->left);
                }
                if (node->right && !visited.count(node->right)) {
                    burned = true;
                    visited.insert(node->right);
                    q.push(node->right);
                }
                if (parentMap.count(node) &&
                    !visited.count(parentMap[node])) {
                    burned = true;
                    visited.insert(parentMap[node]);
                    q.push(parentMap[node]);
                }
            }
            if (burned)
                time++;
        }
        return time;
    }
};
```

### [ğŸ’» FULL CPP CODE](./06.MinTimeBurn.cpp)

## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Step 1: Map Parent Nodes

```
BFS from root
For every child:
    parentMap[child] = parent
```



### ğŸ’¡ Step 2: Find Target Node

```
BFS until node->data == target
```



### ğŸ’¡ Step 3: BFS to Burn Tree

```
Start BFS from target
Each level = 1 second
Move to left, right, parent
Use visited set
Increment time only if fire spreads
```



## ğŸ”‘ Why the `burned` flag?

Because:

* Some BFS levels may not spread fire
* Time should increase **only when new nodes burn**

This avoids off-by-one errors â±ï¸



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(N)** |

Where:

* `N` = number of nodes

Parent map + visited set both require O(N).



## ğŸ§ª Test Cases

| Case          | Output         |
| - | -- |
| Empty tree    | 0              |
| Single node   | 0              |
| Target = root | Height of tree |
| Skewed tree   | Height         |
| Balanced tree | Max distance   |



## ğŸ§  Key Observations

* Burning spreads in **all directions**
* Tree becomes a graph
* BFS ensures minimum time
* Similar to â€œdistance Kâ€ problem



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Nodes at Distance K

Same BFS logic, no time tracking

### 2ï¸âƒ£ Distance Between Two Nodes

LCA-based solution

### 3ï¸âƒ£ Fire Spread in Graph

General graph BFS problem



# â“ FAQs

### Q1: Why BFS and not DFS?

Because time corresponds to **levels**.



### Q2: What if target doesnâ€™t exist?

Problem usually guarantees it exists.



### Q3: Can this be solved without parent map?

Only by modifying the tree (not allowed).



### Q4: Is this a graph problem?

Yes âœ”ï¸
Tree is converted into an **implicit graph**.



### Q5: Is this asked in interviews?

Very frequently ğŸ”¥



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Tree â†’ Graph
Map parents
BFS from target
Each level = 1 unit time
Use visited set
```