

# ğŸŒ³ Serialize and Deserialize a Binary Tree [Leetcode #[297](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/)]

## ğŸ“Œ Problem Statement

Design an algorithm to:

* **Serialize** a binary tree â†’ convert it into a string
* **Deserialize** the string â†’ rebuild the original tree

The process must be:

```
deserialize(serialize(tree)) = original tree
```



## ğŸ§  Why this problem matters (A LOT)

This problem tests:

* Tree traversal
* Data encoding/decoding
* BFS/DFS mastery
* Handling null nodes
* Real-world system design thinking

This is basically:

> â€œHow would you send a tree over the network?â€ ğŸŒğŸŒ³



## ğŸ‘€ Example

### Tree

```
        1
       / \
      2   3
         / \
        4   5
```

### Serialized String

```
"1,2,3,#,#,4,5,#,#,#,#,"
```

### After Deserialization

Same tree is reconstructed âœ”ï¸



## ğŸ§© Core Intuition (THIS is the key ğŸ”‘)

To reconstruct a tree **exactly**, you must store:

* Node values
* **Null positions**

Because without nulls:

```
1,2,3
```

Could represent **many different trees**.

So we:

* Use **level order (BFS)**
* Store `#` for null nodes

This makes the structure **unambiguous**.



# ğŸŒ Brute Force Approach (What NOT to do)

âŒ Store only inorder/preorder
âŒ Ignore null nodes
âŒ Try to â€œguessâ€ structure

All lead to:

* Information loss
* Impossible reconstruction



# âœ… Optimal Approach (BFS with Null Markers)

### ğŸ”¥ Strategy

* Use **level order traversal**
* Convert nodes into string
* Use `#` for nulls
* While decoding, rebuild using queue

This is the **industry standard solution**.



## âœ… The Code (Implementation)

### ğŸ”¹ Serialize

```cpp
string serialize(TreeNode* root) {
    if (!root)
        return "";
    
    string res = "";
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* curNode = q.front();
        q.pop();

        if (curNode == nullptr) {
            res += "#,";
        } 
        else {
            res += to_string(curNode->val) + ",";
            q.push(curNode->left);
            q.push(curNode->right);
        }
    }
    return res;
}
```



### ğŸ”¹ Deserialize

```cpp
TreeNode* deserialize(string data) {
    if (data.empty()) {
        return nullptr;
    }

    stringstream s(data);
    string str;
    getline(s, str, ',');

    TreeNode* root = new TreeNode(stoi(str));
    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();

        getline(s, str, ',');
        if (str != "#") {
            TreeNode* leftNode = new TreeNode(stoi(str));
            node->left = leftNode;
            q.push(leftNode);
        }

        getline(s, str, ',');
        if (str != "#") {
            TreeNode* rightNode = new TreeNode(stoi(str));
            node->right = rightNode;
            q.push(rightNode);
        }
    }
    return root;
}
```



## ğŸ§  Algorithm (Step-by-Step)

### ğŸ”¹ Serialization

```
If root is null â†’ return empty string

Queue â† root
While queue not empty:
    pop node
    If node is null:
        append "#,"
    Else:
        append node value
        push left
        push right
```



### ğŸ”¹ Deserialization

```
Read first value â†’ root
Queue â† root

While queue not empty:
    pop node
    read left value
    if not "#":
        create left node
        push it

    read right value
    if not "#":
        create right node
        push it
```



## ğŸ”‘ Why BFS is perfect here

* Maintains structure level-by-level
* Naturally aligns with how trees are built
* Easier than DFS for decoding



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(N)** |

Where:

* `N` = number of nodes



## ğŸ§ª Test Cases

| Tree        | Serialized  | Works? |
| -- | -- | - |
| Empty       | ""          | âœ”ï¸     |
| Single node | "1,#,#,"    | âœ”ï¸     |
| Balanced    | long string | âœ”ï¸     |
| Skewed      | many #      | âœ”ï¸     |



## ğŸ§  Key Observations

* Null markers are mandatory
* BFS keeps structure intact
* Works for all tree shapes
* This is reversible encoding



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ DFS-based Serialization

Use preorder + "#"

### 2ï¸âƒ£ Serialize BST

Can be done without nulls

### 3ï¸âƒ£ Serialize N-ary Tree

Generalization

### 4ï¸âƒ£ File System Serialization

Same idea conceptually




# â“ FAQs

### Q1: Why do we need `#`?

To preserve tree structure. Without it, reconstruction is impossible.



### Q2: Why not use preorder?

You can â€” but decoding is more complex.



### Q3: Is this used in real systems?

Yes âœ”ï¸
This is how trees are stored in:

* Databases
* Caches
* Distributed systems



### Q4: Is the format fixed?

No â€” any consistent format is acceptable.



### Q5: Is this a hard problem?

Conceptually yes.
Implementation-wise, BFS makes it elegant.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Use BFS
Store values + nulls
Use delimiter
Rebuild with queue
```
