# ğŸŒ³ Postorder Traversal in Binary Tree (BT) [#145](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, return the **postorder traversal** of its nodesâ€™ values.

ğŸ‘‰ **Postorder Traversal Order**:

```
Left â†’ Right â†’ Root
```



## ğŸ§  Why Postorder Traversal matters

Postorder traversal is the **most powerful** of the three DFS traversals ğŸ’ª
It processes **children before the parent**, making it perfect for:

* **Deleting / freeing a tree** ğŸ—‘ï¸
* **Evaluating expression trees**
* **Bottom-up problems**:

  * Height
  * Diameter
  * Balanced tree check
  * DP on trees

If preorder is â€œannounce firstâ€
and inorder is â€œprocess in betweenâ€
then postorder is:

> â€œIâ€™ll deal with everything below me firstâ€¦ then myself.â€ ğŸ˜Œ



## ğŸ‘€ Example

Binary Tree:

```
        1
       / \
      2   3
     / \
    4   5
```

### Postorder Traversal Output

```
4 5 2 3 1
```



## ğŸ§© Intuition (key understanding)

At every node:

1. Fully traverse the **left subtree**
2. Fully traverse the **right subtree**
3. **Process the current node**

This guarantees that when a node is visited, **both its children are already handled**.

Thatâ€™s why postorder is used in **destructive and DP-based tree problems**.



# âœ… Given Code (Your Implementation)

### ğŸ’» Code

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> arr;
        recPostorder(root, arr);
        return arr;
    }

    void recPostorder(TreeNode* root, vector<int> &arr) {
        if (root == nullptr)
            return;

        recPostorder(root->left, arr);
        recPostorder(root->right, arr);
        arr.push_back(root->val);
    }
};
```



## âœ… Code Review & Validation ğŸ§

âœ”ï¸ **Correctness**:

* Visits nodes in **Left â†’ Right â†’ Root** order
* Handles `nullptr` safely
* Passes vector by reference (efficient)

âœ”ï¸ **No changes needed**
Your implementation is **clean, optimal, and interview-acceptable**.



## ğŸ§  Algorithm (Recursive â€“ Optimal)

### ğŸ’¡ Steps

```
If root is NULL:
    return

Postorder(root.left)
Postorder(root.right)
Visit root
```



## ğŸŒ Brute Force Approach (Conceptual)

Thereâ€™s no real brute-force traversal, but beginners often:

* Use extra arrays to reverse preorder
* Overcomplicate recursion
* Forget base cases

ğŸ‘‰ Your recursive solution is already **optimal**.



# ğŸ” Alternative Approaches (Important for Interviews)

## 1ï¸âƒ£ Recursive Postorder Traversal ğŸŒ± (Your code)

âœ”ï¸ Best for clarity
âœ”ï¸ Easy to write
âŒ Risk of stack overflow for deep trees



### â± Complexity

* **Time:** O(N)
* **Space:** O(H) recursion stack



## 2ï¸âƒ£ Iterative Postorder Traversal (Using Two Stacks) ğŸ§±

ğŸ”¥ Very common interview follow-up



### ğŸ§  Intuition

Postorder = Left â†’ Right â†’ Root
If we do:

```
Root â†’ Right â†’ Left
```

and then **reverse it**, we get postorder ğŸ˜



### ğŸ’¡ Algorithm

1. Push root to stack1
2. Pop from stack1 â†’ push to stack2
3. Push left & right children to stack1
4. Reverse stack2



### ğŸ’» Code (C++)

```cpp
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    if (!root) return result;

    stack<TreeNode*> s1, s2;
    s1.push(root);

    while (!s1.empty()) {
        TreeNode* curr = s1.top();
        s1.pop();
        s2.push(curr);

        if (curr->left) s1.push(curr->left);
        if (curr->right) s1.push(curr->right);
    }

    while (!s2.empty()) {
        result.push_back(s2.top()->val);
        s2.pop();
    }

    return result;
}
```



### â± Complexity

* **Time:** O(N)
* **Space:** O(N)



## 3ï¸âƒ£ Iterative Postorder (Single Stack) ğŸ§ ğŸ’¥

âš ï¸ Harder, but very impressive if you can explain it



### ğŸ§  Idea

* Track last visited node
* Peek stack top to decide direction



### ğŸ’» Code (Advanced)

```cpp
vector<int> postorderTraversal(TreeNode* root) {
    vector<int> result;
    stack<TreeNode*> st;
    TreeNode* curr = root;
    TreeNode* lastVisited = nullptr;

    while (curr || !st.empty()) {
        if (curr) {
            st.push(curr);
            curr = curr->left;
        } else {
            TreeNode* peek = st.top();
            if (peek->right && lastVisited != peek->right) {
                curr = peek->right;
            } else {
                result.push_back(peek->val);
                lastVisited = peek;
                st.pop();
            }
        }
    }
    return result;
}
```



## 4ï¸âƒ£ Morris Postorder Traversal ğŸŒŸ (O(1) Space)

ğŸ§  Jedi-level traversal
Used **very rarely**, but good to know it exists.

* Uses temporary threads
* Reverses right boundary paths
* Complex & error-prone

ğŸ‘‰ Usually **not required in interviews** unless explicitly asked.



# ğŸ§ª Test Cases

| Tree          | Output                 |
| - | - |
| Empty tree    | []                     |
| Single node   | [1]                    |
| Left skewed   | bottom â†’ root          |
| Right skewed  | bottom â†’ root          |
| Balanced tree | children before parent |



# ğŸ§  Key Observations

* Root is always **last**
* Postorder is **bottom-up**
* Ideal for:

  * Tree deletion
  * DP on trees
  * Height / diameter problems



# ğŸš€ Common Variations & Uses

* Delete Binary Tree
* Evaluate Expression Tree
* Check if tree is balanced
* Diameter of tree
* Maximum path sum
* Serialize tree (with markers)



# â“ FAQs

### Q1: Why is postorder harder than inorder/preorder?

Because root comes **last**, making iterative solutions tricky.



### Q2: Is recursion always safe?

No.
For deep trees (degenerate), recursion can cause **stack overflow**.



### Q3: Which iterative approach should I remember?

* Two stacks â†’ easiest
* One stack â†’ advanced
* Morris â†’ optional flex



### Q4: Can postorder be derived from preorder?

Yes:

```
Postorder = reverse( Preorder with Left & Right swapped )
```



### Q5: Is postorder traversal used in BST sorting?

No.
Only **inorder** gives sorted order for BST.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Postorder = Left â†’ Right â†’ Root
Recursive = simplest
Iterative = tricky
Best for bottom-up problems
```
