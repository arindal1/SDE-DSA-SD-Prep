# ğŸŒ³ Preorder Traversal in Binary Tree (Iterative using Stack) [#144](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, return the **preorder traversal** of its nodesâ€™ values **without using recursion**.

ğŸ‘‰ **Preorder Traversal Order**:

```
Root â†’ Left â†’ Right
```



## ğŸ§  Why Iterative Preorder Traversal matters

While recursive preorder is easy, **interviewers often ask for the iterative version** to test:

* Understanding of **DFS mechanics**
* Stack usage
* Control over traversal order
* Avoiding recursion stack overflow

Think of it as:

> â€œCan you simulate recursion manually?â€ ğŸ§ ğŸ’ª



## ğŸ‘€ Example

Binary Tree:

```
        1
       / \
      2   3
     / \
    4   5
```

### Preorder Output

```
1 2 4 5 3
```



## ğŸ§© Intuition (the real trick)

Preorder means:

1. Visit root
2. Go left
3. Go right

But stacks are **LIFO (Last In, First Out)**.

So to process **left first**, we must:

* Push **right child first**
* Push **left child after**

That way:

```
Left child is popped before right child
```

This single idea is the heart of iterative preorder traversal ğŸ”‘



# âœ… Given Code (Your Implementation)

### ğŸ’» Code

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> preorder;
        
        if(root == nullptr) {
            return preorder;
        }
        
        stack<TreeNode*> st;
        st.push(root);
        
        while(!st.empty()) {
            root = st.top();
            st.pop();
            
            preorder.push_back(root->val);
            
            if(root->right != nullptr) {
                st.push(root->right);
            }
            
            if(root->left != nullptr) {
                st.push(root->left);
            }
        }
        
        return preorder;
    }
};
```



## âœ… Code Review & Validation ğŸ§

âœ”ï¸ **Correct traversal order**
âœ”ï¸ Proper stack usage
âœ”ï¸ Handles `nullptr` safely
âœ”ï¸ Pushes right child **before** left (crucial!)
âœ”ï¸ Optimal time and space complexity

ğŸ‘‰ **No changes required** â€” this is an **ideal interview answer**.



## ğŸ§  Algorithm (Iterative Preorder)

### ğŸ’¡ Step-by-step

1. If tree is empty â†’ return empty result
2. Push root onto stack
3. While stack is not empty:

   * Pop the top node
   * Visit it
   * Push right child (if exists)
   * Push left child (if exists)



### âœ¨ Why this works

* Stack simulates recursive DFS
* Right child pushed first â†’ left child processed first
* Each node visited **exactly once**



## ğŸŒ Brute Force Approach (Conceptual)

Some beginners try:

* Recursive traversal + extra data structures
* Reversing other traversals

All unnecessary âŒ
Your stack-based solution is already **optimal and clean**.



# â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of the tree

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



# ğŸ§ª Test Cases

| Tree Type     | Output           |
| - | - |
| Empty tree    | []               |
| Single node   | [1]              |
| Left skewed   | root â†’ bottom    |
| Right skewed  | root â†’ bottom    |
| Balanced tree | Root-first order |



# ğŸ§  Key Observations

* Root is always processed **first**
* Stack replaces recursion
* Order of pushing children is **critical**
* Same logic works for tree copying & serialization



# ğŸš€ Common Variations & Related Problems

### 1ï¸âƒ£ Recursive Preorder Traversal

Simpler, but uses recursion stack

### 2ï¸âƒ£ Morris Preorder Traversal

* O(1) space
* Temporarily modifies tree
* Rarely required

### 3ï¸âƒ£ Construct Tree from Preorder + Inorder

Very popular interview problem

### 4ï¸âƒ£ Serialize / Deserialize Binary Tree

Preorder traversal is often used



# âš ï¸ Common Mistakes (Interview Traps)

âŒ Pushing left child before right
â†’ Output becomes **Root â†’ Right â†’ Left**

âŒ Forgetting null check
â†’ Runtime error

âŒ Assuming stack behaves like queue
â†’ Traversal breaks



# â“ FAQs

### Q1: Why push right before left?

Because stack is LIFO.
Pushing right first ensures left is processed first.



### Q2: Is this DFS or BFS?

**DFS**
Even though we use a stack, traversal goes deep before wide.



### Q3: Is recursion better than iterative?

* Recursive â†’ cleaner
* Iterative â†’ safer for deep trees
* Interviewers often prefer iterative



### Q4: Can preorder traversal sort a BST?

No âŒ
Only **inorder traversal** gives sorted output for BST.



### Q5: Can this cause stack overflow?

No recursion â†’ no recursion stack overflow
But stack memory still grows to O(N) in worst case.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Preorder = Root â†’ Left â†’ Right
Use stack
Push right child first
Each node visited once
```
