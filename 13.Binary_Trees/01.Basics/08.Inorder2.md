

# ğŸŒ³ Inorder Traversal in Binary Tree (Iterative using Stack) [#94](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, perform **inorder traversal** *without recursion* and return the list of node values.

ğŸ‘‰ **Inorder Traversal Order**:

```
Left â†’ Root â†’ Right
```



## ğŸ§  Why Iterative Inorder Traversal matters

Recursive inorder is easy.
Iterative inorder is where interviewers check whether you **actually understand traversal mechanics** ğŸ§ 

This pattern is used in:

* Tree traversals without recursion
* BST problems (kth smallest, validation)
* Avoiding stack overflow in deep trees

Think of it as:

> â€œManually doing what recursion does automatically.â€ ğŸ› ï¸



## ğŸ‘€ Example

Binary Tree:

```
        1
       / \
      2   3
     / \
    4   5
```

### Inorder Output

```
4 2 5 1 3
```



## ğŸ§© Core Intuition (MOST IMPORTANT PART)

In inorder traversal:

1. You must go **as left as possible**
2. Only when left is done, you **process the node**
3. Then you move to the **right subtree**

The stack is used to:

* **Remember the path back**
* Simulate recursive calls


## âœ… Cpp Code

```cpp
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> inorder;
    stack<TreeNode*> st;
    TreeNode* node = root;

    while (node != nullptr || !st.empty()) {
        if (node != nullptr) {
            st.push(node);
            node = node->left;
        } else {
            node = st.top();
            st.pop();
            inorder.push_back(node->val);
            node = node->right;
        }
    }
    return inorder;
}
```



# ğŸ§  Algorithm (Iterative Inorder)

### ğŸ’¡ Step-by-step

1. Start from root
2. Push all left children into stack
3. When leftmost is reached:

   * Pop from stack
   * Visit node
   * Move to right child
4. Repeat until stack is empty and node is null



### ğŸ”‘ Why this works

* Stack stores **ancestors**
* Ensures **Left â†’ Root â†’ Right** order
* Each node is pushed & popped **exactly once**



## ğŸŒ Brute Force Approach (Conceptual)

A bad approach would be:

* Compute height
* For each level, traverse whole tree

âŒ O(NÂ²), unnecessary
ğŸ‘‰ Stack-based inorder is optimal



# â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree

Worst case (degenerate tree):
ğŸ‘‰ Space = O(N)



# ğŸ§ª Test Cases

| Tree         | Output           |
| - | - |
| Empty tree   | []               |
| Single node  | [1]              |
| Left skewed  | ascending        |
| Right skewed | same as preorder |
| BST          | sorted order     |



# ğŸ§  Key Observations

* Stack replaces recursion
* Order of operations is critical
* Inorder traversal of BST â†’ **sorted sequence**
* Each node is visited once



# âš ï¸ Common Mistakes (VERY IMPORTANT)

âŒ Forgetting `node != nullptr` condition

âŒ Using wrong data member (`data` vs `val`)

âŒ Popping before reaching leftmost node

âŒ Confusing inorder with preorder logic



# ğŸš€ Variations & Related Problems

* Kth smallest element in BST
* Validate BST
* Recover swapped BST
* Inorder successor / predecessor
* Tree flattening



# â“ FAQs

### Q1: Why not just use recursion?

Recursion is simpler, but:

* Uses call stack
* Can overflow for deep trees

Iterative gives **better control**



### Q2: Why do we go left first?

Because inorder demands **Left â†’ Root â†’ Right**



### Q3: Is this DFS or BFS?

DFS âœ”ï¸
Stack-based depth-first traversal



### Q4: Can this be done without stack or recursion?

Yes â€” **Morris Traversal** (O(1) space)



### Q5: Is this pattern reusable?

YES.
This pattern appears everywhere in tree problems.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Inorder = Left â†’ Root â†’ Right
Push left nodes first
Stack remembers parents
Process node when popping
```

