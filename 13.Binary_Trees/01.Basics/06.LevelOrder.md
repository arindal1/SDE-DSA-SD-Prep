

# ğŸŒ³ Level Order Traversal in Binary Tree (BFS) [#102](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)

## ğŸ“Œ Problem Statement

Given the **root of a Binary Tree**, return its **Level Order Traversal** â€”
i.e., return the node values **level by level from left to right**.

ğŸ‘‰ Each level should be stored in a **separate list**.



## ğŸ§  Why Level Order Traversal matters

Level order traversal is the **only traversal that uses BFS** instead of DFS.

Itâ€™s extremely useful for:

* Printing trees **level-wise**
* Finding **minimum depth**
* Checking **completeness**
* Solving **distance-based** problems
* Zigzag traversal, vertical traversal, views (top, bottom, left, right)

Think of it as:

> â€œScan the tree the way a printer prints a page â€” line by line.â€ ğŸ–¨ï¸



## ğŸ‘€ Example

Binary Tree:

```
        1
       / \
      2   3
     / \   \
    4   5   6
```

### Level Order Output

```
[
  [1],
  [2, 3],
  [4, 5, 6]
]
```



## ğŸ§© Intuition (the key idea)

Level Order Traversal explores nodes:

1. **Level by level**
2. **Left to right within each level**

To do this, we need a **queue**:

* First in â†’ First out
* Perfect for breadth-first exploration



# âœ… Given Code (Your Implementation)

### ğŸ’» Code

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans; 
        if (root == nullptr) {
            return ans; 
        }
        
        queue<TreeNode*> q;
        q.push(root); 

        while (!q.empty()) {
            int size = q.size(); 
            vector<int> level; 

            for (int i = 0; i < size; i++) {
                TreeNode* node = q.front();
                q.pop();
                level.push_back(node->val); 

                if (node->left != nullptr) {
                    q.push(node->left);
                }
                if (node->right != nullptr) {
                    q.push(node->right);
                }
            }
            ans.push_back(level); 
        }
        return ans;
    }
};
```



## âœ… Code Review & Validation ğŸ§

âœ”ï¸ **Correct traversal order**
âœ”ï¸ Uses **queue** (BFS)
âœ”ï¸ Correctly separates levels using `size = q.size()`
âœ”ï¸ Handles `nullptr` root safely
âœ”ï¸ Optimal time & space complexity

ğŸ‘‰ **No modification needed** â€” this is textbook-perfect BFS.



## ğŸ§  Algorithm (Level-by-Level BFS)

### ğŸ’¡ Step-by-step

1. If tree is empty â†’ return empty list
2. Push root into queue
3. While queue is not empty:

   * Capture current queue size (nodes in this level)
   * Process exactly that many nodes
   * Push children into queue
4. Store each level separately



### ğŸ§  Why `size = q.size()` is important

It locks the **current level boundary**
New nodes added to the queue belong to the **next level**.

Without this â†’ all nodes mix together ğŸ˜µâ€ğŸ’«



# ğŸŒ Brute Force Approach (Conceptual)

You *could*:

* Calculate height of tree
* For each level, traverse entire tree to collect nodes

âŒ That would be **O(NÂ²)**
ğŸ‘‰ BFS does it cleanly in **O(N)**



# â± Complexity Analysis

| Metric           | Value                     |
| - | - |
| Time Complexity  | **O(N)**                  |
| Space Complexity | **O(N)** (queue + output) |

Worst case:

* Complete tree â†’ queue holds ~N/2 nodes



# ğŸ§ª Test Cases

| Tree          | Output                 |
| - | - |
| Empty tree    | []                     |
| Single node   | [[1]]                  |
| Left skewed   | [[1], [2], [3]]        |
| Right skewed  | [[1], [2], [3]]        |
| Complete tree | Clean level separation |



# ğŸ§  Key Observations

* BFS â‰  DFS
* Queue is mandatory
* Level separation comes from queue size
* Great for **shortest path** & **minimum depth**



# ğŸš€ Important Variations (VERY common in interviews)

### 1ï¸âƒ£ Zigzag Level Order Traversal

```
Level 0 â†’ left to right
Level 1 â†’ right to left
```

### 2ï¸âƒ£ Reverse Level Order

Bottom â†’ Top

### 3ï¸âƒ£ Average of Levels

Return average value at each level

### 4ï¸âƒ£ Left / Right / Top / Bottom View

All built on top of BFS

### 5ï¸âƒ£ Level Order without extra space

(Using recursion + height)
âŒ Not recommended



# ğŸ”„ Common Modifications

### ğŸ”¹ Zigzag Example Snippet

```cpp
if (levelIndex % 2 == 1)
    reverse(level.begin(), level.end());
```



# â“ FAQs

### Q1: Why not use recursion for level order?

You can, but:

* Requires height calculation
* Less efficient
* More complex

BFS is cleaner âœ”ï¸



### Q2: Is this traversal DFS or BFS?

**BFS (Breadth First Search)**



### Q3: Can this be done with a stack?

No âŒ
Stacks are LIFO â†’ DFS
Queues are FIFO â†’ BFS



### Q4: What happens if we skip `size = q.size()`?

All nodes collapse into one level ğŸ˜¬



### Q5: Is this traversal stable?

Yes. Left child always comes before right child.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Level Order = BFS
Uses Queue
Process level by level
size = q.size() defines level boundary
```
