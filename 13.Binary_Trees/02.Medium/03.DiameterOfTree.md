# ğŸŒ³ Diameter of a Binary Tree [#543](https://leetcode.com/problems/diameter-of-binary-tree/description/)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return the **diameter of the tree**.

ğŸ‘‰ **Diameter** is defined as:

> The **length of the longest path between any two nodes** in the tree.

âš ï¸ Important:

* The path **may or may not pass through the root**
* Diameter is measured in **number of edges**, not nodes (LeetCode convention)



## ğŸ§  Why this problem matters

This problem is a **classic interview favorite** because it tests:

* Postorder DFS
* Tree Dynamic Programming
* Avoiding repeated computations
* Understanding that **global answer â‰  local height**

If you understand this problem, you understand **50% of advanced tree problems** ğŸ’ª



## ğŸ‘€ Example

### Example Tree

```
        1
       / \
      2   3
     / \
    4   5
```

### Longest Path

```
4 â†’ 2 â†’ 5
```

### Diameter = **2 edges**



## ğŸ§© Key Insight (MOST IMPORTANT)

At **every node**, the longest path **through that node** is:

```
leftHeight + rightHeight
```

But the **overall diameter** is the **maximum** such value across **all nodes**.

So we must:

* Compute height
* Update diameter
* Do both in **one DFS**

Thatâ€™s the trick ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (What NOT to do)

### âŒ Naive Idea

For every node:

* Compute height of left subtree â†’ O(N)
* Compute height of right subtree â†’ O(N)
* Update diameter

Repeat for all nodes âŒ



### âŒ Complexity

```
O(NÂ²)
```

Interviewers âŒ this immediately ğŸ˜¬



# âœ… Optimal Approach (Single DFS â€“ Tree DP)

### ğŸ”¥ Key Idea

Use **postorder traversal**:

* First compute left & right heights
* Update diameter
* Return height to parent



## âœ… Given Code (Your Implementation)

### ğŸ’» Code

```cpp
class Solution {
public:
    int diameter = 0;

    int diameterOfBinaryTree(TreeNode* root) {
        dia(root);
        return diameter;
    }

    int dia(TreeNode* node) {
        if (!node) {
            return 0;
        }

        int lh = dia(node->left);
        int rh = dia(node->right);

        diameter = max(diameter, lh + rh);
        return 1 + max(lh, rh);
    }
};
```




## ğŸ§  Algorithm (Postorder DFS)

### ğŸ’¡ Steps

```
dfs(node):
    if node is null:
        return 0

    leftHeight = dfs(left)
    rightHeight = dfs(right)

    diameter = max(diameter, leftHeight + rightHeight)

    return 1 + max(leftHeight, rightHeight)
```

Final Answer = `diameter`



## ğŸ”‘ Why Postorder?

Because:

* Height depends on children
* Diameter depends on children
* Bottom-up is mandatory

Postorder = tree DP ğŸ§ 



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree

Worst case (skewed tree):
ğŸ‘‰ Space = O(N)



## ğŸ§ª Test Cases

| Tree          | Diameter |
| - | -- |
| Empty tree    | 0        |
| Single node   | 0        |
| Two nodes     | 1        |
| Balanced tree | depends  |
| Skewed tree   | N âˆ’ 1    |



## ğŸ§  Key Observations

* Diameter does **not** always pass through root
* Height and diameter are different concepts
* Count edges, not nodes
* Single DFS is the goal



# ğŸš€ Common Variations & Follow-ups

### 1ï¸âƒ£ Diameter in terms of nodes

Return `diameter + 1`

### 2ï¸âƒ£ Maximum Path Sum

More complex version of this problem

### 3ï¸âƒ£ Longest ZigZag Path

DFS with state

### 4ï¸âƒ£ Diameter of N-ary Tree

Same idea, more children



# â“ FAQs

### Q1: Why `lh + rh`?

Because the longest path through a node connects the **deepest node in left subtree** to the **deepest node in right subtree**.



### Q2: Why diameter starts at 0?

Single node has no edges â†’ diameter = 0



### Q3: Can this be solved using BFS?

Not efficiently âŒ
DFS is the natural approach.



### Q4: Is recursion safe?

For skewed trees â†’ risk of stack overflow
But acceptable for most constraints.



### Q5: Is this a Tree DP problem?

Yes âœ”ï¸
One of the **cleanest examples**.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Diameter = longest path between any two nodes
At each node â†’ lh + rh
Use postorder DFS
Time = O(N)
```
