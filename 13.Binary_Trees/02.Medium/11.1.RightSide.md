

# ğŸŒ³ Right Side View of a Binary Tree [#199](https://leetcode.com/problems/binary-tree-right-side-view/description/)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return the **values of the nodes visible from the right side**, ordered from **top to bottom**.

ğŸ‘‰ Imagine standing on the **right side** of the tree and looking at it.
What nodes can you see?



## ğŸ§  Why this problem matters

This problem is important because it tests:

* **Level order traversal (BFS)**
* Understanding of **level boundaries**
* How to extract **one special node per level**

Itâ€™s also a gateway problem for:

* Left view
* Top view
* Bottom view
* Vertical traversal

Think of it as:

> â€œWhoâ€™s the last person visible in each row?â€ ğŸ‘€â¡ï¸ğŸŒ³



## ğŸ‘€ Example

### Input Tree

```
        1
       / \
      2   3
       \   \
        5   4
```

### Right Side View Output

```
[1, 3, 4]
```

Why?

* Level 0 â†’ 1
* Level 1 â†’ 3
* Level 2 â†’ 4



## ğŸ§© Intuition (the key idea)

If you traverse the tree **level by level**:

* Each level has multiple nodes
* The **last node processed at that level** is the one visible from the right

So the problem becomes:

> â€œFor every level, take the **last node**.â€

Thatâ€™s it. Simple and elegant ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Naive Idea

* For each level, scan the entire tree
* Track depth manually
* Store the rightmost node per depth

âŒ Complicated
âŒ Inefficient
âŒ Unnecessary



# âœ… Optimal Approach (BFS / Level Order Traversal)

### ğŸ”¥ Key Insight

* Use a queue for BFS
* Process **one level at a time**
* Add the value of the **last node of each level** to the result


### ğŸ’» Code

```cpp
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if (!root)
            return res;

        queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            int level = q.size();

            for (int i = 0; i < level; ++i) {
                TreeNode* node = q.front();
                q.pop();

                if (i == level - 1)
                    res.push_back(node->val);

                if (node->left)
                    q.push(node->left);
                if (node->right)
                    q.push(node->right);
            }
        }
        return res;
    }
};
```



## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
If root is null:
    return empty list

Push root into queue

While queue is not empty:
    levelSize = queue size

    For i from 0 to levelSize - 1:
        pop node from queue

        if i == levelSize - 1:
            add node value to result

        push left child if exists
        push right child if exists
```



## ğŸ”‘ Why this works

* BFS guarantees nodes are processed **level by level**
* Queue size fixes the boundary of the current level
* Last node processed = rightmost visible node



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(N)** |

Where:

* `N` = number of nodes

Queue can hold up to a full level of nodes.



## ğŸ§ª Test Cases

| Tree          | Output              |
| - | - |
| Empty tree    | []                  |
| Single node   | [1]                 |
| Balanced tree | Rightmost per level |
| Left skewed   | All nodes           |
| Right skewed  | All nodes           |



## ğŸ§  Key Observations

* This is a **view**, not a traversal
* One node per level is enough
* BFS makes level handling easy
* Order of pushing children doesnâ€™t matter here



# ğŸš€ Alternative Approaches (Good to Know)

### 1ï¸âƒ£ DFS (Right-first Preorder)

Visit right child before left and record first visit per depth.

```cpp
void dfs(TreeNode* node, int depth, vector<int>& res) {
    if (!node) return;

    if (depth == res.size())
        res.push_back(node->val);

    dfs(node->right, depth + 1, res);
    dfs(node->left, depth + 1, res);
}
```



### 2ï¸âƒ£ Left Side View

Just record the **first node** of each level instead of the last.





# â“ FAQs

### Q1: Why is BFS preferred here?

Because the problem is **level-based**.
DFS works too, but BFS is more intuitive.



### Q2: Does pushing left before right matter?

No âŒ
Since we explicitly take the **last node**, order doesnâ€™t affect correctness.



### Q3: Can this be solved in one DFS?

Yes âœ”ï¸
But BFS is simpler to explain.



### Q4: Is this problem related to tree traversal?

Indirectly.
Itâ€™s more about **tree visualization**.



### Q5: Whatâ€™s the difference between right view and bottom view?

* **Right view** â†’ last node per level
* **Bottom view** â†’ lowest node per vertical line



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Right View = last node of each level
Use BFS
Queue size defines level
Time = O(N)
```

