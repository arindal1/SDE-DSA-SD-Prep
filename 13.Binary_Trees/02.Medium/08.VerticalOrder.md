


# ğŸŒ³ Vertical Order Traversal of a Binary Tree [#987](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return its **vertical order traversal**.

ğŸ‘‰ Vertical traversal rules:

1. Nodes are grouped by **vertical column**
2. Columns are ordered **from left to right**
3. Within the same column:

   * Nodes are ordered **top to bottom**
   * If multiple nodes share the same position, they are ordered by **value**



## ğŸ§  Why this problem matters

This problem tests:

* BFS with **coordinates**
* Ordered data structures (`map`, `multiset`)
* Careful interpretation of problem constraints

Itâ€™s a **perfect storm** of:

> Trees + BFS + sorting + edge cases ğŸŒªï¸ğŸŒ³



## ğŸ‘€ Visual Intuition (VERY IMPORTANT)

We assign **coordinates** to each node:

* Root â†’ `(x = 0, y = 0)`
* Left child â†’ `(x - 1, y + 1)`
* Right child â†’ `(x + 1, y + 1)`

```
            3 (0,0)
           /       \
     9 (-1,1)     20 (1,1)
                   /    \
            15 (0,2)   7 (2,2)
```

### Expected Output

```
[
  [9],
  [3, 15],
  [20],
  [7]
]
```



## ğŸ§© Core Intuition (the real trick)

We must sort nodes by **three keys**:

1. **Column (x)** â†’ left to right
2. **Row (y)** â†’ top to bottom
3. **Value** â†’ ascending (only if same x & y)

So we need a data structure that preserves **nested ordering**.

ğŸ‘‰ Thatâ€™s why we use:

```
map<x, map<y, multiset<values>>>
```

This is the heart of the solution ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (What NOT to do)

### âŒ Naive Idea

* Assign coordinates
* Store all nodes in a list
* Sort by `(x, y, value)`

This works, but:

* More complex
* Manual sorting logic
* Less elegant in interviews



# âœ… Optimal Approach (BFS + Ordered Maps)

### ğŸ”¥ Strategy

1. BFS traversal to assign coordinates
2. Store nodes in ordered structure
3. Read structure column-by-column



### ğŸ’» Code

```cpp
class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        vector<vector<int>> res;
        if (!root)
            return res;

        map<int, map<int, multiset<int>>> nodes;
        queue<pair<TreeNode*, pair<int, int>>> todo;
        todo.push({root, {0, 0}});

        while (!todo.empty()) {
            auto q = todo.front();
            todo.pop();

            TreeNode* p = q.first;
            int x = q.second.first;
            int y = q.second.second;

            nodes[x][y].insert(p->val);

            if (p->left)
                todo.push({p->left, {x - 1, y + 1}});
            if (p->right)
                todo.push({p->right, {x + 1, y + 1}});
        }

        for (auto p : nodes) {
            vector<int> col;
            for (auto q : p.second) {
                col.insert(col.end(), q.second.begin(), q.second.end());
            }
            res.push_back(col);
        }

        return res;
    }
};
```



## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Step 1: BFS with Coordinates

```
Queue stores: (node, x, y)
Root â†’ (0,0)
Left â†’ (x-1, y+1)
Right â†’ (x+1, y+1)
```



### ğŸ’¡ Step 2: Store in Ordered Structure

```
nodes[x][y].insert(value)
```

* `map` keeps x sorted
* inner `map` keeps y sorted
* `multiset` keeps values sorted



### ğŸ’¡ Step 3: Build Answer

```
For each x (left â†’ right):
    For each y (top â†’ bottom):
        append all values
```



## ğŸ”‘ Why BFS (not DFS)?

DFS can work, but:

* BFS aligns naturally with level (`y`)
* Prevents stack overflow
* Easier to reason about ordering



## â± Complexity Analysis

| Metric           | Value          |
| - | -- |
| Time Complexity  | **O(N log N)** |
| Space Complexity | **O(N)**       |

Why `log N`?

* `map` and `multiset` insertions



## ğŸ§ª Test Cases

| Tree                    | Output               |
| -- | -- |
| Empty tree              | []                   |
| Single node             | [[node]]             |
| Same column, diff rows  | ordered by row       |
| Same (x,y), diff values | sorted by value      |
| Skewed tree             | one value per column |



## ğŸ§  Key Observations

* Vertical traversal â‰  vertical view
* Sorting rules matter
* BFS + map is the cleanest approach
* Multiset handles duplicates gracefully



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Vertical Order Traversal (without sorting by value)

Simpler version

### 2ï¸âƒ£ Top View of Binary Tree

First node per column

### 3ï¸âƒ£ Bottom View of Binary Tree

Last node per column

### 4ï¸âƒ£ Diagonal Traversal

Different coordinate system




# â“ FAQs

### Q1: Why use `multiset` instead of vector?

Because:

* Multiple nodes can share same `(x, y)`
* Values must be sorted automatically



### Q2: Can DFS be used?

Yes, but:

* More bookkeeping
* BFS is cleaner



### Q3: Is vertical traversal the same as vertical order?

No âŒ
Vertical traversal has **strict sorting rules**.



### Q4: Why not sort at the end?

You can, but nested maps simplify logic and reduce bugs.



### Q5: Is this problem hard?

Conceptually â€” yes ğŸ˜„
Implementation-wise â€” manageable with the right structure.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Assign (x,y) coordinates
Use map<x, map<y, multiset>>
BFS traversal
Read column by column
```


