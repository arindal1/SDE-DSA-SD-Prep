

# ğŸŒ³ Boundary Traversal of a Binary Tree - [GFG](https://www.geeksforgeeks.org/problems/boundary-traversal-of-binary-tree/1)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return its **boundary traversal** in **anti-clockwise order**, starting from the root.

### Boundary traversal includes:

1. **Root** (if not a leaf)
2. **Left boundary** (excluding leaves)
3. **All leaf nodes** (left to right)
4. **Right boundary** (excluding leaves, bottom to top)



## ğŸ§  Why this problem matters

This problem is a **composite traversal**:

* It mixes **iterative + recursive**
* It mixes **multiple traversal styles**
* It requires **strict ordering**

Interviewers love this because:

> You canâ€™t brute-force your way out ğŸ˜„



## ğŸ‘€ Example

### Input Tree

```
            1
          /   \
         2     3
        / \   / \
       4   5 6   7
          / \
         8   9
```

### Boundary Traversal Output

```
1 2 4 8 9 6 7 3
```

### Why?

* Root â†’ `1`
* Left boundary â†’ `2`
* Leaves â†’ `4 8 9 6 7`
* Right boundary (bottom-up) â†’ `3`



## ğŸ§© Core Intuition (VERY IMPORTANT)

Boundary traversal is **NOT** a single traversal.

It is the **combination of 3 traversals**:

1. Left boundary (top-down)
2. Leaves (DFS)
3. Right boundary (bottom-up)

And **no leaf should be printed twice** ğŸš«

This separation is the key ğŸ”‘



# ğŸŒ Brute Force Approach (What NOT to do)

### âŒ Naive Idea

* Do level order
* Track boundary nodes with flags
* Filter duplicates later

âŒ Complicated
âŒ Bug-prone
âŒ Interview disaster



# âœ… Optimal Approach

### ğŸ’» Full Code

```cpp
class Solution {
  public:
    vector<int> boundaryTraversal(Node *root) {
        vector<int> res;
        if (root == nullptr)
            return res;

        if (!isLeaf(root))
            res.push_back(root->data);
            
        boundLeft(root, res);
        leaves(root, res);
        boundRight(root, res);

        return res;
    }

private:
    bool isLeaf(Node* root) {
        return root->left == nullptr && root->right == nullptr;
    }
    
    void boundLeft(Node* root, vector<int> &res) {
        Node* cur = root->left;
        while (cur) {
            if (!isLeaf(cur))
                res.push_back(cur->data);
            if (cur->left)
                cur = cur->left;
            else
                cur = cur->right;
        }
    }
    
    void boundRight(Node* root, vector<int> &res) {
        Node* cur = root->right;
        vector<int> temp;

        while (cur) {
            if (!isLeaf(cur))
                temp.push_back(cur->data);
            if (cur->right)
                cur = cur->right;
            else
                cur = cur->left;
        }
        
        for (int i = temp.size() - 1; i >= 0; --i)
            res.push_back(temp[i]);
    }
    
    void leaves(Node* root, vector<int> &res) {
        if (isLeaf(root)) {
            res.push_back(root->data);
            return;
        }
        if (root->left)
            leaves(root->left, res);
        if (root->right)
            leaves(root->right, res);
    }
};
```



## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Step 1: Root

```
If root is not a leaf:
    add root
```



### ğŸ’¡ Step 2: Left Boundary (excluding leaves)

```
Start from root->left
Prefer left child
Fallback to right child
Stop at leaves
```



### ğŸ’¡ Step 3: All Leaf Nodes

```
DFS traversal
Add node if leaf
```



### ğŸ’¡ Step 4: Right Boundary (excluding leaves)

```
Start from root->right
Prefer right child
Fallback to left child
Store in temp
Reverse temp and append
```



## ğŸ”‘ Why this works

* Each node belongs to **only one category**
* Leaves are handled separately
* Right boundary reversal preserves anti-clockwise order



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree (recursion stack)



## ğŸ§ª Test Cases

| Tree Type     | Output          |
| - | - |
| Empty tree    | []              |
| Single node   | [node]          |
| Left skewed   | All nodes       |
| Right skewed  | All nodes       |
| Balanced tree | Proper boundary |



## ğŸ§  Key Observations

* Root is added **once**
* Leaves are added **once**
* Boundaries exclude leaves
* Order matters more than traversal type



# ğŸš€ Variations & Related Problems

* Left Boundary Traversal
* Right Boundary Traversal
* Tree Views (Left / Right / Top / Bottom)
* Perimeter of Binary Tree



# â“ FAQs

### Q1: Why exclude leaves in boundary functions?

Because leaves are handled **separately** to avoid duplicates.



### Q2: Why reverse right boundary?

Because boundary traversal is **anti-clockwise**.



### Q3: Is this BFS or DFS?

Both:

* Left & Right boundary â†’ iterative
* Leaves â†’ DFS



### Q4: Can this be done in one traversal?

Technically yes, but:

* Much harder
* More bug-prone
* Not interview-friendly



### Q5: Is boundary traversal unique?

Yes âœ”ï¸
Order is strictly defined.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Boundary = Root + LeftBoundary + Leaves + RightBoundary(reversed)
No leaf duplication
Anti-clockwise order
Time = O(N)
```

