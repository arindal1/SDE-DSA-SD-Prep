

# ğŸŒ³ Left View of a Binary Tree #[GFG](https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1)

## ğŸ“Œ Problem Statement

Given the **root of a binary tree**, return the **left view** of the tree.

ğŸ‘‰ The **left view** consists of the nodes visible when the tree is viewed from the **left side**.

* One node per level
* Output is ordered from **top to bottom**



## ğŸ§  Why this problem matters

This problem tests:

* Level order traversal (BFS)
* Correct handling of **level boundaries**
* Selecting the **first node per level**

Itâ€™s a close sibling of:

* Right View
* Top View
* Bottom View

Think of it as:

> â€œWho is standing at the **front of each row** when you look from the left?â€ ğŸ‘€â¬…ï¸ğŸŒ³



## ğŸ‘€ Example

### Input Tree

```
        1
       / \
      2   3
       \
        4
         \
          5
```

### Left View Output

```
[1, 2, 4, 5]
```



## ğŸ§© Core Intuition (key idea)

If you process the tree **level by level**:

* Each level has multiple nodes
* The **first node processed at that level** is visible from the left

So the rule becomes:

> For every level, pick the **first node**.

BFS makes this trivial ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (Conceptual)

### âŒ Naive Idea

* Track depth for each node
* Store nodes by depth
* Pick the leftmost one manually

âŒ Overcomplicated
âŒ Extra bookkeeping
âŒ Unnecessary



# âœ… Optimal Approach (BFS / Level Order Traversal)

### ğŸ”¥ Key Insight

* BFS naturally processes nodes level by level
* Queue size gives a **fixed boundary per level**
* First node in each level = left view node



### ğŸ’» Code

```cpp
class Solution {
  public:
    vector<int> leftView(Node *root) {
        vector<int> res;
        if (!root)
            return res;
            
        queue<Node*> q;
        q.push(root);
        
        while (!q.empty()) {
            int line = q.size();
            
            for (int i = 0; i < line; ++i) {
                Node* p = q.front();
                q.pop();
                
                if (i == 0) {
                    res.push_back(p->data);
                }
                
                if (p->left)
                    q.push(p->left);
                if (p->right)
                    q.push(p->right);
            }
        }
        return res;
    }
};
```




## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Steps

```
If root is null â†’ return empty list

Push root into queue

While queue is not empty:
    levelSize = queue size

    For i from 0 to levelSize - 1:
        pop node

        if i == 0:
            add node value to result

        push left child
        push right child
```



## ğŸ”‘ Why BFS works best

* BFS ensures **top-down traversal**
* Queue size locks the level
* No need to track depth explicitly

DFS can also work, but BFS is simpler.



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(N)** |

Queue can hold up to an entire level.



## ğŸ§ª Test Cases

| Tree          | Output        |
| - | - |
| Empty tree    | []            |
| Single node   | [node]        |
| Balanced tree | One per level |
| Left skewed   | All nodes     |
| Right skewed  | All nodes     |



## ğŸ§  Key Observations

* One node per level
* Order matters
* Left view â‰  top view
* BFS is intuitive here



# ğŸš€ Alternative Approach (DFS â€“ Preorder)

Sometimes interviewers ask:

> â€œCan you do this using DFS?â€



### ğŸ’» DFS Code (Left-first)

```cpp
void dfs(Node* node, int depth, vector<int>& res) {
    if (!node) return;

    if (depth == res.size())
        res.push_back(node->data);

    dfs(node->left, depth + 1, res);
    dfs(node->right, depth + 1, res);
}
```




# â“ FAQs

### Q1: Why does `i == 0` work?

Because itâ€™s the **first node processed** at that level.



### Q2: What if right child is pushed first?

Then left view breaks âŒ
Push left child before right child.



### Q3: Is left view always unique?

Yes âœ”ï¸
For a given tree, the left view is deterministic.



### Q4: Can unordered_map be used?

Not needed here â€” BFS avoids maps entirely.



### Q5: Is this problem easy or tricky?

Easy if you understand BFS.
Tricky if you donâ€™t ğŸ˜„



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Left View = first node per level
Use BFS
Queue size defines level
Push left before right
```

