
# ğŸŒ³ Construct Binary Tree from Preorder & Inorder Traversal [Leetcode #[105](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)]

## ğŸ“Œ Problem Statement

Given two arrays:

* **Preorder traversal** of a binary tree
* **Inorder traversal** of the same tree

Reconstruct and return the **original binary tree**.



## ğŸ§  Why this problem matters

This problem tests:

* Deep understanding of tree traversals
* Recursive tree construction
* Index math & subtree boundaries
* Time optimization using hashing

Itâ€™s a **core interview problem** â€” if you crack this, tree recursion becomes much easier ğŸ”“ğŸŒ³



## ğŸ‘€ Traversal Refresher (Quick)

### Preorder (Root â†’ Left â†’ Right)

```
[root, left..., right...]
```

### Inorder (Left â†’ Root â†’ Right)

```
[left..., root, right...]
```

ğŸ‘‰ These two together uniquely define a binary tree
(assuming **all values are unique**).



## ğŸ‘€ Example

### Input

```
Preorder = [3, 9, 20, 15, 7]
Inorder  = [9, 3, 15, 20, 7]
```

### Output Tree

```
        3
       / \
      9  20
         / \
        15  7
```



## ğŸ§© Core Intuition (THIS is the key ğŸ”‘)

### Step-by-step thinking:

1. **Preorder tells you the root**

   * First element of preorder is always the root

2. **Inorder tells you left & right subtrees**

   * Everything left of root â†’ left subtree
   * Everything right of root â†’ right subtree

3. **Size of left subtree** tells you how to split preorder

ğŸ‘‰ Recursively repeat this logic for subtrees.

This is a **divide & conquer** problem ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (Why itâ€™s slow)

### âŒ Naive Idea

* For every recursive call:

  * Linearly search root in inorder array

â›” Time Complexity: **O(NÂ²)**
â›” Will TLE for large inputs



# âœ… Optimal Approach (Recursion + Hash Map)

### ğŸ”¥ Key Insight

* Use a map to store inorder indices
* Lookup becomes O(1)
* Overall complexity improves drastically




### ğŸ’» Full Code

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        map<int, int> inMap;

        for (int i = 0; i < inorder.size(); i++) {
            inMap[inorder[i]] = i;
        }
        return build(preorder, 0, preorder.size() - 1,
                     inorder, 0, inorder.size() - 1,
                     inMap);
    }

private:
    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,
                    vector<int>& inorder, int inStart, int inEnd,
                    map<int, int>& inMap) {
        if (preStart > preEnd || inStart > inEnd)
            return nullptr;

        TreeNode* root = new TreeNode(preorder[preStart]);

        int inRoot = inMap[root->val];
        int numsLeft = inRoot - inStart;

        root->left = build(preorder,
                           preStart + 1,
                           preStart + numsLeft,
                           inorder,
                           inStart,
                           inRoot - 1,
                           inMap);

        root->right = build(preorder,
                            preStart + numsLeft + 1,
                            preEnd,
                            inorder,
                            inRoot + 1,
                            inEnd,
                            inMap);

        return root;
    }
};
```




## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Preprocessing

```
Create a map for inorder indices
```



### ğŸ’¡ Recursive Build

```
build(preStart, preEnd, inStart, inEnd):

    If indices invalid â†’ return null

    rootVal = preorder[preStart]
    Create root node

    inRoot = index of rootVal in inorder
    leftSize = inRoot - inStart

    Build left subtree
    Build right subtree

    Return root
```



## ğŸ”‘ Why this works

* Preorder gives root instantly
* Inorder splits tree perfectly
* Recursion builds tree bottom-up
* Hash map avoids repeated scans



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(N)** |

Where:

* `N` = number of nodes
* Space used by recursion stack + map



## ğŸ§ª Test Cases

| Preorder      | Inorder | Result      |
| - | - | -- |
| []            | []      | nullptr     |
| [1]           | [1]     | single node |
| Balanced tree | âœ”ï¸      | correct     |
| Skewed tree   | âœ”ï¸      | correct     |



## ğŸ§  Key Observations

* Values must be unique
* Boundaries are crucial
* Off-by-one errors are common
* Preorder index math is the trickiest part



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Construct from Inorder & Postorder

(Similar logic, root at end)

### 2ï¸âƒ£ Construct from Preorder & Postorder

(More constraints needed)

### 3ï¸âƒ£ Serialize & Deserialize Binary Tree

Advanced version of this idea





# â“ FAQs

### Q1: Why canâ€™t we use preorder alone?

Because preorder alone doesnâ€™t define structure uniquely.



### Q2: Why map instead of unordered_map?

Either works.
Map is fine, unordered_map is slightly faster.



### Q3: What if duplicates exist?

Tree cannot be uniquely reconstructed âŒ



### Q4: Is recursion mandatory?

Practically yes â€” iterative version is very complex.



### Q5: Is this asked in interviews?

Very frequently âœ”ï¸



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Preorder â†’ root
Inorder â†’ split
Map â†’ O(1) lookup
Recurse on left & right
```
