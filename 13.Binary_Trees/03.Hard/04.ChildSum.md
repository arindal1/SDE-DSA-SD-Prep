
# ğŸŒ³ Convert Binary Tree to Children Sum Tree

## ğŸ“Œ Problem Statement

Given a **binary tree**, modify it so that it satisfies the **Children Sum Property**:

> For every non-leaf node
>
> ```
> node->val = left child value + right child value
> ```

### Rules

* You are **allowed to increment node values**
* You are **NOT allowed to decrement any node value**
* Tree structure must remain unchanged
* Leaf nodes remain the same



## ğŸ§  Why this problem matters

This problem tests:

* Tree recursion
* Bottom-up thinking
* In-place tree transformation
* Handling constraints carefully (no decrement!)

Itâ€™s a **classic interview problem**, often asked as a follow-up to:

* Children Sum Property (validation)
* Sum Tree
* Tree DP

Think of it as:

> â€œFix the family budget â€” but youâ€™re only allowed to give more money, never take it awayâ€ ğŸ’¸ğŸŒ³



## ğŸ‘€ Example

### Input Tree

```
        50
       /  \
      7    2
     / \    \
    3   5    1
```

### Output Tree

```
        50
       /  \
     19    31
     / \     \
    14  5     1
```

âœ”ï¸ Every parent equals sum of children
âœ”ï¸ No value was decreased



## ğŸ§© Core Intuition (VERY IMPORTANT ğŸ”‘)

We fix the tree in **two phases** at every node:

### ğŸ”¹ Phase 1: Top-down correction

* If children sum is **greater** than parent â†’ increase parent
* If parent is **greater** â†’ push parentâ€™s value down to children

### ğŸ”¹ Phase 2: Bottom-up correction

* After fixing subtrees, recompute parent as:

```
parent = left child + right child
```

This ensures:

* Constraint is satisfied
* No values are decreased
* Tree is fixed bottom-up



# ğŸŒ Brute Force Approach (What NOT to do)

âŒ Rebuild the tree
âŒ Use extra memory
âŒ Try to decrement values

All violate constraints or overcomplicate things.



# âœ… Optimal Approach (DFS + Postorder Fix)

Your solution uses:

* DFS
* Preorder adjustment
* Postorder recomputation

This is **exactly what interviewers expect** âœ…




```cpp
void checkChild (TreeNode* root) {
    if (!root)
        return;

    int child = 0;
    if (root->left)
        child += root->left->val;
    if (root->right)
        child += root->right->val;

    // Step 1: Push value down if needed
    if (child > root->val)
        root->val = child;
    else {
        if (root->left)
            root->left->val = root->val;
        else if (root->right)
            root->right->val = root->val;
    }

    // Step 2: Fix subtrees
    checkChild(root->left);
    checkChild(root->right);

    // Step 3: Recalculate after recursion
    int tot = 0;
    if (root->left)
        tot += root->left->val;
    if (root->right)
        tot += root->right->val;

    if (root->left || root->right)
        root->val = tot;
}
```


## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Step 1: Compute children sum

```
childSum = left.val + right.val
```



### ğŸ’¡ Step 2: Fix mismatch (Top-down)

```
If childSum > node.val:
    node.val = childSum
Else:
    push node.val to children
```



### ğŸ’¡ Step 3: Recursive calls

```
Fix left subtree
Fix right subtree
```



### ğŸ’¡ Step 4: Bottom-up recomputation

```
node.val = left.val + right.val
```



## ğŸ”‘ Why this works

* Ensures no decrement of values
* Fixes violations top-down
* Locks correctness bottom-up
* One DFS traversal



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(H)** |

Where:

* `N` = number of nodes
* `H` = height of tree (recursion stack)

Worst case (skewed tree): **O(N)** space.



## ğŸ§ª Test Cases

| Tree              | Result               |
| -- | -- |
| Empty tree        | No change            |
| Single node       | No change            |
| Already valid     | Same tree            |
| Parent > children | Children incremented |
| Children > parent | Parent incremented   |



## ğŸ§  Key Observations

* Leaves are never changed
* Values only increase
* Order of operations is critical
* Postorder correction is mandatory



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Validate Children Sum Property

(Check only)

### 2ï¸âƒ£ Sum Tree

(Stricter version)

### 3ï¸âƒ£ Path Sum Problems

(Different constraints)




# â“ FAQs

### Q1: Why canâ€™t we just fix bottom-up?

Because parent might violate constraints before children are fixed.



### Q2: Why two passes at each node?

* First pass pushes values down
* Second pass recomputes correctly



### Q3: Can this be done iteratively?

Technically yes, but recursion is far cleaner.



### Q4: Does this work for negative values?

Usually problem constraints use non-negative values.



### Q5: Is this asked in interviews?

Yes â€” **very frequently**.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Fix mismatch top-down
Recurse
Recalculate bottom-up
Never decrement values
```

