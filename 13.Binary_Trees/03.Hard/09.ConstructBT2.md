

# ğŸŒ³ Construct Binary Tree from Inorder & Postorder Traversal [Leetcode #[106](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)]

## ğŸ“Œ Problem Statement

Given two arrays:

* **Inorder traversal** of a binary tree
* **Postorder traversal** of the same tree

Reconstruct and return the **original binary tree**.

ğŸ‘‰ All node values are **unique**.



## ğŸ§  Why this problem matters

This problem checks:

* Deep understanding of traversal orders
* Recursive tree construction
* Correct index arithmetic
* Ability to adapt logic (preorder vs postorder)

Interviewers often ask:

> â€œYou solved preorder + inorderâ€¦ can you do postorder too?â€ ğŸ˜„



## ğŸ‘€ Traversal Refresher (Quick)

### Inorder (Left â†’ Root â†’ Right)

```
[left..., root, right...]
```

### Postorder (Left â†’ Right â†’ Root)

```
[left..., right..., root]
```

ğŸ‘‰ Together, these uniquely define a binary tree.



## ğŸ‘€ Example

### Input

```
Inorder   = [9, 3, 15, 20, 7]
Postorder = [9, 15, 7, 20, 3]
```

### Output Tree

```
        3
       / \
      9  20
         / \
        15  7
```



## ğŸ§© Core Intuition (THIS is the key ğŸ”‘)

### Key Observations:

1. **Postorderâ€™s last element is always the root**
2. **Inorder tells us how to split left & right subtrees**
3. Size of left subtree tells us how to split postorder

So the plan is:

* Pick root from postorder (last element)
* Find its index in inorder
* Recursively build left and right subtrees

This is **divide & conquer on trees** ğŸ§ âœ¨



# ğŸŒ Brute Force Approach (Why itâ€™s slow)

### âŒ Naive Idea

* For every recursive call:

  * Linearly search root in inorder array

â›” Time Complexity: **O(NÂ²)**
â›” Fails for large trees



# âœ… Optimal Approach (Recursion + Hash Map)

### ğŸ”¥ Key Insight

* Store inorder indices in a map
* Root lookup becomes O(1)
* Overall complexity improves to O(N)




### ğŸ’» Full Code

```cpp
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() != postorder.size())
            return nullptr;

        map<int, int> mpp;
        for (int i = 0; i < inorder.size(); ++i) {
            mpp[inorder[i]] = i;
        }

        return build(inorder, 0, inorder.size() - 1,
                     postorder, 0, postorder.size() - 1,
                     mpp);
    }

    TreeNode* build(vector<int>& inorder, int inStart, int inEnd,
                    vector<int>& postorder, int poStart, int poEnd,
                    map<int, int> &mpp) {
        if (inStart > inEnd || poStart > poEnd)
            return nullptr;

        TreeNode* root = new TreeNode(postorder[poEnd]);

        int indRoot = mpp[postorder[poEnd]];
        int numLeft = indRoot - inStart;

        root->left = build(inorder,
                           inStart,
                           indRoot - 1,
                           postorder,
                           poStart,
                           poStart + numLeft - 1,
                           mpp);

        root->right = build(inorder,
                            indRoot + 1,
                            inEnd,
                            postorder,
                            poStart + numLeft,
                            poEnd - 1,
                            mpp);

        return root;
    }
};
```




## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Preprocessing

```
Create a map: inorder value â†’ index
```



### ğŸ’¡ Recursive Build

```
build(inStart, inEnd, poStart, poEnd):

    If indices invalid â†’ return null

    rootVal = postorder[poEnd]
    Create root node

    inRoot = index of rootVal in inorder
    leftSize = inRoot - inStart

    Build left subtree
    Build right subtree

    Return root
```



## ğŸ”‘ Why this works

* Postorder guarantees root position
* Inorder guarantees subtree split
* Map removes repeated scanning
* Recursion assembles tree bottom-up



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(N)** |

Where:

* `N` = number of nodes
* Space includes recursion stack + map



## ğŸ§ª Test Cases

| Inorder       | Postorder | Result      |
| - | - | -- |
| []            | []        | nullptr     |
| [1]           | [1]       | single node |
| Balanced tree | âœ”ï¸        | correct     |
| Left-skewed   | âœ”ï¸        | correct     |
| Right-skewed  | âœ”ï¸        | correct     |



## ğŸ§  Key Observations

* Root comes from **end of postorder**
* Index math is the trickiest part
* Off-by-one errors are common
* Requires **unique values**



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Construct from Preorder & Inorder

(Sister problem)

### 2ï¸âƒ£ Construct from Preorder & Postorder

(Needs extra constraints)

### 3ï¸âƒ£ Serialize & Deserialize Binary Tree

Advanced construction problem






# â“ FAQs

### Q1: Why canâ€™t we use postorder alone?

Postorder alone doesnâ€™t uniquely define structure âŒ



### Q2: Why map instead of unordered_map?

Both work.
`unordered_map` is slightly faster, `map` is simpler.



### Q3: What if duplicates exist?

Tree cannot be uniquely reconstructed âŒ



### Q4: Is recursion mandatory?

Practically yes â€” iterative version is very complex.



### Q5: Is this asked in interviews?

Yes âœ”ï¸ Very frequently.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Postorder â†’ root (last element)
Inorder â†’ split left & right
Map â†’ O(1) lookup
Recurse correctly
```
