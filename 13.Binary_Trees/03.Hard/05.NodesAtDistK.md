# ğŸŒ³ Nodes at Distance K from Target (Binary Tree) #[863](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/description/)

## ğŸ“Œ Problem Statement

Given:

* The **root** of a binary tree
* A **target node**
* An integer **k**

Return **all node values that are exactly `k` edges away** from the target node.

ğŸ‘‰ Distance is measured in **number of edges**, not levels.



## ğŸ§  Why this problem matters

This problem tests whether you can:

* Convert a **tree into a graph**
* Traverse in **all directions** (up + down)
* Avoid revisiting nodes
* Use BFS properly for distance-based queries

Think of it as:

> â€œStart at one node and spread out exactly `k` steps in every directionâ€ ğŸŒŠğŸŒ³



## ğŸ‘€ Example

### Tree

```
             3
          /    \
         5      1
        / \    / \
       6   2  0   8
          / \
         7   4
```

### Target = `5`, k = `2`

### Output

```
[7, 4, 1]
```

Why?

* From 5 â†’ 6 (1 step)
* From 5 â†’ 2 (1 step)
* From 5 â†’ 3 (1 step)

Two steps away:

* 7, 4, 1



## ğŸ§© Core Intuition (THIS is the key ğŸ”‘)

A binary tree normally lets you move:

* **Down** â†’ left / right

But this problem ALSO requires moving:

* **Up** â†’ parent

So the tree must be treated as an **undirected graph**.

### Strategy:

1. First, **map parent pointers**
2. Then, run **BFS from the target**
3. Stop when distance = `k`



# ğŸŒ Brute Force Approach (Why it fails)

### âŒ Naive Idea

* From target, repeatedly search entire tree for nodes at distance `k`

âŒ Very inefficient
âŒ Hard to implement
âŒ Repeats work unnecessarily



# âœ… Optimal Approach (Tree â†’ Graph + BFS)

### ğŸ”¥ Two-Phase Solution

1. **Build parent mapping**
2. **BFS from target in all directions**

This ensures:

* Correct distance tracking
* No revisits
* O(N) traversal




### ğŸ’» Full Code

```cpp
class Solution {
public:
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        if (!root) return {}; 

        unordered_map<TreeNode*, TreeNode*> parentMap;
        mapParentNodes(root, parentMap);

        return bfsFromTarget(target, parentMap, k);
    }

private:
    void mapParentNodes(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& parentMap) {
        queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();

            if (node->left) {
                parentMap[node->left] = node;
                q.push(node->left);
            }
            if (node->right) {
                parentMap[node->right] = node;
                q.push(node->right);
            }
        }
    }

    vector<int> bfsFromTarget(TreeNode* target,
                              unordered_map<TreeNode*, TreeNode*>& parentMap,
                              int k) {
        queue<TreeNode*> q;
        unordered_set<TreeNode*> visited;

        q.push(target);
        visited.insert(target);

        int currentLevel = 0;

        while (!q.empty()) {
            int size = q.size();
            if (currentLevel++ == k)
                break;

            for (int i = 0; i < size; ++i) {
                TreeNode* node = q.front();
                q.pop();

                if (node->left && !visited.count(node->left)) {
                    visited.insert(node->left);
                    q.push(node->left);
                }
                if (node->right && !visited.count(node->right)) {
                    visited.insert(node->right);
                    q.push(node->right);
                }
                if (parentMap.count(node) &&
                    !visited.count(parentMap[node])) {
                    visited.insert(parentMap[node]);
                    q.push(parentMap[node]);
                }
            }
        }

        vector<int> result;
        while (!q.empty()) {
            result.push_back(q.front()->val);
            q.pop();
        }
        return result;
    }
};
```





## ğŸ§  Algorithm (Step-by-Step)

### ğŸ’¡ Step 1: Map Parent Nodes

```
BFS from root
For each node:
    parentMap[child] = parent
```



### ğŸ’¡ Step 2: BFS from Target

```
Start BFS from target
Mark target as visited
For each level:
    If currentLevel == k:
        stop BFS
    Move to left, right, and parent
```



### ğŸ’¡ Step 3: Collect Answer

```
Nodes left in queue = distance k
```



## ğŸ”‘ Why BFS (not DFS)?

* Distance = number of edges
* BFS guarantees shortest distance
* DFS would need manual depth tracking and pruning



## â± Complexity Analysis

| Metric           | Value    |
| - | -- |
| Time Complexity  | **O(N)** |
| Space Complexity | **O(N)** |

Where:

* `N` = number of nodes

Parent map + visited set both use O(N).



## ğŸ§ª Test Cases

| Case           | Output           |
| -- | - |
| Empty tree     | []               |
| k = 0          | [target]         |
| Target is leaf | Valid nodes      |
| k > height     | []               |
| Balanced tree  | Multiple answers |



## ğŸ§  Key Observations

* Tree is treated as an undirected graph
* Parent mapping is essential
* Visited set prevents revisits
* BFS level control is crucial



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Distance Between Two Nodes

Uses LCA + depth

### 2ï¸âƒ£ Burn a Binary Tree

Same BFS-from-target idea ğŸ”¥

### 3ï¸âƒ£ All Nodes at Distance K in Graph

General graph version





# â“ FAQs

### Q1: Why not store parent in TreeNode?

Problem constraints usually donâ€™t allow modification.



### Q2: Why break when `currentLevel == k`?

Because BFS queue already contains exactly distance `k` nodes.



### Q3: What if target is root?

Works fine â€” parent traversal just wonâ€™t apply.



### Q4: Is order of result important?

Usually not (unless specified).



### Q5: Is this hard?

Conceptually â€” yes ğŸ˜„
Once you see the â€œtree â†’ graphâ€ trick, it becomes mechanical.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Tree â†’ Graph
Map parents
BFS from target
Use visited set
Stop at distance k
```

