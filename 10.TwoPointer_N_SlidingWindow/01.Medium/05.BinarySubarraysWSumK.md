# ğŸ§© Count of Subarrays with Given Sum #[930](https://leetcode.com/problems/binary-subarrays-with-sum/description/)


## âœ… Problem Statement

Given a binary array `nums` (elements are `0` or `1`) and an integer `goal`, return the **number of non-empty subarrays** whose sum equals `goal`.

> Example
> Input: `nums = [1,0,1,0,1], goal = 2`
> Output: `4`
> Explanation: valid subarrays (0-indexed) â€” `[0..2]`, `[0..4]`? (we'll list later) â€” there are 4 subarrays whose elements sum to 2.

> **Important**: the typical problem has `nums` composed of 0s and 1s (non-negative). The sliding-window method used here relies on non-negativity.

---

### ğŸ§  Key Intuition

For arrays with **non-negative** numbers (like a binary array), the number of subarrays whose sum is **exactly** `goal` can be obtained by counting subarrays with sum **â‰¤ goal** and subtracting those with sum **â‰¤ (goal - 1)**:

```
exact(goal) = â‰¤goal âˆ’ â‰¤(goal âˆ’ 1)
```

Why? A subarray has sum exactly `goal` iff it's counted by `â‰¤goal` but not by `â‰¤(goal-1)`.

So the task reduces to: **efficiently compute how many subarrays have sum â‰¤ X** for a given X. For non-negative arrays, a classic sliding-window (two-pointer) technique does this in O(n).


### âš’ Brute Force

* Iterate over all start indices `i`, expand `j` and compute `sum(i..j)`.
* Count when `sum == goal`.
* Time: O(nÂ²) with O(1) extra space.
* Works for small `n`, but too slow for typical constraints (n up to 10âµ).


### âš¡ Optimal Approach â€” Sliding Window for â‰¤ X (O(n))

For non-negative arrays, count the number of subarrays with sum â‰¤ `X`:

* Maintain a window `[l, r]` with running `sum`.
* Expand `r` (add `nums[r]`) while `sum â‰¤ X`.
* If `sum > X`, move `l` forward until `sum â‰¤ X`.
* For each `r`, the number of valid subarrays ending at `r` is `(r - l + 1)` (all subarrays that start at any index between `l` and `r` inclusive).
* Accumulate these counts.

Then compute `exactGoal = countLE(goal) - countLE(goal - 1)`.

This is linear time, linear passes (two calls to `countLE`), constant extra space.



### âœ… Polished C++ Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        // Use long long internally to avoid overflow for large n
        long long ans = countSubarraysWithSumAtMost(nums, goal)
                      - countSubarraysWithSumAtMost(nums, goal - 1);
        return static_cast<int>(ans);
    }

private:
    // Counts number of subarrays with sum <= goal
    long long countSubarraysWithSumAtMost(const vector<int>& nums, int goal) {
        if (goal < 0) return 0; // no subarray of non-negative nums can have sum <= negative
        long long count = 0;
        long long sum = 0;
        int l = 0;
        int n = (int)nums.size();

        for (int r = 0; r < n; ++r) {
            sum += nums[r];

            while (sum > goal && l <= r) {
                sum -= nums[l];
                ++l;
            }
            // now sum <= goal, all subarrays starting in [l..r] and ending at r are valid
            count += (r - l + 1);
        }
        return count;
    }
};
```

> Notes:
>
> * `if (goal < 0) return 0;` is important: when `goal-1` becomes negative, we quickly return 0.
> * `count` and `sum` are `long long` to avoid overflow for large `n` (e.g., `n ~ 10^5` â†’ #subarrays can be ~5e9).


### ğŸ” Example Walkthrough

`nums = [1,0,1,0,1]`, `goal = 2`

First compute `â‰¤ 2`:

* r=0: sum=1 â‰¤2 â†’ count += 1  (subarrays ending at 0: [0..0])
* r=1: sum=1 â†’ count += 2       ([1..1], [0..1])
* r=2: sum=2 â†’ count += 3
* r=3: sum=2 â†’ count += 4
* r=4: sum=3 â†’ shrink left until sumâ‰¤2: remove nums[0]=1 â†’ sum=2, l becomes 1 â†’ count += (4 - 1 + 1) = 4

Total `â‰¤2` = 1+2+3+4+4 = 14 (intermediate numbers are counts of subarrays ending at each r)

Compute `â‰¤1` similarly â†’ suppose it is 10.

Then exact goal = 14 - 10 = 4.

(You can enumerate subarrays of sum 2 to verify â€” there are 4.)


### ğŸ§ª Test Cases

**Basic**

* `nums = [1,1,1], goal = 2` â†’ 2 (`[0..1]`, `[1..2]`)
* `nums = [0,0,0], goal = 0` â†’ 6 (all subarrays) â€” check `n*(n+1)/2`

**Mixed**

* `nums = [1,0,1,0,1], goal = 2` â†’ 4
* `nums = [1,0,1,0,1], goal = 1` â†’ 6

**Edge**

* `nums = [], goal = 0` â†’ 0
* `goal = 0` with binary arrays: count of subarrays consisting of all zeros. Works fine.

**Large / Stress**

* `nums = [0]*100000`, goal = 0 â†’ `100000*100001/2` â†’ ~5e9 (needs 64-bit!)
* Random binary arrays with varying goals.


### â± Complexity

* **Time:** `O(n)` â€” each of the two helper passes scans the array once (two-pointer amortized linear).
* **Space:** `O(1)` â€” constant extra memory.

This is optimal for the non-negative case.

---

### ğŸ” Variations & Alternative Approaches

1. **Prefix-sum + Hashmap** (works for general integers, including negatives)

   * Count subarrays with sum exactly `goal` by maintaining prefix sum counts:
     For prefix sum `pref`, you need `pref - goal` seen earlier.
   * Complexity: O(n) time, O(n) space.
   * This is the usual robust method when numbers can be negative.

2. **For binary arrays specifically**

   * The sliding-window trick you used is elegant and fast.
   * Another approach for binary arrays: store indices of `1`s and use combinatorics to count zeros-between possibilities â€” more complex but instructional.

3. **If only zeros and ones but goal large**

   * The sliding-window approach still handles it; just be careful with types.


### âš ï¸ Common Pitfalls

* **Using 32-bit ints** for `count` may overflow on large arrays (`n ~ 10^5` leads to ~5e9 subarrays).
* **Applying sliding-window to arrays with negatives** â€” wrong. Use prefix-sum hashmap instead.
* **Forgetting goal-1 negative case** â€” we handle it with `if (goal < 0) return 0;`.


### â“ FAQs

**Q: Can this approach be used for arrays with negative numbers?**
> A: No â€” the sliding-window counting of `â‰¤ X` relies on sums being monotonic when you extend the window. Use prefix-sum + hashmap for general integers.

**Q: Why do we do `â‰¤goal` - `â‰¤(goal-1)`?**
> A: Because every subarray's sum is an integer. Those with exact `goal` are included in â‰¤goal but not in â‰¤goal-1.

**Q: Will the answer fit in 32-bit int?**
> A: Not always. For large `n` full of zeros and `goal = 0`, number of subarrays is `n*(n+1)/2`. For `n=10^5` thatâ€™s ~5e9, which exceeds signed 32-bit. Always use 64-bit to accumulate counts and sums.

**Q: Which method is better â€” sliding-window or prefix-hash?**
> A: For non-negative arrays, sliding-window is simpler and uses O(1) extra space. For general arrays with negatives, use prefix-sum + hashmap.

