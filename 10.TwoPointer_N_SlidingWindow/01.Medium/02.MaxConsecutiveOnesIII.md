# ğŸ“˜ Longest Ones (Max Consecutive Ones III) [#1004](https://leetcode.com/problems/max-consecutive-ones-iii/description/)

> **Problem (short)**
> Given a binary array `nums` and an integer `k`, you may flip at most `k` zeroes into ones. Return the **maximum number of consecutive 1s** in the array after at most `k` flips.


## âœ… Problem Statement

You are given an array `nums` of 0s and 1s and an integer `k`. You can flip at most `k` zeros to ones. Find the length of the longest contiguous subarray that contains only 1s after applying at most `k` flips.

**Example**

```
Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: Flip the two 0s at positions 4 and 10 (0-indexed) â€” the longest 1s subarray has length 6.
```



### ğŸ§  Intuition (why sliding window works)

We want the **longest contiguous segment** where the number of zeros inside the segment â‰¤ `k`.
As we extend a window to the right, we keep track of how many zeros are inside. If the zero count exceeds `k`, we must move the left boundary to the right until the count is â‰¤ `k` again. While scanning once leftâ†’right this way, we can keep track of the maximum window size we saw.

This is a canonical *two pointers / variable-length sliding window* pattern.



### ğŸ›  Brute Force (naive)

* Try all subarrays `nums[i..j]` (O(nÂ²) choices).
* For each, count zeros (O(n) in worst-case) or maintain prefix sums to make counting O(1).
* With naive counting overall O(nÂ³); with prefix sum O(nÂ²).

**Complexity (brute with prefix sums)**

* Time: O(nÂ²)
* Space: O(n) for prefix-sum array

Brute force is fine for small `n`, but not for typical constraints (n up to 10âµ).



## âš¡ Optimal Approach â€” Sliding Window

Maintain `[l, r)` or inclusive `[l, r]` window:

* Expand `r` one step at a time.
* If `nums[r] == 0`, increase `zero_count`.
* While `zero_count > k`, move `l` forward and decrement `zero_count` if a zero leaves the window.
* Track `max_length = max(max_length, r - l + 1)`.

This uses a single pass O(n) with O(1) extra space.



### âœ… Polished C++ Code


```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size();
        int left = 0;
        int zeroCount = 0;
        int maxLen = 0;

        for (int right = 0; right < n; ++right) {
            if (nums[right] == 0) ++zeroCount;

            while (zeroCount > k) {
                if (nums[left] == 0) --zeroCount;
                ++left;
            }

            // window [left, right] is valid (zeroCount <= k)
            maxLen = max(maxLen, right - left + 1);
        }

        return maxLen;
    }
};
```



## ğŸ” Walkthrough (example)

Let `nums = [1,0,1,1,0,1,0,1]`, `k = 1`.

* Start `left = 0`, `right = 0`: window `[0,0] = [1]` â†’ zeros = 0 â†’ max = 1
* `r=1`: see 0 â†’ zeros = 1 â†’ window valid â†’ max = 2
* `r=2`: see 1 â†’ zeros = 1 â†’ max = 3
* `r=3`: see 1 â†’ zeros = 1 â†’ max = 4
* `r=4`: see 0 â†’ zeros = 2 â†’ *> k* â†’ move left until zeros â‰¤ k:

  * left=0 â†’ nums[0]=1 â†’ left=1
  * left=1 â†’ nums[1]=0 â†’ zeros-- â†’ zeros=1, left=2
    â†’ Now window `[2,4]` â†’ size 3 â†’ max remains 4
* Continue similarly â€” final max = 4.

Graphically: we keep a window that allows at most `k` zeroes inside it.

### ğŸ§© Why this is correct (invariants)

At any point after the `while` loop finishes:

* The window `[left, right]` satisfies `zeroCount <= k`.
* We consider `right - left + 1` as a candidate answer.
* Since `right` moves strictly forward and `left` only increases, every valid subarray is considered exactly once as a maximal-window for its ending index.


### Alternative (not optimal, but works)

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int l = 0, r = 0, n = nums.size();
        int cnt = 0, maxL = 0, len = 0;

        while (r < n) {
            int x = nums[r];
            if (x == 0)
                cnt++;
            
            while (cnt > k) {
                if (nums[l] == 0)
                    cnt --;
                l ++;
            } 
            
            maxL = max(maxL, (r + 1) - l);
            r ++;
        }

        return maxL;
    }
};
```

> since this has an internal while loop, the TC can reach N^2 at worst case.

### ğŸ§ª Test Cases

Include edge cases!

1. **Basic**

   * `nums = [1,1,1,1], k = 0` â†’ `4`
   * `nums = [0,0,0], k = 2` â†’ `2`

2. **Mixed**

   * `nums = [1,0,1,1,0,1]`, `k = 1` â†’ `4`
   * `nums = [1,0,1,1,0,1,0,1,1]`, `k = 2` â†’ `6`

3. **Edge**

   * `nums = []`, `k = 0` â†’ `0`
   * `nums = [0]`, `k = 0` â†’ `0`
   * `nums = [0]`, `k = 1` â†’ `1`
   * `k >= number of zeros in array` â†’ result = `n`

4. **Large input sanity**

   * Long array of alternating `1,0` with `k = 1`. Ensures sliding window moves correctly.


## â± Complexity Analysis

* **Time:** `O(n)` â€” single pass; each pointer (`left`, `right`) moves at most `n` steps.
* **Space:** `O(1)` â€” constant extra space (counters and indices).

This is optimal in time and space for this problem.


### ğŸ§  Tips & Tricks

* Sliding window pattern is perfect when you need longest/shortest subarray meeting a condition that's monotonic (e.g., count of something â‰¤ threshold).
* Instead of counting zeros explicitly, some people store indices of zeros in a queue/deque and pop when size > k â€” that also works but is effectively the same idea.
* Use `right - left + 1` carefully depending on whether your window is inclusive or exclusive. I used inclusive `[left, right]`.
* If you need to *return the subarray* indices, record `bestLeft` when you update `maxLen`.


### ğŸ”€ Variations

* **Return indices** of the subarray to be flipped.
* **Minimum flips** required to get a subarray of length `L` â€” binary search + sliding window or two-pointer.
* **Generalization**: instead of zeros, allow up to `k` occurrences of some value `x`. Same idea.


### â— Common Mistakes

* Forgetting to decrement zero count when moving `left`.
* Using `maxLen = max(maxLen, r - l)` but treating window as inclusive â€” leads to off-by-one.
* Not handling empty array edge case â€” though code above works and returns 0.


### ğŸ§¾ FAQ (Quick)

**Q: What if `k` is larger than number of zeros?**
A: The window will expand to the whole array; result is `n`.

**Q: Can we do better than O(n)?**
A: No â€” you must at least inspect each element once, so O(n) is optimal.

**Q: Why not use prefix sums?**
A: You can â€” but sliding window is simpler and O(1) space. Prefix sums are typically used for counting with brute force to reduce cost to O(nÂ²).

**Q: Is this approach stable if `nums` is huge (10â·)?**
A: Memory-wise yes, but runtime might be large â€” algorithmic complexity is as good as it gets. Implementation in C++ should handle up to typical competitive sizes (10âµâ€“10â¶) comfortably.


## ğŸ¯ Bonus â€” If you want to also return the indices of the solution

```cpp
pair<int,int> longestOnesWithIndices(vector<int>& nums, int k) {
    int n = nums.size();
    int left = 0, zeroCount = 0, maxLen = 0;
    pair<int,int> best = {-1, -1};

    for (int right = 0; right < n; ++right) {
        if (nums[right] == 0) ++zeroCount;
        while (zeroCount > k) {
            if (nums[left] == 0) --zeroCount;
            ++left;
        }
        if (right - left + 1 > maxLen) {
            maxLen = right - left + 1;
            best = {left, right};
        }
    }
    return best; // inclusive indices of the max window
}
```
