# üç∞ Count of Nice Subarrays [#1248](https://leetcode.com/problems/count-number-of-nice-subarrays/)

### ‚úÖ Problem Statement (short)

Given an array `nums` of integers and an integer `k`, return the number of **contiguous subarrays** that contain **exactly `k` odd numbers**. A subarray is *nice* if it contains exactly `k` odd numbers.

**Example**

```
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The nice subarrays are [1,1,2,1] and [1,2,1,1].
```

---

### üß† Key Intuition

For **non-negative** counts (odd/even indicator), counting subarrays with *exactly* `k` of something can be transformed to:

```
exactly(k) = atMost(k) - atMost(k - 1)
```

Why? A subarray with exactly `k` odd numbers gets counted in `atMost(k)` but not in `atMost(k-1)`.

Now focus on how to compute `atMost(k)` efficiently:

* Treat each element as `1` if odd, `0` if even.
* Count subarrays whose sum ‚â§ `k` ‚Äî for non-negative arrays this is a standard sliding-window two-pointer trick: for each right index `r`, find the smallest left `l` such that sum ‚â§ `k`, then add `(r - l + 1)` valid subarrays ending at `r`.

This gives an O(n) algorithm with O(1) extra space.



### üõ† Brute Force

* Try every subarray `i..j` (O(n¬≤)).
* For each, count odd numbers (O(length) or maintain prefix sums to make it O(1)).
* Complexity with prefix sums: O(n¬≤) time, O(n) space.
* Too slow for large `n` (e.g., `n = 10^5`).


### ‚ö° Optimal Approach : Sliding Window (O(n))

**Algorithm (atMost):**

1. Let `l = 0`, `count = 0`, `numOdd = 0`.
2. For each `r` from `0` to `n-1`:

   * `numOdd += (nums[r] % 2 != 0)`
   * While `numOdd > k`, move `l` forward and subtract `(nums[l] % 2 != 0)` from `numOdd`.
   * Now the window `[l..r]` has at most `k` odd numbers. There are `r - l + 1` subarrays ending at `r` with ‚â§ k odds. Add that to `count`.
3. Return `count`.

Then `answer = atMost(k) - atMost(k-1)`.

**Why O(n)?**
Each index enters and leaves the window at most once. `l` and `r` both move forward, so total operations proportional to `n`.


### ‚úÖ Polished C++ Implementation


```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        long long ans = atMostNice(nums, k) - atMostNice(nums, k - 1);
        return static_cast<int>(ans);
    }

private:
    // Counts subarrays with at most `k` odd numbers
    long long atMostNice(const vector<int>& nums, int k) {
        if (k < 0) return 0; // safe guard: no subarray can have <= negative odd count
        int n = nums.size();
        int l = 0;
        long long count = 0;
        int numOdd = 0;

        for (int r = 0; r < n; ++r) {
            numOdd += (nums[r] & 1); // 1 if odd, 0 if even

            while (numOdd > k) {
                numOdd -= (nums[l] & 1);
                ++l;
            }
            // Now window [l..r] has at most k odd numbers
            count += (r - l + 1);
        }
        return count;
    }
};
```



### üîç Step-by-Step Walkthrough

Example: `nums = [2, 2, 1, 2, 1, 2, 2]`, `k = 2`.

Compute `atMost(2)`:

* r=0: numOdd=0 ‚Üí add 1
* r=1: numOdd=0 ‚Üí add 2
* r=2: numOdd=1 ‚Üí add 3
* r=3: numOdd=1 ‚Üí add 4
* r=4: numOdd=2 ‚Üí add 5
* r=5: numOdd=2 ‚Üí add 6
* r=6: numOdd=2 ‚Üí add 7
  Total `atMost(2)` = 1+2+3+4+5+6+7 = 28

Compute `atMost(1)` similarly ‚Üí suppose it equals 20.

Then `exactly(2)` = 28 - 20 = 8.

Interpretation: there are 8 subarrays with exactly 2 odd numbers.


### ‚è± Complexity Analysis

* **Time:** `O(n)` ‚Äî single pass for each `atMost` call, so two passes ‚Üí still O(n).
* **Space:** `O(1)` ‚Äî constant extra space.

---

### üß™ Test Cases

**Basic**

```text
nums = [1,1,2,1,1], k = 3 => 2
nums = [2,4,6], k = 0 => 6 (all subarrays are nice: 3*4/2=6)
```

**Mixed**

```text
nums = [1,0,1,0,1], k = 2 => (manually verify)
```

**Edge**

```text
nums = [], k = 0 => 0
k = 0: return count of subarrays with no odd numbers (all-even subarray counts)
k < 0: result 0 (handled in atMost)
```

**Large**

* `nums = [0]*100000`, `k = 0` -> `100000*100001/2` -> ~5e9 (use 64-bit!)


### üîÅ Variations & Alternative Approaches

1. **Positions-of-odds method (combinatorial)**

   * Record indices of all odd numbers. For each block of `k` consecutive odd indices `oddPos[i] .. oddPos[i+k-1]`, the number of nice subarrays that use these as the `k` odds equals:

     ```
     leftEvenChoices = oddPos[i] - (i==0 ? -1 : oddPos[i-1])
     rightEvenChoices = (i+k-1==m-1 ? n : oddPos[i+k] ) - oddPos[i+k-1]
     contribution = leftEvenChoices * rightEvenChoices
     ```
   * Sum contributions over all windows of `k` odd indices. This method is O(n) too, and sometimes conceptually clearer.

2. **Prefix-sum + hashmap**

   * Convert to `1` for odd, `0` for even; count subarrays with sum exactly `k` using prefix-sum frequency map. Works in O(n) time and O(n) space. Useful if thinking in terms of sums.


### ‚ö†Ô∏è Common Pitfalls & Tips

* **Integer overflow**: the count of subarrays can exceed 32-bit. Use `long long`.
* **k can be 0**: the code handles it naturally ‚Äî it counts subarrays with no odd numbers (i.e., contiguous blocks of even numbers).
* **k negative**: guard `atMost` to return 0 if `k < 0`.
* **Parity only matters**: values of elements (beyond parity) are irrelevant to the count; the algorithm uses `(num & 1)`.


### üßæ Proof Sketch of Correctness

* `atMost(k)` counts all subarrays whose odd-count ‚â§ k by amortized sliding-window reasoning: for each `r`, the minimal `l` ensures all starts `l..r` produce valid subarrays. Summing `r - l + 1` over `r` enumerates all such subarrays exactly once.
* `exactly(k) = atMost(k) - atMost(k-1)` is an identity because any subarray with sum `s` contributes to all `atMost(t)` for `t ‚â• s` and not to those with `t < s`.
* The sliding-window is correct because the odd count is non-negative and monotonic when window expands/contracts.


### üîé Example Combinatorial Method (short sketch)

Given odd indices `pos = [i0, i1, i2, ...]` and `m = pos.size()`:

* For each window of length `k` of these indices (`pos[j] ... pos[j+k-1]`):

  * `leftChoices = pos[j] - (j == 0 ? -1 : pos[j-1])`
  * `rightChoices = (j+k-1 == m-1 ? n : pos[j+k]) - pos[j+k-1]`
  * Add `leftChoices * rightChoices` to answer.
    This multiplies how many even-run choices extend left and right of the exact `k` odd block.


### ‚ùì FAQs (Quick)

**Q: Why subtract `atMost(k-1)`?**
>A: Because it removes subarrays whose odd-count < `k`, leaving only those equal to `k`.

**Q: Do we need 64-bit ints?**
>A: Yes, for large `n` the number of subarrays may exceed 2¬≥¬π‚àí1.

**Q: What if `k` is 0?**
>A: The code works ‚Äî it counts subarrays with no odd values, i.e., contiguous even-only subarrays.

**Q: Could the sliding-window break for negative numbers?**
>A: The problem is about parity of integers; parity is either 0 or 1 (non-negative) so sliding-window monotonicity holds.
