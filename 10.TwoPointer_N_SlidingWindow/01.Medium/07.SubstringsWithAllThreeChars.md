# üî§ Number of Substrings Containing all Three Characters [#1358](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/)


## üßæ Problem Statement

> Given a string `s` consisting only of the characters `'a'`, `'b'`, and `'c'`, return the **number of substrings** of `s` that contain **at least one `'a'`, one `'b'`, and one `'c'`**.

A substring is any **contiguous** sequence of characters from `s`.

### Example

```text
Input:  s = "abc"
Output: 3

Substrings:
"a"      ‚ùå
"b"      ‚ùå
"c"      ‚ùå
"ab"     ‚ùå
"bc"     ‚ùå
"abc"    ‚úÖ contains 'a', 'b', 'c'

But the answer is 3? Wait‚Äî
The valid substrings are:
- "abc" (starting at index 0)
- also, when length grows in other examples, more substrings work.

A clearer example:
s = "abcabc"

You‚Äôd find multiple substrings that contain all 'a', 'b', 'c'.
```

(We‚Äôll see how the counting works shortly.)

---

### üß† Intuition

We want to count all substrings that contain **at least one** of each character `'a'`, `'b'`, and `'c'`.

Brute forcing all substrings is O(n¬≤), and checking each one is annoying and slow. But there‚Äôs a **window-based insight**:

When we have a window `[left, right]` such that:

* it already contains at least one `'a'`, `'b'`, and `'c'`,
  then **every substring that starts at or after `left` and ends at or after `right` with the same `right` is also valid**?

Even better:
Once `[left, right]` is valid (contains all 3 chars), then:

* `[left, right]`
* `[left, right+1]`
* `[left, right+2]`
* ...
* `[left, n-1]`

are **all valid substrings starting at `left`**, because extending to the right can‚Äôt remove characters.

So the count of valid substrings starting at `left` when the current `right` makes it valid is:

> `n - right`

This is the heart of the trick.

Then we **move `left` forward** (shrink window from the left) to find the next possible starting position that still keeps the window valid, updating the frequency counts along the way.


### üßÆ Brute Force (for contrast)

1. Enumerate all substrings `s[i..j]` (O(n¬≤) substrings).
2. For each substring:

   * Count how many of `'a'`, `'b'`, `'c'` appear (or keep frequency while expanding).
   * If all three present ‚Üí increment answer.

### Complexity

* **Time:** O(n¬≤) in worst case.
* **Space:** O(1).

Works for small inputs, but not scalable for large `n` (like 10‚Åµ).



### ‚ö° Optimal Approach ‚Äî Sliding Window + Counting Trick

We‚Äôll use:

* Two pointers: `left`, `right`
* `freq[3]` to count occurrences of `'a'`, `'b'`, `'c'` in the current window.
* A running `count` of valid substrings.

#### Core Idea

1. Expand `right` one step at a time.
2. For each `right`, update `freq[s[right] - 'a']`.
3. When the window `[left, right]` is valid ‚Äî that is, it contains **at least one** of each 'a', 'b', 'c':

   * All substrings `[left, right]`, `[left, right+1]`, ..., `[left, n-1]` are valid.
   * So we increase `count` by `n - right`.
4. Then we **shrink from the left**:

   * Decrease `freq[s[left] - 'a']`
   * Move `left` forward
   * While still valid, keep adding `n - right` again.
5. Continue this until `right` reaches the end.

This gives us the total in **O(n)** time.

### ‚úÖ Cpp Code


```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int numberOfSubstrings(string s) {
        int n = s.size();
        vector<int> freq(3, 0); // freq[0] -> 'a', freq[1] -> 'b', freq[2] -> 'c'
        int left = 0, right = 0;
        long long count = 0; // might be large, but final fits in int for typical constraints

        while (right < n) {
            freq[s[right] - 'a']++;

            // While current window has at least one 'a', 'b', and 'c'
            while (freq[0] > 0 && freq[1] > 0 && freq[2] > 0) {
                // All substrings starting at `left` and ending at [right..n-1] are valid
                count += (n - right);

                // Shrink window from the left
                freq[s[left] - 'a']--;
                left++;
            }

            right++;
        }

        return static_cast<int>(count);
    }
};
```

> If constraints are small, even `int` for `count` is fine. This just future-proofs it.


### üîç Step-by-Step Example

Let‚Äôs walk through a simple example:

### Example: `s = "abc"`

* `n = 3`
* Start: `left = 0`, `right = 0`, `freq = [0,0,0]`, `count = 0`

1. `right = 0`, char = `'a'`:

   * `freq = [1,0,0]` (only `a` present)
   * Not yet valid (need `b` and `c`)
   * `count = 0`

2. `right = 1`, char = `'b'`:

   * `freq = [1,1,0]`
   * Not yet valid
   * `count = 0`

3. `right = 2`, char = `'c'`:

   * `freq = [1,1,1]` ‚Üí all present üéâ
   * Window `[0, 2]` is valid.
   * Now, valid substrings starting at `left=0` with this `right=2`:

     * `[0,2]` only (since `right` is last index)
     * `count += n - right = 3 - 2 = 1` ‚Üí `count = 1`
   * Shrink from left:

     * Decrease `freq['a']` ‚Üí `freq = [0,1,1]`, `left = 1`
   * Now `freq[0] == 0`, so window no longer valid.
   * `right` moves on (but here the string ends)

Total: `count = 1` ‚Üí only `"abc"`.

For bigger strings like `"abcabc"`, you‚Äôd see multiple valid windows and accumulate more counts like `n - right` each time.


### üß† Why does `count += n - right` work?

When the current window `[left, right]` first becomes **valid**:

* Any substring that:

  * starts at `left`, and
  * ends at an index `end ‚â• right`
    will still contain at least one `'a'`, `'b'`, and `'c'`.

So valid substrings starting at `left` are:

* `[left, right]`
* `[left, right+1]`
* `[left, right+2]`
* ...
* `[left, n-1]`

Number of such substrings = `n - right`.

When we increment `left`, we remove some characters; if the window is still valid, we again do `count += n - right` for the new `left`.

Thus, by sliding `left` while the window is valid, we count all substrings that contain all three characters exactly once, without double-counting.


### ‚è± Complexity

* **Time Complexity:** O(n)
  Both `left` and `right` move from 0 to n at most once. Each index is processed O(1) times.

* **Space Complexity:** O(1)
  Just an array `freq` of size 3.

Super efficient. üöÄ


### ‚ö†Ô∏è Assumptions & Gotchas

* Assumes `s` only contains characters `'a'`, `'b'`, and `'c'`.
  If other characters are allowed, `freq[s[right] - 'a']` may go out of bounds ‚Äî then you'd need a different mapping.
* Remember that `freq[0]`, `freq[1]`, `freq[2]` map to `'a'`, `'b'`, `'c'` respectively.
* Use `long long` for `count` if `n` can be large (just to be safe).


### üß™ Test Cases

### 1. Minimal

```text
s = "abc"          -> 1
s = "aaa"          -> 0 (no 'b' or 'c')
s = "a"            -> 0
s = "ab"           -> 0
```

### 2. Simple Mixed

```text
s = "abcabc"

You should get multiple valid substrings:
- "abc"
- "abca"
- "abcab"
- "abcabc"
- "bca"
- "bcab"
- "bcabc"
- "cab"
- "cabc"
... (and so on)
```

### 3. All same char

```text
s = "aaaaaa"       -> 0
```

### 4. Edge

```text
s = ""             -> 0  (empty string)
s = "bac"          -> 1 ("bac" itself)
s = "abccba"       -> multiple; ensure logic is correct
```

### üîÅ Variations

This pattern generalizes nicely:

* **Count substrings that contain all characters from a given set**

  * E.g., containing all vowels: use a `freq` map over vowels and a similar window condition.
* **Count substrings that contain at least one of each digit `0-9`**

  * Use `freq[10]` or `unordered_map<char,int>` and check all > 0.
* **Longest substring containing all required chars** ‚Üí slightly different (maximize length rather than count), but still sliding window.

You‚Äôve basically unlocked a mini-template for ‚Äúsubstrings with all of X‚Äù.


### ‚ùì FAQs

**Q: Why not just count ‚Äúat most k‚Äù style?**
Here the condition is ‚Äúmust include all 3 letters‚Äù, not ‚Äúat most k** of something‚Äù. The `n - right` trick fits this pattern better than `atMost` subtract pattern.

**Q: Will this double-count any substring?**
No. Each substring is uniquely determined by its `(left, right)` pair. We count substrings in terms of their start (`left`) only, for a fixed `right`. When we increment `left`, we only count new substrings starting at that new `left`.

**Q: Could we do this with a frequency map instead of vector?**
Yes, but since we know there are exactly 3 characters (`'a'`, `'b'`, `'c'`), a small fixed-size vector is faster and simpler.

