# `maxFruits` (Longest Subarray with ‚â§ k Distinct Elements) üçéüçåüçá


## ‚úÖ Problem Statement (short)

Given an array `fruits[]` of integers representing fruit types and an integer `k`, find the **length of the longest contiguous subarray** that contains **at most `k` distinct fruit types**.

This is the array-version of "longest substring with at most k distinct characters". For `k = 2` it's the classical "Fruits into Baskets" problem.

**Example**

```
Input: fruits = [1, 2, 3, 2, 2], k = 2
Output: 4
Explanation: The longest subarray with at most 2 distinct types is [2,3,2,2] or [1,2, ...] -> max length is 4.
```

---

### üß† Intuition

We want the longest contiguous window where the number of distinct items ‚â§ `k`.
Slide a window `[l, r]` across the array:

* Expand `r` to include new elements, counting distinct types with a hashmap (type ‚Üí count).
* If distinct count > `k`, move `l` forward until distinct count ‚â§ `k` again (decrementing counts and removing entries whose count hits 0).
* Track `maxLen` = `max(maxLen, r - l + 1)` at every step.

This is a variable-length sliding window ‚Äî optimal and elegant.


### ‚öí Brute Force (naive)

Try every subarray `i..j`, compute distinct types inside:

* Use a set or frequency count for each subarray.
* Time: O(n¬≤) subarrays √ó O(window_length) to count distinct ‚Üí O(n¬≥) naive.
* With prefix structures and careful counting you can reduce to O(n¬≤) but that's still slower than the optimal O(n).

**Takeaway:** Brute force is simple but too slow for large `n` (e.g., (n = 10^5)).


### ‚ö° Optimal Approach ‚Äî Sliding Window (O(n))

Use two pointers `l` and `r` + `unordered_map<int,int> counts`:

1. Expand `r`: `counts[fruits[r]]++`.
2. While `counts.size() > k`: decrement `counts[fruits[l]]`, erase if zero, then `l++`.
3. Window is valid ‚Üí update `maxLen = max(maxLen, r - l + 1)`.
4. Continue until `r` traverses the array.

Single pass, linear time.


### ‚úÖ Polished C++ Code


```cpp
#include <bits/stdc++.h>
using namespace std;

/*
 * Returns the length of the longest contiguous subarray that contains
 * at most k distinct elements (fruit types).
 */
int maxFruits(const vector<int> &fruits, int k) {
    int n = (int)fruits.size();
    int left = 0, right = 0;
    int maxLen = 0;
    unordered_map<int,int> count; // fruit_type -> frequency in current window

    while (right < n) {
        count[fruits[right]]++;

        // If more than k distinct types, shrink from the left
        while ((int)count.size() > k) {
            int f = fruits[left];
            count[f]--;
            if (count[f] == 0) count.erase(f);
            left++;
        }

        // Now window [left, right] has <= k distinct types
        maxLen = max(maxLen, right - left + 1);
        right++;
    }

    return maxLen;
}

int main() {
    vector<int> fruits = {1, 2, 3, 2, 2};
    int k = 2;
    cout << maxFruits(fruits, k) << endl; // prints 4
    return 0;
}
```



### üîç Example Walkthrough

`fruits = [1, 2, 3, 2, 2]`, `k = 2`:

* Start `left=0`, `right=0`: {1:1} ‚Üí size=1 ‚â§ 2 ‚Üí max=1
* `r=1`: {1:1,2:1} ‚Üí size=2 ‚Üí max=2
* `r=2`: {1:1,2:1,3:1} ‚Üí size=3 > 2 ‚Üí move left:

  * remove fruits[0]=1 ‚Üí {2:1,3:1} left=1 ‚Üí size=2 ‚â§ 2 ‚Üí window [1,2], length 2 ‚Üí max still 2
* `r=3`: add 2 ‚Üí {2:2,3:1} ‚Üí window [1,3] length 3 ‚Üí max=3
* `r=4`: add 2 ‚Üí {2:3,3:1} ‚Üí window length 4 ‚Üí max=4 ‚Üí answer 4.

The algorithm finds the window `[1..4]` (0-indexed) or `[2,3,2,2]`.


### ‚è± Complexity Analysis

* **Time:** `O(n)` ‚Äî each element is visited at most twice (once by `right`, once by `left` when shrinking).
* **Space:** `O(min(n, k))` ‚Äî hashmap stores at most `k+1` distinct keys; in worst-case `O(min(n, distinct_values))`.

`unordered_map` average operations are O(1), but worst-case could be higher depending on hash collisions. For practical input sizes and standard library implementations, it's considered O(1) average.


### üß™ Test Cases

**Basic**

* `fruits = [1,1,1], k = 1` ‚Üí `3`
* `fruits = [1,2,3], k = 1` ‚Üí `1`

**Mixed**

* `fruits = [1,2,1,2,3], k = 2` ‚Üí `4` (subarray `[1,2,1,2]`)
* `fruits = [4,1,1,2,3,1,1], k = 2` ‚Üí `4` (subarray `[1,1,2,3]`? careful - distinct types... actually best is `[1,1,2]` length 3; check your test)

**Edge**

* `fruits = [], k = 2` ‚Üí `0`
* `k = 0` ‚Üí `max` length is the longest run of identical fruit where distinct count must be ‚â§ 0 (interprets as none? Usually k >= 1; treat k=0: result is 0 unless you treat zero distinct allowed meaning no elements ‚Üí 0)
* `k >= number_of_distinct_types` ‚Üí answer = `n`

**Large**

* Alternating values with `k = X` to stress test window adjustments.

(When preparing tests, always hand-verify expected results.)


### ‚ö†Ô∏è Common Pitfalls & Notes

* **Passing `n` separately** is redundant; prefer `fruits.size()`.
* **k = 0** semantics: depending on problem spec, k may be guaranteed ‚â• 1. If `k == 0`, the window must contain ‚â§ 0 distinct types ‚Üí only empty window qualifies, so return 0. Usually problem constraints avoid this or clarify.
* **Negative/large fruit IDs**: `unordered_map<int,int>` handles any int key, including negatives.
* **Performance nuance:** `unordered_map` has average O(1) operations. If fruit IDs are small non-negative integers and `max_value` is small, consider using a vector-based frequency array for micro-optimizations.
* **Stability**: Keep `left` and `right` as integers; don't forget to cast sizes when comparing to `k` to avoid signed/unsigned subtle bugs.


### üîÅ Useful Variations

* **Return indices**: Track and return `(bestLeft, bestRight)` for the longest window.
* **Minimum window with at least k distinct**: Slightly different sliding window variant (often use two pointers but conditions invert).
* **String version**: Replace `fruits` with chars for `longest substring with ‚â§ k distinct characters`.
* **Exact k distinct**: Find longest subarray with *exactly* k distinct types ‚Üí compute `F(k) = longest ‚â§ k` and `F(k-1)` then derive answer? Actually to get exactly k, you'd need adaptions (or two-pass: # of subarrays ‚â§ k minus ‚â§ k-1 = # with exactly k for counting problem).
* **If values bounded** (e.g., 0..1000) use vector<int> freq to avoid hashmap overhead.


### üí° Tips & Tricks (Interview-friendly)

* Explain the **invariant**: after shrinking, `count.size() ‚â§ k`. This proves correctness.
* Show examples where left moves multiple steps after a single right increase ‚Äî demonstrates amortized O(n).
* If asked for memory optimization, mention using hash ‚Üí sliding window index queue for certain problems.
* If asked about hidden constants: `unordered_map` is simple and acceptable; if extreme performance needed and fruit types small, use vector freq.



### üîé Return Indices - Example Code

If you want to also **return the indices** of the best window:

```cpp
pair<int,int> maxFruitsWithIndices(const vector<int> &fruits, int k) {
    int n = fruits.size();
    int left = 0, right = 0;
    int maxLen = 0;
    pair<int,int> best = {-1, -1};
    unordered_map<int,int> count;

    while (right < n) {
        count[fruits[right]]++;
        while ((int)count.size() > k) {
            int f = fruits[left];
            count[f]--;
            if (count[f] == 0) count.erase(f);
            left++;
        }
        if (right - left + 1 > maxLen) {
            maxLen = right - left + 1;
            best = {left, right}; // inclusive
        }
        right++;
    }
    return best;
}
```


### ü§î FAQs

**Q: Why `unordered_map` vs `map`?**
> A: `unordered_map` has average O(1) access. `map` is O(log n) ‚Äî slower. Use `map` only if you need ordered keys.

**Q: What if `k` is bigger than distinct types?**
> A: The entire array is valid ‚Üí return `n`.

**Q: Are there pathological inputs that make `unordered_map` slow?**
> A: Rare, but adversarial inputs could cause collisions. In contests and interviews this is ignored, but in security-critical systems prefer `robin_hood` hashing or other robust maps.

**Q: What about memory?**
> A: `unordered_map` stores up to `k` keys, so memory cost is small relative to `n`, typically `O(k)`.

