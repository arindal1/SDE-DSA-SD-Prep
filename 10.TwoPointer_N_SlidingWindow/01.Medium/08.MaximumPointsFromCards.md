# üÉè Max Score from Card Points [#1423](https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/submissions/1844154512/)



## üßæ Problem Statement

You‚Äôre given:

* An array `cardPoints` where `cardPoints[i]` is the points of the `i`-th card.
* An integer `k`.

You can take exactly **`k` cards**, and each time you must take a card from either the **front** (left end) or the **back** (right end) of the array.

üëâ **Goal:** Return the **maximum total score** you can get.

---

### üß† Intuition

You must pick `k` cards from either end, in any order:

* You might take all `k` cards from the **left**.
* Or all `k` from the **right**.
* Or `x` from the left + `k - x` from the right (for any `0 ‚â§ x ‚â§ k`).

Brute forcing all these combinations directly is possible, but we can do it smartly:

1. First, assume you take all `k` cards from the **left**.
   That gives some initial sum `lSum`.
2. Then, gradually **give up one** card from the left and replace it with one card from the **right**:

   * Remove last chosen left card.
   * Add one more card from the right end.
3. Track the **maximum** sum over all these configurations.

There are only `k + 1` such configurations (0..k cards from left), so iterating over them is O(k). This is exactly what your code does.


### üê¢ Brute Force (conceptual)

One naive idea:

* For each choice `x` from `0` to `k`:

  * Take `x` cards from the left.
  * Take `k - x` cards from the right.
  * Compute the sum each time.

If you recompute the sums from scratch for each `x`, complexity becomes O(k¬≤). Still fine for small `k`, but not great for big ones.

Your solution makes this O(k) by **reusing sums incrementally.**


### ‚ö° Optimal Approach #1 : Enumerate Left/Right Splits (O(k))

### Algorithm

1. Compute:

   ```cpp
   lSum = sum of first k elements (taking all k from left)
   totSum = lSum
   rSum = 0
   ```
2. Maintain a pointer `l` at the **end** of the array (`n - 1`), representing cards from the right.
3. For `j = k-1` down to `0`:

   * Remove `cardPoints[j]` from `lSum` (you give up this left card).
   * Add `cardPoints[l]` to `rSum` (you instead take a right card).
   * Move `l` leftwards.
   * Update `totSum = max(totSum, lSum + rSum)`.

By the end, `totSum` is the maximum score for taking `k` cards from either end.

### Why it works

At iteration:

* `j` tells you how many cards you‚Äôre still taking from left (from index `0` to `j-1`).
* `rSum` accumulates how many from right you‚Äôve taken so far.
* Together, you always use exactly `k` cards (because each step removes one from left and adds one from right).

We‚Äôre basically checking:

* `k` left, `0` right
* `k-1` left, `1` right
* `k-2` left, `2` right
  ...
* `0` left, `k` right

and tracking the best sum.


### ‚úÖ CPP Code (with small, safe tweaks)



```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        long long lSum = 0, rSum = 0;
        long long totSum = 0;

        // Take all k from the left initially
        for (int i = 0; i < k; ++i) {
            lSum += cardPoints[i];
        }
        totSum = lSum;

        int rightIndex = n - 1;
        // Now gradually replace left cards with right cards
        for (int j = k - 1; j >= 0; --j) {
            lSum -= cardPoints[j];           // give up this left card
            rSum += cardPoints[rightIndex];  // take one from right
            --rightIndex;

            totSum = max(totSum, lSum + rSum);
        }

        return static_cast<int>(totSum);
    }
};
```

> If constraints guarantee no overflow for `int`, you *can* keep `int`, but `long long` is safer in general.


### üîç Example Walkthrough

Let‚Äôs say:

```text
cardPoints = [1, 2, 3, 4, 5, 6, 1], k = 3
n = 7
```

1. Initial left sum (take first 3):
   `lSum = 1 + 2 + 3 = 6`
   `rSum = 0`
   `totSum = 6`

2. Start swapping from right:

* Step 1: give up `cardPoints[2] = 3`, take from right `cardPoints[6] = 1`
  `lSum = 6 - 3 = 3`
  `rSum = 0 + 1 = 1`
  total = `4`, `totSum = max(6,4) = 6`

* Step 2: give up `cardPoints[1] = 2`, take from right `cardPoints[5] = 6`
  `lSum = 3 - 2 = 1`
  `rSum = 1 + 6 = 7`
  total = `8`, `totSum = 8`

* Step 3: give up `cardPoints[0] = 1`, take from right `cardPoints[4] = 5`
  `lSum = 1 - 1 = 0`
  `rSum = 7 + 5 = 12`
  total = `12`, `totSum = 12`

Final answer: `12` (taking `[6,5,1]` from the right side).

---

### ‚ö° Optimal Approach #2 ‚Äî ‚ÄúRemove Middle Window‚Äù Trick (O(n))

Another popular way to think about it:

* Instead of choosing `k` cards to **take** from ends,
* Think of choosing `n - k` cards in the **middle** to **throw away** (don‚Äôt take).

Let:

* `total = sum(cardPoints)`
* We want to **minimize** the sum of a **contiguous subarray of length `n - k`**.
* Then result = `total - minSubarraySumOfLength(n - k)`.

Implementation uses a fixed-size sliding window of length `n - k`. Complexity: O(n). For large `k`, Approach #1 is O(k), which is also up to O(n), so both are efficient.

---

### ‚è± Complexity

For your approach:

* **Time:**

  * Sum of first `k` ‚Üí O(k)
  * Loop from `k-1` down to `0` ‚Üí O(k)
    ‚Üí Overall: **O(k)** (and since `k ‚â§ n`, that‚Äôs at most O(n))

* **Space:**

  * O(1) extra (just a few variables).



### üß™ Test Cases

### 1. Basic

```text
cardPoints = [1,2,3,4,5,6,1], k = 3 ‚Üí 12
(cardCombo: 6 + 5 + 1 from right)
```

### 2. All from left

```text
cardPoints = [9,7,7,9,7,7,9], k = 7 ‚Üí sum of all
```

### 3. All from right

```text
cardPoints = [1,1000,1], k = 1 ‚Üí 1000
```

### 4. Mixed choices

```text
cardPoints = [2,2,2], k = 2 ‚Üí 4 (either first 2 or last 2)
cardPoints = [1,2,3,4,5], k = 2 ‚Üí max(1+2, 2+3, 3+4, 4+5, 1+5) = 9 (4+5 or 1+8? no, 4+5)
```

### 5. Edge

```text
cardPoints = [5], k = 1 ‚Üí 5
cardPoints = [1,2,3], k = 3 ‚Üí 6
```


### ‚ö†Ô∏è Common Pitfalls

* Forgetting to consider the case where **all `k` cards come from one side** (your initialization handles this via `totSum = lSum`).
* Off-by-one errors in left/right indices.
* Not tracking the total correctly when subtracting left and adding right.
* Integer overflow if card values and `k` are big ‚Üí use `long long`.


### üîÅ Variations & Extensions

1. **Min score instead of max**
   Same approach, just flip `max` to `min` logic.

2. **Generalized ends-picking**
   Similar problems:

   * Pick `k` items from beginning or end with constraints
   * 2D version (grid ends)
   * Weighted cost vs score

3. **Dynamic constraints**
   Like ‚Äúat most k picks from left‚Äù or ‚Äúat least x from right‚Äù ‚Äî still variations around the same pattern.


### ‚ùì FAQs

**Q: Why not just try every combination of left & right picks?**
A: There are only `k+1` combinations (`0..k` from left), so we basically do try all of them ‚Äî but efficiently, using prefix/suffix sums updated in O(1) per step, giving O(k) instead of O(k¬≤).

**Q: Is Approach #2 better than this?**
A: Both are O(n) in the worst case.

* Approach #1 (your approach) feels more intuitive: ‚ÄúI‚Äôll swap left picks for right picks.‚Äù
* Approach #2 thinks in terms of ‚Äúsmallest middle window to throw away.‚Äù

Use whichever clicks with you or matches the interviewer‚Äôs hints.
