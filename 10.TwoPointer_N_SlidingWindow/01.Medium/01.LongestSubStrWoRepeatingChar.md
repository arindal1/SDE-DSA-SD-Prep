# Length of Longest Substring Without Repeating Characters [#3](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)

> **Goal**
> Given a string `s`, find the length of the longest substring without repeating characters.

## üß© Problem statement

Given a string `s`, return the length of the longest substring that contains no repeating characters.

Examples:

* Input: `"abcabcbb"` ‚Üí Output: `3` (`"abc"`)
* Input: `"bbbbb"` ‚Üí Output: `1` (`"b"`)
* Input: `"pwwkew"` ‚Üí Output: `3` (`"wke"`)

---

### üß† Intuition

Think of a sliding window `[left, right]` that represents a candidate substring with no duplicates. Expand `right` to include new characters. When you hit a repeated character inside the current window, move `left` right after the previous occurrence of that character, so the substring regains uniqueness.

The trick is to remember the last index where each character was seen. That lets you jump `left` forward in one step when needed, instead of moving it one by one.


### üê¢ Brute force idea (and why it‚Äôs slow)

Try every possible substring and check if it's made of unique characters.

* For each start index `i`, expand to all end indices `j` and test uniqueness with a set.
* Time complexity: `O(n^3)` naive (substring extraction + check), or `O(n^2)` with hashing but still too slow for large inputs.

We want `O(n)` or close to it. Enter sliding window.


### üî• Optimal approach : sliding window + last-seen map

Key idea:

* Maintain `left` and `right` pointers for the current window.
* Keep an array or map `lastSeen` that stores the **most recent index** of each character (or -1 if unseen).
* When we see `s[right]` and `lastSeen[s[right]] >= left`, we must move `left` to `lastSeen[s[right]] + 1` to remove the duplicate from the window.
* Update `lastSeen[s[right]] = right`, then compute window length `right - left + 1`, and update `maxLen`.

Important safety detail:

* In C++ `char` may be signed, so when indexing an array of size 256, cast to `unsigned char` to avoid negative indices.

This yields linear time `O(n)` and constant extra space `O(1)` (array of size 256) when alphabet is fixed. If using a general Unicode set, use `unordered_map<char, int>`.


### ‚öõÔ∏è Clean C++ code


```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int lengthOfLongestSubstring(const string& s) {
        if (s.empty()) return 0;
        int n = (int)s.size();

        // last position seen for each possible byte value; -1 means unseen.
        vector<int> lastSeen(256, -1);

        int left = 0;
        int maxLen = 0;

        for (int right = 0; right < n; ++right) {
            unsigned char uc = static_cast<unsigned char>(s[right]);
            if (lastSeen[uc] >= left) {
                // duplicate inside current window -> move left
                left = lastSeen[uc] + 1;
            }
            lastSeen[uc] = right;
            maxLen = max(maxLen, right - left + 1);
        }
        return maxLen;
    }
};
```

If you prefer a version using `unordered_map<char, int>` for generality (eg. for Unicode or very large alphabets), swap the `vector` for a `map` - same logic.

---

### ü™ú Step-by-step worked example

Input: `"abba"`

* Initialize `lastSeen` = all `-1`, `left = 0`, `maxLen = 0`.
* `right = 0` -> `'a'`, lastSeen['a'] = -1 -> no move, lastSeen['a'] = 0, maxLen = 1 (`[0..0]`)
* `right = 1` -> `'b'`, lastSeen['b'] = -1 -> no move, lastSeen['b'] = 1, maxLen = 2 (`[0..1]`)
* `right = 2` -> `'b'`, lastSeen['b'] = 1 >= left -> left = 1 + 1 = 2; update lastSeen['b'] = 2; maxLen = max(2, 2-2+1=1) = 2
* `right = 3` -> `'a'`, lastSeen['a'] = 0 < left(2) -> no move; lastSeen['a'] = 3; maxLen = max(2, 3-2+1 = 2) = 2

Answer is `2`. The longest unique substrings are `"ab"` and `"ba"`.


### üß™ Important test cases

* Empty string: `""` ‚Üí `0`
* Single char: `"a"` ‚Üí `1`
* All unique: `"abcdef"` ‚Üí `6`
* All same: `"aaaaa"` ‚Üí `1`
* Repeating pattern: `"abcabcbb"` ‚Üí `3`
* Palindrome-like duplicates: `"abba"` ‚Üí `2`
* Edge with signed `char` if not cast: use `"\x80\x81"` to check indexing safety

Also try:

* Long string with no repeats to test performance
* Mixed ASCII and extended bytes if using byte-based solution


### ‚åõ Complexity analysis

* Time complexity: **O(n)**, where `n` is the length of `s`. Each character is processed once and left moves only forward.
* Space complexity:

  * **O(1)** if you use a fixed 256-size `vector<int>` for ASCII/byte characters.
  * **O(min(n, k))** if using a hash map with `k` being character variety (for Unicode use).


### üêç Tips, tricks, and pitfalls

* Always cast `char` to `unsigned char` when using it to index a 256-sized vector in C++. Without this, negative `char` values can cause UB.
* Use `lastSeen[c] = -1` initial value so a previously unseen character doesn't move `left`.
* Update `maxLen` after you update `left` and `lastSeen` for clarity.
* You can implement with `unordered_map<char,int>` for arbitrary alphabets, but vector is fastest for fixed small alphabets.
* If you need the actual substring, you can store the best `left` and `right` seen so far, then extract `s.substr(bestLeft, bestLen)` at the end.


### üîÅ Variations & related problems

* Longest substring with at most K distinct characters
* Longest substring with all unique vowels only
* Longest substring containing exactly K distinct characters
* Longest substring with at most one repeating character
* Longest palindromic substring (different technique, Manacher or expand-around-center)


### ‚ÅâÔ∏è FAQs

**Q: Why move `left` to `lastSeen[c] + 1` instead of `lastSeen[c]`?**
> Because `lastSeen[c]` is the index of the duplicate character inside the current window. You want to exclude that previous occurrence, so the new window should start right after it.

**Q: Can `left` ever move backwards?**
> No. `left` only moves forward, which guarantees linear time.

**Q: Do I always need 256-sized array?**
> No. If your input is strictly lowercase letters, you can use size 26 and map `'a'` to `0`. When in doubt, 256 covers all byte values.

**Q: What about Unicode?**
> If `s` contains multi-byte or wide characters, treat them properly as `wstring` or process codepoints; using `char` and 256-sized arrays won‚Äôt be correct for multi-byte encodings like UTF-8.

**Q: Can we also return the substring itself?**
> Yes. Track the `start` index when you update `maxLen`, then return `s.substr(start, maxLen)`.

