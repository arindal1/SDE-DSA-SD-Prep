# ðŸŽ¯ Character Replacement (LeetCode [424](https://leetcode.com/problems/longest-repeating-character-replacement/description/))

## âœ… Problem Statement (short)

Given a string `s` consisting of uppercase English letters and an integer `k`, you may replace **at most `k` letters** in the string with any other letter. Return the **length of the longest substring** containing the same letter after at most `k` replacements.

**Example**

```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in "BABBA" to get "BBBB" or replace the 'B' in "AABA" to get "AAAA". Longest length = 4.
```


## ðŸ§  Intuition

We want the longest window where the number of letters that are **not** the most frequent letter in that window â‰¤ `k`.
Equivalently, in a window `[l..r]` if `maxFreq` is the count of the most common letter inside that window, then the number of replacements required is:

```
window_size - maxFreq
```

We need this to be â‰¤ `k`. So expand the right pointer, update counts and the current `maxFreq`. If the required replacements exceed `k`, move the left pointer forward until the window is valid again. Track the maximum window size throughout.

This is a standard variable-length sliding-window problem.


### ðŸ§ª Brute Force (naive)

* Try every substring `s[i..j]` (O(nÂ²)).
* For each substring, compute frequency counts and check how many replacements needed -> O(26) to compute `maxFreq`.
* Total: O(26 * nÂ²) â‰ˆ O(nÂ²) time, O(1) extra space.

Not great for big `n` (n up to 10âµ in constraints). Sliding window brings this down to linear time.


### âš¡ Optimal Approach - Sliding Window (O(n), O(1) space)

Key idea:

* Maintain frequency array `freq[26]` for window `[l..r]`.
* Keep `maxFreq` = maximum frequency of any letter seen **so far in any window ending at current r**.
* Expand `r` incrementally; after each addition:

  * If `(r - l + 1) - maxFreq > k`, shrink from `l` (decrement frequency).
  * Update `maxLen` at each step.

**Important subtlety:** we do *not* recompute `maxFreq` when shrinking. `maxFreq` is allowed to be a non-decreasing value (it only increases when we see more occurrences of some letter). Even if `maxFreq` becomes stale (but larger than the true current max in the active window), the algorithm remains correct â€” the window may be temporarily larger than strictly allowed by the exact current `maxFreq`, but if replacements required exceed `k` we will shrink `l`. Using the monotonic `maxFreq` keeps complexity linear; recomputing max each shrink would cost extra O(26) but still constant factor.


### âœ… Cleaned & Commented C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int characterReplacement(const string &s, int k) {
        int n = s.size();
        if (n == 0) return 0;

        vector<int> freq(26, 0);
        int left = 0;
        int maxFreq = 0;     // highest frequency of any single char seen in the current sliding progress
        int maxLen = 0;

        for (int right = 0; right < n; ++right) {
            // include s[right]
            int idx = s[right] - 'A';
            freq[idx]++;
            maxFreq = max(maxFreq, freq[idx]);

            // if replacements needed exceed k, shrink window from left
            while ((right - left + 1) - maxFreq > k) {
                freq[s[left] - 'A']--;
                left++;
                // Note: we do NOT recompute maxFreq here â€” it's allowed to be non-decreasing
            }

            maxLen = max(maxLen, right - left + 1);
        }

        return maxLen;
    }
};
```



### ðŸ” Walkthrough (example)

` s = "AABABBA"`, `k = 1`

* Expand window and update `freq` and `maxFreq`:

  * r=0: "A" â†’ maxFreq=1, window=1 â†’ maxLen=1
  * r=1: "AA" â†’ maxFreq=2, window=2 â†’ maxLen=2
  * r=2: "AAB" â†’ maxFreq=2, replacements needed=1 â†’ ok â†’ maxLen=3
  * r=3: "AABA" â†’ maxFreq=3, replacements=1 â†’ ok â†’ maxLen=4
  * r=4: "AABAB" â†’ maxFreq=3, replacements=2 > k â†’ shrink left until replacements â‰¤ k

    * shrink => left moves, window becomes valid...
  * Continue and final `maxLen = 4`.

### âœ… Return Indices : C++ snippet

If you want the substring indices too:

```cpp
pair<int,int> characterReplacementWithIndices(const string &s, int k) {
    int n = s.size();
    if (n == 0) return {-1, -1};

    vector<int> freq(26, 0);
    int left = 0, maxFreq = 0, bestLen = 0;
    pair<int,int> best = {0, 0};

    for (int right = 0; right < n; ++right) {
        int idx = s[right] - 'A';
        freq[idx]++;
        maxFreq = max(maxFreq, freq[idx]);

        while ((right - left + 1) - maxFreq > k) {
            freq[s[left] - 'A']--;
            left++;
        }

        if (right - left + 1 > bestLen) {
            bestLen = right - left + 1;
            best = {left, right}; // inclusive indices
        }
    }
    return best;
}
```

### â± Complexity

* **Time:** `O(n)` â€” single pass; `left` and `right` each move at most `n` steps.
* **Space:** `O(1)` â€” `freq` has fixed 26 slots, other variables constant.

Small constant factors â€” very fast in practice.


### ðŸ§ª Test Cases

**Basic**

```
s = "A", k = 0 -> 1
s = "AA", k = 2 -> 2
s = "AB", k = 1 -> 2
```

**Given**

```
s = "AABABBA", k = 1 -> 4
```

**Edge**

```
s = "", k = 0 -> 0
s = "AAAA", k = 0 -> 4
s = "ABCDE", k = 10 -> 5
s = "ABABBA", k = 2 -> 6
```

**Large**

* long random uppercase strings with various `k` values to confirm linear runtime.


### âš ï¸ Common Mistakes

* Recomputing `maxFreq` on every left move (works but unnecessary).
* Off-by-one error when computing window size: use `(right - left + 1)`.
* Forgetting to handle empty string â€” return 0.
* Not limiting frequencies to `'A'..'Z'` if input may contain other characters â€” problem statement usually guarantees uppercase letters.


### ðŸ” Variations & Extensions

* **Lowercase string:** use `'a'` base instead of `'A'` or map characters dynamically.
* **Return substring indices** (the actual longest window) â€” track `bestLeft` when updating `maxLen`.
* **Minimum replacements to get substring of length `L` all same** â€” can binary search length `L` + sliding window check.
* **Exact `k` replacements** (not at most): requires slight changes to check equality rather than â‰¤.


### ðŸ’¡ Tips & Interview Notes

* Emphasize the **invariant**: after shrinking, `(window_size) - maxFreq â‰¤ k`.
* Explain why `maxFreq` can be left stale: it only increases, so amortized logic still holds.
* If interviewers push: demonstrate the O(n * 26) alternative that recomputes max on shrink, then explain why we prefer the monotonic `maxFreq` trick for speed and clarity.
* Mention complexity and edge cases explicitly.


### ðŸ”Ž FAQ 

**Q: Why not recompute `maxFreq` from `freq[]` after every change?**
> A: You *can* (cost O(26) = O(1) per step). But monotonic `maxFreq` keeps the code simpler and runs faster in practice.

**Q: Does this handle lowercase letters?**
> A: Change `'A'` â†’ `'a'` base or use a bigger map/dictionary.

**Q: What if k is huge?**
> A: If `k >= n`, answer is `n` â€” the whole string can be turned into one letter.

**Q: Can this be extended to arbitrary alphabets?**
> A: Yes â€” either a map/dict for frequencies or a vector sized to the alphabet. Complexity remains linear.

