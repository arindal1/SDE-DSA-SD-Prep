# ðŸªŸ Minimum Window Substring [#76](https://leetcode.com/problems/minimum-window-substring/description/)


## ðŸ§¾ Problem Statement

You are given two strings:

* `s` (the main string)
* `t` (the pattern string)

Find the **smallest substring of `s`** that contains **all the characters of `t`**, including duplicates.
If no such substring exists, return an empty string `""`.

> Order doesnâ€™t matter. You just need all characters of `t` present in any order within some window of `s`.

### Example

```text
s = "ADOBECODEBANC"
t = "ABC"

Answer: "BANC"
```

Because:

* `"ADOBEC"` contains A, B, C (valid) but length 6.
* `"BANC"` contains A, B, C and has length 4. Thatâ€™s the minimum.


### ðŸ§  Intuition

We want the **smallest window** `[l..r]` in `s` that contains all characters of `t` with correct frequencies.

Brute forcing all windows is too slow. Instead, sliding window comes to the rescue:

1. Expand the window to the right until it contains all characters of `t`.
2. Once valid, try to **shrink from the left** while still remaining valid.
   Each time itâ€™s valid, check if this window is the smallest so far.
3. Repeat until the right pointer reaches the end.

We track how many required characters we have matched using a frequency table and a running `cnt` of how many characters from `t` are currently satisfied.

Think of it like trying to collect all Infinity Stones with minimum walking distance. Once youâ€™ve got them all, you try to minimize the path while still holding all of them. ðŸ˜„


### ðŸ¢ Brute Force Approach

### Idea

Check all substrings `s[i..j]`:

1. For every pair `(i, j)`:

   * Count characters in `s[i..j]`.
   * Compare with frequency of `t`.
   * If window covers `t`, update minimum length.

### Complexity

* There are O(nÂ²) substrings.
* Checking each substring against `t` can cost up to O(Î£) or O(n) depending on implementation.
* Overall worst case: **O(nÂ³)** naive, or **O(nÂ²)** with some optimizations.

Not great for large `n`. So we move to sliding window.


### âš¡ Optimal Approach â€” Sliding Window + Frequency Array

### Key Ideas

* Use a frequency array `hash[256]` to store counts of characters needed from `t`.
* `hash[c] > 0` means we still need that many of character `c` to fully cover `t`.
* A variable `cnt` tracks how many total characters from `t` are currently matched in the window.
* We move `r` right to expand the window and `l` right to shrink it when we have a valid window.

### Algorithm

1. Preprocess `t`:

   ```cpp
   vector<int> hash(256, 0);
   for (char c : t) {
       hash[(unsigned char)c]++;
   }
   ```
2. Initialize:

   ```cpp
   int l = 0, r = 0;
   int cnt = 0;           // total matched characters from t
   int minLen = INT_MAX;  // best window length
   int startIndex = -1;   // start of best window
   ```
3. Expand right pointer:

   * If `hash[s[r]] > 0`, we are using a needed character â†’ `cnt++`.
   * Then decrement `hash[s[r]]` (weâ€™re taking one instance of that character into our window).
4. Once `cnt == m` (where `m = t.size()`), it means current window has all characters of `t`.

   * Now try to shrink from the left:

     * While still valid:

       * Update `minLen` and `startIndex` if this window is better.
       * Add back `s[l]` to `hash`, and if `hash[s[l]] > 0` after increment, it means removing `s[l]` broke the full coverage, so `cnt--`.
       * Move `l++`.
5. Continue until `r` reaches the end of `s`.
6. If `startIndex == -1`, no valid window was found â†’ return `""`.
   Otherwise, return `s.substr(startIndex, minLen)`.


### âœ… Polished CPP Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    string minWindow(string s, string t) {
        int n = s.size();
        int m = t.size();

        if (n < m || m == 0) {
            return "";
        }

        // Frequency of characters required from t
        vector<int> hash(256, 0);
        for (int i = 0; i < m; ++i) {
            hash[(unsigned char)t[i]]++;
        }

        int left = 0, right = 0;
        int cnt = 0;                // total matched characters from t
        int minLen = INT_MAX;
        int startIndex = -1;

        while (right < n) {
            unsigned char rc = (unsigned char)s[right];

            // If this character is still needed
            if (hash[rc] > 0) {
                cnt++;
            }
            // Use this character in our window
            hash[rc]--;

            // When we have all characters from t in current window
            while (cnt == m) {
                // Update answer if this window is smaller
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    startIndex = left;
                }

                unsigned char lc = (unsigned char)s[left];
                hash[lc]++;

                // If adding this back makes it > 0,
                // it means we just removed a required char from the window
                if (hash[lc] > 0) {
                    cnt--;
                }

                left++;
            }

            right++;
        }

        return (startIndex == -1) ? "" : s.substr(startIndex, minLen);
    }
};
```

> Your original logic was correct. The important tweak is casting `s[...]` to `(unsigned char)` consistently when indexing into `hash`.


### ðŸ” Walkthrough Example

Take:

```text
s = "ADOBECODEBANC"
t = "ABC"
```

* Initially populate `hash` with counts of `A`, `B`, `C`.
* Move `right` across `s`:

  * When you see `A`, `B`, or `C` and `hash[c] > 0`, you increment `cnt`.
  * Every time `cnt == t.size()` (which is 3), you know current window has all required chars.
  * Then you push `left` forward as far as possible while keeping `cnt == 3`, updating the minimum window along the way.
* Eventually you discover `"BANC"` as the shortest window.


### â± Complexity

* **Time:**

  * Each character is visited at most twice (once when `right` moves, once when `left` moves).
  * Overall complexity: **O(n + m)**.

* **Space:**

  * `hash[256]` is constant size (assuming ASCII).
  * So: **O(1)** extra space.


### âš ï¸ Edge Cases

* `s` shorter than `t`: immediately return `""`.
* `t` empty: depending on problem spec; here we just return `""`.
* Duplicate characters in `t`:

  * Handled by frequency counts correctly (we require all occurrences).
* Characters in `s` that do not appear in `t`:

  * They will make `hash[c]` go negative but thatâ€™s fine; it just means â€œwe have extra copies of that characterâ€.


### ðŸ§ª Test Cases

### Basic

```cpp
s = "ADOBECODEBANC", t = "ABC" -> "BANC"
s = "a",               t = "a"   -> "a"
s = "a",               t = "aa"  -> ""
```

### Mixed

```cpp
s = "aa",       t = "aa"  -> "aa"
s = "aaab",     t = "ab"  -> "ab"
s = "ab",       t = "b"   -> "b"
s = "abc",      t = "ac"  -> "abc"
```

### Edge

```cpp
s = "",         t = "a"   -> ""
s = "abc",      t = ""    -> ""  (depending on spec)
s = "aaaaab",   t = "ab"  -> "ab"
```


### ðŸ§  Common Pitfalls

* Forgetting to cast `char` to `unsigned char` when indexing into `hash[256]` on systems where `char` is signed.
* Using `cnt` incorrectly:

  * `cnt` should track how many characters of `t` (including duplicates) have been matched, not how many distinct characters.
* Forgetting to decrease `cnt` when moving `left` and losing a required character.
* Off by one mistakes in `substr(sInd, minLen)` or in checking `r - l + 1`.

### ðŸ” Variations

* **Minimum window with all characters from a set** (like all vowels, etc).
* **Minimum window containing all characters of `t` at least once, but `t` may have duplicates or even weights.**
* **Find the maximum window with at most `k` of something**
  This often flips into the â€œat most kâ€ pattern you already used in previous problems.


### â“ FAQs

**Q: Why does `cnt == m` guarantee we have all characters from `t`?**
Because:

* We initialize `hash` with `hash[c] = frequency of c in t`.
* Every time we see a character `c` in `s` such that `hash[c] > 0`, we know that one of the required `c`s is being satisfied, so `cnt++`.
* `cnt` counts how many characters from `t` have been satisfied so far (including duplicates).
* When `cnt == m` (the length of `t`), all required characters are included at least as many times as in `t`.

**Q: Why do `hash` values go negative sometimes?**
That just means the current window has more than enough of that character. It doesnâ€™t hurt the logic.

**Q: Why not use a `map<char,int>` instead of a 256-array?**
You can, but `vector<int> hash(256)` is faster and simpler if you assume ASCII chars.

