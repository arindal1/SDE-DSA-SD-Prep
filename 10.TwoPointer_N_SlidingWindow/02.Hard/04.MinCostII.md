
# ğŸ§® Minimum Cost with Sliding Window + K Smallest Elements [Leetcode #[3013](https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/description/)]

## ğŸ“Œ Problem Statement (Simplified)

You are given:

* An array `nums`
* An integer `k`
* An integer `dist`

You must:

* Always include `nums[0]`
* Choose **kâˆ’1 more elements**
* Those elements must lie within a **window of size `dist+1`**
* Minimize the **total sum**

Return the minimum possible cost.



## ğŸ§  Why this problem matters

This problem tests:

* Sliding window technique
* Maintaining **k smallest elements dynamically**
* Multiset / balanced BST usage
* Two-heap / two-set pattern
* Real-world streaming statistics

This is a **Google-level pattern**.

Think of it as:

> â€œAt every step, keep the cheapest kâˆ’1 items nearbyâ€ ğŸ›’ğŸ˜„



## ğŸ§© Core Intuition (THE KEY ğŸ”‘)

We want:

```
nums[0] + sum of (kâˆ’1 smallest elements in window)
```

But the window keeps sliding.
So we need a structure that can:

* Insert elements
* Remove elements
* Always give sum of kâˆ’1 smallest

All in **log time**.



# ğŸ”¥ Optimal Strategy: Two Multisets

We maintain two sets:

### 1ï¸âƒ£ `low`

Stores the **kâˆ’1 smallest elements**

### 2ï¸âƒ£ `high`

Stores the remaining elements

And we maintain:

```
sumLow = sum of elements in low
```

So answer at any time:

```
nums[0] + sumLow
```



# ğŸ§  Data Structure Invariant

At all times:

* `low.size() == k-1`
* Every element in `low` â‰¤ every element in `high`

This is basically a **dynamic k-smallest tracker**.



# ğŸ§  Code Walkthrough (Your Implementation)

## Class Members

```cpp
multiset<long long> low, high;
long long sumLow = 0;
int k_minus_1;
```

* `low` â†’ kâˆ’1 smallest elements
* `high` â†’ rest
* `sumLow` â†’ running sum of low
* `k_minus_1 = k-1`



## â• Add Operation

```cpp
void add(int x) {
    low.insert(x);
    sumLow += x;

    if (low.size() > k_minus_1) {
        long long val = *low.rbegin(); // largest in low
        sumLow -= val;
        high.insert(val);
        low.erase(prev(low.end()));
    }
}
```

### Whatâ€™s happening?

* Insert into `low`
* If `low` becomes too big:

  * Move the **largest element** from `low` â†’ `high`

This keeps `low` containing only the kâˆ’1 smallest.



## â– Remove Operation

```cpp
void remove(int x) {
    auto it = low.find(x);
    if (it != low.end()) {
        sumLow -= x;
        low.erase(it);

        if (low.size() < k_minus_1 && !high.empty()) {
            long long val = *high.begin();
            sumLow += val;
            low.insert(val);
            high.erase(high.begin());
        }
    } else {
        high.erase(high.find(x));
    }
}
```

### Whatâ€™s happening?

* If `x` was in `low`:

  * Remove it
  * Pull smallest from `high` to rebalance
* Else:

  * Just remove from `high`

This maintains the invariant.



# ğŸ§  Main Sliding Window Logic

```cpp
for (int i = 1; i <= dist + 1; ++i)
    add(nums[i]);
```

Initial window:
We take elements from indices `[1 ... dist+1]`



### First Cost

```cpp
long long minCost = nums[0] + sumLow;
```



### Slide the Window

```cpp
for (int i = 1; i + dist + 1 < n; ++i) {
    remove(nums[i]);
    add(nums[i + dist + 1]);
    minCost = min(minCost, nums[0] + sumLow);
}
```

Classic sliding window:

* Remove left
* Add right
* Update answer



# â± Complexity Analysis

| Metric           | Value          |
| - | -- |
| Time Complexity  | **O(N log K)** |
| Space Complexity | **O(K)**       |

Because:

* Each add/remove is `log K`
* Window slides N times



# ğŸ§ª Example Walkthrough

```
nums = [10, 1, 3, 5, 2, 8]
k = 3
dist = 2
```

Window size = `dist+1 = 3`

We always include `10`
We choose 2 smallest from window.

Sliding window picks:

* {1,3,5} â†’ sumLow = 1+3 = 4 â†’ cost = 14
* {3,5,2} â†’ sumLow = 2+3 = 5 â†’ cost = 15
* {5,2,8} â†’ sumLow = 2+5 = 7 â†’ cost = 17

Minimum = **14**



# ğŸ§  Why this is a brilliant pattern

This technique appears in:

* Sliding window median
* K smallest in stream
* Maintain top K elements
* Online statistics
* Dynamic percentile queries

Itâ€™s the **â€œtwo heaps / two setsâ€ master pattern**.



# ğŸš€ Variations & Related Problems

### 1ï¸âƒ£ Sliding Window Median

Same idea, but balance two halves.

### 2ï¸âƒ£ K Largest Elements in Stream

Use reversed logic.

### 3ï¸âƒ£ Online Order Statistics

Generalization of this.

### 4ï¸âƒ£ Minimize Deviation in Array

Also uses multiset balancing.





# â“ FAQs

### Q1: Why multiset and not priority_queue?

Because we need:

* Deletions of arbitrary elements
* Not just top element



### Q2: Why not sort every window?

That would be:

```
O(N * dist * log dist)
```

Way too slow.



### Q3: Is this interview-level?

This is **top-tier**.
More common in:

* Google
* Meta
* Hard LeetCode
* Competitive programming



### Q4: Can this be done with heaps?

Yes, but you need **lazy deletion**, which is more complex.



# ğŸ§  Quick Revision Cheat Sheet ğŸ“

```
Two multisets:
low = k smallest
high = rest
Maintain sumLow
Sliding window:
  remove left
  add right
Answer = nums[0] + sumLow
```

