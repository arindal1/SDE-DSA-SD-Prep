# üî° Longest Substring With At Most `k` Distinct Characters #[GFG](https://www.geeksforgeeks.org/problems/longest-k-unique-characters-substring0853/1)



## üßæ Problem Statement

**Goal:**
Given a string `s` and an integer `k`, find the **length of the longest substring** that contains **at most `k` distinct characters**.

> A substring is a contiguous block of characters in the string.

### Example

```text
Input:
s = "aababbcaacc"
k = 2

Output:
8

Explanation:
One of the longest substrings with at most 2 distinct characters is "abbcaacc" (or others of length 8 depending on how you slice it).
```

---

### üß† Intuition

We want the longest window `[l..r]` such that the **number of distinct characters** in that window is ‚â§ `k`.

This is a perfect use case for a **sliding window** + **frequency map**:

* Expand `r` to include more characters.
* Track counts of each character in a hashmap (`unordered_map<char,int>`).
* If the number of distinct chars (`map.size()`) becomes more than `k`, shrink from the left (`l++`) until distinct characters ‚â§ `k` again.
* At each step, track the maximum window length.

Think of it like keeping a playlist that can only contain at most `k` artists. As soon as you add a song from a `(k+1)`-th artist, you start dropping songs from the beginning until you‚Äôre back to at most `k` artists. Meanwhile, you remember the longest ‚Äúvalid playlist‚Äù you had. üéß


### üê¢ Brute Force Approach

#### Idea

Check **all substrings**, and for each substring, count how many distinct characters it has.

1. For each `i` from 0 to n-1:

   * For each `j` from `i` to n-1:

     * Build `s[i..j]`, use a set or frequency map to count distinct characters.
     * If distinct ‚â§ `k`, update answer.

#### Complexity

* There are O(n¬≤) substrings.
* Counting distinct chars for each substring na√Øvely is O(n) ‚Üí total O(n¬≥).
* With some prefix tricks / reusing counts per start index, you might push it to ~O(n¬≤).

Still too slow for large strings (`n` up to 10‚Åµ).



### ‚ö° Optimal Approach ‚Äî Sliding Window (Two Pointers)

#### Key Observations

* We only care about **contiguous** substrings.
* Characters are processed from left to right.
* We maintain:

  * `l` (left index),
  * `r` (right index),
  * a hashmap `map<char,int>` tracking character frequencies in `[l..r]`,
  * and ensure `map.size() <= k`.

#### Algorithm

1. Initialize:

   ```cpp
   int l = 0, r = 0, maxLen = 0;
   unordered_map<char,int> freq;
   ```
2. While `r < n`:

   * Add `s[r]` to the map: `freq[s[r]]++`.
   * If `freq.size() > k`, shrink from the left:

     * Decrement `freq[s[l]]`.
     * If `freq[s[l]] == 0`, erase that char from map.
     * Move `l++`.
   * Now window `[l..r]` has at most `k` distinct chars.
   * Update `maxLen = max(maxLen, r - l + 1)`.
   * `r++`.



### ‚úÖ Polished C++ Version


```cpp
#include <bits/stdc++.h>
using namespace std;

// Returns length of the longest substring with at most k distinct characters
int distinctChars(const string &s, int k) {
    int n = s.size();
    int maxLen = 0;
    int left = 0, right = 0;
    unordered_map<char, int> freq; // char -> count in current window

    while (right < n) {
        freq[s[right]]++;

        // If more than k distinct characters, shrink from left
        while ((int)freq.size() > k) {
            char c = s[left];
            freq[c]--;
            if (freq[c] == 0) {
                freq.erase(c);
            }
            left++;
        }

        // Now [left..right] has at most k distinct chars
        maxLen = max(maxLen, right - left + 1);
        right++;
    }

    return maxLen;
}

int main() {
    string s = "aababbcaacc";
    int k = 2;

    cout << distinctChars(s, k) << endl;
    return 0;
}
```

---

### üîç Walkthrough Example

Let‚Äôs walk `s = "aababbcaacc"`, `k = 2` conceptually (short version):

* Expand window and keep at most 2 distinct chars:

  * `"a"` ‚Üí ok
  * `"aa"` ‚Üí ok
  * `"aab"` ‚Üí ok (a, b)
  * `"aaba"` ‚Üí ok
  * `"aabab"` ‚Üí ok
  * `"aababb"` ‚Üí ok
  * `"aababba"` ‚Üí ok
  * `"aababbca"` ‚Üí now (a, b, c) ‚Üí 3 distinct ‚Üí too many.
* Start shrinking from the left until only 2 distinct remain:

  * Remove chars from the left and update the map.
* Track the longest window you had at any point where `freq.size() <= k`.

This sliding behavior is like dragging a rubber band over the string and stretching it as far as possible while keeping the ‚Äúdistinct char limit‚Äù satisfied.


### ‚è± Complexity Analysis

* **Time:** O(n) average
  Each character is added once (when `right` moves) and removed at most once (when `left` moves).
  `unordered_map` operations are O(1) average.

* **Space:** O(min(n, alphabet_size))
  In worst case, you store up to all distinct characters in the map. With lowercase letters, that‚Äôs at most 26.


### üß™ Test Cases

### Basic

```cpp
s = "aababbcaacc", k = 2 -> 8
s = "eceba",       k = 2 -> 3   // "ece"
s = "aa",          k = 1 -> 2   // "aa"
```

### Edge Cases

```cpp
s = "", k = 2        -> 0
s = "a", k = 0       -> 0 (can't have any distinct chars)
s = "a", k = 1       -> 1
s = "abc", k = 3     -> 3 (whole string)
s = "abc", k = 1     -> 1 (any single char)
```

### Stress / Bigger Patterns

```cpp
s = "aaaaaa", k = 1  -> 6
s = "abaccc", k = 2  -> 4   // "accc"
```


### ‚ö†Ô∏è Common Pitfalls

* Forgetting to remove characters from the map when their count hits zero.
* Off-by-one errors when calculating length ‚Üí always use `right - left + 1` for inclusive windows.
* Misunderstanding the condition: this is **‚Äúat most‚Äù** `k` distinct, not **‚Äúexactly‚Äù** `k`.
* Using `map` instead of `unordered_map` ‚Äî still correct but a bit slower (O(log n) per operation).


### üîÅ Variations You‚Äôll See in Interviews

This sliding-window + hashmap template is super reusable:

1. **Longest substring with at most `k` distinct characters** (this problem).
2. **Longest substring with exactly `k` distinct characters**
   ‚Üí often implemented as:

   ```text
   exactly(k) = atMost(k) - atMost(k - 1)
   ```
3. Same idea but on arrays:

   * Longest subarray with at most `k` distinct elements.
4. Combine with counts:

   * Longest substring where each char frequency must obey some rule.
5. Restrict alphabet:

   * e.g., only lowercase, digits, etc. ‚Üí you can use a fixed-size frequency array instead of a hashmap for speed.


### üí° Tips & Interview Nuggets

* Explicitly mention the **invariant**:

  > ‚ÄúAt every step, our window `[left..right]` contains at most `k` distinct characters.‚Äù
* Be prepared to explain `while (map.size() > k)`:

  * This loop ensures we shrink until we're valid again.
* Mention average-case complexity of `unordered_map` for brownie points.
* If they ask for exactly `k` distinct characters, immediately mention the ‚ÄúatMost trick‚Äù.


### ‚ùì FAQs

**Q: What if `k` is larger than number of distinct chars in `s`?**
A: Then the whole string is valid. The answer = `s.length()`.

**Q: Does this work for Unicode or just lowercase letters?**
A: Conceptually works for any chars. But `unordered_map<char,int>` assumes `char`. For Unicode, you‚Äôd use `unordered_map<wchar_t,int>` or something similar depending on encoding.

**Q: Can we do this without using a hashmap?**
A: If we know the alphabet is small and bounded (like only lowercase English), we can use a fixed `vector<int> freq(26)` and track distinct count separately.

