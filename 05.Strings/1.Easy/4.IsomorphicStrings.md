# ✨ Isomorphic Strings

> **Problem** — Given two strings `s` and `t`, determine if they are *isomorphic*.
> Two strings are **isomorphic** if the characters in `s` can be replaced to get `t`, with a **one-to-one mapping** between characters (no two chars in `s` map to the same char in `t`) and mapping respects order.

This corresponds to LeetCode **205. Isomorphic Strings**.



### ✅ Example

* `s = "egg"`, `t = "add"` → **true**
  mapping: `e -> a`, `g -> d`
* `s = "foo"`, `t = "bar"` → **false**
  `o` would need to map to both `a` and `r`
* `s = "paper"`, `t = "title"` → **true**



## 💡 Intuition 

We need to check whether there's a consistent *bijective* (one-to-one) mapping from characters of `s` to characters of `t`. For each index `i`:

* If we've seen `s[i]` before, it must map to the same `t[i]` as earlier.
* If `s[i]` hasn't been seen, we must ensure `t[i]` hasn't already been mapped to some other `s`-character (to keep the mapping injective).

There are two common, efficient approaches:

1. **Index-last-seen technique**
   Track the last index where each character appeared in `s` and `t`. If the last-seen indices differ at any position, mapping fails.

2. **Explicit char-to-char mapping (and reverse check)**
   Maintain a map `mapS2T` and a reverse `mapT2S` (or a set of already-mapped `t` characters). Ensure consistency and injectivity.

Both run in **O(n)** time and use **O(1)** extra space for fixed alphabet (or O(min(n, alphabet)) with maps).



## 😬 Brute Force (inefficient) 

One could attempt to try all possible mappings (exponential) or for each character of `s` check repeatedly that mapping holds using nested loops — **O(n²)** or worse. This is unnecessary; linear solutions exist and are simple.

---
---


### Implementation A — Index-last-seen (Recommended for speed)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    bool isIsomorphic(const string &s, const string &t) {
        if (s.size() != t.size()) return false;
        // Assuming input is ASCII (256). For Unicode you'd use unordered_map<int,int>.
        vector<int> lastS(256, 0), lastT(256, 0);

        for (int i = 0; i < (int)s.size(); ++i) {
            unsigned char cs = static_cast<unsigned char>(s[i]);
            unsigned char ct = static_cast<unsigned char>(t[i]);

            // Use i+1 so default 0 means "not seen yet"
            if (lastS[cs] != lastT[ct]) return false;

            lastS[cs] = i + 1;
            lastT[ct] = i + 1;
        }
        return true;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s, t;
    // Read two whitespace-separated strings (single test)
    if (!(cin >> s >> t)) {
        cout << "Input error\n";
        return 0;
    }

    Solution sol;
    cout << (sol.isIsomorphic(s, t) ? "true\n" : "false\n");
    return 0;
}
```

**Why `i + 1`?**
We initialize arrays with `0`. If we store the *index* directly, index `0` would be stored for the first occurrence and it's indistinguishable from "not seen". Using `i + 1` makes `0` mean *not seen yet*, and any positive value means last seen index.



### Implementation B — Explicit Mapping (very clear semantics)

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    bool isIsomorphic(const string &s, const string &t) {
        if (s.size() != t.size()) return false;

        unordered_map<char, char> mapS2T;
        unordered_map<char, char> mapT2S;

        for (size_t i = 0; i < s.size(); ++i) {
            char cs = s[i];
            char ct = t[i];

            // If mapping exists from s -> t, it must match
            if (mapS2T.count(cs)) {
                if (mapS2T[cs] != ct) return false;
            } else {
                // If ct is already mapped from some other char in s, fail (ensures injective)
                if (mapT2S.count(ct)) return false;
                mapS2T[cs] = ct;
                mapT2S[ct] = cs;
            }
        }
        return true;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s, t;
    if (!(cin >> s >> t)) {
        cout << "Input error\n";
        return 0;
    }

    Solution sol;
    cout << (sol.isIsomorphic(s, t) ? "true\n" : "false\n");
    return 0;
}
```



## ⚖️ Algorithm (step-by-step)

**1. Index-last-seen approach:**

1. If lengths differ → return `false`.
2. Create two structures `lastS` and `lastT` holding last seen index (initialized to 0).
3. Iterate `i` from `0` to `n-1`:

   * If `lastS[s[i]] != lastT[t[i]]` → return `false` (inconsistent seen-pattern).
   * Set `lastS[s[i]] = lastT[t[i]] = i+1`.
4. If loop completes, return `true`.

**2. Mapping approach:**

1. If lengths differ → `false`.
2. For each position `i`, check/create mapping `s[i] -> t[i]`.

   * If `s[i]` already mapped, ensure value equals `t[i]`.
   * If not mapped, ensure `t[i]` is not already the image of some other `s`-char.
3. If no contradictions → `true`.



## ⏱️ Complexity Analysis

Let `n = s.length()`.

* **Time complexity:** `O(n)` — single pass through strings.
* **Space complexity:**

  * Index-array approach: `O(1)` (arrays of fixed size 256 or 128).
  * Map approach: `O(min(n, alphabet_size))` — at most one entry per distinct char.

---

### ✅ Test Cases

1. `s = "egg"`, `t = "add"` → **true**
2. `s = "foo"`, `t = "bar"` → **false**
3. `s = "paper"`, `t = "title"` → **true**
4. `s = ""`, `t = ""` → **true** (empty strings)
5. `s = "a"`, `t = "a"` → **true**
6. `s = "ab"`, `t = "aa"` → **false** (`a` and `b` would both map to `a`)
7. Different lengths: `s = "abc"`, `t = "ab"` → **false** (length mismatch)

Edge cases:

* Repeated patterns like `s = "abba"`, `t = "cccc"` → **false**
* Large strings — performs in linear time.



## ✨ Tips & Tricks 

* **Use `i+1`** when storing positions to differentiate "not seen" (`0`) from "seen at index 0".
* For fixed small alphabets (ASCII lowercase letters), arrays of length 256 or 128 are fastest.
* If input may include Unicode beyond `char`, process codepoints (e.g., using `wstring` or mapping `int` codepoints).
* When debugging, map values printed at each index can reveal where pattern diverges.
* Two-maps approach is clearer conceptually (explicit bijection), but index technique is compact and fast.



### 🔁 Variations & Related Problems 

* Check whether two arrays follow the same pattern (same technique applies).
* Determine if a string is isomorphic to a palindrome (variation).
* Count distinct isomorphism classes for a set of strings.
* Pattern-matching problems (e.g., Word Pattern) use similar logic.



## ❓ FAQs 

**Q: Why do we need both maps in explicit mapping?**

> A: To ensure bijection — we must confirm that two different `s`-chars don't map to the same `t`-char (injectivity). `mapT2S` provides that reverse check.

**Q: Can we use `std::map` instead of `unordered_map`?**

> A: Yes, but `unordered_map` typically gives average O(1) lookup; `std::map` gives O(log m). For character mapping `unordered_map` is fine.

**Q: Why not only check that the sets of patterns are equal?**

> A: Pattern identity requires positional consistency, not just global frequency. Example: `s = "abb"`, `t = "xyz"` — both have a repeated char, but mapping matters per position.

**Q: Will this work for Unicode strings?**

> A: Not directly if you treat `char`. Use codepoint-aware iteration (e.g., `wstring`, or decode to `vector<int>` of codepoints) and then `unordered_map<int,int>`.

---

## ✅ Final Notes / Summary 

* The goal is to confirm a *consistent* one-to-one mapping from `s` characters to `t` characters.
* Always check for **equal length** first.
* Two practical and reliable solutions are:

  * **Index-last-seen** using arrays + `i+1` (fast, compact).
  * **Explicit mapping** using two hash maps (clear, safe for arbitrary alphabets).
* Both run in linear time and are straightforward to implement.
