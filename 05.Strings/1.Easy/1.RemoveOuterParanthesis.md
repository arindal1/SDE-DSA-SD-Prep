# 🎯 Remove Outermost Parentheses

---

## 📄 Problem Statement

Given a valid parentheses string `S`—meaning every prefix has no more `)` than `(` and the total counts match—**remove** the **outermost** pair of parentheses for every **primitive** substring and return the resulting string.

* A **primitive** valid parentheses string is a non-empty substring that cannot be split into two non-empty valid parentheses strings.

**Example**

```
Input:  "(()())(())"
Output: "()()()"
Explanation:
  - The primitives are "(()())" and "(())".
  - After removing their outermost parentheses, they become "()()" and "()".
  - Concatenate → "()()()".
```

---

## 💡 Intuition

* As we scan through `S`, maintain a **balance** counter:

  * `(` → increment `balance`
  * `)` → decrement `balance`
* The **outermost** parentheses of a primitive occur exactly when:

  * We see a `(` that brings `balance` from `0` to `1` (start of a primitive).
  * We see a `)` that brings `balance` from `1` to `0` (end of a primitive).
* **Skip** those two characters; **include** all others in the result.

---

## 🐢 Brute-Force Approach

1. **Split** `S` into primitives by scanning and cutting whenever `balance` returns to `0`.
2. For each primitive substring, **slice** off the first and last character.
3. **Concatenate** the results.

```cpp
string removeOuterParenthesesBrute(string S) {
    string ans;
    int balance = 0, start = 0;
    for (int i = 0; i < S.size(); ++i) {
        balance += (S[i] == '(' ? 1 : -1);
        if (balance == 0) {
            // primitive is S[start..i]
            ans += S.substr(start+1, i - start - 1);
            start = i + 1;
        }
    }
    return ans;
}
```

* **Time Complexity:** *O(n²)* due to repeated substring operations.
* **Space Complexity:** *O(n)* for the result.

> ❌ Substring copying can be expensive for large `S`.

---

## 🚀 Optimal Approach: Single-Pass with Balance

```cpp
string removeOuterParentheses(string S) {
    string ans;
    ans.reserve(S.size());  // optional: avoid reallocations
    int balance = 0;
    for (char c : S) {
        if (c == '(') {
            if (balance > 0) 
                ans += c;
            balance++;
        } else {
            balance--;
            if (balance > 0) 
                ans += c;
        }
    }
    return ans;
}
```

* **Key Idea:** Only append `(` when `balance > 0`, and append `)` when `balance > 0` *after* decrementing.
* **Single scan**, **no substrings** → **O(n)** time.

---

## ✅ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Removes the outermost parentheses of every primitive substring.
 */
string removeOuterParentheses(const string& S) {
    string ans;
    ans.reserve(S.size());
    int balance = 0;
    for (char c : S) {
        if (c == '(') {
            if (balance > 0) 
                ans += c;
            balance++;
        } else {
            balance--;
            if (balance > 0) 
                ans += c;
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string S;
    cin >> S;
    cout << removeOuterParentheses(S) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Aspect    | Complexity   |
| --------- | ------------ |
| **Time**  | *O(n)*       |
| **Space** | *O(n)* (ans) |

* We make a single pass over `S` of length `n`.
* The output string is at most length `n`.

---

## 🎯 Tips & Tricks

* **Balance counter** is a powerful tool for parentheses problems.
* Reserve output capacity if you know the approximate length to **avoid reallocations**.
* Always analyze **when** to include or exclude characters based on state transitions.

---

## 🔄 Variations

* **Check Validity** of a parentheses string using balance only.
* **Longest Valid Parentheses**: use a stack or DP to find the maximum-length valid substring.
* **Generate Parentheses**: recursively build all valid combinations for `n` pairs.

---

## ❓ FAQs

> **Q1. What if `S` is empty?**
> Return an empty string.

> **Q2. Could there be invalid input?**
> Problem guarantees `S` is valid and non-empty.

> **Q3. Why reserve `S.size()`?**
> Amortizes the cost of appending to avoid multiple reallocations.

> **Q4. Can we do it in-place?**
> In a mutable buffer, you could overwrite, but managing indices is error-prone—better to build a new `ans`.

---
