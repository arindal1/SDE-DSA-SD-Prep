# 📝 String to Integer (atoi)


## 📜 Problem Statement 

Given a string `s`, implement the `myAtoi(string s)` function, which converts a string to a **32-bit signed integer** (`int` type in C++).
The algorithm should:

1. **Ignore** any leading whitespace characters `' '`.
2. **Optional sign**: detect `+` or `-` to determine positive or negative.
3. **Read digits** until:

   * Non-digit character is found, or
   * End of string reached.
4. **Clamp to range**:
   If the integer is out of the range `[-2^31, 2^31 - 1]` (`[-2147483648, 2147483647]`), return `INT_MIN` or `INT_MAX` accordingly.
5. Return the final integer.



## 💡 Intuition 

We simulate what the `atoi` function does:

* Ignore whitespace → Decide sign → Read number → Stop when invalid → Handle overflow.
* Since 32-bit integers have limits, we must **check overflow while parsing**, not after, to avoid undefined behavior.


## 🚀 Optimal One-pass Approach

### Steps:

1. **Skip leading spaces**: Move pointer until first non-space char.
2. **Check sign**: If `+` or `-`, store sign and advance pointer.
3. **Read digits**:

   * Update result as `res = res * 10 + (digit)`.
   * If `res` exceeds `INT_MAX` during calculation:

     * If positive, return `INT_MAX`
     * If negative, return `INT_MIN`
4. **Return** `res * sign`.

### Why it works:

* Only one pass through the string.
* Overflow check is done before result exceeds limit.



## 🧾 Full Code 

```cpp
#include <bits/stdc++.h>
using namespace std;

int myAtoi(string s) {
    int i = 0, n = s.size(), sign = 1;
    long res = 0;

    // Skip leading spaces
    while (i < n && s[i] == ' ') i++;

    // Handle sign
    if (i < n && (s[i] == '+' || s[i] == '-'))
        sign = (s[i++] == '-') ? -1 : 1;

    // Convert digits
    while (i < n && isdigit(static_cast<unsigned char>(s[i]))) {
        res = res * 10 + (s[i] - '0');

        // Overflow check
        if (res > INT_MAX)
            return (sign == 1) ? INT_MAX : INT_MIN;

        i++;
    }

    return static_cast<int>(res * sign);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cout << "Enter strings to convert to integers (Ctrl+D to stop):\n";
    string line;
    while (getline(cin, line)) {
        try {
            cout << "\"" << line << "\" -> " << myAtoi(line) << "\n";
        } catch (...) {
            cout << "Error occurred!\n";
        }
    }
    return 0;
}
```


## 🔍 Walk-through Examples 

1. **Input:** `"42"`
   Steps:

   * No leading space
   * Sign = +1
   * Read digits → 4 → 42
     Output: **42**

2. **Input:** `"   -42"`
   Steps:

   * Skip spaces
   * Sign = -1
   * Read digits → 4 → 42 → result = -42
     Output: **-42**

3. **Input:** `"4193 with words"`
   Steps:

   * Read digits until `w` → stop
     Output: **4193**

4. **Input:** `"words and 987"`
   Steps:

   * First char is not space/sign/digit → stop, return 0
     Output: **0**

5. **Input:** `"-91283472332"`
   Steps:

   * Sign = -1
   * Read digits, overflow detected → return `INT_MIN` (-2147483648)
     Output: **-2147483648**


## 📈 Complexity Analysis

* **Time Complexity:** `O(n)` (scan once)
* **Space Complexity:** `O(1)` (constant variables)

---

### ✅ Test Cases

| Input               | Expected Output |
| ------------------- | --------------- |
| `"42"`              | 42              |
| `"   -42"`          | -42             |
| `"4193 with words"` | 4193            |
| `"words and 987"`   | 0               |
| `"-91283472332"`    | -2147483648     |
| `"2147483648"`      | 2147483647      |
| `"+1"`              | 1               |
| `"00000-42a1234"`   | 0               |
| `"   +0 123"`       | 0               |



### 🛠️ Tips & Tricks 

* Always **check overflow before it happens** (compare with limits before multiplying by 10).
* Use `long` or `long long` temporarily to store intermediate results.
* `isdigit()` should be passed `unsigned char` to avoid UB with negative char values.
* Don’t trim trailing spaces — the parsing stops naturally when encountering them.



### ❗️ Common Pitfalls 

* Not handling leading spaces correctly.
* Ignoring cases with `+` sign.
* Overflow before detection.
* Treating non-digit after sign as part of number.
* Assuming no invalid input — robust functions must handle all.


### 🔁 Variations 

1. **Support hexadecimal strings** (prefix `0x`) — detect and parse base 16.
2. **Strict mode** — reject strings with extra non-space characters after number.
3. **Unsigned version** — clamp within `[0, UINT_MAX]`.



## ❓ FAQs 

**Q: Why not use `stoi`?**
A: `stoi` throws exceptions and is slower. Implementing manually avoids exceptions and handles overflow predictably.

**Q: What happens if string is empty?**
A: Returns `0` — matches `atoi` behavior.

**Q: How to detect overflow without `long`?**
A: Compare `res` with `(INT_MAX - digit) / 10` before multiplying.


### ✨ Summary

* **Skip spaces → Detect sign → Read digits → Check overflow → Return**.
* One-pass `O(n)` solution.
* Safe, robust, handles edge cases.

