# 🏛️ Convert Roman Numeral to Integer


## 📝 Problem Statement 

**Given** a string `s` representing a Roman numeral, convert it to an integer.

* Roman numerals use the symbols: `I(1)`, `V(5)`, `X(10)`, `L(50)`, `C(100)`, `D(500)`, `M(1000)`.
* Usually symbols are written largest to smallest left-to-right, and their values add up.
* However, **subtractive notation** applies for a few cases: when a smaller-value symbol appears before a larger one, you subtract the smaller from the larger (e.g., `IV = 4`, `IX = 9`, `XL = 40`, `XC = 90`, `CD = 400`, `CM = 900`).

**Return** the integer value corresponding to the Roman numeral string `s`.


## 💡 Intuition

A Roman numeral is mostly additive: add each symbol's value. Whenever a symbol has a smaller value than the following symbol, it **should be subtracted** instead of added.

So: traverse the string left → right, look at the current symbol and its next neighbor:

* if `current < next` → subtract `current`
* otherwise → add `current`

This simple one-pass greedy check handles both additive and subtractive patterns.



## 🐢 Brute Force Approach (conceptual) 

One could:

1. Enumerate all valid subtractive pairs `IV, IX, XL, XC, CD, CM` and process them first (replace them or handle as tokens).
2. Then sum remaining symbols.

This works but requires extra passes or string manipulation and is more complex. Time complexity still `O(n)`, but more fiddly and less elegant.



## 🚀 Optimal Approach — One-pass Lookahead (Greedy)

**Algorithm (high-level)**:

1. Prepare a mapping from Roman characters to their integer values.
2. Initialize `result = 0`.
3. For each index `i` from `0` to `n-1`:

   * Let `curr = value(s[i])`
   * Let `next = (i+1 < n) ? value(s[i+1]) : 0`
   * If `curr < next` → `result -= curr`
   * Else → `result += curr`
4. Return `result`.

**Why it works**:

* When a smaller value precedes a larger one, subtracting it is exactly the subtractive rule (e.g., `I` in `IV` gets subtracted once).
* For a chain of increasing values, each smaller is subtracted and larger added, giving correct net value.
* Runs in one pass, uses constant extra space.



## 🧾 Full C++ Code (robust, ready-to-run)

This program:

* Reads lines from standard input (each line a Roman numeral), converts them, prints the integer.
* Skips empty lines.
* Handles lowercase letters by converting to uppercase.
* Validates characters and reports invalid input.

```cpp
#include <iostream>
#include <string>
#include <cctype>
using namespace std;

int romanToInt(const string &s) {
    int val[256] = {0};
    val['I']=1; val['V']=5; val['X']=10; val['L']=50;
    val['C']=100; val['D']=500; val['M']=1000;

    int result = 0;
    for (size_t i = 0; i < s.size(); ++i) {
        unsigned char c = static_cast<unsigned char>(toupper(s[i]));
        int curr = val[c];
        if (curr == 0) return -1;            // invalid character
        int next = (i + 1 < s.size()) ? val[static_cast<unsigned char>(toupper(s[i+1]))] : 0;
        result += (curr < next) ? -curr : curr;
    }
    return result;
}

int main() {
    string s;
    if (!(cin >> s)) return 0;               // read a single token
    int ans = romanToInt(s);
    if (ans < 0) cout << "Invalid Roman numeral\n";
    else cout << ans << '\n';
    return 0;
}

```



## 📈 Complexity Analysis

* **Time Complexity:** `O(n)` where `n = s.length()`. Single pass comparing each character with next.
* **Space Complexity:** `O(1)` additional space (table of size 256 and a few ints). No extra memory proportional to input size.

---

### 🔍 Example Walk-throughs (explain step-by-step)

1. **Input:** `III`
   Steps: `1 + 1 + 1 = 3` → **Output:** `3`

2. **Input:** `IV`
   Steps: `I (1) < V (5)` → subtract `1` → result = -1; then add `5` → result = 4 → **Output:** `4`

3. **Input:** `MCMXCIV`
   Map: `M=1000, C=100, M=1000, X=10, C=100, I=1, V=5`
   Steps:

   * `M (1000)` next `C (100)` → add 1000 → r=1000
   * `C (100)` next `M (1000)` → subtract 100 → r=900
   * `M (1000)` next `X (10)` → add 1000 → r=1900
   * `X (10)` next `C (100)` → subtract 10 → r=1890
   * `C (100)` next `I (1)` → add 100 → r=1990
   * `I (1)` next `V (5)` → subtract 1 → r=1989
   * `V (5)` last → add 5 → r=1994
     **Output:** `1994`


### ✅ Test Cases 

* `"III"` → `3`
* `"IV"` → `4`
* `"IX"` → `9`
* `"LVIII"` → `58` (`L(50) + V(5) + I(1) + I(1) + I(1)`)
* `"MCMXCIV"` → `1994`
* `"MMXXV"` → `2025`
* `""` (empty string) → `0` (implementation-defined: here returns 0)
* `"mcmxciv"` (lowercase) → `1994` (our program supports lowercase)
* `"ABCD"` → error: invalid character detection

---

## 🛠️ Tips & Tricks

* Use a small fixed-size array `int val[256]` indexed by `unsigned char` for O(1) lookups (faster than map/unordered\_map).
* Convert to uppercase early if you want to accept lowercase input.
* Validate unknown characters by checking `val[c] == 0` (since all valid roman symbols have positive values).
* Prefer `size_t` for indexing when comparing against `s.size()`.
* If you need to convert **integer → Roman**, that's a common complementary problem; approach with descending value list and greedy subtraction.


## 🔁 Variations & Extensions

1. **Integer → Roman (reverse conversion)** — Greedy from highest to lowest denominations.
2. **Validate whether a string is a *valid* Roman numeral** (e.g., `IM` is not standard). That requires rules about repetition (I, X, C, M can repeat up to 3 times; V, L, D cannot repeat; subtractive pairs are restricted).
3. **Support extended Roman notations** (bars over numerals to indicate multiplication by 1,000) — requires extra rules.
4. **Return an error for empty string** — change `romanToInt` to throw for empty input if desired.


## ❗️ Common Pitfalls

* Using `int i = 0; i < s.size()` can generate signed/unsigned comparison warnings. Use `size_t` or cast.
* Forgetting to handle invalid characters will silently produce incorrect results (value 0 treated as valid).
* Not handling lowercase input if expected.
* Assuming Roman numerals are unbounded — standard forms have practical limits (and would overflow typical integer types if unrealistically large).


## ❓ FAQs

**Q: Does this handle subtractive forms like `IL` or `XM`?**
> **A:** The algorithm will numerically treat them (e.g., `IL` would be `50 - 1 = 49`) but *`IL` is not a standard Roman numeral* — standard 49 is `XLIX`. If you need to strictly validate *standard* Roman rules, add a validation layer that only permits the legal subtractive pairs: `IV`, `IX`, `XL`, `XC`, `CD`, `CM`.

**Q: What about lowercase input?**
> **A:** The example code converts input to uppercase, so lowercase is accepted.

**Q: What about empty string?**
> **A:** Example returns `0`. You can change behavior to throw an exception if you prefer.

**Q: Can the result overflow `int`?**
A: For normal Roman numerals (up to a few thousand) no. If you accept crazy inputs like `MMMM...` repeated thousands of times, you might overflow — use `long long` if you need larger range.

**Q: Is the time complexity optimal?**
> **A:** Yes — `O(n)` is optimal because you must inspect each character at least once.

---

### ✨ Short Summary

* Single-pass lookahead algorithm: subtract when current < next, otherwise add.
* Time `O(n)`, space `O(1)`.
* Robust C++ code provided (handles input, validation, uppercase).
* Consider adding stricter validation if you need *only valid canonical* Roman numerals.
