# üî° Frequency Sort 

> **Problem (short)** ‚Äî Given a string `s`, sort its characters in descending order by their frequency of occurrence.
> If two characters have the same frequency, any order between them is acceptable.

This corresponds to **LeetCode 451. Sort Characters By Frequency**.


### ‚úÖ Examples

* `s = "tree"` ‚Üí `"eetr"` or `"eert"`
  (`'e'` appears 2√ó, `'t'` 1√ó, `'r'` 1√ó; `'e'` goes first)
* `s = "cccaaa"` ‚Üí `"cccaaa"` or `"aaaccc"`
  (both `'c'` and `'a'` have same frequency; order doesn't matter)
* `s = "Aabb"` ‚Üí `"bbAa"` or `"bbaA"`
  (case-sensitive; `'b'` appears 2√ó, `'A'` and `'a'` appear once each)



## üí° Intuition 

We need to rearrange characters so that the ones occurring **more frequently** appear **first**.

Natural steps:

1. **Count frequencies** of each character.
2. **Sort** characters by frequency descending.
3. **Build result** string by appending each character `freq` times.



## ‚ùå Brute force (not good) 

We could:

* For each position, scan the entire string to count how many times each character occurs ‚Üí `O(n¬≤)` time.
  This is wasteful, we can compute frequencies in `O(n)` using a map.



## ‚ö° Optimal Approaches

### 1Ô∏è‚É£ Map + Sort (simplest to implement)

* Count frequencies in a hash map.
* Move `(char, freq)` pairs to a vector.
* Sort vector by `freq` descending.
* Build string.

**Time:** `O(n + k log k)` where `n` = length of string, `k` = number of distinct characters (‚â§ `n`).
**Space:** `O(k)`.

---

### 2Ô∏è‚É£ Bucket Sort (most optimal in theory)

* Since `freq` ‚â§ `n`, create a vector of buckets, each holding characters with the same frequency.
* Iterate from highest frequency bucket to lowest.
* Append characters.

**Time:** `O(n)`
**Space:** `O(n)`

---

## üíª Provided Code (Map + Sort version)

```cpp
string frequencySort(string s) {
    unordered_map<char, int> freq;
    for (char c : s) 
        freq[c]++;

    vector<pair<char, int>> vec(freq.begin(), freq.end());
    sort(vec.begin(), vec.end(), [](auto &a, auto &b) {
        return a.second > b.second; // sort by frequency desc
    });

    string result;
    result.reserve(s.size()); // avoid reallocations
    for (auto &p : vec) {
        result.append(p.second, p.first); // append char p.second times
    }
    return result;
}
```

---

## Step-by-step explanation

1. **Count frequencies**

   ```cpp
   unordered_map<char, int> freq;
   for (char c : s)
       freq[c]++;
   ```

   * `unordered_map` gives average O(1) insertion & lookup.
   * Keys are `char`, values are integer counts.

2. **Move to vector**

   ```cpp
   vector<pair<char, int>> vec(freq.begin(), freq.end());
   ```

   * We want to sort, but maps aren't sorted by value, so we copy into a vector.

3. **Sort by frequency descending**

   ```cpp
   sort(vec.begin(), vec.end(), [](auto &a, auto &b) {
       return a.second > b.second;
   });
   ```

4. **Build result string**

   ```cpp
   string result;
   result.reserve(s.size()); // optimize memory usage
   for (auto &p : vec) {
       result.append(p.second, p.first);
   }
   ```

   * `string::append(count, char)` appends the char repeated `count` times.

---

## üñ•Ô∏è Full Code

```cpp
#include <bits/stdc++.h>
using namespace std;

string frequencySort(const string &s) {
    unordered_map<char, int> freq;
    for (char c : s)
        freq[c]++;

    vector<pair<char, int>> vec(freq.begin(), freq.end());
    sort(vec.begin(), vec.end(), [](auto &a, auto &b) {
        return a.second > b.second;
    });

    string result;
    result.reserve(s.size());
    for (auto &p : vec) {
        result.append(p.second, p.first);
    }
    return result;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s;
    if (!(cin >> s)) {
        return 1;
    }

    cout << frequencySort(s) << "\n";
    return 0;
}
```

---

## üìà Complexity Analysis 

Let:

* `n` = length of string
* `k` = number of distinct characters

**Map + Sort**:

* Time:

  * Counting: `O(n)`
  * Sorting: `O(k log k)`
  * Building result: `O(n)`
  * **Overall:** `O(n + k log k)` ‚Üí worst-case `O(n log n)`
* Space: `O(k)` extra

**Bucket sort**:

* Time: `O(n)`
* Space: `O(n)`

---

### ‚úÖ Test Cases 

1. **Basic**

   ```
   Input: "tree"
   Output: "eetr" or "eert"
   ```

2. **All same char**

   ```
   Input: "aaaa"
   Output: "aaaa"
   ```

3. **Tie in frequency**

   ```
   Input: "cccaaa"
   Output: "cccaaa" or "aaaccc"
   ```

4. **Mixed case**

   ```
   Input: "Aabb"
   Output: "bbAa" or "bbaA"
   ```

5. **Empty string**

   ```
   Input: ""
   Output: ""
   ```

---

## ‚ú® Tips & Tricks 

* `result.reserve(s.size())` is a neat micro-optimization to avoid repeated allocations while appending.
* Sorting by frequency is straightforward but **bucket sort** is better when the alphabet size is large relative to `n`.
* For Unicode strings, you'd use `unordered_map<char32_t, int>` after decoding UTF-8 into codepoints.
* To break ties lexicographically, adjust the sort comparator:

  ```cpp
  [](auto &a, auto &b) {
      return a.second != b.second ? a.second > b.second : a.first < b.first;
  }
  ```

---

## ü™£ Bucket Sort version (faster for large inputs)

```cpp
string frequencySort_bucket(const string &s) {
    unordered_map<char, int> freq;
    for (char c : s) freq[c]++;

    vector<vector<char>> buckets(s.size() + 1);
    for (auto &p : freq)
        buckets[p.second].push_back(p.first);

    string result;
    result.reserve(s.size());
    for (int f = s.size(); f > 0; --f) {
        for (char c : buckets[f]) {
            result.append(f, c);
        }
    }
    return result;
}
```

* No sorting ‚Äî just direct indexing by frequency.
* **Time:** `O(n)`
* **Space:** `O(n)`

---

## üîÅ Related Problems 

* **Top K Frequent Elements** (LeetCode 347)
* **Sort Array by Increasing Frequency** (LeetCode 1636)
* **Reorganize String** (LeetCode 767) ‚Äî frequency + heap usage
* **Character frequency compression** ‚Äî variations in data compression tasks

---

## ‚ùì FAQs 

**Q: Why store frequencies in a map and then move to a vector?**
> A: `unordered_map` is not sortable by value; copying to a vector allows sorting by frequency.

**Q: Will ties in frequency affect correctness?**
> A: No, problem allows any order among same-frequency characters unless specified otherwise.

**Q: Can this be done in-place in the original string?**
> A: Not directly, because we need to group identical characters together first; building a new string is simpler.

**Q: Does this handle Unicode?**
> A: Only if each `char` represents one codepoint (e.g., ASCII). For UTF-8, decode first.

---
