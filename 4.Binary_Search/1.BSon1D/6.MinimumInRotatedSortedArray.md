# ğŸ•µï¸â€â™‚ï¸ Find Minimum in Rotated Sorted Array


## ğŸ“„ Problem Statement

Suppose an array of **distinct** integers `nums` sorted in ascending order is **rotated** at some pivot unknown to you. For example,

```
Original: [0,1,2,4,5,6,7]
Rotated:  [4,5,6,7,0,1,2]
```

Given the rotated array `nums`, **find the minimum element**. You must do this in **O(logâ€¯n)** time.

* **Input:**

  * An integer `n` (size of `nums`)
  * Array `nums` of length `n`, a rotated version of a strictly increasing sequence
* **Output:**

  * The minimum value in `nums`

---

## ğŸ’¡ Intuition

* A rotated sorted array consists of two sorted subarrays: one from the pivot to end, and one from start to pivot-1.
* At each step, look at the interval `[lowâ€¦high]`:

  1. If `nums[low] â‰¤ nums[mid]`, the **left half** is sorted, so the minimum must be **either** at `nums[low]` **or** in the right half.
  2. Otherwise, the **right half** is sorted (or the pivot lies in the left half), so the minimum is **either** at `nums[mid]` **or** in the left half.
* Keep track of the smallest candidate (`ans`) seen so far, and **halve** the search window accordingly.

This yields a classic **binary-search**â€“style solution in **O(logâ€¯n)**.

---

## ğŸ¢ Bruteâ€‘Force Approach

Scan the entire array to find the minimum:

```cpp
int findMinBrute(vector<int>& nums) {
    int ans = nums[0];
    for (int x : nums)
        ans = min(ans, x);
    return ans;
}
```

* **Time Complexity:** *O(n)*
* **Space Complexity:** *O(1)*

> âŒ Doesnâ€™t meet the logarithmic time requirement.

---

## ğŸš€ Optimal Approach: Modified Binary Search

```cpp
int findMin(vector<int>& nums) {
    int low = 0, high = nums.size() - 1;
    int ans = INT_MAX;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        // If left half [low..mid] is sorted
        if (nums[low] <= nums[mid]) {
            ans = min(ans, nums[low]);   // candidate from left half
            low = mid + 1;               // search right half
        } else {
            // Right half [mid..high] is sorted, so pivot/min in left half
            ans = min(ans, nums[mid]);   // candidate from mid
            high = mid - 1;              // search left half
        }
    }
    return ans;
}
```

* **Why it works:**

  * If `nums[low] â‰¤ nums[mid]`, the smallest in `[low..mid]` is at `low`.
  * Otherwise, the smallest in `[low..mid]` lies to the left of `mid`.
  * Continuously update `ans` with the best candidate before discarding a half.

---

## âœ… Test Cases

| `nums`            | Output | Explanation                    |
| ----------------- | ------ | ------------------------------ |
| `[3,4,5,1,2]`     | `1`    | Rotated at index 3             |
| `[4,5,6,7,0,1,2]` | `0`    | Rotated at index 4             |
| `[11,13,15,17]`   | `11`   | Not rotated (minimum at start) |
| `[2,1]`           | `1`    | Small size, pivot at index 1   |
| `[5]`             | `5`    | Single-element array           |

---

## âœï¸ Full Corrected Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Finds the minimum in a rotated sorted array of distinct integers.
 */
int findMin(vector<int>& nums) {
    int low = 0, high = nums.size() - 1;
    int ans = INT_MAX;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (nums[low] <= nums[mid]) {
            ans = min(ans, nums[low]);
            low = mid + 1;
        } else {
            ans = min(ans, nums[mid]);
            high = mid - 1;
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    cout << findMin(nums) << "\n";
    return 0;
}
```

---

## ğŸ“Š Complexity Analysis

| Phase                       | Time Complexity | Space Complexity |
| --------------------------- | --------------- | ---------------- |
| Modified binary search loop | *O(logâ€¯n)*      | *O(1)*           |
| **Overall**                 | **O(logâ€¯n)**    | **O(1)**         |

---

## ğŸ¯ Tips & Tricks

* ğŸŒ„ **Always compare** `nums[low]` and `nums[mid]` to detect which half is sorted.
* ğŸ”¢ Use **overflow-safe** mid calculation: `mid = low + (high - low)/2`.
* ğŸ—ï¸ Keep track of the **best candidate** (`ans`) before discarding a half.

---

## ğŸ”„ Variations

1. **With Duplicates** (Leetcode â€œFind Minimum in Rotated Sorted Array IIâ€):

   * When `nums[low] == nums[mid]`, perform `low++` to skip ambiguity.
2. **Find Pivot Index**: Return the index of the minimum element (rotation pivot).
3. **Search Target in Rotated Array**: Combine this pivot logic with a second binary search.

---

## â“ FAQs

> **Q1. What if the array is not rotated?** <br>
> The check `nums[low] â‰¤ nums[mid]` will always be true for every half, so `ans` becomes `nums[0]`.

> **Q2. Why track `ans` separately?** <br>
> We want to consider both ends (`nums[low]` or `nums[mid]`) before discarding that half.

> **Q3. Can this handle empty arrays?** <br>
> You may add a guard at the start:
>
> ```cpp
> if (nums.empty()) throw invalid_argument("Array must be non-empty");
> ```

> **Q4. How to adapt for finding the maximum?** <br>
> Use a similar pivot detection but track the largest candidate when discarding halves.

---
