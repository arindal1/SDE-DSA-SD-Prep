# 🕵️‍♂️ Find Minimum in Rotated Sorted Array


## 📄 Problem Statement

Suppose an array of **distinct** integers `nums` sorted in ascending order is **rotated** at some pivot unknown to you. For example,

```
Original: [0,1,2,4,5,6,7]
Rotated:  [4,5,6,7,0,1,2]
```

Given the rotated array `nums`, **find the minimum element**. You must do this in **O(log n)** time.

* **Input:**

  * An integer `n` (size of `nums`)
  * Array `nums` of length `n`, a rotated version of a strictly increasing sequence
* **Output:**

  * The minimum value in `nums`

---

## 💡 Intuition

* A rotated sorted array consists of two sorted subarrays: one from the pivot to end, and one from start to pivot-1.
* At each step, look at the interval `[low…high]`:

  1. If `nums[low] ≤ nums[mid]`, the **left half** is sorted, so the minimum must be **either** at `nums[low]` **or** in the right half.
  2. Otherwise, the **right half** is sorted (or the pivot lies in the left half), so the minimum is **either** at `nums[mid]` **or** in the left half.
* Keep track of the smallest candidate (`ans`) seen so far, and **halve** the search window accordingly.

This yields a classic **binary-search**–style solution in **O(log n)**.

---

## 🐢 Brute‑Force Approach

Scan the entire array to find the minimum:

```cpp
int findMinBrute(vector<int>& nums) {
    int ans = nums[0];
    for (int x : nums)
        ans = min(ans, x);
    return ans;
}
```

* **Time Complexity:** *O(n)*
* **Space Complexity:** *O(1)*

> ❌ Doesn’t meet the logarithmic time requirement.

---

## 🚀 Optimal Approach: Modified Binary Search

```cpp
int findMin(vector<int>& nums) {
    int low = 0, high = nums.size() - 1;
    int ans = INT_MAX;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        // If left half [low..mid] is sorted
        if (nums[low] <= nums[mid]) {
            ans = min(ans, nums[low]);   // candidate from left half
            low = mid + 1;               // search right half
        } else {
            // Right half [mid..high] is sorted, so pivot/min in left half
            ans = min(ans, nums[mid]);   // candidate from mid
            high = mid - 1;              // search left half
        }
    }
    return ans;
}
```

* **Why it works:**

  * If `nums[low] ≤ nums[mid]`, the smallest in `[low..mid]` is at `low`.
  * Otherwise, the smallest in `[low..mid]` lies to the left of `mid`.
  * Continuously update `ans` with the best candidate before discarding a half.

---

## ✅ Test Cases

| `nums`            | Output | Explanation                    |
| ----------------- | ------ | ------------------------------ |
| `[3,4,5,1,2]`     | `1`    | Rotated at index 3             |
| `[4,5,6,7,0,1,2]` | `0`    | Rotated at index 4             |
| `[11,13,15,17]`   | `11`   | Not rotated (minimum at start) |
| `[2,1]`           | `1`    | Small size, pivot at index 1   |
| `[5]`             | `5`    | Single-element array           |

---

## ✏️ Full Corrected Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Finds the minimum in a rotated sorted array of distinct integers.
 */
int findMin(vector<int>& nums) {
    int low = 0, high = nums.size() - 1;
    int ans = INT_MAX;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (nums[low] <= nums[mid]) {
            ans = min(ans, nums[low]);
            low = mid + 1;
        } else {
            ans = min(ans, nums[mid]);
            high = mid - 1;
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    cout << findMin(nums) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                       | Time Complexity | Space Complexity |
| --------------------------- | --------------- | ---------------- |
| Modified binary search loop | *O(log n)*      | *O(1)*           |
| **Overall**                 | **O(log n)**    | **O(1)**         |

---

## 🎯 Tips & Tricks

* 🌄 **Always compare** `nums[low]` and `nums[mid]` to detect which half is sorted.
* 🔢 Use **overflow-safe** mid calculation: `mid = low + (high - low)/2`.
* 🏗️ Keep track of the **best candidate** (`ans`) before discarding a half.

---

## 🔄 Variations

1. **With Duplicates** (Leetcode “Find Minimum in Rotated Sorted Array II”):

   * When `nums[low] == nums[mid]`, perform `low++` to skip ambiguity.
2. **Find Pivot Index**: Return the index of the minimum element (rotation pivot).
3. **Search Target in Rotated Array**: Combine this pivot logic with a second binary search.

---

## ❓ FAQs

> **Q1. What if the array is not rotated?** <br>
> The check `nums[low] ≤ nums[mid]` will always be true for every half, so `ans` becomes `nums[0]`.

> **Q2. Why track `ans` separately?** <br>
> We want to consider both ends (`nums[low]` or `nums[mid]`) before discarding that half.

> **Q3. Can this handle empty arrays?** <br>
> You may add a guard at the start:
>
> ```cpp
> if (nums.empty()) throw invalid_argument("Array must be non-empty");
> ```

> **Q4. How to adapt for finding the maximum?** <br>
> Use a similar pivot detection but track the largest candidate when discarding halves.

---
