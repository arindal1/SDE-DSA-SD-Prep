# ‚öñÔ∏è Median of Two Sorted Arrays


## üìÑ Problem Statement

Given two **sorted** arrays `a` and `b` of sizes `n1` and `n2` respectively, return the **median** value of the combined sorted array of length `n1 + n2`. Your algorithm must run in **O(log‚ÄØmin(n1,‚ÄØn2))** time.

* **Input:**

  * Two integer vectors `a` (size `n1`) and `b` (size `n2`), both sorted in non‚Äëdecreasing order
* **Output:**

  * A `double` representing the median of the merged sequence

---

## üí° Intuition

* The **median** splits a sorted array into two halves of equal length (or nearly equal if the total length is odd).
* We can view picking a split index `i` in `a` and `j` in `b` such that:

  * `i + j = (n1 + n2 + 1)/2` ‚Üí total elements in the ‚Äúleft‚Äù half.
* Define:

  * `l1 = (i>0 ? a[i‚àí1] : ‚àí‚àû)`
  * `r1 = (i<n1 ? a[i]   : +‚àû)`
  * `l2 = (j>0 ? b[j‚àí1] : ‚àí‚àû)`
  * `r2 = (j<n2 ? b[j]   : +‚àû)`
* We require:

  ```
  l1 ‚â§ r2  and  l2 ‚â§ r1
  ```

  which guarantees all left‚Äëhalf elements ‚â§ all right‚Äëhalf elements.
* Once found:

  * If total length is **odd**, median = `max(l1,‚ÄØl2)`.
  * If **even**, median = `(max(l1,‚ÄØl2) + min(r1,‚ÄØr2)) / 2.0`.

By **binary searching** `i` in `[0‚Ä¶n1]`, we adjust `j` accordingly and test the above condition in **O(log‚ÄØn1)**.

---

## üê¢ Brute‚ÄëForce Approach

Merge the two arrays explicitly and then pick the median:

```cpp
double medianBrute(const vector<int>& a, const vector<int>& b) {
    vector<int> merged;
    merged.reserve(a.size() + b.size());
    merge(a.begin(), a.end(), b.begin(), b.end(), back_inserter(merged));
    int n = merged.size();
    if (n % 2)
        return merged[n/2];
    else
        return (merged[n/2 - 1] + merged[n/2]) / 2.0;
}
```

* **Time Complexity:** *O(n1 + n2)*
* **Space Complexity:** *O(n1 + n2)*

> ‚ùå Uses extra memory and is linear rather than logarithmic.

---

## üöÄ Optimal Approach: Binary Search on the Smaller Array

```cpp
double median(vector<int>& a, vector<int>& b) {
    int n1 = a.size(), n2 = b.size();
    // Ensure we binary-search the smaller
    if (n1 > n2) return median(b, a);

    int total = n1 + n2, half = (total + 1) / 2;
    int low = 0, high = n1;

    while (low <= high) {
        int i = (low + high) / 2;
        int j = half - i;

        int l1 = (i > 0)     ? a[i - 1] : INT_MIN;
        int r1 = (i < n1)    ? a[i]     : INT_MAX;
        int l2 = (j > 0)     ? b[j - 1] : INT_MIN;
        int r2 = (j < n2)    ? b[j]     : INT_MAX;

        if (l1 <= r2 && l2 <= r1) {
            // Found correct partition
            if (total % 2)
                return double(max(l1, l2));
            return (max(l1, l2) + min(r1, r2)) / 2.0;
        }
        else if (l1 > r2) {
            // Too many elements from a on left ‚Üí move left
            high = i - 1;
        } else {
            // Too few ‚Üí move right
            low = i + 1;
        }
    }
    return 0.0; // unreachable
}
```

* **Time Complexity:** *O(log‚ÄØmin(n1,‚ÄØn2))*
* **Space Complexity:** *O(1)*

---

## ‚úÖ Full Code with `main()` & User Input

```cpp
#include <bits/stdc++.h>
using namespace std;

double medianOfTwoSorted(const vector<int>& a, const vector<int>& b) {
    int n1 = a.size(), n2 = b.size();
    if (n1 > n2) 
        return medianOfTwoSorted(b, a);

    int total = n1 + n2, half = (total + 1) / 2;
    int low = 0, high = n1;

    while (low <= high) {
        int i = (low + high) / 2;
        int j = half - i;

        int l1 = (i > 0)     ? a[i - 1] : INT_MIN;
        int r1 = (i < n1)    ? a[i]     : INT_MAX;
        int l2 = (j > 0)     ? b[j - 1] : INT_MIN;
        int r2 = (j < n2)    ? b[j]     : INT_MAX;

        if (l1 <= r2 && l2 <= r1) {
            if (total % 2)
                return double(max(l1, l2));
            return (max(l1, l2) + min(r1, r2)) / 2.0;
        }
        else if (l1 > r2) {
            high = i - 1;
        } else {
            low = i + 1;
        }
    }
    return 0.0; // Should never reach here
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n1, n2;
    // Read sizes
    cin >> n1 >> n2;
    vector<int> a(n1), b(n2);

    // Read array a
    for (int i = 0; i < n1; i++) 
        cin >> a[i];
    // Read array b
    for (int i = 0; i < n2; i++) 
        cin >> b[i];

    double ans = medianOfTwoSorted(a, b);
    // Print with one decimal if needed
    if (ans == int(ans)) 
        cout << int(ans) << "\n";
    else 
        cout << fixed << setprecision(1) << ans << "\n";

    return 0;
}
```

---

## üìä Complexity Analysis

| Phase                    | Time Complexity        | Space Complexity |
| ------------------------ | ---------------------- | ---------------- |
| Binary search on smaller | *O(log‚ÄØmin(n1,‚ÄØn2))*   | *O(1)*           |
| **Overall**              | **O(log‚ÄØmin(n1,‚ÄØn2))** | **O(1)**         |

---

## üéØ Tips & Tricks

* Always search on the **smaller** array to minimize iterations.
* Use `INT_MIN` and `INT_MAX` as sentinels to avoid corner‚Äëcase checks.
* Carefully index so that the **left** half has `(total + 1)/2` elements.

---

## üîÑ Variations

1. **K‚Äëth element in two sorted arrays** (generalizing median to arbitrary rank).
2. **Median of multiple sorted lists** via a min‚Äëheap or divide‚Äëand‚Äëconquer.
3. **Weighted median** where elements have weights.

---

## ‚ùì FAQs

> **Q1. Why `(total + 1)/2` for the left half?** <br>
> Ensures the left half contains the extra element when the total is odd.

> **Q2. How do sentinels simplify code?** <br>
> They let you treat out‚Äëof‚Äëbounds as infinitely small/large, avoiding boundary checks.

> **Q3. What if the arrays are empty?** <br>
> By problem constraints, at least one array must be non-empty. You can guard against both empty as an error.

> **Q4. Can this approach extend to more than 2 arrays?** <br>
> It‚Äôs non-trivial; better generalizations use selection algorithms or heap approaches.

---

