# â›½ Problem: Minimize Maximum Distance to Gas Station

---

## ðŸ“„ Problem Statement

Given an array `arr` of `n` **sorted** integer positions of existing gas stations along a oneâ€‘dimensional road, you want to add **k** new gas stations such that the **maximum distance** between any two **adjacent** stations (old or new) is **minimized**. Return that minimum possible maximum distance.

* **Input:**

  * Integer `n` â€” number of existing stations
  * Sorted vector `arr` of length `n`, where `arr[i]` is the position of the iâ€‘th station
  * Integer `k` â€” number of additional stations you may build
* **Output:**

  * A floatingâ€‘point number: the smallest possible value of

    $$
      \max_{0 \le i < n + k - 1}\bigl(\text{distance between consecutive stations}\bigr).
    $$

---

## ðŸ’¡ Intuition

* If you fix a candidate maximum distance `D`, you can **greedily** decide how many new stations you must build on each interval to ensure no gap exceeds `D`:

  1. For each adjacent pair `arr[i-1]` to `arr[i]`, the gap is `gap = arr[i] - arr[i-1]`.
  2. You need

     $$
       \bigl\lceil \frac{\text{gap}}{D} \bigr\rceil - 1
     $$

     new stations to break the gap into subâ€‘segments of length â‰¤â€¯`D`.
  3. Sum these required stations; if it exceeds `k`, `D` is **too small**.
* As `D` **increases**, the required number of new stations **non-increases** (monotonic).
* We can therefore **binary search** on `D` over a real interval `[0 â€¦ maxGap]` and stop when the precision is within `1e-6`.

---

## ðŸ¢ Bruteâ€‘Force Approach

Try a sequence of candidate `D` values from the maximum initial gap down to 0 in small decrements (e.g. `0.1`), recomputing needed stations each time until you find the first feasible:

```cpp
double minimiseMaxDistanceBrute(vector<int>& arr, int k) {
    int n = arr.size();
    // find maximum initial gap
    double maxGap = 0;
    for (int i = 1; i < n; ++i)
        maxGap = max(maxGap, double(arr[i] - arr[i-1]));

    // decrement by 0.1 until feasible
    for (double D = maxGap; D >= 0; D -= 0.1) {
        int required = 0;
        for (int i = 1; i < n; ++i) {
            required += int(ceil((arr[i] - arr[i-1]) / D)) - 1;
            if (required > k) break;
        }
        if (required <= k)
            return D;
    }
    return 0;
}
```

* **Time Complexity:** roughly *O((maxGap/0.1)Â·n)*
* **Space Complexity:** *O(1)*

> âŒ Too slow and imprecise.

---

## ðŸš€ Optimal Approach: Binary Search on Real Answer

1. **Compute bounds**:

   ```cpp
   double low  = 0.0;
   double high = max_{i}(arr[i] - arr[i-1]);
   ```
2. **Predicate** `requiredStations(D)`:

   ```cpp
   int required = 0;
   for (i = 1â€¦n-1)
     required += (int)((arr[i] - arr[i-1]) / D);
   return required;
   ```

   This works because

   $$
     \Bigl\lceil\frac{gap}{D}\Bigr\rceil - 1
     = \bigl\lfloor\frac{gap}{D}\bigr\rfloor.
   $$
3. **Binary search** loop until `high - low â‰¤ 1e-6`:

   ```cpp
   while (high - low > 1e-6) {
     double mid = (low + high) / 2;
     if (requiredStations(mid) > k)
       low  = mid;  // need more stations â†’ increase D
     else
       high = mid;  // feasible â†’ try smaller D
   }
   return high;
   ```

This yields **O(nâ€¯logâ€¯( maxGap/Îµ ))**, where Îµ = 1e-6.

---

## âœ… Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns how many new stations are required so that
 * no two consecutive stations are more than 'D' apart.
 */
int numberOfGasStationsRequired(const vector<int>& arr, double D) {
    int cnt = 0, n = arr.size();
    for (int i = 1; i < n; ++i) {
        cnt += int((arr[i] - arr[i-1]) / D);
    }
    return cnt;
}

/**
 * Finds the minimal possible maximum distance between adjacent
 * stations after adding up to k new stations.
 */
double minimiseMaxDistance(vector<int>& arr, int k) {
    sort(arr.begin(), arr.end());
    int n = arr.size();
    double low = 0.0, high = 0.0;
    // upper bound = largest existing gap
    for (int i = 1; i < n; ++i)
        high = max(high, double(arr[i] - arr[i-1]));

    const double eps = 1e-6;
    while (high - low > eps) {
        double mid = (low + high) / 2.0;
        if (numberOfGasStationsRequired(arr, mid) > k)
            low = mid;   // too many needed â†’ D too small
        else
            high = mid;  // feasible â†’ try smaller D
    }
    return high;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    cin >> n >> k;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    double result = minimiseMaxDistance(arr, k);
    cout << fixed << setprecision(6) << result << "\n";
    return 0;
}
```

---

## ðŸ“Š Complexity Analysis

| Phase                                  | Time Complexity             | Space Complexity |
| -------------------------------------- | --------------------------- | ---------------- |
| Sorting stations                       | *O(nâ€¯logâ€¯n)*                | *O(1)* \*        |
| Each required check (`numberOfâ€¦`)      | *O(n)*                      | *O(1)*           |
| Binary search (\~logâ€¯(maxGap/Îµ) steps) | *O(nâ€¯log(maxGap/Îµ))*        | *O(1)*           |
| **Overall**                            | **O(nâ€¯logâ€¯n + nâ€¯log(1/Îµ))** | **O(1)**         |

***Sorting may use *O(logâ€¯n)* stack.***

---

---

## ðŸ› ï¸ Alternative Approach: Maxâ€‘Heap (Priority Queue)

Besides binary searching on the answer, you can also solve the gasâ€‘station problem by **always splitting** the largest current interval. Each time you add a station, you reduce the worst gap, and you repeat this **k** times. At the end, the largest remaining gap is your answer.

### Idea

1. **Initialize** a maxâ€‘heap of all initial gaps between consecutive stations:

   ```cpp
   for (int i = 1; i < n; ++i) {
     long double gap = arr[i] - arr[i-1];
     // we store (current worst piece after s splits, original gap, splits so far)
     pq.push({gap, gap, 1});
   }
   ```
2. **Repeat** `k` times:

   * Pop the entry with the **largest** current worstâ€‘piece length: say `(currLen, origGap, splits)`.
   * Increment `splits` by 1 â†’ weâ€™re placing one more station in this interval.
   * Compute the **new** worstâ€‘piece length as

     $$
       \text{newLen} = \frac{\text{origGap}}{\text{splits}+1}\quad\text{(using long double division).}
     $$
   * Push `(newLen, origGap, splits+1)` back into the heap.
3. After **k** splits, the **top** of the heap holds the interval with the maximum segment length; that is the minimized maximum distance.

### Code Sketch

```cpp
#include <bits/stdc++.h>
using namespace std;

// Each heap entry: (current worst piece length, original gap, splits made)
struct Interval {
    long double currLen;
    long double origGap;
    int splits;
    bool operator<(Interval const &o) const {
        // max-heap by currLen
        return currLen < o.currLen;
    }
};

long double minimiseMaxDistanceHeap(vector<int>& arr, int k) {
    int n = arr.size();
    priority_queue<Interval> pq;

    // Build initial gaps
    for (int i = 1; i < n; ++i) {
        long double gap = arr[i] - arr[i-1];
        pq.push({gap, gap, 1});
    }

    // Place k new stations greedily into the largest current gap
    for (int i = 0; i < k; ++i) {
        auto top = pq.top(); pq.pop();
        // We are splitting this origGap into (splits+1)+1 parts now
        int newSplits = top.splits + 1;
        long double newLen = top.origGap / (newSplits + 1);
        pq.push({newLen, top.origGap, newSplits});
    }

    // After k splits, the worst gap is at the top
    return pq.top().currLen;
}
```

### Complexity

* **Heap size:** *O(n)* initial gaps
* **Each split:** pop + push â†’ *O(logâ€¯n)*
* **Total:** *O((n + k)â€¯logâ€¯n)*

This approach is often faster when *k* is relatively small (say, up to 10âµ) and avoids the repeated linear scans of the binaryâ€search predicate, trading them for logarithmic heap operations.


---

## ðŸŽ¯ Tips & Tricks

* To avoid **floatingâ€‘point ceiling**, note
  $\bigl\lceil gap/D \bigr\rceil - 1 = \lfloor gap / D\rfloor.$
* Always sort the input positions before splitting intervals.
* Use a small `eps` (\~1eâ€‘6) to stop binary search on reals.

---

## ðŸ”„ Variations

1. **Minimize maximum waiting time** at bus stops (same principle).
2. **Distribute k new servers** on a line to minimize latency (continuous binary search).
3. **Maximize minimum signal strength** by placing k boosters.

---

## â“ FAQs

> **Q1. Why use `high` = max gap?** <br>
> Without new stations, that is the largest distance; adding stations can only reduce it.

> **Q2. How do we decide `eps`?** <br>
> `1e-6` ensures **sixâ€‘digit** precision; adjust based on required accuracy.

> **Q3. Why return `high` instead of `low`?** <br>
> After the loop, `high` is the smallest feasible value.

> **Q4. Can `k = 0`?** <br>
> Yesâ€”then answer is just the original maximum gap.

---
