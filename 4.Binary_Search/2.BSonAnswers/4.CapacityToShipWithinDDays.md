# 🚢 Capacity To Ship Packages Within D Days


## 📄 Problem Statement

A conveyor belt has a sequence of packages, where the `i`‑th package has weight `weights[i]`. You want to ship all packages within **D** days in the given order. Each day, you load the ship with some number of **consecutive** packages without exceeding its weight capacity `cap`. Return the **minimum** ship capacity `cap` such that you can ship all packages in at most **D** days.

* **Input:**

  * Integer `n`, the number of packages.
  * Vector `weights` of length `n`, where `weights[i]` is the `i`‑th package’s weight.
  * Integer `D`, the maximum number of days.
* **Output:**

  * The smallest integer `cap` so that all packages can be shipped within `D` days.

---

## 💡 Intuition

* If the capacity `cap` is **too small**, you’ll need **more** than `D` days to ship every package.
* If `cap` is **very large** (e.g. sum of all weights), you ship everything in **one** day.
* As `cap` **increases**, the number of days needed **non-increases** (monotonic).
* We can binary‑search on `cap` between:

  * **low** = `max(weights)` (the ship must at least carry the heaviest package),
  * **high** = `sum(weights)` (ship everything in one go).

For each candidate `cap`, simulate how many days it takes by greedily loading as many consecutive packages as fit.

---

## 🐢 Brute‑Force Approach

Try every capacity from `max(weights)` up to `sum(weights)`:

```cpp
int daysNeeded(const vector<int>& w, int cap) {
    int days = 1, load = 0;
    for (int x : w) {
        if (load + x > cap) {
            days++;
            load = x;
        } else {
            load += x;
        }
    }
    return days;
}

int shipWithinDaysBrute(vector<int>& weights, int D) {
    int low = *max_element(weights.begin(), weights.end());
    int high = accumulate(weights.begin(), weights.end(), 0);
    for (int cap = low; cap <= high; ++cap) {
        if (daysNeeded(weights, cap) <= D)
            return cap;
    }
    return high;
}
```

* **Time Complexity:** *O((sum–max) × n)* → too slow if weights are large.
* **Space Complexity:** *O(1)*

> ❌ Brute‑forcing every capacity is infeasible when values go up to 10⁵ or more.

---

## 🚀 Optimal Approach: Binary Search on Capacity

1. **Set**

   ```cpp
   int low  = *max_element(weights.begin(), weights.end());
   int high = accumulate(weights.begin(), weights.end(), 0);
   ```
2. **Define** helper `daysNeeded(cap)`:

   * Iterate through `weights`, accumulating `load`.
   * When `load + weights[i] > cap`, increment `days`, reset `load = weights[i]`.
   * Return total `days`.
3. **Binary search**:

   ```cpp
   while (low <= high) {
     int mid = low + (high - low) / 2;
     if (daysNeeded(mid) <= D)
       high = mid - 1;  // feasible: try smaller cap
     else
       low  = mid + 1;  // too small: need larger cap
   }
   return low;
   ```
4. **Return** `low` as the minimum feasible capacity.

This runs in **O(n log S)** where *S* = sum(weights).

---

## ✅ Test Cases

| `weights`                       | `D` | Output | Explanation                              |
| ------------------------------- | --- | ------ | ---------------------------------------- |
| `[1,2,3,4,5,6,7,8,9,10]`        | `5` | `15`   | Day loads: \[1–5], \[6–8], \[9–10], etc. |
| `[3,2,2,4,1,4]`                 | `3` | `6`    | Caps 6: days = \[3,2], \[2,4], \[1,4]    |
| `[1,2,3,1,1]`                   | `4` | `3`    | Caps 3: days = \[1,2], \[3,1], \[1]      |
| `[10,50,100,100,50,50,100,100]` | `5` | `160`  | Heaviest chunk determines capacity.      |
| `[5]`                           | `1` | `5`    | Single package → cap = weight.           |

---

## ✏️ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

// Helper: compute days needed with given capacity 'cap'
int findDays(const vector<int>& weights, int cap) {
    int days = 1, load = 0;
    for (int w : weights) {
        if (load + w > cap) {
            days++;
            load = w;
        } else {
            load += w;
        }
    }
    return days;
}

// Main API: binary search the minimum capacity
int leastWeightCapacity(vector<int>& weights, int D) {
    int low  = *max_element(weights.begin(), weights.end());
    int high = accumulate(weights.begin(), weights.end(), 0);
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (findDays(weights, mid) <= D) {
            high = mid - 1;  // feasible, try smaller
        } else {
            low = mid + 1;   // not feasible, increase cap
        }
    }
    return low;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, D;
    cin >> n >> D;
    vector<int> weights(n);
    for (int i = 0; i < n; i++) {
        cin >> weights[i];
    }

    cout << leastWeightCapacity(weights, D) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                   | Time Complexity | Space Complexity |
| ----------------------- | --------------- | ---------------- |
| `findDays` simulation   | *O(n)*          | *O(1)*           |
| Binary search (≈ log S) | *O(n log S)*    | *O(1)*           |
| **Overall**             | **O(n log S)**  | **O(1)**         |

* *n* = number of packages
* *S* = sum of all weights

---

## 🎯 Tips & Tricks

* Bound **low** by the **max weight**—you can’t ship a single package otherwise.
* Bound **high** by the **sum**—one‑day shipping.
* Each step’s simulation is linear, so keeping **constant** factors small matters.

---

## 🔄 Variations

1. **Ship within a weight range**: minimize maximum day count for fixed cap.
2. **Multiple ships per day**: generalize to **k** ships operating in parallel.
3. **Minimize total days**: given a fixed `cap`, find days needed (inverse problem).

---

## ❓ FAQs

> **Q1. Why use binary search on capacity?** <br>
> Because the relationship “days needed ≤ D” is **monotonic** in capacity.

> **Q2. Can weights be zero?** <br>
> Usually positive. If zeroes appear, they don’t affect capacity or days.

> **Q3. What if `D ≥ n`?** <br>
> You could ship one package per day, so answer = `max(weights)`.

> **Q4. What if `D = 1`?** <br>
> You must ship all in one day → cap = `sum(weights)`.

---
