# 🧩 Kth Missing Positive Number


## 📄 Problem Statement

Given a **strictly increasing** sorted array of positive integers `arr` and a positive integer `k`, return the **kth** missing positive integer that is **not** present in `arr`.

* **Input:**

  * `n`: the length of `arr`
  * `arr`: a sorted vector of distinct positive integers
  * `k`: the rank of the missing positive integer to find
* **Output:**

  * The k<sup>th</sup> missing positive integer

### 📌 Example

```text
arr = [2, 3, 4, 7, 11], k = 5
Missing positives: 1,5,6,8,9,10,...
The 5th missing is 9.
```

---

## 💡 Intuition

* For each index `i`, the count of missing numbers **up to** `arr[i]` is

  $$
    \text{missing}(i) = arr[i] - (i + 1).
  $$

  Because if nothing were missing, `arr[i]` would be exactly `i+1`.
* We want the smallest index `idx` where `missing(idx) ≥ k`.

  * If `missing(idx) < k`, the kth missing lies **to the right**.
  * Otherwise, it’s **at or before** `idx`.
* A **binary search** on this monotonic `missing(i)` array finds that critical boundary in **O(log n)**.

---

## 🐢 Brute‑Force Approach

Iterate from `1` upward, checking presence in `arr` using a set:

```cpp
int findKthPositiveBrute(vector<int>& arr, int k) {
    unordered_set<int> s(arr.begin(), arr.end());
    int missingCount = 0, num = 1;
    while (true) {
        if (!s.count(num)) {
            if (++missingCount == k)
                return num;
        }
        ++num;
    }
    return -1; // unreachable
}
```

* **Time Complexity:** *O(k + n)* on average
* **Space Complexity:** *O(n)*

> ❌ Might iterate far if `k` is large relative to `arr`.

---

## 🚀 Optimal Approach: Binary Search

1. **Compute** `missing(i) = arr[i] - (i+1)`.
2. **Binary search** for the first index `idx` where `missing(idx) ≥ k`.

   ```cpp
   int low=0, high=n-1;
   while (low<=high) {
     int mid=(low+high)/2;
     if (arr[mid] - (mid+1) < k)
       low = mid+1;
     else
       high = mid-1;
   }
   ```
3. After the loop, `low` is the count of elements where `missing(i) < k`.
4. The **answer** is then

   $$
     \bigl(\underbrace{\,\text{high}+1\!}_{=\,low}\bigr) + k
     = low + k.
   $$

   More intuitively, we’ve skipped `low` existing elements, so the kth missing is `k` steps beyond `low`.

```cpp
int findKthPositive(vector<int>& arr, int k) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] - (mid + 1) < k)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return low + k;
}
```

* **Time Complexity:** *O(log n)*
* **Space Complexity:** *O(1)*

---

## ✅ Test Cases

| `arr`               | `k`  | Output | Explanation                                        |
| ------------------- | ---- | ------ | -------------------------------------------------- |
| `[2,3,4,7,11]`, `5` | `5`  | `9`    | Missing: 1,5,6,8,**9**,10,...                      |
| `[1,2,3,4]`, `2`    | `2`  | `6`    | Missing: 5,**6**,7,...                             |
| `[3,5,8,10]`, `1`   | `1`  | `1`    | 1 is the first missing.                            |
| `[3,5,8,10]`, `5`   | `5`  | `9`    | Missing:1,2,4,6,**7**,8→ answer=7 but check k=5→7. |
| `[100]`, `99`       | `99` | `99`   | All 1..99 missing → 99th is 99.                    |
| `[]`, `7`           | `7`  | `7`    | Empty array, kth missing is k.                     |

---

## ✏️ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the kth missing positive integer from a sorted array.
 */
int findKthPositive(vector<int>& arr, int k) {
    int low = 0, high = arr.size() - 1;
    // Binary search on missing count
    while (low <= high) {
        int mid = low + (high - low) / 2;
        int missing = arr[mid] - (mid + 1);
        if (missing < k)
            low = mid + 1;
        else
            high = mid - 1;
    }
    // low = count of elements with missing(mid)<k
    return low + k;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    cin >> n >> k;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i)
        cin >> arr[i];

    cout << findKthPositive(arr, k) << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase              | Time Complexity | Space Complexity |
| ------------------ | --------------- | ---------------- |
| Binary search loop | *O(log n)*      | *O(1)*           |
| **Overall**        | **O(log n)**    | **O(1)**         |

---

## 🎯 Tips & Tricks

* **Missing formula**: `arr[i] - (i+1)` elegantly counts how many positives are skipped up to index `i`.
* **Binary search** on a derived monotonic function often beats linear scans for “kth missing” or “kth smallest” problems.
* Edge case: if all `missing(i) < k`, then `low = n` and the answer is `n + k`.

---

## 🔄 Variations

1. **Find kth missing in unsorted array**: sort first or use hash+min-heap.
2. **Multi-dimensional** missing: matrices with sorted rows; extend missing counts per row.
3. **Kth positive NOT missing**: find the kth present value.

---

## ❓ FAQs

> **Q1. Why `low + k`?** <br>
> After skipping `low` actual elements, the first missing is at `1`, so you offset by `k` or `high + 1 + k`.

> **Q2. What if `arr` is empty?** <br>
> The binary search does zero iterations, `low=0`, so returns `0+k = k` correctly.

> **Q3. Can duplicates appear?** <br>
> Problem assumes **distinct** increasing `arr`. Duplicates break the missing-count logic.

> **Q4. Is one‐based vs zero‐based important?** <br>
> Yes: we use `(i+1)` to reflect that at index 0 we expect `1` if nothing were missing.

---

