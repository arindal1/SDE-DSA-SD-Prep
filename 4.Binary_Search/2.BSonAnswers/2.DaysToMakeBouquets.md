# 🌹 Minimum Days to Make m Bouquets


## 📄 Problem Statement

You have a garden of roses laid out in a row; the i‑th rose blooms on day `arr[i]`. You want to make `m` bouquets, each consisting of `k` **adjacent** roses. Once a rose blooms, it stays bloomed. Find the **minimum day** by which you can gather enough bouquets, or return `-1` if it’s impossible.

* **Inputs:**

  * Integer `n`, the number of roses.
  * Vector `arr` of length `n`, where `arr[i]` is the day the i‑th rose blooms.
  * Integer `k`, number of adjacent roses per bouquet.
  * Integer `m`, number of bouquets needed.
* **Output:**

  * The minimum day on which you can pick `m` bouquets, or `-1` if you can’t.

---

## 💡 Intuition

* If you choose a candidate day `d`, any rose `i` with `arr[i] ≤ d` is **available** to pick.
* You then scan the row, grouping **consecutive** available roses into bouquets of size `k`.
* Count how many bouquets you can form; if it’s at least `m`, day `d` **works**; otherwise it’s too early.
* Because increasing `d` only **adds** more available roses, the feasibility of forming `m` bouquets is a **monotonic** predicate.
* We can binary‑search on `d` between the earliest bloom (`min(arr)`) and the latest bloom (`max(arr)`).

---

## 🐢 Brute‑Force Approach

Check every day from `min(arr)` up to `max(arr)`:

```cpp
int minDaysBrute(vector<int>& arr, int k, int m) {
    int n = arr.size();
    int minDay = *min_element(arr.begin(), arr.end());
    int maxDay = *max_element(arr.begin(), arr.end());
    for (int d = minDay; d <= maxDay; ++d) {
        int bouquets = 0, consec = 0;
        for (int x : arr) {
            if (x <= d) {
                if (++consec == k) {
                    bouquets++;
                    consec = 0;
                }
            } else {
                consec = 0;
            }
        }
        if (bouquets >= m) return d;
    }
    return -1;
}
```

* **Time Complexity:** *O((maxDay–minDay) · n)*
* **Space Complexity:** *O(1)*

> ❌ Too slow when bloom days range is large (e.g. up to 10⁹).

---

## 🚀 Optimal Approach: Binary Search on Day

1. **Bounds**:

   ```cpp
   int low  = min(arr);
   int high = max(arr);
   ```
2. **Predicate** `possible(d)`:

   * Scan `arr`, count **consecutive** blooms `arr[i] ≤ d`.
   * Every time you accumulate `k` in a row, you form one bouquet and reset the consecutive count.
   * Return `true` if you form ≥ `m` bouquets.
3. **Binary search**:

   ```cpp
   while (low ≤ high) {
     int mid = low + (high - low)/2;
     if (possible(mid)) high = mid - 1;
     else               low  = mid + 1;
   }
   return low;   // low is the first feasible day, or > maxDay if impossible
   ```
4. Check **impossible** upfront: if `m * k > n`, return `-1`.

This runs in *O(n · log D)* where *D* = `max(arr) – min(arr)`.

---

## ✏️ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns true if by day 'd' we can form at least 'm' bouquets
 * of 'k' consecutive roses.
 */
bool possible(const vector<int>& arr, int d, int m, int k) {
    int bouquets = 0, consec = 0;
    for (int x : arr) {
        if (x <= d) {
            if (++consec == k) {
                bouquets++;
                consec = 0;
                if (bouquets >= m) return true;
            }
        } else {
            consec = 0;
        }
    }
    return false;
}

/**
 * Returns the minimum day to make m bouquets of k roses each,
 * or -1 if impossible.
 */
int minDaysToBouquets(vector<int>& arr, int k, int m) {
    long long needed = 1LL * m * k;
    int n = arr.size();
    if (needed > n) return -1;

    int low  = *min_element(arr.begin(), arr.end());
    int high = *max_element(arr.begin(), arr.end());

    int ans = -1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (possible(arr, mid, m, k)) {
            ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k, m;
    cin >> n >> k >> m;
    vector<int> bloomDays(n);
    for (int i = 0; i < n; ++i) {
        cin >> bloomDays[i];
    }

    int res = minDaysToBouquets(bloomDays, k, m);
    cout << res << "\n";
    return 0;
}
```

---

## 📊 Complexity Analysis

| Phase                   | Time Complexity  | Space Complexity |
| ----------------------- | ---------------- | ---------------- |
| `possible` check        | *O(n)*           | *O(1)*           |
| Binary search over days | *O(log D)*       | *—*              |
| **Overall**             | **O(n · log D)** | **O(1)**         |

* *n* = number of roses
* *D* = `max(arr) − min(arr)` (range of bloom days)

---

## ✅ Test Cases

| `arr`              | `k` | `m` | Output | Explanation                                |
| ------------------ | --- | --- | ------ | ------------------------------------------ |
| `[1,10,3,10,2]`    | `3` | `1` | `3`    | By day 3, a bouquet at indices (0,2,4).    |
| `[1,10,3,10,2]`    | `3` | `2` | `-1`   | Not enough roses for 2 bouquets of 3 each. |
| `[7,7,7,7,12,7,7]` | `7` | `1` | `7`    | Need 7 adjacent, which spans days until 7. |
| `[1,2,4,9,3,4,1]`  | `2` | `2` | `3`    | Day 3 gives segments \[1,2], \[3,4].       |
| `[5,5,5]`          | `1` | `3` | `5`    | Each rose by day 5.                        |

---

## 🎯 Tips & Tricks

* ✔️ Always **check impossibility**: if `m × k > n`, return `-1`.
* 📈 Use **binary search** on the answer when feasibility is monotonic.
* 🔢 Compute **ceil** division by a simple counter of consecutive blooms rather than floating‑point.

---

## 🔄 Variations

1. **Non‑adjacent bouquets**: allow any k bloomed roses → just check sum of `floor(arr[i]/d)`.
2. **Multiple flower types**: each bouquet needs a combination of types.
3. **Parallel picking**: multiple gardeners pick simultaneously—divide `h` differently.

---

## ❓ FAQs

> **Q1. Why binary search on days?** <br>
> Because the ability to form bouquets only **improves** as days increase—monotonic!

> **Q2. Can bloom days be zero or negative?** <br>
> Typically days are positive; adjust bounds if zero-based days appear.

> **Q3. What if k = 1?** <br>
> You just need `m` bloomed roses; answer = the m‑th smallest bloom day.

> **Q4. How to adapt if bouquets must be at **most** k roses (not exactly)?** <br>
> You’d count `consec` runs of length ≥ 1 up to k, adjusting `possible` accordingly.

---

