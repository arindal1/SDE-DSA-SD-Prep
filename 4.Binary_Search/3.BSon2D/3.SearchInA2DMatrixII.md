# üîé Search a 2D Matrix II

## üìÑ Problem Statement

Given an `n x m` matrix of integers where each row is sorted in **ascending** order from left to right, and each column is sorted in **ascending** order from top to bottom, determine whether a given `target` integer exists in the matrix.

* **Input:**

  * Integer `n`, number of rows
  * Integer `m`, number of columns
  * 2D vector `matrix` of size `n √ó m`
  * Integer `target`
* **Output:**

  * `true` if `target` is found, `false` otherwise

### Example

```
matrix = [
  [1,  4,  7, 11, 15],
  [2,  5,  8, 12, 19],
  [3,  6,  9, 16, 22],
  [10,13, 14,17, 24],
  [18,21, 23,26, 30]
]
target = 5 ‚Üí true
target = 20 ‚Üí false
```

---

## üí° Intuition

Because both **rows** and **columns** are sorted:

* Start at the **top-right** corner:

  * If the current value > `target`, move **left** (smaller values).
  * If the current value < `target`, move **down** (larger values).
* Repeat until you either find `target` or go out of bounds.

This ‚Äústaircase‚Äù search runs in **O(n + m)** time.

---

## ‚ùå Brute‚ÄëForce Approach

Scan every element:

```cpp
bool searchMatrixBrute(vector<vector<int>>& matrix, int target) {
    for (auto &row : matrix)
        for (int x : row)
            if (x == target) return true;
    return false;
}
```

* **Time Complexity:** *O(n¬∑m)*
* **Space Complexity:** *O(1)*

> Too slow when `n, m` up to 10‚Å¥ each.

---

## üöÄ Optimal Staircase Search

```cpp
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int n = matrix.size(), m = matrix[0].size();
    int row = 0, col = m - 1;

    while (row < n && col >= 0) {
        int val = matrix[row][col];
        if (val == target) 
            return true;
        else if (val < target)
            ++row;
        else
            --col;
    }
    return false;
}
```

* **Start:** `(row, col) = (0, m-1)`
* **Move left** if current > target
* **Move down** if current < target

This guarantees one step per iteration, at most `n + m` steps.

---

## ‚úÖ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Staircase search in a row‚Äë and column‚Äësorted matrix.
 */
bool searchMatrix(const vector<vector<int>>& matrix, int target) {
    int n = matrix.size(), m = matrix[0].size();
    int row = 0, col = m - 1;

    while (row < n && col >= 0) {
        int val = matrix[row][col];
        if (val == target)
            return true;
        else if (val < target)
            ++row;
        else
            --col;
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m, target;
    cin >> n >> m >> target;
    vector<vector<int>> matrix(n, vector<int>(m));
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            cin >> matrix[i][j];

    cout << (searchMatrix(matrix, target) ? "true" : "false") << "\n";
    return 0;
}
```

---

## üßÆ Complexity Analysis

| Aspect    | Complexity |
| --------- | ---------- |
| **Time**  | *O(n + m)* |
| **Space** | *O(1)*     |

---

## üéØ Tips & Tricks

* **Always start** at a corner where one move decreases and the other increases value:

  * **Top-right** or **bottom-left** both work.
* If matrix isn‚Äôt sorted in both dimensions, this approach fails.
* Watch out for **empty** matrix: guard `n == 0` or `m == 0`.

---

## üîÑ Variations

1. **Search in fully sorted ‚Äúflattened‚Äù matrix** (each row‚Äôs end < next row‚Äôs start) ‚Üí binary search in *O(log‚ÄØ(nm))*.
2. **kth smallest element in sorted matrix** ‚Üí min‚Äëheap or binary search on value.
3. **Search in 3D sorted space** ‚Üí extend staircase logic.

---

## ‚ùì FAQs

> **Q1. Why top‚Äëright corner?**
> From there, moving left reduces value, moving down increases‚Äîperfect for two‚Äëway elimination.

> **Q2. Can we start bottom-left?**
> Yes‚Äîmoving right increases, moving up decreases.

> **Q3. What if rows and columns aren‚Äôt sorted in the same direction?**
> Choose starting corner to align with monotonic directions, or brute force.

> **Q4. How to handle duplicates?**
> Still works‚Äîfirst match returns true. If searching >= or <= relationships, duplicates don‚Äôt break logic.

---
