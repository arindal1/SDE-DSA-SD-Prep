# üèîÔ∏è Find Peak Element - II

---

## üìÑ Problem Statement

> Given an **n x m** integer matrix `mat`, where:
>
> * Each cell `(i, j)` has integer value `mat[i][j]`.
> * A **peak** is defined as a cell that is **strictly greater** than all of its 4-directional neighbors (up, down, left, right).
>
> Return the coordinates `[i, j]` of **any** peak element. It is guaranteed that a peak exists.

```
Example:
mat = [
  [ 1,  4,  3],
  [ 6,  5,  2],
  [ 7,  8,  9]
]
One valid peak: (2, 2) ‚Üí 9 > 2, 8
```

---

## üí° Intuition

* A 2D peak can be found in **O(n¬∑log‚ÄØm)** by **binary‚Äësearching columns**:

  1. Pick a middle column `mid`.
  2. Find the **global maximum** in that column at row `r` (scan `n` rows).
  3. Compare `mat[r][mid]` with its immediate left and right neighbors:

     * If it exceeds both, `(r, mid)` is a peak.
     * If the left neighbor is larger, the peak must lie **to the left** ‚Üí move `high = mid‚àí1`.
     * Else (right neighbor larger), move `low = mid+1`.
* This works because moving toward the larger neighbor **guarantees** you approach a higher region, and eventually find a local maximum that is a 2D peak.

---

## ‚ùå Brute‚ÄëForce Approach

Check every cell in the grid, verify all existing neighbors:

```cpp
vector<int> findPeakBrute(const vector<vector<int>>& mat) {
    int n = mat.size(), m = mat[0].size();
    auto isPeak = [&](int i, int j) {
        static int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
        for (auto &d : dirs) {
            int ni = i + d[0], nj = j + d[1];
            if (ni >= 0 && ni < n && nj >= 0 && nj < m)
                if (mat[ni][nj] >= mat[i][j])
                    return false;
        }
        return true;
    };
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (isPeak(i, j))
                return {i, j};
    return {-1, -1};  // unreachable
}
```

* **Time Complexity:** *O(n¬∑m¬∑1)* = *O(n¬∑m)*
* **Space Complexity:** *O(1)*

> Too slow for large grids.

---

## üöÄ Optimal Approach: Column‚ÄëWise Binary Search

### Helper: Find row of max in column `c`

```cpp
int maxElementRow(const vector<vector<int>>& mat, int c) {
    int n = mat.size(), idx = 0;
    for (int i = 1; i < n; ++i)
        if (mat[i][c] > mat[idx][c])
            idx = i;
    return idx;
}
```

### Main: Binary search on columns

```cpp
vector<int> findPeakGrid(vector<vector<int>>& mat) {
    int n = mat.size(), m = mat[0].size();
    int low = 0, high = m - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;
        int r = maxElementRow(mat, mid);

        int leftVal  = (mid > 0)       ? mat[r][mid-1] : INT_MIN;
        int rightVal = (mid < m - 1)   ? mat[r][mid+1] : INT_MIN;
        int curVal   = mat[r][mid];

        if (curVal > leftVal && curVal > rightVal) {
            return {r, mid};
        }
        else if (curVal < leftVal) {
            high = mid - 1;
        }
        else {
            low = mid + 1;
        }
    }
    return {-1, -1};  // guaranteed not needed
}
```

* **Time Complexity:** *O(n¬∑log‚ÄØm)*
* **Space Complexity:** *O(1)*

---

## ‚úÖ Full Code with `main()`

```cpp
#include <bits/stdc++.h>
using namespace std;

/**
 * Returns the row index of the maximum element in column c.
 */
int maxElementRow(const vector<vector<int>>& mat, int c) {
    int n = mat.size(), idx = 0;
    for (int i = 1; i < n; ++i)
        if (mat[i][c] > mat[idx][c])
            idx = i;
    return idx;
}

/**
 * Performs a binary search over columns to find any 2D peak.
 */
vector<int> findPeakGrid(vector<vector<int>>& mat) {
    int n = mat.size(), m = mat[0].size();
    int low = 0, high = m - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;
        int r = maxElementRow(mat, mid);

        int leftVal  = (mid > 0)       ? mat[r][mid-1] : INT_MIN;
        int rightVal = (mid < m - 1)   ? mat[r][mid+1] : INT_MIN;
        int curVal   = mat[r][mid];

        if (curVal > leftVal && curVal > rightVal) {
            return {r, mid};
        } else if (curVal < leftVal) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return {-1, -1};  // fallback
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;
    vector<vector<int>> mat(n, vector<int>(m));
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            cin >> mat[i][j];

    auto peak = findPeakGrid(mat);
    cout << peak[0] << " " << peak[1] << "\n";
    return 0;
}
```

---

## üßÆ Complexity Analysis

| Step                         | Time Complexity | Space Complexity |
| ---------------------------- | --------------- | ---------------- |
| `maxElementRow` per column   | *O(n)*          | *O(1)*           |
| Binary search on `m` columns | *O(log‚ÄØm)*      | *O(1)*           |
| **Overall**                  | **O(n¬∑log‚ÄØm)**  | **O(1)**         |

---

## üß† Tips & Tricks

* Always choose the **smaller dimension** for binary search to optimize log‚Äëfactor.
* Use `INT_MIN` as sentinel when checking non-existent neighbors.
* A 2D peak need not be the global maximum‚Äîjust larger than its 4 neighbors.

---

## üîÑ Variations

* **1D Peak Finding:** Binary search on a sorted or unimodal array in *O(log‚ÄØn)*.
* **Find All Peaks:** Scan every cell with neighbor checks in *O(n¬∑m)*.
* **3D Peak Finding:** Extension to three dimensions with similar divide‚Äëand‚Äëconquer.

---

## ‚ùì FAQs

> **Q1. Why search on columns instead of rows?**
> 
> Either works; pick the dimension with smaller size to minimize `log`.

> **Q2. Can there be multiple peaks?**
> 
> Yes‚Äîthis returns **any** one peak.

> **Q3. What if `n` or `m` is 1?**
> 
> The algorithm still finds a peak in that degenerate 1D scenario.

> **Q4. What if neighbors out of bounds?**
> 
> We treat them as `‚àí‚àû` (`INT_MIN`), so any in‚Äëbounds value is larger.
